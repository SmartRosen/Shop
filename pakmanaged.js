var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('util').inherits
    
  provide("inherits", module.exports);
}(global));

// pakmanager:cipher-base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Transform = require('stream').Transform
    var inherits = require('inherits')
    var StringDecoder = require('string_decoder').StringDecoder
    module.exports = CipherBase
    inherits(CipherBase, Transform)
    function CipherBase (hashMode) {
      Transform.call(this)
      this.hashMode = typeof hashMode === 'string'
      if (this.hashMode) {
        this[hashMode] = this._finalOrDigest
      } else {
        this.final = this._finalOrDigest
      }
      this._decoder = null
      this._encoding = null
    }
    CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
      if (typeof data === 'string') {
        data = new Buffer(data, inputEnc)
      }
      var outData = this._update(data)
      if (this.hashMode) {
        return this
      }
      if (outputEnc) {
        outData = this._toString(outData, outputEnc)
      }
      return outData
    }
    
    CipherBase.prototype.setAutoPadding = function () {}
    
    CipherBase.prototype.getAuthTag = function () {
      throw new Error('trying to get auth tag in unsupported state')
    }
    
    CipherBase.prototype.setAuthTag = function () {
      throw new Error('trying to set auth tag in unsupported state')
    }
    
    CipherBase.prototype.setAAD = function () {
      throw new Error('trying to set aad in unsupported state')
    }
    
    CipherBase.prototype._transform = function (data, _, next) {
      var err
      try {
        if (this.hashMode) {
          this._update(data)
        } else {
          this.push(this._update(data))
        }
      } catch (e) {
        err = e
      } finally {
        next(err)
      }
    }
    CipherBase.prototype._flush = function (done) {
      var err
      try {
        this.push(this._final())
      } catch (e) {
        err = e
      } finally {
        done(err)
      }
    }
    CipherBase.prototype._finalOrDigest = function (outputEnc) {
      var outData = this._final() || new Buffer('')
      if (outputEnc) {
        outData = this._toString(outData, outputEnc, true)
      }
      return outData
    }
    
    CipherBase.prototype._toString = function (value, enc, final) {
      if (!this._decoder) {
        this._decoder = new StringDecoder(enc)
        this._encoding = enc
      }
      if (this._encoding !== enc) {
        throw new Error('can\'t switch encodings')
      }
      var out = this._decoder.write(value)
      if (final) {
        out += this._decoder.end()
      }
      return out
    }
    
  provide("cipher-base", module.exports);
}(global));

// pakmanager:sha.js/hash
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // prototype class for hash functions
    function Hash (blockSize, finalSize) {
      this._block = new Buffer(blockSize)
      this._finalSize = finalSize
      this._blockSize = blockSize
      this._len = 0
      this._s = 0
    }
    
    Hash.prototype.update = function (data, enc) {
      if (typeof data === 'string') {
        enc = enc || 'utf8'
        data = new Buffer(data, enc)
      }
    
      var l = this._len += data.length
      var s = this._s || 0
      var f = 0
      var buffer = this._block
    
      while (s < l) {
        var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
        var ch = (t - f)
    
        for (var i = 0; i < ch; i++) {
          buffer[(s % this._blockSize) + i] = data[i + f]
        }
    
        s += ch
        f += ch
    
        if ((s % this._blockSize) === 0) {
          this._update(buffer)
        }
      }
      this._s = s
    
      return this
    }
    
    Hash.prototype.digest = function (enc) {
      // Suppose the length of the message M, in bits, is l
      var l = this._len * 8
    
      // Append the bit 1 to the end of the message
      this._block[this._len % this._blockSize] = 0x80
    
      // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
      this._block.fill(0, this._len % this._blockSize + 1)
    
      if (l % (this._blockSize * 8) >= this._finalSize * 8) {
        this._update(this._block)
        this._block.fill(0)
      }
    
      // to this append the block which is equal to the number l written in binary
      // TODO: handle case where l is > Math.pow(2, 29)
      this._block.writeInt32BE(l, this._blockSize - 4)
    
      var hash = this._update(this._block) || this._hash()
    
      return enc ? hash.toString(enc) : hash
    }
    
    Hash.prototype._update = function () {
      throw new Error('_update must be implemented by subclass')
    }
    
    module.exports = Hash
    
  provide("sha.js/hash", module.exports);
}(global));

// pakmanager:sha.js/sha256
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */
    
    var inherits = require('inherits')
    var Hash =  require('sha.js/hash')
    
    var K = [
      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
    ]
    
    var W = new Array(64)
    
    function Sha256 () {
      this.init()
    
      this._w = W // new Array(64)
    
      Hash.call(this, 64, 56)
    }
    
    inherits(Sha256, Hash)
    
    Sha256.prototype.init = function () {
      this._a = 0x6a09e667
      this._b = 0xbb67ae85
      this._c = 0x3c6ef372
      this._d = 0xa54ff53a
      this._e = 0x510e527f
      this._f = 0x9b05688c
      this._g = 0x1f83d9ab
      this._h = 0x5be0cd19
    
      return this
    }
    
    function ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }
    
    function maj (x, y, z) {
      return (x & y) | (z & (x | y))
    }
    
    function sigma0 (x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
    }
    
    function sigma1 (x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
    }
    
    function gamma0 (x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
    }
    
    function gamma1 (x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
    }
    
    Sha256.prototype._update = function (M) {
      var W = this._w
    
      var a = this._a | 0
      var b = this._b | 0
      var c = this._c | 0
      var d = this._d | 0
      var e = this._e | 0
      var f = this._f | 0
      var g = this._g | 0
      var h = this._h | 0
    
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
      for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0
    
      for (var j = 0; j < 64; ++j) {
        var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
        var T2 = (sigma0(a) + maj(a, b, c)) | 0
    
        h = g
        g = f
        f = e
        e = (d + T1) | 0
        d = c
        c = b
        b = a
        a = (T1 + T2) | 0
      }
    
      this._a = (a + this._a) | 0
      this._b = (b + this._b) | 0
      this._c = (c + this._c) | 0
      this._d = (d + this._d) | 0
      this._e = (e + this._e) | 0
      this._f = (f + this._f) | 0
      this._g = (g + this._g) | 0
      this._h = (h + this._h) | 0
    }
    
    Sha256.prototype._hash = function () {
      var H = new Buffer(32)
    
      H.writeInt32BE(this._a, 0)
      H.writeInt32BE(this._b, 4)
      H.writeInt32BE(this._c, 8)
      H.writeInt32BE(this._d, 12)
      H.writeInt32BE(this._e, 16)
      H.writeInt32BE(this._f, 20)
      H.writeInt32BE(this._g, 24)
      H.writeInt32BE(this._h, 28)
    
      return H
    }
    
    module.exports = Sha256
    
  provide("sha.js/sha256", module.exports);
}(global));

// pakmanager:sha.js/sha512
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits')
    var Hash =  require('sha.js/hash')
    
    var K = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ]
    
    var W = new Array(160)
    
    function Sha512 () {
      this.init()
      this._w = W
    
      Hash.call(this, 128, 112)
    }
    
    inherits(Sha512, Hash)
    
    Sha512.prototype.init = function () {
      this._ah = 0x6a09e667
      this._bh = 0xbb67ae85
      this._ch = 0x3c6ef372
      this._dh = 0xa54ff53a
      this._eh = 0x510e527f
      this._fh = 0x9b05688c
      this._gh = 0x1f83d9ab
      this._hh = 0x5be0cd19
    
      this._al = 0xf3bcc908
      this._bl = 0x84caa73b
      this._cl = 0xfe94f82b
      this._dl = 0x5f1d36f1
      this._el = 0xade682d1
      this._fl = 0x2b3e6c1f
      this._gl = 0xfb41bd6b
      this._hl = 0x137e2179
    
      return this
    }
    
    function Ch (x, y, z) {
      return z ^ (x & (y ^ z))
    }
    
    function maj (x, y, z) {
      return (x & y) | (z & (x | y))
    }
    
    function sigma0 (x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
    }
    
    function sigma1 (x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
    }
    
    function Gamma0 (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
    }
    
    function Gamma0l (x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
    }
    
    function Gamma1 (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
    }
    
    function Gamma1l (x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
    }
    
    function getCarry (a, b) {
      return (a >>> 0) < (b >>> 0) ? 1 : 0
    }
    
    Sha512.prototype._update = function (M) {
      var W = this._w
    
      var ah = this._ah | 0
      var bh = this._bh | 0
      var ch = this._ch | 0
      var dh = this._dh | 0
      var eh = this._eh | 0
      var fh = this._fh | 0
      var gh = this._gh | 0
      var hh = this._hh | 0
    
      var al = this._al | 0
      var bl = this._bl | 0
      var cl = this._cl | 0
      var dl = this._dl | 0
      var el = this._el | 0
      var fl = this._fl | 0
      var gl = this._gl | 0
      var hl = this._hl | 0
    
      for (var i = 0; i < 32; i += 2) {
        W[i] = M.readInt32BE(i * 4)
        W[i + 1] = M.readInt32BE(i * 4 + 4)
      }
      for (; i < 160; i += 2) {
        var xh = W[i - 15 * 2]
        var xl = W[i - 15 * 2 + 1]
        var gamma0 = Gamma0(xh, xl)
        var gamma0l = Gamma0l(xl, xh)
    
        xh = W[i - 2 * 2]
        xl = W[i - 2 * 2 + 1]
        var gamma1 = Gamma1(xh, xl)
        var gamma1l = Gamma1l(xl, xh)
    
        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
        var Wi7h = W[i - 7 * 2]
        var Wi7l = W[i - 7 * 2 + 1]
    
        var Wi16h = W[i - 16 * 2]
        var Wi16l = W[i - 16 * 2 + 1]
    
        var Wil = (gamma0l + Wi7l) | 0
        var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
        Wil = (Wil + gamma1l) | 0
        Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
        Wil = (Wil + Wi16l) | 0
        Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0
    
        W[i] = Wih
        W[i + 1] = Wil
      }
    
      for (var j = 0; j < 160; j += 2) {
        Wih = W[j]
        Wil = W[j + 1]
    
        var majh = maj(ah, bh, ch)
        var majl = maj(al, bl, cl)
    
        var sigma0h = sigma0(ah, al)
        var sigma0l = sigma0(al, ah)
        var sigma1h = sigma1(eh, el)
        var sigma1l = sigma1(el, eh)
    
        // t1 = h + sigma1 + ch + K[j] + W[j]
        var Kih = K[j]
        var Kil = K[j + 1]
    
        var chh = Ch(eh, fh, gh)
        var chl = Ch(el, fl, gl)
    
        var t1l = (hl + sigma1l) | 0
        var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
        t1l = (t1l + chl) | 0
        t1h = (t1h + chh + getCarry(t1l, chl)) | 0
        t1l = (t1l + Kil) | 0
        t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
        t1l = (t1l + Wil) | 0
        t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0
    
        // t2 = sigma0 + maj
        var t2l = (sigma0l + majl) | 0
        var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0
    
        hh = gh
        hl = gl
        gh = fh
        gl = fl
        fh = eh
        fl = el
        el = (dl + t1l) | 0
        eh = (dh + t1h + getCarry(el, dl)) | 0
        dh = ch
        dl = cl
        ch = bh
        cl = bl
        bh = ah
        bl = al
        al = (t1l + t2l) | 0
        ah = (t1h + t2h + getCarry(al, t1l)) | 0
      }
    
      this._al = (this._al + al) | 0
      this._bl = (this._bl + bl) | 0
      this._cl = (this._cl + cl) | 0
      this._dl = (this._dl + dl) | 0
      this._el = (this._el + el) | 0
      this._fl = (this._fl + fl) | 0
      this._gl = (this._gl + gl) | 0
      this._hl = (this._hl + hl) | 0
    
      this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
      this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
      this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
      this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
      this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
      this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
      this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
      this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
    }
    
    Sha512.prototype._hash = function () {
      var H = new Buffer(64)
    
      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset)
        H.writeInt32BE(l, offset + 4)
      }
    
      writeInt64BE(this._ah, this._al, 0)
      writeInt64BE(this._bh, this._bl, 8)
      writeInt64BE(this._ch, this._cl, 16)
      writeInt64BE(this._dh, this._dl, 24)
      writeInt64BE(this._eh, this._el, 32)
      writeInt64BE(this._fh, this._fl, 40)
      writeInt64BE(this._gh, this._gl, 48)
      writeInt64BE(this._hh, this._hl, 56)
    
      return H
    }
    
    module.exports = Sha512
    
  provide("sha.js/sha512", module.exports);
}(global));

// pakmanager:sha.js/sha
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
     * in FIPS PUB 180-1
     * This source code is derived from sha1.js of the same repository.
     * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
     * operation was added.
     */
    
    var inherits = require('inherits')
    var Hash =  require('sha.js/hash')
    
    var K = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ]
    
    var W = new Array(80)
    
    function Sha () {
      this.init()
      this._w = W
    
      Hash.call(this, 64, 56)
    }
    
    inherits(Sha, Hash)
    
    Sha.prototype.init = function () {
      this._a = 0x67452301
      this._b = 0xefcdab89
      this._c = 0x98badcfe
      this._d = 0x10325476
      this._e = 0xc3d2e1f0
    
      return this
    }
    
    function rotl5 (num) {
      return (num << 5) | (num >>> 27)
    }
    
    function rotl30 (num) {
      return (num << 30) | (num >>> 2)
    }
    
    function ft (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }
    
    Sha.prototype._update = function (M) {
      var W = this._w
    
      var a = this._a | 0
      var b = this._b | 0
      var c = this._c | 0
      var d = this._d | 0
      var e = this._e | 0
    
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
      for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]
    
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20)
        var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0
    
        e = d
        d = c
        c = rotl30(b)
        b = a
        a = t
      }
    
      this._a = (a + this._a) | 0
      this._b = (b + this._b) | 0
      this._c = (c + this._c) | 0
      this._d = (d + this._d) | 0
      this._e = (e + this._e) | 0
    }
    
    Sha.prototype._hash = function () {
      var H = new Buffer(20)
    
      H.writeInt32BE(this._a | 0, 0)
      H.writeInt32BE(this._b | 0, 4)
      H.writeInt32BE(this._c | 0, 8)
      H.writeInt32BE(this._d | 0, 12)
      H.writeInt32BE(this._e | 0, 16)
    
      return H
    }
    
    module.exports = Sha
    
  provide("sha.js/sha", module.exports);
}(global));

// pakmanager:sha.js/sha1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS PUB 180-1
     * Version 2.1a Copyright Paul Johnston 2000 - 2002.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */
    
    var inherits = require('inherits')
    var Hash =  require('sha.js/hash')
    
    var K = [
      0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
    ]
    
    var W = new Array(80)
    
    function Sha1 () {
      this.init()
      this._w = W
    
      Hash.call(this, 64, 56)
    }
    
    inherits(Sha1, Hash)
    
    Sha1.prototype.init = function () {
      this._a = 0x67452301
      this._b = 0xefcdab89
      this._c = 0x98badcfe
      this._d = 0x10325476
      this._e = 0xc3d2e1f0
    
      return this
    }
    
    function rotl1 (num) {
      return (num << 1) | (num >>> 31)
    }
    
    function rotl5 (num) {
      return (num << 5) | (num >>> 27)
    }
    
    function rotl30 (num) {
      return (num << 30) | (num >>> 2)
    }
    
    function ft (s, b, c, d) {
      if (s === 0) return (b & c) | ((~b) & d)
      if (s === 2) return (b & c) | (b & d) | (c & d)
      return b ^ c ^ d
    }
    
    Sha1.prototype._update = function (M) {
      var W = this._w
    
      var a = this._a | 0
      var b = this._b | 0
      var c = this._c | 0
      var d = this._d | 0
      var e = this._e | 0
    
      for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
      for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])
    
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20)
        var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0
    
        e = d
        d = c
        c = rotl30(b)
        b = a
        a = t
      }
    
      this._a = (a + this._a) | 0
      this._b = (b + this._b) | 0
      this._c = (c + this._c) | 0
      this._d = (d + this._d) | 0
      this._e = (e + this._e) | 0
    }
    
    Sha1.prototype._hash = function () {
      var H = new Buffer(20)
    
      H.writeInt32BE(this._a | 0, 0)
      H.writeInt32BE(this._b | 0, 4)
      H.writeInt32BE(this._c | 0, 8)
      H.writeInt32BE(this._d | 0, 12)
      H.writeInt32BE(this._e | 0, 16)
    
      return H
    }
    
    module.exports = Sha1
    
  provide("sha.js/sha1", module.exports);
}(global));

// pakmanager:sha.js/sha224
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
     * in FIPS 180-2
     * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     *
     */
    
    var inherits = require('inherits')
    var Sha256 =  require('sha.js/sha256')
    var Hash =  require('sha.js/hash')
    
    var W = new Array(64)
    
    function Sha224 () {
      this.init()
    
      this._w = W // new Array(64)
    
      Hash.call(this, 64, 56)
    }
    
    inherits(Sha224, Sha256)
    
    Sha224.prototype.init = function () {
      this._a = 0xc1059ed8
      this._b = 0x367cd507
      this._c = 0x3070dd17
      this._d = 0xf70e5939
      this._e = 0xffc00b31
      this._f = 0x68581511
      this._g = 0x64f98fa7
      this._h = 0xbefa4fa4
    
      return this
    }
    
    Sha224.prototype._hash = function () {
      var H = new Buffer(28)
    
      H.writeInt32BE(this._a, 0)
      H.writeInt32BE(this._b, 4)
      H.writeInt32BE(this._c, 8)
      H.writeInt32BE(this._d, 12)
      H.writeInt32BE(this._e, 16)
      H.writeInt32BE(this._f, 20)
      H.writeInt32BE(this._g, 24)
    
      return H
    }
    
    module.exports = Sha224
    
  provide("sha.js/sha224", module.exports);
}(global));

// pakmanager:sha.js/sha384
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var inherits = require('inherits')
    var SHA512 =  require('sha.js/sha512')
    var Hash =  require('sha.js/hash')
    
    var W = new Array(160)
    
    function Sha384 () {
      this.init()
      this._w = W
    
      Hash.call(this, 128, 112)
    }
    
    inherits(Sha384, SHA512)
    
    Sha384.prototype.init = function () {
      this._ah = 0xcbbb9d5d
      this._bh = 0x629a292a
      this._ch = 0x9159015a
      this._dh = 0x152fecd8
      this._eh = 0x67332667
      this._fh = 0x8eb44a87
      this._gh = 0xdb0c2e0d
      this._hh = 0x47b5481d
    
      this._al = 0xc1059ed8
      this._bl = 0x367cd507
      this._cl = 0x3070dd17
      this._dl = 0xf70e5939
      this._el = 0xffc00b31
      this._fl = 0x68581511
      this._gl = 0x64f98fa7
      this._hl = 0xbefa4fa4
    
      return this
    }
    
    Sha384.prototype._hash = function () {
      var H = new Buffer(48)
    
      function writeInt64BE (h, l, offset) {
        H.writeInt32BE(h, offset)
        H.writeInt32BE(l, offset + 4)
      }
    
      writeInt64BE(this._ah, this._al, 0)
      writeInt64BE(this._bh, this._bl, 8)
      writeInt64BE(this._ch, this._cl, 16)
      writeInt64BE(this._dh, this._dl, 24)
      writeInt64BE(this._eh, this._el, 32)
      writeInt64BE(this._fh, this._fl, 40)
    
      return H
    }
    
    module.exports = Sha384
    
  provide("sha.js/sha384", module.exports);
}(global));

// pakmanager:sha.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var exports = module.exports = function SHA (algorithm) {
      algorithm = algorithm.toLowerCase()
    
      var Algorithm = exports[algorithm]
      if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')
    
      return new Algorithm()
    }
    
    exports.sha =  require('sha.js/sha')
    exports.sha1 =  require('sha.js/sha1')
    exports.sha224 =  require('sha.js/sha224')
    exports.sha256 =  require('sha.js/sha256')
    exports.sha384 =  require('sha.js/sha384')
    exports.sha512 =  require('sha.js/sha512')
    
  provide("sha.js", module.exports);
}(global));

// pakmanager:create-hash
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('crypto').createHash;
  provide("create-hash", module.exports);
}(global));

// pakmanager:fill-range
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isObject = require('isobject');
    var isNumber = require('is-number');
    var randomize = require('randomatic');
    var repeatStr = require('repeat-string');
    var repeat = require('repeat-element');
    
    /**
     * Expose `fillRange`
     */
    
    module.exports = fillRange;
    
    /**
     * Return a range of numbers or letters.
     *
     * @param  {String} `a` Start of the range
     * @param  {String} `b` End of the range
     * @param  {String} `step` Increment or decrement to use.
     * @param  {Function} `fn` Custom function to modify each element in the range.
     * @return {Array}
     */
    
    function fillRange(a, b, step, options, fn) {
      if (a == null || b == null) {
        throw new Error('fill-range expects the first and second args to be strings.');
      }
    
      if (typeof step === 'function') {
        fn = step; options = {}; step = null;
      }
    
      if (typeof options === 'function') {
        fn = options; options = {};
      }
    
      if (isObject(step)) {
        options = step; step = '';
      }
    
      var expand, regex = false, sep = '';
      var opts = options || {};
    
      if (typeof opts.silent === 'undefined') {
        opts.silent = true;
      }
    
      step = step || opts.step;
    
      // store a ref to unmodified arg
      var origA = a, origB = b;
    
      b = (b.toString() === '-0') ? 0 : b;
    
      if (opts.optimize || opts.makeRe) {
        step = step ? (step += '~') : step;
        expand = true;
        regex = true;
        sep = '~';
      }
    
      // handle special step characters
      if (typeof step === 'string') {
        var match = stepRe().exec(step);
    
        if (match) {
          var i = match.index;
          var m = match[0];
    
          // repeat string
          if (m === '+') {
            return repeat(a, b);
    
          // randomize a, `b` times
          } else if (m === '?') {
            return [randomize(a, b)];
    
          // expand right, no regex reduction
          } else if (m === '>') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
    
          // expand to an array, or if valid create a reduced
          // string for a regex logic `or`
          } else if (m === '|') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
            regex = true;
            sep = m;
    
          // expand to an array, or if valid create a reduced
          // string for a regex range
          } else if (m === '~') {
            step = step.substr(0, i) + step.substr(i + 1);
            expand = true;
            regex = true;
            sep = m;
          }
        } else if (!isNumber(step)) {
          if (!opts.silent) {
            throw new TypeError('fill-range: invalid step.');
          }
          return null;
        }
      }
    
      if (/[.&*()[\]^%$#@!]/.test(a) || /[.&*()[\]^%$#@!]/.test(b)) {
        if (!opts.silent) {
          throw new RangeError('fill-range: invalid range arguments.');
        }
        return null;
      }
    
      // has neither a letter nor number, or has both letters and numbers
      // this needs to be after the step logic
      if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {
        if (!opts.silent) {
          throw new RangeError('fill-range: invalid range arguments.');
        }
        return null;
      }
    
      // validate arguments
      var isNumA = isNumber(zeros(a));
      var isNumB = isNumber(zeros(b));
    
      if ((!isNumA && isNumB) || (isNumA && !isNumB)) {
        if (!opts.silent) {
          throw new TypeError('fill-range: first range argument is incompatible with second.');
        }
        return null;
      }
    
      // by this point both are the same, so we
      // can use A to check going forward.
      var isNum = isNumA;
      var num = formatStep(step);
    
      // is the range alphabetical? or numeric?
      if (isNum) {
        // if numeric, coerce to an integer
        a = +a; b = +b;
      } else {
        // otherwise, get the charCode to expand alpha ranges
        a = a.charCodeAt(0);
        b = b.charCodeAt(0);
      }
    
      // is the pattern descending?
      var isDescending = a > b;
    
      // don't create a character class if the args are < 0
      if (a < 0 || b < 0) {
        expand = false;
        regex = false;
      }
    
      // detect padding
      var padding = isPadded(origA, origB);
      var res, pad, arr = [];
      var ii = 0;
    
      // character classes, ranges and logical `or`
      if (regex) {
        if (shouldExpand(a, b, num, isNum, padding, opts)) {
          // make sure the correct separator is used
          if (sep === '|' || sep === '~') {
            sep = detectSeparator(a, b, num, isNum, isDescending);
          }
          return wrap([origA, origB], sep, opts);
        }
      }
    
      while (isDescending ? (a >= b) : (a <= b)) {
        if (padding && isNum) {
          pad = padding(a);
        }
    
        // custom function
        if (typeof fn === 'function') {
          res = fn(a, isNum, pad, ii++);
    
        // letters
        } else if (!isNum) {
          if (regex && isInvalidChar(a)) {
            res = null;
          } else {
            res = String.fromCharCode(a);
          }
    
        // numbers
        } else {
          res = formatPadding(a, pad);
        }
    
        // add result to the array, filtering any nulled values
        if (res !== null) arr.push(res);
    
        // increment or decrement
        if (isDescending) {
          a -= num;
        } else {
          a += num;
        }
      }
    
      // now that the array is expanded, we need to handle regex
      // character classes, ranges or logical `or` that wasn't
      // already handled before the loop
      if ((regex || expand) && !opts.noexpand) {
        // make sure the correct separator is used
        if (sep === '|' || sep === '~') {
          sep = detectSeparator(a, b, num, isNum, isDescending);
        }
        if (arr.length === 1 || a < 0 || b < 0) { return arr; }
        return wrap(arr, sep, opts);
      }
    
      return arr;
    }
    
    /**
     * Wrap the string with the correct regex
     * syntax.
     */
    
    function wrap(arr, sep, opts) {
      if (sep === '~') { sep = '-'; }
      var str = arr.join(sep);
      var pre = opts && opts.regexPrefix;
    
      // regex logical `or`
      if (sep === '|') {
        str = pre ? pre + str : str;
        str = '(' + str + ')';
      }
    
      // regex character class
      if (sep === '-') {
        str = (pre && pre === '^')
          ? pre + str
          : str;
        str = '[' + str + ']';
      }
      return [str];
    }
    
    /**
     * Check for invalid characters
     */
    
    function isCharClass(a, b, step, isNum, isDescending) {
      if (isDescending) { return false; }
      if (isNum) { return a <= 9 && b <= 9; }
      if (a < b) { return step === 1; }
      return false;
    }
    
    /**
     * Detect the correct separator to use
     */
    
    function shouldExpand(a, b, num, isNum, padding, opts) {
      if (isNum && (a > 9 || b > 9)) { return false; }
      return !padding && num === 1 && a < b;
    }
    
    /**
     * Detect the correct separator to use
     */
    
    function detectSeparator(a, b, step, isNum, isDescending) {
      var isChar = isCharClass(a, b, step, isNum, isDescending);
      if (!isChar) {
        return '|';
      }
      return '~';
    }
    
    /**
     * Correctly format the step based on type
     */
    
    function formatStep(step) {
      return Math.abs(step >> 0) || 1;
    }
    
    /**
     * Format padding, taking leading `-` into account
     */
    
    function formatPadding(ch, pad) {
      var res = pad ? pad + ch : ch;
      if (pad && ch.toString().charAt(0) === '-') {
        res = '-' + pad + ch.toString().substr(1);
      }
      return res.toString();
    }
    
    /**
     * Check for invalid characters
     */
    
    function isInvalidChar(str) {
      var ch = toStr(str);
      return ch === '\\'
        || ch === '['
        || ch === ']'
        || ch === '^'
        || ch === '('
        || ch === ')'
        || ch === '`';
    }
    
    /**
     * Convert to a string from a charCode
     */
    
    function toStr(ch) {
      return String.fromCharCode(ch);
    }
    
    
    /**
     * Step regex
     */
    
    function stepRe() {
      return /\?|>|\||\+|\~/g;
    }
    
    /**
     * Return true if `val` has either a letter
     * or a number
     */
    
    function noAlphaNum(val) {
      return /[a-z0-9]/i.test(val);
    }
    
    /**
     * Return true if `val` has both a letter and
     * a number (invalid)
     */
    
    function hasBoth(val) {
      return /[a-z][0-9]|[0-9][a-z]/i.test(val);
    }
    
    /**
     * Normalize zeros for checks
     */
    
    function zeros(val) {
      if (/^-*0+$/.test(val.toString())) {
        return '0';
      }
      return val;
    }
    
    /**
     * Return true if `val` has leading zeros,
     * or a similar valid pattern.
     */
    
    function hasZeros(val) {
      return /[^.]\.|^-*0+[0-9]/.test(val);
    }
    
    /**
     * If the string is padded, returns a curried function with
     * the a cached padding string, or `false` if no padding.
     *
     * @param  {*} `origA` String or number.
     * @return {String|Boolean}
     */
    
    function isPadded(origA, origB) {
      if (hasZeros(origA) || hasZeros(origB)) {
        var alen = length(origA);
        var blen = length(origB);
    
        var len = alen >= blen
          ? alen
          : blen;
    
        return function (a) {
          return repeatStr('0', len - length(a));
        };
      }
      return false;
    }
    
    /**
     * Get the string length of `val`
     */
    
    function length(val) {
      return val.toString().length;
    }
    
  provide("fill-range", module.exports);
}(global));

// pakmanager:for-in
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * for-in <https://github.com/jonschlinkert/for-in>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function forIn(o, fn, thisArg) {
      for (var key in o) {
        if (fn.call(thisArg, o[key], key, o) === false) {
          break;
        }
      }
    };
  provide("for-in", module.exports);
}(global));

// pakmanager:glob-parent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path = require('path');
    var isglob = require('is-glob');
    
    module.exports = function globParent(str) {
    	str += 'a'; // preserves full path in case of trailing path separator
    	do {str = path.dirname(str)} while (isglob(str));
    	return str;
    };
    
  provide("glob-parent", module.exports);
}(global));

// pakmanager:is-glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    var isExtglob = require('is-extglob');
    
    module.exports = function isGlob(str) {
      return typeof str === 'string'
        && (/[*!?{}(|)[\]]/.test(str)
         || isExtglob(str));
    };
  provide("is-glob", module.exports);
}(global));

// pakmanager:is-extglob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    module.exports = function isExtglob(str) {
      return typeof str === 'string'
        && /[@?!+*]\(/.test(str);
    };
    
  provide("is-extglob", module.exports);
}(global));

// pakmanager:is-primitive
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-primitive <https://github.com/jonschlinkert/is-primitive>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    // see http://jsperf.com/testing-value-is-primitive/7
    module.exports = function isPrimitive(value) {
      return value == null || (typeof value !== 'function' && typeof value !== 'object');
    };
    
  provide("is-primitive", module.exports);
}(global));

// pakmanager:delegates
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Delegator`.
     */
    
    module.exports = Delegator;
    
    /**
     * Initialize a delegator.
     *
     * @param {Object} proto
     * @param {String} target
     * @api public
     */
    
    function Delegator(proto, target) {
      if (!(this instanceof Delegator)) return new Delegator(proto, target);
      this.proto = proto;
      this.target = target;
      this.methods = [];
      this.getters = [];
      this.setters = [];
      this.fluents = [];
    }
    
    /**
     * Delegate method `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */
    
    Delegator.prototype.method = function(name){
      var proto = this.proto;
      var target = this.target;
      this.methods.push(name);
    
      proto[name] = function(){
        return this[target][name].apply(this[target], arguments);
      };
    
      return this;
    };
    
    /**
     * Delegator accessor `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */
    
    Delegator.prototype.access = function(name){
      return this.getter(name).setter(name);
    };
    
    /**
     * Delegator getter `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */
    
    Delegator.prototype.getter = function(name){
      var proto = this.proto;
      var target = this.target;
      this.getters.push(name);
    
      proto.__defineGetter__(name, function(){
        return this[target][name];
      });
    
      return this;
    };
    
    /**
     * Delegator setter `name`.
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */
    
    Delegator.prototype.setter = function(name){
      var proto = this.proto;
      var target = this.target;
      this.setters.push(name);
    
      proto.__defineSetter__(name, function(val){
        return this[target][name] = val;
      });
    
      return this;
    };
    
    /**
     * Delegator fluent accessor
     *
     * @param {String} name
     * @return {Delegator} self
     * @api public
     */
    
    Delegator.prototype.fluent = function (name) {
      var proto = this.proto;
      var target = this.target;
      this.fluents.push(name);
    
      proto[name] = function(val){
        if ('undefined' != typeof val) {
          this[target][name] = val;
          return this;
        } else {
          return this[target][name];
        }
      };
    
      return this;
    };
    
  provide("delegates", module.exports);
}(global));

// pakmanager:readable-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = (function (){
      try {
        return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
      } catch(_){}
    }());
    exports = module.exports = require('./lib/_stream_readable.js');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require('./lib/_stream_writable.js');
    exports.Duplex = require('./lib/_stream_duplex.js');
    exports.Transform = require('./lib/_stream_transform.js');
    exports.PassThrough = require('./lib/_stream_passthrough.js');
    
  provide("readable-stream", module.exports);
}(global));

// pakmanager:has-unicode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    var os = require("os")
    
    var hasUnicode = module.exports = function () {
      // Recent Win32 platforms (>XP) CAN support unicode in the console but
      // don't have to, and in non-english locales often use traditional local
      // code pages. There's no way, short of windows system calls or execing
      // the chcp command line program to figure this out. As such, we default
      // this to false and encourage your users to override it via config if
      // appropriate.
      if (os.type() == "Windows_NT") { return false }
    
      var isUTF8 = /[.]UTF-8/
      if (isUTF8.test(process.env.LC_ALL)
       || process.env.LC_CTYPE == 'UTF-8'
       || isUTF8.test(process.env.LANG)) {
        return true
      }
    
      return false
    }
    
  provide("has-unicode", module.exports);
}(global));

// pakmanager:lodash.pad
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var repeat = require('lodash.repeat'),
        toString = require('lodash.tostring');
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
        rsComboSymbolsRange = '\\u20d0-\\u20f0',
        rsVarRange = '\\ufe0e\\ufe0f';
    
    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';
    
    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result++;
      }
      return result;
    }
    
    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor;
    
    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(string, length, chars) {
      length = toInteger(length);
    
      var strLength = stringSize(string);
      if (!length || strLength >= length) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars === undefined ? ' ' : (chars + '');
    
      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));
      return reHasComplexSymbol.test(chars)
        ? stringToArray(result).slice(0, padLength).join('')
        : result.slice(0, padLength);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3');
     * // => 3
     */
    function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);
    
      var strLength = stringSize(string);
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = nativeFloor(mid),
          rightLength = nativeCeil(mid);
    
      return createPadding('', leftLength, chars) + string + createPadding('', rightLength, chars);
    }
    
    module.exports = pad;
    
  provide("lodash.pad", module.exports);
}(global));

// pakmanager:lodash.padend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.2.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var repeat = require('lodash.repeat'),
        toString = require('lodash.tostring');
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
        rsComboSymbolsRange = '\\u20d0-\\u20f0',
        rsVarRange = '\\ufe0e\\ufe0f';
    
    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';
    
    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result++;
      }
      return result;
    }
    
    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil;
    
    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(string, length, chars) {
      length = toInteger(length);
    
      var strLength = stringSize(string);
      if (!length || strLength >= length) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars === undefined ? ' ' : (chars + '');
    
      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));
      return reHasComplexSymbol.test(chars)
        ? stringToArray(result).slice(0, padLength).join('')
        : result.slice(0, padLength);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3');
     * // => 3
     */
    function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      return string + createPadding(string, length, chars);
    }
    
    module.exports = padEnd;
    
  provide("lodash.padend", module.exports);
}(global));

// pakmanager:lodash.padstart
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.2.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var repeat = require('lodash.repeat'),
        toString = require('lodash.tostring');
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
        rsComboSymbolsRange = '\\u20d0-\\u20f0',
        rsVarRange = '\\ufe0e\\ufe0f';
    
    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';
    
    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      if (!(string && reHasComplexSymbol.test(string))) {
        return string.length;
      }
      var result = reComplexSymbol.lastIndex = 0;
      while (reComplexSymbol.test(string)) {
        result++;
      }
      return result;
    }
    
    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return string.match(reComplexSymbol);
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil;
    
    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(string, length, chars) {
      length = toInteger(length);
    
      var strLength = stringSize(string);
      if (!length || strLength >= length) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars === undefined ? ' ' : (chars + '');
    
      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));
      return reHasComplexSymbol.test(chars)
        ? stringToArray(result).slice(0, padLength).join('')
        : result.slice(0, padLength);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3');
     * // => 3
     */
    function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      return createPadding(string, length, chars) + string;
    }
    
    module.exports = padStart;
    
  provide("lodash.padstart", module.exports);
}(global));

// pakmanager:mime-types
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-types
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var db = require('mime-db')
    var extname = require('path').extname
    
    /**
     * Module variables.
     * @private
     */
    
    var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
    var textTypeRegExp = /^text\//i
    
    /**
     * Module exports.
     * @public
     */
    
    exports.charset = charset
    exports.charsets = { lookup: charset }
    exports.contentType = contentType
    exports.extension = extension
    exports.extensions = Object.create(null)
    exports.lookup = lookup
    exports.types = Object.create(null)
    
    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types)
    
    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
      var mime = match && db[match[1].toLowerCase()]
    
      if (mime && mime.charset) {
        return mime.charset
      }
    
      // default text/* to utf-8
      if (match && textTypeRegExp.test(match[1])) {
        return 'UTF-8'
      }
    
      return false
    }
    
    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */
    
    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false
      }
    
      var mime = str.indexOf('/') === -1
        ? exports.lookup(str)
        : str
    
      if (!mime) {
        return false
      }
    
      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime)
        if (charset) mime += '; charset=' + charset.toLowerCase()
      }
    
      return mime
    }
    
    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */
    
    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // TODO: use media-typer
      var match = extractTypeRegExp.exec(type)
    
      // get extensions
      var exts = match && exports.extensions[match[1].toLowerCase()]
    
      if (!exts || !exts.length) {
        return false
      }
    
      return exts[0]
    }
    
    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */
    
    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false
      }
    
      // get the extension ("ext" or ".ext" or full path)
      var extension = extname('x.' + path)
        .toLowerCase()
        .substr(1)
    
      if (!extension) {
        return false
      }
    
      return exports.types[extension] || false
    }
    
    /**
     * Populate the extensions and types maps.
     * @private
     */
    
    function populateMaps(extensions, types) {
      // source preference (least -> most)
      var preference = ['nginx', 'apache', undefined, 'iana']
    
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type]
        var exts = mime.extensions
    
        if (!exts || !exts.length) {
          return
        }
    
        // mime -> extensions
        extensions[type] = exts
    
        // extension -> mime
        for (var i = 0; i < exts.length; i++) {
          var extension = exts[i]
    
          if (types[extension]) {
            var from = preference.indexOf(db[types[extension]].source)
            var to = preference.indexOf(mime.source)
    
            if (types[extension] !== 'application/octet-stream'
              && from > to || (from === to && types[extension].substr(0, 12) === 'application/')) {
              // skip the remapping
              continue
            }
          }
    
          // set the extension -> mime
          types[extension] = type
        }
      })
    }
    
  provide("mime-types", module.exports);
}(global));

// pakmanager:chalk
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var escapeStringRegexp = require('escape-string-regexp');
    var ansiStyles = require('ansi-styles');
    var stripAnsi = require('strip-ansi');
    var hasAnsi = require('has-ansi');
    var supportsColor = require('supports-color');
    var defineProps = Object.defineProperties;
    var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);
    
    function Chalk(options) {
    	// detect mode if not set manually
    	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
    }
    
    // use bright blue on Windows as the normal blue color is illegible
    if (isSimpleWindowsTerm) {
    	ansiStyles.blue.open = '\u001b[94m';
    }
    
    var styles = (function () {
    	var ret = {};
    
    	Object.keys(ansiStyles).forEach(function (key) {
    		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    
    		ret[key] = {
    			get: function () {
    				return build.call(this, this._styles.concat(key));
    			}
    		};
    	});
    
    	return ret;
    })();
    
    var proto = defineProps(function chalk() {}, styles);
    
    function build(_styles) {
    	var builder = function () {
    		return applyStyle.apply(builder, arguments);
    	};
    
    	builder._styles = _styles;
    	builder.enabled = this.enabled;
    	// __proto__ is used because we must return a function, but there is
    	// no way to create a function with a different prototype.
    	/* eslint-disable no-proto */
    	builder.__proto__ = proto;
    
    	return builder;
    }
    
    function applyStyle() {
    	// support varags, but simply cast to string in case there's only one arg
    	var args = arguments;
    	var argsLen = args.length;
    	var str = argsLen !== 0 && String(arguments[0]);
    
    	if (argsLen > 1) {
    		// don't slice `arguments`, it prevents v8 optimizations
    		for (var a = 1; a < argsLen; a++) {
    			str += ' ' + args[a];
    		}
    	}
    
    	if (!this.enabled || !str) {
    		return str;
    	}
    
    	var nestedStyles = this._styles;
    	var i = nestedStyles.length;
    
    	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
    	// see https://github.com/chalk/chalk/issues/58
    	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
    	var originalDim = ansiStyles.dim.open;
    	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
    		ansiStyles.dim.open = '';
    	}
    
    	while (i--) {
    		var code = ansiStyles[nestedStyles[i]];
    
    		// Replace any instances already present with a re-opening code
    		// otherwise only the part of the string until said closing code
    		// will be colored, and the rest will simply be 'plain'.
    		str = code.open + str.replace(code.closeRe, code.open) + code.close;
    	}
    
    	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
    	ansiStyles.dim.open = originalDim;
    
    	return str;
    }
    
    function init() {
    	var ret = {};
    
    	Object.keys(styles).forEach(function (name) {
    		ret[name] = {
    			get: function () {
    				return build.call(this, [name]);
    			}
    		};
    	});
    
    	return ret;
    }
    
    defineProps(Chalk.prototype, init());
    
    module.exports = new Chalk();
    module.exports.styles = ansiStyles;
    module.exports.hasColor = hasAnsi;
    module.exports.stripColor = stripAnsi;
    module.exports.supportsColor = supportsColor;
    
  provide("chalk", module.exports);
}(global));

// pakmanager:commander
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var EventEmitter = require('events').EventEmitter;
    var spawn = require('child_process').spawn;
    var readlink = require('graceful-readlink').readlinkSync;
    var path = require('path');
    var dirname = path.dirname;
    var basename = path.basename;
    var fs = require('fs');
    
    /**
     * Expose the root command.
     */
    
    exports = module.exports = new Command();
    
    /**
     * Expose `Command`.
     */
    
    exports.Command = Command;
    
    /**
     * Expose `Option`.
     */
    
    exports.Option = Option;
    
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {String} flags
     * @param {String} description
     * @api public
     */
    
    function Option(flags, description) {
      this.flags = flags;
      this.required = ~flags.indexOf('<');
      this.optional = ~flags.indexOf('[');
      this.bool = !~flags.indexOf('-no-');
      flags = flags.split(/[ ,|]+/);
      if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
      this.long = flags.shift();
      this.description = description || '';
    }
    
    /**
     * Return option name.
     *
     * @return {String}
     * @api private
     */
    
    Option.prototype.name = function() {
      return this.long
        .replace('--', '')
        .replace('no-', '');
    };
    
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {String} arg
     * @return {Boolean}
     * @api private
     */
    
    Option.prototype.is = function(arg) {
      return arg == this.short || arg == this.long;
    };
    
    /**
     * Initialize a new `Command`.
     *
     * @param {String} name
     * @api public
     */
    
    function Command(name) {
      this.commands = [];
      this.options = [];
      this._execs = {};
      this._allowUnknownOption = false;
      this._args = [];
      this._name = name || '';
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    Command.prototype.__proto__ = EventEmitter.prototype;
    
    /**
     * Add command `name`.
     *
     * The `.action()` callback is invoked when the
     * command `name` is specified via __ARGV__,
     * and the remaining arguments are applied to the
     * function for access.
     *
     * When the `name` is "*" an un-matched command
     * will be passed as the first arg, followed by
     * the rest of __ARGV__ remaining.
     *
     * Examples:
     *
     *      program
     *        .version('0.0.1')
     *        .option('-C, --chdir <path>', 'change the working directory')
     *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
     *        .option('-T, --no-tests', 'ignore test hook')
     *
     *      program
     *        .command('setup')
     *        .description('run remote setup commands')
     *        .action(function() {
     *          console.log('setup');
     *        });
     *
     *      program
     *        .command('exec <cmd>')
     *        .description('run the given remote command')
     *        .action(function(cmd) {
     *          console.log('exec "%s"', cmd);
     *        });
     *
     *      program
     *        .command('teardown <dir> [otherDirs...]')
     *        .description('run teardown commands')
     *        .action(function(dir, otherDirs) {
     *          console.log('dir "%s"', dir);
     *          if (otherDirs) {
     *            otherDirs.forEach(function (oDir) {
     *              console.log('dir "%s"', oDir);
     *            });
     *          }
     *        });
     *
     *      program
     *        .command('*')
     *        .description('deploy the given env')
     *        .action(function(env) {
     *          console.log('deploying "%s"', env);
     *        });
     *
     *      program.parse(process.argv);
      *
     * @param {String} name
     * @param {String} [desc] for git-style sub-commands
     * @return {Command} the new command
     * @api public
     */
    
    Command.prototype.command = function(name, desc, opts) {
      opts = opts || {};
      var args = name.split(/ +/);
      var cmd = new Command(args.shift());
    
      if (desc) {
        cmd.description(desc);
        this.executables = true;
        this._execs[cmd._name] = true;
        if (opts.isDefault) this.defaultExecutable = cmd._name;
      }
    
      cmd._noHelp = !!opts.noHelp;
      this.commands.push(cmd);
      cmd.parseExpectedArgs(args);
      cmd.parent = this;
    
      if (desc) return this;
      return cmd;
    };
    
    /**
     * Define argument syntax for the top-level command.
     *
     * @api public
     */
    
    Command.prototype.arguments = function (desc) {
      return this.parseExpectedArgs(desc.split(/ +/));
    };
    
    /**
     * Add an implicit `help [cmd]` subcommand
     * which invokes `--help` for the given command.
     *
     * @api private
     */
    
    Command.prototype.addImplicitHelpCommand = function() {
      this.command('help [cmd]', 'display help for [cmd]');
    };
    
    /**
     * Parse expected `args`.
     *
     * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parseExpectedArgs = function(args) {
      if (!args.length) return;
      var self = this;
      args.forEach(function(arg) {
        var argDetails = {
          required: false,
          name: '',
          variadic: false
        };
    
        switch (arg[0]) {
          case '<':
            argDetails.required = true;
            argDetails.name = arg.slice(1, -1);
            break;
          case '[':
            argDetails.name = arg.slice(1, -1);
            break;
        }
    
        if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
          argDetails.variadic = true;
          argDetails.name = argDetails.name.slice(0, -3);
        }
        if (argDetails.name) {
          self._args.push(argDetails);
        }
      });
      return this;
    };
    
    /**
     * Register callback `fn` for the command.
     *
     * Examples:
     *
     *      program
     *        .command('help')
     *        .description('display verbose help')
     *        .action(function() {
     *           // output help here
     *        });
     *
     * @param {Function} fn
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.action = function(fn) {
      var self = this;
      var listener = function(args, unknown) {
        // Parse any so-far unknown options
        args = args || [];
        unknown = unknown || [];
    
        var parsed = self.parseOptions(unknown);
    
        // Output help if necessary
        outputHelpIfNecessary(self, parsed.unknown);
    
        // If there are still any unknown options, then we simply
        // die, unless someone asked for help, in which case we give it
        // to them, and then we die.
        if (parsed.unknown.length > 0) {
          self.unknownOption(parsed.unknown[0]);
        }
    
        // Leftover arguments need to be pushed back. Fixes issue #56
        if (parsed.args.length) args = parsed.args.concat(args);
    
        self._args.forEach(function(arg, i) {
          if (arg.required && null == args[i]) {
            self.missingArgument(arg.name);
          } else if (arg.variadic) {
            if (i !== self._args.length - 1) {
              self.variadicArgNotLast(arg.name);
            }
    
            args[i] = args.splice(i);
          }
        });
    
        // Always append ourselves to the end of the arguments,
        // to make sure we match the number of arguments the user
        // expects
        if (self._args.length) {
          args[self._args.length] = self;
        } else {
          args.push(self);
        }
    
        fn.apply(self, args);
      };
      var parent = this.parent || this;
      var name = parent === this ? '*' : this._name;
      parent.on(name, listener);
      if (this._alias) parent.on(this._alias, listener);
      return this;
    };
    
    /**
     * Define option with `flags`, `description` and optional
     * coercion `fn`.
     *
     * The `flags` string should contain both the short and long flags,
     * separated by comma, a pipe or space. The following are all valid
     * all will output this way when `--help` is used.
     *
     *    "-p, --pepper"
     *    "-p|--pepper"
     *    "-p --pepper"
     *
     * Examples:
     *
     *     // simple boolean defaulting to false
     *     program.option('-p, --pepper', 'add pepper');
     *
     *     --pepper
     *     program.pepper
     *     // => Boolean
     *
     *     // simple boolean defaulting to true
     *     program.option('-C, --no-cheese', 'remove cheese');
     *
     *     program.cheese
     *     // => true
     *
     *     --no-cheese
     *     program.cheese
     *     // => false
     *
     *     // required argument
     *     program.option('-C, --chdir <path>', 'change the working directory');
     *
     *     --chdir /tmp
     *     program.chdir
     *     // => "/tmp"
     *
     *     // optional argument
     *     program.option('-c, --cheese [type]', 'add cheese [marble]');
     *
     * @param {String} flags
     * @param {String} description
     * @param {Function|Mixed} fn or default
     * @param {Mixed} defaultValue
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.option = function(flags, description, fn, defaultValue) {
      var self = this
        , option = new Option(flags, description)
        , oname = option.name()
        , name = camelcase(oname);
    
      // default as 3rd arg
      if (typeof fn != 'function') {
        if (fn instanceof RegExp) {
          var regex = fn;
          fn = function(val, def) {
            var m = regex.exec(val);
            return m ? m[0] : def;
          }
        }
        else {
          defaultValue = fn;
          fn = null;
        }
      }
    
      // preassign default value only for --no-*, [optional], or <required>
      if (false == option.bool || option.optional || option.required) {
        // when --no-* we make sure default is true
        if (false == option.bool) defaultValue = true;
        // preassign only if we have a default
        if (undefined !== defaultValue) self[name] = defaultValue;
      }
    
      // register the option
      this.options.push(option);
    
      // when it's passed assign the value
      // and conditionally invoke the callback
      this.on(oname, function(val) {
        // coercion
        if (null !== val && fn) val = fn(val, undefined === self[name]
          ? defaultValue
          : self[name]);
    
        // unassigned or bool
        if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {
          // if no value, bool true, and we have a default, then use it!
          if (null == val) {
            self[name] = option.bool
              ? defaultValue || true
              : false;
          } else {
            self[name] = val;
          }
        } else if (null !== val) {
          // reassign
          self[name] = val;
        }
      });
    
      return this;
    };
    
    /**
     * Allow unknown options on the command line.
     *
     * @param {Boolean} arg if `true` or omitted, no error will be thrown
     * for unknown options.
     * @api public
     */
    Command.prototype.allowUnknownOption = function(arg) {
        this._allowUnknownOption = arguments.length === 0 || arg;
        return this;
    };
    
    /**
     * Parse `argv`, settings options and invoking commands when defined.
     *
     * @param {Array} argv
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.parse = function(argv) {
      // implicit help
      if (this.executables) this.addImplicitHelpCommand();
    
      // store raw args
      this.rawArgs = argv;
    
      // guess name
      this._name = this._name || basename(argv[1], '.js');
    
      // github-style sub-commands with no sub-command
      if (this.executables && argv.length < 3 && !this.defaultExecutable) {
        // this user needs help
        argv.push('--help');
      }
    
      // process argv
      var parsed = this.parseOptions(this.normalize(argv.slice(2)));
      var args = this.args = parsed.args;
    
      var result = this.parseArgs(this.args, parsed.unknown);
    
      // executable sub-commands
      var name = result.args[0];
      if (this._execs[name] && typeof this._execs[name] != "function") {
        return this.executeSubCommand(argv, args, parsed.unknown);
      } else if (this.defaultExecutable) {
        // use the default subcommand
        args.unshift(name = this.defaultExecutable);
        return this.executeSubCommand(argv, args, parsed.unknown);
      }
    
      return result;
    };
    
    /**
     * Execute a sub-command executable.
     *
     * @param {Array} argv
     * @param {Array} args
     * @param {Array} unknown
     * @api private
     */
    
    Command.prototype.executeSubCommand = function(argv, args, unknown) {
      args = args.concat(unknown);
    
      if (!args.length) this.help();
      if ('help' == args[0] && 1 == args.length) this.help();
    
      // <cmd> --help
      if ('help' == args[0]) {
        args[0] = args[1];
        args[1] = '--help';
      }
    
      // executable
      var f = argv[1];
      // name of the subcommand, link `pm-install`
      var bin = basename(f, '.js') + '-' + args[0];
    
    
      // In case of globally installed, get the base dir where executable
      //  subcommand file should be located at
      var baseDir
        , link = readlink(f);
    
      // when symbolink is relative path
      if (link !== f && link.charAt(0) !== '/') {
        link = path.join(dirname(f), link)
      }
      baseDir = dirname(link);
    
      // prefer local `./<bin>` to bin in the $PATH
      var localBin = path.join(baseDir, bin);
    
      // whether bin file is a js script with explicit `.js` extension
      var isExplicitJS = false;
      if (exists(localBin + '.js')) {
        bin = localBin + '.js';
        isExplicitJS = true;
      } else if (exists(localBin)) {
        bin = localBin;
      }
    
      args = args.slice(1);
    
      var proc;
      if (process.platform !== 'win32') {
        if (isExplicitJS) {
          args.unshift(localBin);
          // add executable arguments to spawn
          args = (process.execArgv || []).concat(args);
    
          proc = spawn('node', args, { stdio: 'inherit', customFds: [0, 1, 2] });
        } else {
          proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
        }
      } else {
        args.unshift(localBin);
        proc = spawn(process.execPath, args, { stdio: 'inherit'});
      }
    
      proc.on('close', process.exit.bind(process));
      proc.on('error', function(err) {
        if (err.code == "ENOENT") {
          console.error('\n  %s(1) does not exist, try --help\n', bin);
        } else if (err.code == "EACCES") {
          console.error('\n  %s(1) not executable. try chmod or run with root\n', bin);
        }
        process.exit(1);
      });
    
      // Store the reference to the child process
      this.runningCommand = proc;
    };
    
    /**
     * Normalize `args`, splitting joined short flags. For example
     * the arg "-abc" is equivalent to "-a -b -c".
     * This also normalizes equal sign and splits "--abc=def" into "--abc def".
     *
     * @param {Array} args
     * @return {Array}
     * @api private
     */
    
    Command.prototype.normalize = function(args) {
      var ret = []
        , arg
        , lastOpt
        , index;
    
      for (var i = 0, len = args.length; i < len; ++i) {
        arg = args[i];
        if (i > 0) {
          lastOpt = this.optionFor(args[i-1]);
        }
    
        if (arg === '--') {
          // Honor option terminator
          ret = ret.concat(args.slice(i));
          break;
        } else if (lastOpt && lastOpt.required) {
          ret.push(arg);
        } else if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {
          arg.slice(1).split('').forEach(function(c) {
            ret.push('-' + c);
          });
        } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
          ret.push(arg.slice(0, index), arg.slice(index + 1));
        } else {
          ret.push(arg);
        }
      }
    
      return ret;
    };
    
    /**
     * Parse command `args`.
     *
     * When listener(s) are available those
     * callbacks are invoked, otherwise the "*"
     * event is emitted and those actions are invoked.
     *
     * @param {Array} args
     * @return {Command} for chaining
     * @api private
     */
    
    Command.prototype.parseArgs = function(args, unknown) {
      var name;
    
      if (args.length) {
        name = args[0];
        if (this.listeners(name).length) {
          this.emit(args.shift(), args, unknown);
        } else {
          this.emit('*', args);
        }
      } else {
        outputHelpIfNecessary(this, unknown);
    
        // If there were no args and we have unknown options,
        // then they are extraneous and we need to error.
        if (unknown.length > 0) {
          this.unknownOption(unknown[0]);
        }
      }
    
      return this;
    };
    
    /**
     * Return an option matching `arg` if any.
     *
     * @param {String} arg
     * @return {Option}
     * @api private
     */
    
    Command.prototype.optionFor = function(arg) {
      for (var i = 0, len = this.options.length; i < len; ++i) {
        if (this.options[i].is(arg)) {
          return this.options[i];
        }
      }
    };
    
    /**
     * Parse options from `argv` returning `argv`
     * void of these options.
     *
     * @param {Array} argv
     * @return {Array}
     * @api public
     */
    
    Command.prototype.parseOptions = function(argv) {
      var args = []
        , len = argv.length
        , literal
        , option
        , arg;
    
      var unknownOptions = [];
    
      // parse options
      for (var i = 0; i < len; ++i) {
        arg = argv[i];
    
        // literal args after --
        if ('--' == arg) {
          literal = true;
          continue;
        }
    
        if (literal) {
          args.push(arg);
          continue;
        }
    
        // find matching Option
        option = this.optionFor(arg);
    
        // option is defined
        if (option) {
          // requires arg
          if (option.required) {
            arg = argv[++i];
            if (null == arg) return this.optionMissingArgument(option);
            this.emit(option.name(), arg);
          // optional arg
          } else if (option.optional) {
            arg = argv[i+1];
            if (null == arg || ('-' == arg[0] && '-' != arg)) {
              arg = null;
            } else {
              ++i;
            }
            this.emit(option.name(), arg);
          // bool
          } else {
            this.emit(option.name());
          }
          continue;
        }
    
        // looks like an option
        if (arg.length > 1 && '-' == arg[0]) {
          unknownOptions.push(arg);
    
          // If the next argument looks like it might be
          // an argument for this option, we pass it on.
          // If it isn't, then it'll simply be ignored
          if (argv[i+1] && '-' != argv[i+1][0]) {
            unknownOptions.push(argv[++i]);
          }
          continue;
        }
    
        // arg
        args.push(arg);
      }
    
      return { args: args, unknown: unknownOptions };
    };
    
    /**
     * Return an object containing options as key-value pairs
     *
     * @return {Object}
     * @api public
     */
    Command.prototype.opts = function() {
      var result = {}
        , len = this.options.length;
    
      for (var i = 0 ; i < len; i++) {
        var key = camelcase(this.options[i].name());
        result[key] = key === 'version' ? this._version : this[key];
      }
      return result;
    };
    
    /**
     * Argument `name` is missing.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.missingArgument = function(name) {
      console.error();
      console.error("  error: missing required argument `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * `Option` is missing an argument, but received `flag` or nothing.
     *
     * @param {String} option
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.optionMissingArgument = function(option, flag) {
      console.error();
      if (flag) {
        console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);
      } else {
        console.error("  error: option `%s' argument missing", option.flags);
      }
      console.error();
      process.exit(1);
    };
    
    /**
     * Unknown option `flag`.
     *
     * @param {String} flag
     * @api private
     */
    
    Command.prototype.unknownOption = function(flag) {
      if (this._allowUnknownOption) return;
      console.error();
      console.error("  error: unknown option `%s'", flag);
      console.error();
      process.exit(1);
    };
    
    /**
     * Variadic argument with `name` is not the last argument as required.
     *
     * @param {String} name
     * @api private
     */
    
    Command.prototype.variadicArgNotLast = function(name) {
      console.error();
      console.error("  error: variadic arguments must be last `%s'", name);
      console.error();
      process.exit(1);
    };
    
    /**
     * Set the program version to `str`.
     *
     * This method auto-registers the "-V, --version" flag
     * which will print the version number when passed.
     *
     * @param {String} str
     * @param {String} flags
     * @return {Command} for chaining
     * @api public
     */
    
    Command.prototype.version = function(str, flags) {
      if (0 == arguments.length) return this._version;
      this._version = str;
      flags = flags || '-V, --version';
      this.option(flags, 'output the version number');
      this.on('version', function() {
        process.stdout.write(str + '\n');
        process.exit(0);
      });
      return this;
    };
    
    /**
     * Set the description to `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.description = function(str) {
      if (0 === arguments.length) return this._description;
      this._description = str;
      return this;
    };
    
    /**
     * Set an alias for the command
     *
     * @param {String} alias
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.alias = function(alias) {
      if (0 == arguments.length) return this._alias;
      this._alias = alias;
      return this;
    };
    
    /**
     * Set / get the command usage `str`.
     *
     * @param {String} str
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.usage = function(str) {
      var args = this._args.map(function(arg) {
        return humanReadableArgName(arg);
      });
    
      var usage = '[options]'
        + (this.commands.length ? ' [command]' : '')
        + (this._args.length ? ' ' + args.join(' ') : '');
    
      if (0 == arguments.length) return this._usage || usage;
      this._usage = str;
    
      return this;
    };
    
    /**
     * Get the name of the command
     *
     * @param {String} name
     * @return {String|Command}
     * @api public
     */
    
    Command.prototype.name = function() {
      return this._name;
    };
    
    /**
     * Return the largest option length.
     *
     * @return {Number}
     * @api private
     */
    
    Command.prototype.largestOptionLength = function() {
      return this.options.reduce(function(max, option) {
        return Math.max(max, option.flags.length);
      }, 0);
    };
    
    /**
     * Return help for options.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.optionHelp = function() {
      var width = this.largestOptionLength();
    
      // Prepend the help information
      return [pad('-h, --help', width) + '  ' + 'output usage information']
          .concat(this.options.map(function(option) {
            return pad(option.flags, width) + '  ' + option.description;
          }))
          .join('\n');
    };
    
    /**
     * Return command help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.commandHelp = function() {
      if (!this.commands.length) return '';
    
      var commands = this.commands.filter(function(cmd) {
        return !cmd._noHelp;
      }).map(function(cmd) {
        var args = cmd._args.map(function(arg) {
          return humanReadableArgName(arg);
        }).join(' ');
    
        return [
          cmd._name
            + (cmd._alias ? '|' + cmd._alias : '')
            + (cmd.options.length ? ' [options]' : '')
            + ' ' + args
          , cmd.description()
        ];
      });
    
      var width = commands.reduce(function(max, command) {
        return Math.max(max, command[0].length);
      }, 0);
    
      return [
        ''
        , '  Commands:'
        , ''
        , commands.map(function(cmd) {
          var desc = cmd[1] ? '  ' + cmd[1] : '';
          return pad(cmd[0], width) + desc;
        }).join('\n').replace(/^/gm, '    ')
        , ''
      ].join('\n');
    };
    
    /**
     * Return program help documentation.
     *
     * @return {String}
     * @api private
     */
    
    Command.prototype.helpInformation = function() {
      var desc = [];
      if (this._description) {
        desc = [
          '  ' + this._description
          , ''
        ];
      }
    
      var cmdName = this._name;
      if (this._alias) {
        cmdName = cmdName + '|' + this._alias;
      }
      var usage = [
        ''
        ,'  Usage: ' + cmdName + ' ' + this.usage()
        , ''
      ];
    
      var cmds = [];
      var commandHelp = this.commandHelp();
      if (commandHelp) cmds = [commandHelp];
    
      var options = [
        '  Options:'
        , ''
        , '' + this.optionHelp().replace(/^/gm, '    ')
        , ''
        , ''
      ];
    
      return usage
        .concat(cmds)
        .concat(desc)
        .concat(options)
        .join('\n');
    };
    
    /**
     * Output help information for this command
     *
     * @api public
     */
    
    Command.prototype.outputHelp = function(cb) {
      if (!cb) {
        cb = function(passthru) {
          return passthru;
        }
      }
      process.stdout.write(cb(this.helpInformation()));
      this.emit('--help');
    };
    
    /**
     * Output help information and exit.
     *
     * @api public
     */
    
    Command.prototype.help = function(cb) {
      this.outputHelp(cb);
      process.exit();
    };
    
    /**
     * Camel-case the given `flag`
     *
     * @param {String} flag
     * @return {String}
     * @api private
     */
    
    function camelcase(flag) {
      return flag.split('-').reduce(function(str, word) {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }
    
    /**
     * Pad `str` to `width`.
     *
     * @param {String} str
     * @param {Number} width
     * @return {String}
     * @api private
     */
    
    function pad(str, width) {
      var len = Math.max(0, width - str.length);
      return str + Array(len + 1).join(' ');
    }
    
    /**
     * Output help information if necessary
     *
     * @param {Command} command to output help for
     * @param {Array} array of options to search for -h or --help
     * @api private
     */
    
    function outputHelpIfNecessary(cmd, options) {
      options = options || [];
      for (var i = 0; i < options.length; i++) {
        if (options[i] == '--help' || options[i] == '-h') {
          cmd.outputHelp();
          process.exit(0);
        }
      }
    }
    
    /**
     * Takes an argument an returns its human readable equivalent for help usage.
     *
     * @param {Object} arg
     * @return {String}
     * @api private
     */
    
    function humanReadableArgName(arg) {
      var nameOutput = arg.name + (arg.variadic === true ? '...' : '');
    
      return arg.required
        ? '<' + nameOutput + '>'
        : '[' + nameOutput + ']'
    }
    
    // for versions before node v0.8 when there weren't `fs.existsSync`
    function exists(file) {
      try {
        if (fs.statSync(file).isFile()) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    
    
  provide("commander", module.exports);
}(global));

// pakmanager:is-my-json-valid/formats
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
    exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
    exports['time'] = /^\d{2}:\d{2}:\d{2}$/
    exports['email'] = /^\S+@\S+$/
    exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
    exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
    exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
    exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
    exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
    exports['alpha'] = /^[a-zA-Z]+$/
    exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
    exports['style'] = /\s*(.+?):\s*([^;]+);?/g
    exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
    exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/
    
  provide("is-my-json-valid/formats", module.exports);
}(global));

// pakmanager:is-my-json-valid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var genobj = require('generate-object-property')
    var genfun = require('generate-function')
    var jsonpointer = require('jsonpointer')
    var xtend = require('xtend')
    var formats =  require('is-my-json-valid/formats')
    
    var get = function(obj, additionalSchemas, ptr) {
    
      var visit = function(sub) {
        if (sub && sub.id === ptr) return sub
        if (typeof sub !== 'object' || !sub) return null
        return Object.keys(sub).reduce(function(res, k) {
          return res || visit(sub[k])
        }, null)
      }
    
      var res = visit(obj)
      if (res) return res
    
      ptr = ptr.replace(/^#/, '')
      ptr = ptr.replace(/\/$/, '')
    
      try {
        return jsonpointer.get(obj, decodeURI(ptr))
      } catch (err) {
        var end = ptr.indexOf('#')
        var other
        // external reference
        if (end !== 0) {
          // fragment doesn't exist.
          if (end === -1) {
            other = additionalSchemas[ptr]
          } else {
            var ext = ptr.slice(0, end)
            other = additionalSchemas[ext]
            var fragment = ptr.slice(end).replace(/^#/, '')
            try {
              return jsonpointer.get(other, fragment)
            } catch (err) {}
          }
        } else {
          other = additionalSchemas[ptr]
        }
        return other || null
      }
    }
    
    var formatName = function(field) {
      field = JSON.stringify(field)
      var pattern = /\[([^\[\]"]+)\]/
      while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
      return field
    }
    
    var types = {}
    
    types.any = function() {
      return 'true'
    }
    
    types.null = function(name) {
      return name+' === null'
    }
    
    types.boolean = function(name) {
      return 'typeof '+name+' === "boolean"'
    }
    
    types.array = function(name) {
      return 'Array.isArray('+name+')'
    }
    
    types.object = function(name) {
      return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
    }
    
    types.number = function(name) {
      return 'typeof '+name+' === "number"'
    }
    
    types.integer = function(name) {
      return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
    }
    
    types.string = function(name) {
      return 'typeof '+name+' === "string"'
    }
    
    var unique = function(array) {
      var list = []
      for (var i = 0; i < array.length; i++) {
        list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
      }
      for (var i = 1; i < list.length; i++) {
        if (list.indexOf(list[i]) !== i) return false
      }
      return true
    }
    
    var isMultipleOf = function(name, multipleOf) {
      var res;
      var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1
      if (factor > 1) {
        var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1
        if (factorName > factor) res = true
        else res = Math.round(factor * name) % (factor * multipleOf)
      }
      else res = name % multipleOf;
      return !res;
    }
    
    var toType = function(node) {
      return node.type
    }
    
    var compile = function(schema, cache, root, reporter, opts) {
      var fmts = opts ? xtend(formats, opts.formats) : formats
      var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}
      var verbose = opts ? !!opts.verbose : false;
      var greedy = opts && opts.greedy !== undefined ?
        opts.greedy : false;
    
      var syms = {}
      var gensym = function(name) {
        return name+(syms[name] = (syms[name] || 0)+1)
      }
    
      var reversePatterns = {}
      var patterns = function(p) {
        if (reversePatterns[p]) return reversePatterns[p]
        var n = gensym('pattern')
        scope[n] = new RegExp(p)
        reversePatterns[p] = n
        return n
      }
    
      var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
      var genloop = function() {
        var v = vars.shift()
        vars.push(v+v[0])
        return v
      }
    
      var visit = function(name, node, reporter, filter) {
        var properties = node.properties
        var type = node.type
        var tuple = false
    
        if (Array.isArray(node.items)) { // tuple type
          properties = {}
          node.items.forEach(function(item, i) {
            properties[i] = item
          })
          type = 'array'
          tuple = true
        }
    
        var indent = 0
        var error = function(msg, prop, value) {
          validate('errors++')
          if (reporter === true) {
            validate('if (validate.errors === null) validate.errors = []')
            if (verbose) {
              validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))
            } else {
              validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
            }
          }
        }
    
        if (node.required === true) {
          indent++
          validate('if (%s === undefined) {', name)
          error('is required')
          validate('} else {')
        } else {
          indent++
          validate('if (%s !== undefined) {', name)
        }
    
        var valid = [].concat(type)
          .map(function(t) {
            return types[t || 'any'](name)
          })
          .join(' || ') || 'true'
    
        if (valid !== 'true') {
          indent++
          validate('if (!(%s)) {', valid)
          error('is the wrong type')
          validate('} else {')
        }
    
        if (tuple) {
          if (node.additionalItems === false) {
            validate('if (%s.length > %d) {', name, node.items.length)
            error('has additional items')
            validate('}')
          } else if (node.additionalItems) {
            var i = genloop()
            validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
            visit(name+'['+i+']', node.additionalItems, reporter, filter)
            validate('}')
          }
        }
    
        if (node.format && fmts[node.format]) {
          if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
          var n = gensym('format')
          scope[n] = fmts[node.format]
    
          if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
          else validate('if (!%s.test(%s)) {', n, name)
          error('must be '+node.format+' format')
          validate('}')
          if (type !== 'string' && formats[node.format]) validate('}')
        }
    
        if (Array.isArray(node.required)) {
          var isUndefined = function(req) {
            return genobj(name, req) + ' === undefined'
          }
    
          var checkRequired = function (req) {
            var prop = genobj(name, req);
            validate('if (%s === undefined) {', prop)
            error('is required', prop)
            validate('missing++')
            validate('}')
          }
          validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
          validate('var missing = 0')
          node.required.map(checkRequired)
          validate('}');
          if (!greedy) {
            validate('if (missing === 0) {')
            indent++
          }
        }
    
        if (node.uniqueItems) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
          validate('if (!(unique(%s))) {', name)
          error('must be unique')
          validate('}')
          if (type !== 'array') validate('}')
        }
    
        if (node.enum) {
          var complex = node.enum.some(function(e) {
            return typeof e === 'object'
          })
    
          var compare = complex ?
            function(e) {
              return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
            } :
            function(e) {
              return name+' !== '+JSON.stringify(e)
            }
    
          validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
          error('must be an enum value')
          validate('}')
        }
    
        if (node.dependencies) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          Object.keys(node.dependencies).forEach(function(key) {
            var deps = node.dependencies[key]
            if (typeof deps === 'string') deps = [deps]
    
            var exists = function(k) {
              return genobj(name, k) + ' !== undefined'
            }
    
            if (Array.isArray(deps)) {
              validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
              error('dependencies not set')
              validate('}')
            }
            if (typeof deps === 'object') {
              validate('if (%s !== undefined) {', genobj(name, key))
              visit(name, deps, reporter, filter)
              validate('}')
            }
          })
    
          if (type !== 'object') validate('}')
        }
    
        if (node.additionalProperties || node.additionalProperties === false) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          var i = genloop()
          var keys = gensym('keys')
    
          var toCompare = function(p) {
            return keys+'['+i+'] !== '+JSON.stringify(p)
          }
    
          var toTest = function(p) {
            return '!'+patterns(p)+'.test('+keys+'['+i+'])'
          }
    
          var additionalProp = Object.keys(properties || {}).map(toCompare)
            .concat(Object.keys(node.patternProperties || {}).map(toTest))
            .join(' && ') || 'true'
    
          validate('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
              ('if (%s) {', additionalProp)
    
          if (node.additionalProperties === false) {
            if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
            error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
          } else {
            visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
          }
    
          validate
              ('}')
            ('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.$ref) {
          var sub = get(root, opts && opts.schemas || {}, node.$ref)
          if (sub) {
            var fn = cache[node.$ref]
            if (!fn) {
              cache[node.$ref] = function proxy(data) {
                return fn(data)
              }
              fn = compile(sub, cache, root, false, opts)
            }
            var n = gensym('ref')
            scope[n] = fn
            validate('if (!(%s(%s))) {', n, name)
            error('referenced schema does not match')
            validate('}')
          }
        }
    
        if (node.not) {
          var prev = gensym('prev')
          validate('var %s = errors', prev)
          visit(name, node.not, false, filter)
          validate('if (%s === errors) {', prev)
          error('negative schema matches')
          validate('} else {')
            ('errors = %s', prev)
          ('}')
        }
    
        if (node.items && !tuple) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
    
          var i = genloop()
          validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
          visit(name+'['+i+']', node.items, reporter, filter)
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.patternProperties) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
          var keys = gensym('keys')
          var i = genloop()
          validate
            ('var %s = Object.keys(%s)', keys, name)
            ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
    
          Object.keys(node.patternProperties).forEach(function(key) {
            var p = patterns(key)
            validate('if (%s.test(%s)) {', p, keys+'['+i+']')
            visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
            validate('}')
          })
    
          validate('}')
          if (type !== 'object') validate('}')
        }
    
        if (node.pattern) {
          var p = patterns(node.pattern)
          if (type !== 'string') validate('if (%s) {', types.string(name))
          validate('if (!(%s.test(%s))) {', p, name)
          error('pattern mismatch')
          validate('}')
          if (type !== 'string') validate('}')
        }
    
        if (node.allOf) {
          node.allOf.forEach(function(sch) {
            visit(name, sch, reporter, filter)
          })
        }
    
        if (node.anyOf && node.anyOf.length) {
          var prev = gensym('prev')
    
          node.anyOf.forEach(function(sch, i) {
            if (i === 0) {
              validate('var %s = errors', prev)
            } else {
              validate('if (errors !== %s) {', prev)
                ('errors = %s', prev)
            }
            visit(name, sch, false, false)
          })
          node.anyOf.forEach(function(sch, i) {
            if (i) validate('}')
          })
          validate('if (%s !== errors) {', prev)
          error('no schemas match')
          validate('}')
        }
    
        if (node.oneOf && node.oneOf.length) {
          var prev = gensym('prev')
          var passes = gensym('passes')
    
          validate
            ('var %s = errors', prev)
            ('var %s = 0', passes)
    
          node.oneOf.forEach(function(sch, i) {
            visit(name, sch, false, false)
            validate('if (%s === errors) {', prev)
              ('%s++', passes)
            ('} else {')
              ('errors = %s', prev)
            ('}')
          })
    
          validate('if (%s !== 1) {', passes)
          error('no (or more than one) schemas match')
          validate('}')
        }
    
        if (node.multipleOf !== undefined) {
          if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
    
          validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)
    
          error('has a remainder')
          validate('}')
    
          if (type !== 'number' && type !== 'integer') validate('}')
        }
    
        if (node.maxProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
          error('has more properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.minProperties !== undefined) {
          if (type !== 'object') validate('if (%s) {', types.object(name))
    
          validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
          error('has less properties than allowed')
          validate('}')
    
          if (type !== 'object') validate('}')
        }
    
        if (node.maxItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
    
          validate('if (%s.length > %d) {', name, node.maxItems)
          error('has more items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.minItems !== undefined) {
          if (type !== 'array') validate('if (%s) {', types.array(name))
    
          validate('if (%s.length < %d) {', name, node.minItems)
          error('has less items than allowed')
          validate('}')
    
          if (type !== 'array') validate('}')
        }
    
        if (node.maxLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length > %d) {', name, node.maxLength)
          error('has longer length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minLength !== undefined) {
          if (type !== 'string') validate('if (%s) {', types.string(name))
    
          validate('if (%s.length < %d) {', name, node.minLength)
          error('has less length than allowed')
          validate('}')
    
          if (type !== 'string') validate('}')
        }
    
        if (node.minimum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
          error('is less than minimum')
          validate('}')
        }
    
        if (node.maximum !== undefined) {
          validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
          error('is more than maximum')
          validate('}')
        }
    
        if (properties) {
          Object.keys(properties).forEach(function(p) {
            if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)
    
            visit(genobj(name, p), properties[p], reporter, filter)
    
            if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
          })
        }
    
        while (indent--) validate('}')
      }
    
      var validate = genfun
        ('function validate(data) {')
          ('validate.errors = null')
          ('var errors = 0')
    
      visit('data', schema, reporter, opts && opts.filter)
    
      validate
          ('return errors === 0')
        ('}')
    
      validate = validate.toFunction(scope)
      validate.errors = null
    
      if (Object.defineProperty) {
        Object.defineProperty(validate, 'error', {
          get: function() {
            if (!validate.errors) return ''
            return validate.errors.map(function(err) {
              return err.field + ' ' + err.message;
            }).join('\n')
          }
        })
      }
    
      validate.toJSON = function() {
        return schema
      }
    
      return validate
    }
    
    module.exports = function(schema, opts) {
      if (typeof schema === 'string') schema = JSON.parse(schema)
      return compile(schema, {}, schema, true, opts)
    }
    
    module.exports.filter = function(schema, opts) {
      var validate = module.exports(schema, xtend(opts, {filter: true}))
      return function(sch) {
        validate(sch)
        return sch
      }
    }
    
  provide("is-my-json-valid", module.exports);
}(global));

// pakmanager:assert-plus
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright (c) 2012, Mark Cavage. All rights reserved.
    // Copyright 2015 Joyent, Inc.
    
    var assert = require('assert');
    var Stream = require('stream').Stream;
    var util = require('util');
    
    
    ///--- Globals
    
    /* JSSTYLED */
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    
    
    ///--- Internal
    
    function _capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
    }
    
    function _toss(name, expected, oper, arg, actual) {
        throw new assert.AssertionError({
            message: util.format('%s (%s) is required', name, expected),
            actual: (actual === undefined) ? typeof (arg) : actual(arg),
            expected: expected,
            operator: oper || '===',
            stackStartFunction: _toss.caller
        });
    }
    
    function _getClass(arg) {
        return (Object.prototype.toString.call(arg).slice(8, -1));
    }
    
    function noop() {
        // Why even bother with asserts?
    }
    
    
    ///--- Exports
    
    var types = {
        bool: {
            check: function (arg) { return typeof (arg) === 'boolean'; }
        },
        func: {
            check: function (arg) { return typeof (arg) === 'function'; }
        },
        string: {
            check: function (arg) { return typeof (arg) === 'string'; }
        },
        object: {
            check: function (arg) {
                return typeof (arg) === 'object' && arg !== null;
            }
        },
        number: {
            check: function (arg) {
                return typeof (arg) === 'number' && !isNaN(arg);
            }
        },
        finite: {
            check: function (arg) {
                return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
            }
        },
        buffer: {
            check: function (arg) { return Buffer.isBuffer(arg); },
            operator: 'Buffer.isBuffer'
        },
        array: {
            check: function (arg) { return Array.isArray(arg); },
            operator: 'Array.isArray'
        },
        stream: {
            check: function (arg) { return arg instanceof Stream; },
            operator: 'instanceof',
            actual: _getClass
        },
        date: {
            check: function (arg) { return arg instanceof Date; },
            operator: 'instanceof',
            actual: _getClass
        },
        regexp: {
            check: function (arg) { return arg instanceof RegExp; },
            operator: 'instanceof',
            actual: _getClass
        },
        uuid: {
            check: function (arg) {
                return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
            },
            operator: 'isUUID'
        }
    };
    
    function _setExports(ndebug) {
        var keys = Object.keys(types);
        var out;
    
        /* re-export standard assert */
        if (process.env.NODE_NDEBUG) {
            out = noop;
        } else {
            out = function (arg, msg) {
                if (!arg) {
                    _toss(msg, 'true', arg);
                }
            };
        }
    
        /* standard checks */
        keys.forEach(function (k) {
            if (ndebug) {
                out[k] = noop;
                return;
            }
            var type = types[k];
            out[k] = function (arg, msg) {
                if (!type.check(arg)) {
                    _toss(msg, k, type.operator, arg, type.actual);
                }
            };
        });
    
        /* optional checks */
        keys.forEach(function (k) {
            var name = 'optional' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            out[name] = function (arg, msg) {
                if (arg === undefined || arg === null) {
                    return;
                }
                if (!type.check(arg)) {
                    _toss(msg, k, type.operator, arg, type.actual);
                }
            };
        });
    
        /* arrayOf checks */
        keys.forEach(function (k) {
            var name = 'arrayOf' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            var expected = '[' + k + ']';
            out[name] = function (arg, msg) {
                if (!Array.isArray(arg)) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
                var i;
                for (i = 0; i < arg.length; i++) {
                    if (!type.check(arg[i])) {
                        _toss(msg, expected, type.operator, arg, type.actual);
                    }
                }
            };
        });
    
        /* optionalArrayOf checks */
        keys.forEach(function (k) {
            var name = 'optionalArrayOf' + _capitalize(k);
            if (ndebug) {
                out[name] = noop;
                return;
            }
            var type = types[k];
            var expected = '[' + k + ']';
            out[name] = function (arg, msg) {
                if (arg === undefined || arg === null) {
                    return;
                }
                if (!Array.isArray(arg)) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
                var i;
                for (i = 0; i < arg.length; i++) {
                    if (!type.check(arg[i])) {
                        _toss(msg, expected, type.operator, arg, type.actual);
                    }
                }
            };
        });
    
        /* re-export built-in assertions */
        Object.keys(assert).forEach(function (k) {
            if (k === 'AssertionError') {
                out[k] = assert[k];
                return;
            }
            if (ndebug) {
                out[k] = noop;
                return;
            }
            out[k] = assert[k];
        });
    
        /* export ourselves (for unit tests _only_) */
        out._setExports = _setExports;
    
        return out;
    }
    
    module.exports = _setExports(process.env.NODE_NDEBUG);
    
  provide("assert-plus", module.exports);
}(global));

// pakmanager:mime-db
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = require('./db.json')
    
  provide("mime-db", module.exports);
}(global));

// pakmanager:graceful-fs/fs.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var fs = require('fs')
    
    module.exports = clone(fs)
    
    function clone (obj) {
      if (obj === null || typeof obj !== 'object')
        return obj
    
      if (obj instanceof Object)
        var copy = { __proto__: obj.__proto__ }
      else
        var copy = Object.create(null)
    
      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
      })
    
      return copy
    }
    
  provide("graceful-fs/fs.js", module.exports);
}(global));

// pakmanager:graceful-fs/polyfills.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs =  require('graceful-fs/fs.js')
    var constants = require('constants')
    
    var origCwd = process.cwd
    var cwd = null
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process)
      return cwd
    }
    try {
      process.cwd()
    } catch (er) {}
    
    var chdir = process.chdir
    process.chdir = function(d) {
      cwd = null
      chdir.call(process, d)
    }
    
    module.exports = patch
    
    function patch (fs) {
      // (re-)implement some things that are known busted or missing.
    
      // lchmod, broken prior to 0.6.2
      // back-port the fix here.
      if (constants.hasOwnProperty('O_SYMLINK') &&
          process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs)
      }
    
      // lutimes implementation, or no-op
      if (!fs.lutimes) {
        patchLutimes(fs)
      }
    
      // https://github.com/isaacs/node-graceful-fs/issues/4
      // Chown should not fail on einval or eperm if non-root.
      // It should not fail on enosys ever, as this just indicates
      // that a fs doesn't support the intended operation.
    
      fs.chown = chownFix(fs.chown)
      fs.fchown = chownFix(fs.fchown)
      fs.lchown = chownFix(fs.lchown)
    
      fs.chmod = chownFix(fs.chmod)
      fs.fchmod = chownFix(fs.fchmod)
      fs.lchmod = chownFix(fs.lchmod)
    
      fs.chownSync = chownFixSync(fs.chownSync)
      fs.fchownSync = chownFixSync(fs.fchownSync)
      fs.lchownSync = chownFixSync(fs.lchownSync)
    
      fs.chmodSync = chownFix(fs.chmodSync)
      fs.fchmodSync = chownFix(fs.fchmodSync)
      fs.lchmodSync = chownFix(fs.lchmodSync)
    
      // if lchmod/lchown do not exist, then make them no-ops
      if (!fs.lchmod) {
        fs.lchmod = function (path, mode, cb) {
          process.nextTick(cb)
        }
        fs.lchmodSync = function () {}
      }
      if (!fs.lchown) {
        fs.lchown = function (path, uid, gid, cb) {
          process.nextTick(cb)
        }
        fs.lchownSync = function () {}
      }
    
      // on Windows, A/V software can lock the directory, causing this
      // to fail with an EACCES or EPERM if the directory contains newly
      // created files.  Try again on failure, for up to 1 second.
      if (process.platform === "win32") {
        fs.rename = (function (fs$rename) { return function (from, to, cb) {
          var start = Date.now()
          fs$rename(from, to, function CB (er) {
            if (er
                && (er.code === "EACCES" || er.code === "EPERM")
                && Date.now() - start < 1000) {
              return fs$rename(from, to, CB)
            }
            if (cb) cb(er)
          })
        }})(fs.rename)
      }
    
      // if read() returns EAGAIN, then just try it again.
      fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
        var callback
        if (callback_ && typeof callback_ === 'function') {
          var eagCounter = 0
          callback = function (er, _, __) {
            if (er && er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++
              return fs$read.call(fs, fd, buffer, offset, length, position, callback)
            }
            callback_.apply(this, arguments)
          }
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback)
      }})(fs.read)
    
      fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
        var eagCounter = 0
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position)
          } catch (er) {
            if (er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++
              continue
            }
            throw er
          }
        }
      }})(fs.readSync)
    }
    
    function patchLchmod (fs) {
      fs.lchmod = function (path, mode, callback) {
        callback = callback || noop
        fs.open( path
               , constants.O_WRONLY | constants.O_SYMLINK
               , mode
               , function (err, fd) {
          if (err) {
            callback(err)
            return
          }
          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          fs.fchmod(fd, mode, function (err) {
            fs.close(fd, function(err2) {
              callback(err || err2)
            })
          })
        })
      }
    
      fs.lchmodSync = function (path, mode) {
        var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
    
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        var threw = true
        var ret
        try {
          ret = fs.fchmodSync(fd, mode)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }
    }
    
    function patchLutimes (fs) {
      if (constants.hasOwnProperty("O_SYMLINK")) {
        fs.lutimes = function (path, at, mt, cb) {
          fs.open(path, constants.O_SYMLINK, function (er, fd) {
            cb = cb || noop
            if (er) return cb(er)
            fs.futimes(fd, at, mt, function (er) {
              fs.close(fd, function (er2) {
                return cb(er || er2)
              })
            })
          })
        }
    
        fs.lutimesSync = function (path, at, mt) {
          var fd = fs.openSync(path, constants.O_SYMLINK)
          var ret
          var threw = true
          try {
            ret = fs.futimesSync(fd, at, mt)
            threw = false
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd)
              } catch (er) {}
            } else {
              fs.closeSync(fd)
            }
          }
          return ret
        }
    
      } else {
        fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
        fs.lutimesSync = function () {}
      }
    }
    
    function chownFix (orig) {
      if (!orig) return orig
      return function (target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function (er, res) {
          if (chownErOk(er)) er = null
          cb(er, res)
        })
      }
    }
    
    function chownFixSync (orig) {
      if (!orig) return orig
      return function (target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid)
        } catch (er) {
          if (!chownErOk(er)) throw er
        }
      }
    }
    
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk (er) {
      if (!er)
        return true
    
      if (er.code === "ENOSYS")
        return true
    
      var nonroot = !process.getuid || process.getuid() !== 0
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true
      }
    
      return false
    }
    
  provide("graceful-fs/polyfills.js", module.exports);
}(global));

// pakmanager:graceful-fs/legacy-streams.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream').Stream
    
    module.exports = legacy
    
    function legacy (fs) {
      return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
      }
    
      function ReadStream (path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
    
        Stream.call(this);
    
        var self = this;
    
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
    
        this.flags = 'r';
        this.mode = 438; /*=0666*/
        this.bufferSize = 64 * 1024;
    
        options = options || {};
    
        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
    
        if (this.encoding) this.setEncoding(this.encoding);
    
        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if ('number' !== typeof this.end) {
            throw TypeError('end must be a Number');
          }
    
          if (this.start > this.end) {
            throw new Error('start must be <= end');
          }
    
          this.pos = this.start;
        }
    
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
    
        fs.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit('error', err);
            self.readable = false;
            return;
          }
    
          self.fd = fd;
          self.emit('open', fd);
          self._read();
        })
      }
    
      function WriteStream (path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
    
        Stream.call(this);
    
        this.path = path;
        this.fd = null;
        this.writable = true;
    
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/
        this.bytesWritten = 0;
    
        options = options || {};
    
        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
    
        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.start < 0) {
            throw new Error('start must be >= zero');
          }
    
          this.pos = this.start;
        }
    
        this.busy = false;
        this._queue = [];
    
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
          this.flush();
        }
      }
    }
    
  provide("graceful-fs/legacy-streams.js", module.exports);
}(global));

// pakmanager:graceful-fs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var polyfills =  require('graceful-fs/polyfills.js')
    var legacy =  require('graceful-fs/legacy-streams.js')
    var queue = []
    
    var util = require('util')
    
    function noop () {}
    
    var debug = noop
    if (util.debuglog)
      debug = util.debuglog('gfs4')
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util.format.apply(util, arguments)
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
        console.error(m)
      }
    
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
      process.on('exit', function() {
        debug(queue)
        require('assert').equal(queue.length, 0)
      })
    }
    
    module.exports = patch( require('graceful-fs/fs.js'))
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
      module.exports = patch(fs)
    }
    
    // Always patch fs.close/closeSync, because we want to
    // retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    module.exports.close =
    fs.close = (function (fs$close) { return function (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        if (!err)
          retry()
    
        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }})(fs.close)
    
    module.exports.closeSync =
    fs.closeSync = (function (fs$closeSync) { return function (fd) {
      // Note that graceful-fs also retries when fs.closeSync() fails.
      // Looks like a bug to me, although it's probably a harmless one.
      var rval = fs$closeSync.apply(fs, arguments)
      retry()
      return rval
    }})(fs.closeSync)
    
    function patch (fs) {
      // Everything that references the open() function needs to be in here
      polyfills(fs)
      fs.gracefulify = patch
      fs.FileReadStream = ReadStream;  // Legacy name.
      fs.FileWriteStream = WriteStream;  // Legacy name.
      fs.createReadStream = createReadStream
      fs.createWriteStream = createWriteStream
      var fs$readFile = fs.readFile
      fs.readFile = readFile
      function readFile (path, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$readFile(path, options, cb)
    
        function go$readFile (path, options, cb) {
          return fs$readFile(path, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readFile, [path, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$writeFile = fs.writeFile
      fs.writeFile = writeFile
      function writeFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$writeFile(path, data, options, cb)
    
        function go$writeFile (path, data, options, cb) {
          return fs$writeFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$writeFile, [path, data, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$appendFile = fs.appendFile
      if (fs$appendFile)
        fs.appendFile = appendFile
      function appendFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null
    
        return go$appendFile(path, data, options, cb)
    
        function go$appendFile (path, data, options, cb) {
          return fs$appendFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$appendFile, [path, data, options, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      var fs$readdir = fs.readdir
      fs.readdir = readdir
      function readdir (path, cb) {
        return go$readdir(path, cb)
    
        function go$readdir () {
          return fs$readdir(path, function (err, files) {
            if (files && files.sort)
              files.sort();  // Backwards compatibility with graceful-fs.
    
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readdir, [path, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
    
      if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs)
        ReadStream = legStreams.ReadStream
        WriteStream = legStreams.WriteStream
      }
    
      var fs$ReadStream = fs.ReadStream
      ReadStream.prototype = Object.create(fs$ReadStream.prototype)
      ReadStream.prototype.open = ReadStream$open
    
      var fs$WriteStream = fs.WriteStream
      WriteStream.prototype = Object.create(fs$WriteStream.prototype)
      WriteStream.prototype.open = WriteStream$open
    
      fs.ReadStream = ReadStream
      fs.WriteStream = WriteStream
    
      function ReadStream (path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
      }
    
      function ReadStream$open () {
        var that = this
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy()
    
            that.emit('error', err)
          } else {
            that.fd = fd
            that.emit('open', fd)
            that.read()
          }
        })
      }
    
      function WriteStream (path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
      }
    
      function WriteStream$open () {
        var that = this
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy()
            that.emit('error', err)
          } else {
            that.fd = fd
            that.emit('open', fd)
          }
        })
      }
    
      function createReadStream (path, options) {
        return new ReadStream(path, options)
      }
    
      function createWriteStream (path, options) {
        return new WriteStream(path, options)
      }
    
      var fs$open = fs.open
      fs.open = open
      function open (path, flags, mode, cb) {
        if (typeof mode === 'function')
          cb = mode, mode = null
    
        return go$open(path, flags, mode, cb)
    
        function go$open (path, flags, mode, cb) {
          return fs$open(path, flags, mode, function (err, fd) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$open, [path, flags, mode, cb]])
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments)
              retry()
            }
          })
        }
      }
    
      return fs
    }
    
    function enqueue (elem) {
      debug('ENQUEUE', elem[0].name, elem[1])
      queue.push(elem)
    }
    
    function retry () {
      var elem = queue.shift()
      if (elem) {
        debug('RETRY', elem[0].name, elem[1])
        elem[0].apply(null, elem[1])
      }
    }
    
  provide("graceful-fs", module.exports);
}(global));

// pakmanager:mkdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    var _0777 = parseInt('0777', 8);
    
    module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    
    function mkdirP (p, opts, f, made) {
        if (typeof opts === 'function') {
            f = opts;
            opts = {};
        }
        else if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
        
        var cb = f || function () {};
        p = path.resolve(p);
        
        xfs.mkdir(p, mode, function (er) {
            if (!er) {
                made = made || p;
                return cb(null, made);
            }
            switch (er.code) {
                case 'ENOENT':
                    mkdirP(path.dirname(p), opts, function (er, made) {
                        if (er) cb(er, made);
                        else mkdirP(p, opts, cb, made);
                    });
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    xfs.stat(p, function (er2, stat) {
                        // if the stat fails, then that's super weird.
                        // let the original error be the failure reason.
                        if (er2 || !stat.isDirectory()) cb(er, made)
                        else cb(null, made);
                    });
                    break;
            }
        });
    }
    
    mkdirP.sync = function sync (p, opts, made) {
        if (!opts || typeof opts !== 'object') {
            opts = { mode: opts };
        }
        
        var mode = opts.mode;
        var xfs = opts.fs || fs;
        
        if (mode === undefined) {
            mode = _0777 & (~process.umask());
        }
        if (!made) made = null;
    
        p = path.resolve(p);
    
        try {
            xfs.mkdirSync(p, mode);
            made = made || p;
        }
        catch (err0) {
            switch (err0.code) {
                case 'ENOENT' :
                    made = sync(path.dirname(p), opts, made);
                    sync(p, opts, made);
                    break;
    
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                    var stat;
                    try {
                        stat = xfs.statSync(p);
                    }
                    catch (err1) {
                        throw err0;
                    }
                    if (!stat.isDirectory()) throw err0;
                    break;
            }
        }
    
        return made;
    };
    
  provide("mkdirp", module.exports);
}(global));

// pakmanager:rimraf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = rimraf
    rimraf.sync = rimrafSync
    
    var assert = require("assert")
    var path = require("path")
    var fs = require("fs")
    var glob = require("glob")
    
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    }
    
    // for EMFILE handling
    var timeout = 0
    
    var isWindows = (process.platform === "win32")
    
    function defaults (options) {
      var methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
      ]
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m]
        m = m + 'Sync'
        options[m] = options[m] || fs[m]
      })
    
      options.maxBusyTries = options.maxBusyTries || 3
      options.emfileWait = options.emfileWait || 1000
      if (options.glob === false) {
        options.disableGlob = true
      }
      options.disableGlob = options.disableGlob || false
      options.glob = options.glob || defaultGlobOpts
    }
    
    function rimraf (p, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = {}
      }
    
      assert(p, 'rimraf: missing path')
      assert.equal(typeof p, 'string', 'rimraf: path should be a string')
      assert(options, 'rimraf: missing options')
      assert.equal(typeof options, 'object', 'rimraf: options should be object')
      assert.equal(typeof cb, 'function', 'rimraf: callback function required')
    
      defaults(options)
    
      var busyTries = 0
      var errState = null
      var n = 0
    
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p])
    
      fs.lstat(p, function (er, stat) {
        if (!er)
          return afterGlob(null, [p])
    
        glob(p, options.glob, afterGlob)
      })
    
      function next (er) {
        errState = errState || er
        if (--n === 0)
          cb(errState)
      }
    
      function afterGlob (er, results) {
        if (er)
          return cb(er)
    
        n = results.length
        if (n === 0)
          return cb()
    
        results.forEach(function (p) {
          rimraf_(p, options, function CB (er) {
            if (er) {
              if (isWindows && (er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
                  busyTries < options.maxBusyTries) {
                busyTries ++
                var time = busyTries * 100
                // try again, with the same exact callback as this one.
                return setTimeout(function () {
                  rimraf_(p, options, CB)
                }, time)
              }
    
              // this one won't happen if graceful-fs is used.
              if (er.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function () {
                  rimraf_(p, options, CB)
                }, timeout ++)
              }
    
              // already gone
              if (er.code === "ENOENT") er = null
            }
    
            timeout = 0
            next(er)
          })
        })
      }
    }
    
    // Two possible strategies.
    // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
    // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
    //
    // Both result in an extra syscall when you guess wrong.  However, there
    // are likely far more normal files in the world than directories.  This
    // is based on the assumption that a the average number of files per
    // directory is >= 1.
    //
    // If anyone ever complains about this, then I guess the strategy could
    // be made configurable somehow.  But until then, YAGNI.
    function rimraf_ (p, options, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
    
      // sunos lets the root user unlink directories, which is... weird.
      // so we have to lstat here and make sure it's not a dir.
      options.lstat(p, function (er, st) {
        if (er && er.code === "ENOENT")
          return cb(null)
    
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb)
    
        options.unlink(p, function (er) {
          if (er) {
            if (er.code === "ENOENT")
              return cb(null)
            if (er.code === "EPERM")
              return (isWindows)
                ? fixWinEPERM(p, options, er, cb)
                : rmdir(p, options, er, cb)
            if (er.code === "EISDIR")
              return rmdir(p, options, er, cb)
          }
          return cb(er)
        })
      })
    }
    
    function fixWinEPERM (p, options, er, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
      if (er)
        assert(er instanceof Error)
    
      options.chmod(p, 666, function (er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er)
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er)
            else if (stats.isDirectory())
              rmdir(p, options, er, cb)
            else
              options.unlink(p, cb)
          })
      })
    }
    
    function fixWinEPERMSync (p, options, er) {
      assert(p)
      assert(options)
      if (er)
        assert(er instanceof Error)
    
      try {
        options.chmodSync(p, 666)
      } catch (er2) {
        if (er2.code === "ENOENT")
          return
        else
          throw er
      }
    
      try {
        var stats = options.statSync(p)
      } catch (er3) {
        if (er3.code === "ENOENT")
          return
        else
          throw er
      }
    
      if (stats.isDirectory())
        rmdirSync(p, options, er)
      else
        options.unlinkSync(p)
    }
    
    function rmdir (p, options, originalEr, cb) {
      assert(p)
      assert(options)
      if (originalEr)
        assert(originalEr instanceof Error)
      assert(typeof cb === 'function')
    
      // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
      // if we guessed wrong, and it's not a directory, then
      // raise the original error.
      options.rmdir(p, function (er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb)
        else if (er && er.code === "ENOTDIR")
          cb(originalEr)
        else
          cb(er)
      })
    }
    
    function rmkids(p, options, cb) {
      assert(p)
      assert(options)
      assert(typeof cb === 'function')
    
      options.readdir(p, function (er, files) {
        if (er)
          return cb(er)
        var n = files.length
        if (n === 0)
          return options.rmdir(p, cb)
        var errState
        files.forEach(function (f) {
          rimraf(path.join(p, f), options, function (er) {
            if (errState)
              return
            if (er)
              return cb(errState = er)
            if (--n === 0)
              options.rmdir(p, cb)
          })
        })
      })
    }
    
    // this looks simpler, and is strictly *faster*, but will
    // tie up the JavaScript thread and fail on excessively
    // deep directory trees.
    function rimrafSync (p, options) {
      options = options || {}
      defaults(options)
    
      assert(p, 'rimraf: missing path')
      assert.equal(typeof p, 'string', 'rimraf: path should be a string')
      assert(options, 'rimraf: missing options')
      assert.equal(typeof options, 'object', 'rimraf: options should be object')
    
      var results
    
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p]
      } else {
        try {
          fs.lstatSync(p)
          results = [p]
        } catch (er) {
          results = glob.sync(p, options.glob)
        }
      }
    
      if (!results.length)
        return
    
      for (var i = 0; i < results.length; i++) {
        var p = results[i]
    
        try {
          var st = options.lstatSync(p)
        } catch (er) {
          if (er.code === "ENOENT")
            return
        }
    
        try {
          // sunos lets the root user unlink directories, which is... weird.
          if (st && st.isDirectory())
            rmdirSync(p, options, null)
          else
            options.unlinkSync(p)
        } catch (er) {
          if (er.code === "ENOENT")
            return
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
          if (er.code !== "EISDIR")
            throw er
          rmdirSync(p, options, er)
        }
      }
    }
    
    function rmdirSync (p, options, originalEr) {
      assert(p)
      assert(options)
      if (originalEr)
        assert(originalEr instanceof Error)
    
      try {
        options.rmdirSync(p)
      } catch (er) {
        if (er.code === "ENOENT")
          return
        if (er.code === "ENOTDIR")
          throw originalEr
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options)
      }
    }
    
    function rmkidsSync (p, options) {
      assert(p)
      assert(options)
      options.readdirSync(p).forEach(function (f) {
        rimrafSync(path.join(p, f), options)
      })
      options.rmdirSync(p, options)
    }
    
  provide("rimraf", module.exports);
}(global));

// pakmanager:ms
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Helpers.
     */
    
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    
    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */
    
    module.exports = function(val, options){
      options = options || {};
      if ('string' == typeof val) return parse(val);
      return options.long
        ? long(val)
        : short(val);
    };
    
    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */
    
    function parse(str) {
      str = '' + str;
      if (str.length > 10000) return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    
    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + 'd';
      if (ms >= h) return Math.round(ms / h) + 'h';
      if (ms >= m) return Math.round(ms / m) + 'm';
      if (ms >= s) return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    
    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */
    
    function long(ms) {
      return plural(ms, d, 'day')
        || plural(ms, h, 'hour')
        || plural(ms, m, 'minute')
        || plural(ms, s, 'second')
        || ms + ' ms';
    }
    
    /**
     * Pluralization helper.
     */
    
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
    
  provide("ms", module.exports);
}(global));

// pakmanager:fstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.Abstract = require('./lib/abstract.js')
    exports.Reader = require('./lib/reader.js')
    exports.Writer = require('./lib/writer.js')
    
    exports.File = {
      Reader: require('./lib/file-reader.js'),
      Writer: require('./lib/file-writer.js')
    }
    
    exports.Dir = {
      Reader: require('./lib/dir-reader.js'),
      Writer: require('./lib/dir-writer.js')
    }
    
    exports.Link = {
      Reader: require('./lib/link-reader.js'),
      Writer: require('./lib/link-writer.js')
    }
    
    exports.Proxy = {
      Reader: require('./lib/proxy-reader.js'),
      Writer: require('./lib/proxy-writer.js')
    }
    
    exports.Reader.Dir = exports.DirReader = exports.Dir.Reader
    exports.Reader.File = exports.FileReader = exports.File.Reader
    exports.Reader.Link = exports.LinkReader = exports.Link.Reader
    exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader
    
    exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer
    exports.Writer.File = exports.FileWriter = exports.File.Writer
    exports.Writer.Link = exports.LinkWriter = exports.Link.Writer
    exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer
    
    exports.collect = require('./lib/collect.js')
    
  provide("fstream", module.exports);
}(global));

// pakmanager:minimatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = minimatch
    minimatch.Minimatch = Minimatch
    
    var path = { sep: '/' }
    try {
      path = require('path')
    } catch (er) {}
    
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    var expand = require('brace-expansion')
    
    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]'
    
    // * => any number of characters
    var star = qmark + '*?'
    
    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
    
    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
    
    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!')
    
    // "abc" -> { a:true, b:true, c:true }
    function charSet (s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }
    
    // normalizes slashes.
    var slashSplit = /\/+/
    
    minimatch.filter = filter
    function filter (pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }
    
    function ext (a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }
    
    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch
    
      var orig = minimatch
    
      var m = function minimatch (p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }
    
      m.Minimatch = function Minimatch (pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }
    
      return m
    }
    
    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }
    
    function minimatch (p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
    
      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }
    
      // "" only matches ""
      if (pattern.trim() === '') return p === ''
    
      return new Minimatch(pattern, options).match(p)
    }
    
    function Minimatch (pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options)
      }
    
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }
    
      if (!options) options = {}
      pattern = pattern.trim()
    
      // windows support: need to use /, not \
      if (path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/')
      }
    
      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false
    
      // make the set of regexps etc.
      this.make()
    }
    
    Minimatch.prototype.debug = function () {}
    
    Minimatch.prototype.make = make
    function make () {
      // don't do it more than once.
      if (this._made) return
    
      var pattern = this.pattern
      var options = this.options
    
      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }
    
      // step 1: figure out negation, etc.
      this.parseNegate()
    
      // step 2: expand braces
      var set = this.globSet = this.braceExpand()
    
      if (options.debug) this.debug = console.error
    
      this.debug(this.pattern, set)
    
      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })
    
      this.debug(this.pattern, set)
    
      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)
    
      this.debug(this.pattern, set)
    
      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      })
    
      this.debug(this.pattern, set)
    
      this.set = set
    }
    
    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate () {
      var pattern = this.pattern
      var negate = false
      var options = this.options
      var negateOffset = 0
    
      if (options.nonegate) return
    
      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate
        negateOffset++
      }
    
      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }
    
    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    }
    
    Minimatch.prototype.braceExpand = braceExpand
    
    function braceExpand (pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options
        } else {
          options = {}
        }
      }
    
      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern
    
      if (typeof pattern === 'undefined') {
        throw new Error('undefined pattern')
      }
    
      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }
    
      return expand(pattern)
    }
    
    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse (pattern, isSub) {
      var options = this.options
    
      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''
    
      var re = ''
      var hasMagic = !!options.nocase
      var escaping = false
      // ? => one single character
      var patternListStack = []
      var negativeLists = []
      var plType
      var stateChar
      var inClass = false
      var reClassStart = -1
      var classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
      : '(?!\\.)'
      var self = this
    
      function clearStateChar () {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star
              hasMagic = true
            break
            case '?':
              re += qmark
              hasMagic = true
            break
            default:
              re += '\\' + stateChar
            break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }
    
      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c)
    
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c
          escaping = false
          continue
        }
    
        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false
    
          case '\\':
            clearStateChar()
            escaping = true
          continue
    
          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
    
            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === '!' && i === classStart + 1) c = '^'
              re += c
              continue
            }
    
            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
          continue
    
          case '(':
            if (inClass) {
              re += '('
              continue
            }
    
            if (!stateChar) {
              re += '\\('
              continue
            }
    
            plType = stateChar
            patternListStack.push({
              type: plType,
              start: i - 1,
              reStart: re.length
            })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
          continue
    
          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)'
              continue
            }
    
            clearStateChar()
            hasMagic = true
            re += ')'
            var pl = patternListStack.pop()
            plType = pl.type
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            switch (plType) {
              case '!':
                negativeLists.push(pl)
                re += ')[^/]*?)'
                pl.reEnd = re.length
                break
              case '?':
              case '+':
              case '*':
                re += plType
                break
              case '@': break // the default anyway
            }
          continue
    
          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|'
              escaping = false
              continue
            }
    
            clearStateChar()
            re += '|'
          continue
    
          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar()
    
            if (inClass) {
              re += '\\' + c
              continue
            }
    
            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
          continue
    
          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c
              escaping = false
              continue
            }
    
            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i)
              try {
                RegExp('[' + cs + ']')
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE)
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                hasMagic = hasMagic || sp[1]
                inClass = false
                continue
              }
            }
    
            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
          continue
    
          default:
            // swallow any state char that wasn't consumed
            clearStateChar()
    
            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\'
            }
    
            re += c
    
        } // switch
      } // for
    
      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1)
        sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + '\\[' + sp[0]
        hasMagic = hasMagic || sp[1]
      }
    
      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + 3)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\'
          }
    
          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        })
    
        this.debug('tail=%j\n   %s', tail, tail)
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
          : '\\' + pl.type
    
        hasMagic = true
        re = re.slice(0, pl.reStart) + t + '\\(' + tail
      }
    
      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += '\\\\'
      }
    
      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true
      }
    
      // Hack to work around lack of negative lookbehind in JS
      // A pattern like: *.!(x).!(y|z) needs to ensure that a name
      // like 'a.xyz.yz' doesn't match.  So, the first negative
      // lookahead, has to look ALL the way ahead, to the end of
      // the pattern.
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n]
    
        var nlBefore = re.slice(0, nl.reStart)
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
        var nlAfter = re.slice(nl.reEnd)
    
        nlLast += nlAfter
    
        // Handle nested stuff like *(*.js|!(*.json)), where open parens
        // mean that we should *not* include the ) in the bit that is considered
        // "after" the negated section.
        var openParensBefore = nlBefore.split('(').length - 1
        var cleanAfter = nlAfter
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
        }
        nlAfter = cleanAfter
    
        var dollar = ''
        if (nlAfter === '' && isSub !== SUBPARSE) {
          dollar = '$'
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
        re = newRe
      }
    
      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) {
        re = '(?=.)' + re
      }
    
      if (addPatternStart) {
        re = patternStart + re
      }
    
      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }
    
      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }
    
      var flags = options.nocase ? 'i' : ''
      var regExp = new RegExp('^' + re + '$', flags)
    
      regExp._glob = pattern
      regExp._src = re
    
      return regExp
    }
    
    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }
    
    Minimatch.prototype.makeRe = makeRe
    function makeRe () {
      if (this.regexp || this.regexp === false) return this.regexp
    
      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set
    
      if (!set.length) {
        this.regexp = false
        return this.regexp
      }
      var options = this.options
    
      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
        : twoStarNoDot
      var flags = options.nocase ? 'i' : ''
    
      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
          : (typeof p === 'string') ? regExpEscape(p)
          : p._src
        }).join('\\\/')
      }).join('|')
    
      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$'
    
      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$'
    
      try {
        this.regexp = new RegExp(re, flags)
      } catch (ex) {
        this.regexp = false
      }
      return this.regexp
    }
    
    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }
    
    Minimatch.prototype.match = match
    function match (f, partial) {
      this.debug('match', f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''
    
      if (f === '/' && partial) return true
    
      var options = this.options
    
      // windows: need to use /, not \
      if (path.sep !== '/') {
        f = f.split(path.sep).join('/')
      }
    
      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, 'split', f)
    
      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.
    
      var set = this.set
      this.debug(this.pattern, 'set', set)
    
      // Find the basename of the path by looking for the last non-empty segment
      var filename
      var i
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }
    
      for (i = 0; i < set.length; i++) {
        var pattern = set[i]
        var file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }
    
      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }
    
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options
    
      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern })
    
      this.debug('matchOne', file.length, pattern.length)
    
      for (var fi = 0,
          pi = 0,
          fl = file.length,
          pl = pattern.length
          ; (fi < fl) && (pi < pl)
          ; fi++, pi++) {
        this.debug('matchOne loop')
        var p = pattern[pi]
        var f = file[fi]
    
        this.debug(pattern, p, f)
    
        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false
    
        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])
    
          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
          var pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }
    
          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr]
    
            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
    
            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr)
                break
              }
    
              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr++
            }
          }
    
          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }
    
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug('string match', p, f, hit)
        } else {
          hit = f.match(p)
          this.debug('pattern match', p, f, hit)
        }
    
        if (!hit) return false
      }
    
      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*
    
      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
        return emptyFileEnd
      }
    
      // should be unreachable.
      throw new Error('wtf?')
    }
    
    // replace stuff like \* with *
    function globUnescape (s) {
      return s.replace(/\\(.)/g, '$1')
    }
    
    function regExpEscape (s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }
    
  provide("minimatch", module.exports);
}(global));

// pakmanager:wrappy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Returns a wrapper function that returns a wrapped callback
    // The wrapper function should do some stuff, and return a
    // presumably different callback function.
    // This makes sure that own properties are retained, so that
    // decorations and such are not lost along the way.
    module.exports = wrappy
    function wrappy (fn, cb) {
      if (fn && cb) return wrappy(fn)(cb)
    
      if (typeof fn !== 'function')
        throw new TypeError('need wrapper function')
    
      Object.keys(fn).forEach(function (k) {
        wrapper[k] = fn[k]
      })
    
      return wrapper
    
      function wrapper() {
        var args = new Array(arguments.length)
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
        var ret = fn.apply(this, args)
        var cb = args[args.length-1]
        if (typeof ret === 'function' && ret !== cb) {
          Object.keys(cb).forEach(function (k) {
            ret[k] = cb[k]
          })
        }
        return ret
      }
    }
    
  provide("wrappy", module.exports);
}(global));

// pakmanager:isarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toString = {}.toString;
    
    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };
    
  provide("isarray", module.exports);
}(global));

// pakmanager:process-nextick-args
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    if (!process.version ||
        process.version.indexOf('v0.') === 0 ||
        process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
      module.exports = nextTick;
    } else {
      module.exports = process.nextTick;
    }
    
    function nextTick(fn) {
      var args = new Array(arguments.length - 1);
      var i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
    }
    
  provide("process-nextick-args", module.exports);
}(global));

// pakmanager:string_decoder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var Buffer = require('buffer').Buffer;
    
    var isBufferEncoding = Buffer.isEncoding
      || function(encoding) {
           switch (encoding && encoding.toLowerCase()) {
             case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
             default: return false;
           }
         }
    
    
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    
    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters. CESU-8 is handled as part of the UTF-8 encoding.
    //
    // @TODO Handling all encodings inside a single object makes it very difficult
    // to reason about this code, so it should be split up in the future.
    // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
    // points as used by CESU-8.
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          // CESU-8 represents each of Surrogate Pair by 3-bytes
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          // UTF-16 represents each of Surrogate Pair by 2-bytes
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
    
      // Enough space to store all bytes of a single character. UTF-8 needs 4
      // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
      this.charBuffer = new Buffer(6);
      // Number of bytes received for the current incomplete multi-byte character.
      this.charReceived = 0;
      // Number of bytes expected for the current incomplete multi-byte character.
      this.charLength = 0;
    };
    
    
    // write decodes the given buffer and returns it as JS string that is
    // guaranteed to not contain any partial multi-byte characters. Any partial
    // character found at the end of the buffer is buffered up, and will be
    // returned when calling write again with the remaining bytes.
    //
    // Note: Converting a Buffer containing an orphan surrogate to a String
    // currently works, but converting a String to a Buffer (via `new Buffer`, or
    // Buffer#write) will replace incomplete surrogates with the unicode
    // replacement character. See https://codereview.chromium.org/121173009/ .
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      // if our last write ended with an incomplete multibyte character
      while (this.charLength) {
        // determine how many remaining bytes this buffer has to offer for this char
        var available = (buffer.length >= this.charLength - this.charReceived) ?
            this.charLength - this.charReceived :
            buffer.length;
    
        // add the new bytes to the char buffer
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
    
        if (this.charReceived < this.charLength) {
          // still not enough chars in this buffer? wait for more ...
          return '';
        }
    
        // remove bytes belonging to the current character from the buffer
        buffer = buffer.slice(available, buffer.length);
    
        // get the character that was split
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    
        // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
    
        // if there are no more bytes in this buffer, just emit our char
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
    
      // determine and set charLength / charReceived
      this.detectIncompleteChar(buffer);
    
      var end = buffer.length;
      if (this.charLength) {
        // buffer the incomplete character bytes we got
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
    
      charStr += buffer.toString(this.encoding, 0, end);
    
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
    
      // or just emit the charStr
      return charStr;
    };
    
    // detectIncompleteChar determines if there is an incomplete UTF-8 character at
    // the end of the given buffer. If so, it sets this.charLength to the byte
    // length that character, and sets this.charReceived to the number of bytes
    // that are available for this character.
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      // determine how many bytes we have to check at the end of this buffer
      var i = (buffer.length >= 3) ? 3 : buffer.length;
    
      // Figure out if one of the last i bytes of our buffer announces an
      // incomplete char.
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
    
        // See http://en.wikipedia.org/wiki/UTF-8#Description
    
        // 110XXXXX
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
    
        // 1110XXXX
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
    
        // 11110XXX
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
    
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
    
      return res;
    };
    
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
    
  provide("string_decoder", module.exports);
}(global));

// pakmanager:util-deprecate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * For Node.js, simply re-export the core `util.deprecate` function.
     */
    
    module.exports = require('util').deprecate;
    
  provide("util-deprecate", module.exports);
}(global));

// pakmanager:glob/common.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.alphasort = alphasort
    exports.alphasorti = alphasorti
    exports.setopts = setopts
    exports.ownProp = ownProp
    exports.makeAbs = makeAbs
    exports.finish = finish
    exports.mark = mark
    exports.isIgnored = isIgnored
    exports.childrenIgnored = childrenIgnored
    
    function ownProp (obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field)
    }
    
    var path = require("path")
    var minimatch = require("minimatch")
    var isAbsolute = require("path-is-absolute")
    var Minimatch = minimatch.Minimatch
    
    function alphasorti (a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase())
    }
    
    function alphasort (a, b) {
      return a.localeCompare(b)
    }
    
    function setupIgnores (self, options) {
      self.ignore = options.ignore || []
    
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore]
    
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap)
      }
    }
    
    // ignore patterns are always in dot:true mode.
    function ignoreMap (pattern) {
      var gmatcher = null
      if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '')
        gmatcher = new Minimatch(gpattern, { dot: true })
      }
    
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher: gmatcher
      }
    }
    
    function setopts (self, pattern, options) {
      if (!options)
        options = {}
    
      // base-matching: just use globstar for that.
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar")
        }
        pattern = "**/" + pattern
      }
    
      self.silent = !!options.silent
      self.pattern = pattern
      self.strict = options.strict !== false
      self.realpath = !!options.realpath
      self.realpathCache = options.realpathCache || Object.create(null)
      self.follow = !!options.follow
      self.dot = !!options.dot
      self.mark = !!options.mark
      self.nodir = !!options.nodir
      if (self.nodir)
        self.mark = true
      self.sync = !!options.sync
      self.nounique = !!options.nounique
      self.nonull = !!options.nonull
      self.nosort = !!options.nosort
      self.nocase = !!options.nocase
      self.stat = !!options.stat
      self.noprocess = !!options.noprocess
    
      self.maxLength = options.maxLength || Infinity
      self.cache = options.cache || Object.create(null)
      self.statCache = options.statCache || Object.create(null)
      self.symlinks = options.symlinks || Object.create(null)
    
      setupIgnores(self, options)
    
      self.changedCwd = false
      var cwd = process.cwd()
      if (!ownProp(options, "cwd"))
        self.cwd = cwd
      else {
        self.cwd = path.resolve(options.cwd)
        self.changedCwd = self.cwd !== cwd
      }
    
      self.root = options.root || path.resolve(self.cwd, "/")
      self.root = path.resolve(self.root)
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/")
    
      self.cwdAbs = makeAbs(self, self.cwd)
      self.nomount = !!options.nomount
    
      // disable comments and negation in Minimatch.
      // Note that they are not supported in Glob itself anyway.
      options.nonegate = true
      options.nocomment = true
    
      self.minimatch = new Minimatch(pattern, options)
      self.options = self.minimatch.options
    }
    
    function finish (self) {
      var nou = self.nounique
      var all = nou ? [] : Object.create(null)
    
      for (var i = 0, l = self.matches.length; i < l; i ++) {
        var matches = self.matches[i]
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            // do like the shell, and spit out the literal glob
            var literal = self.minimatch.globSet[i]
            if (nou)
              all.push(literal)
            else
              all[literal] = true
          }
        } else {
          // had matches
          var m = Object.keys(matches)
          if (nou)
            all.push.apply(all, m)
          else
            m.forEach(function (m) {
              all[m] = true
            })
        }
      }
    
      if (!nou)
        all = Object.keys(all)
    
      if (!self.nosort)
        all = all.sort(self.nocase ? alphasorti : alphasort)
    
      // at *some* point we statted all of these
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i])
        }
        if (self.nodir) {
          all = all.filter(function (e) {
            var notDir = !(/\/$/.test(e))
            var c = self.cache[e] || self.cache[makeAbs(self, e)]
            if (notDir && c)
              notDir = c !== 'DIR' && !Array.isArray(c)
            return notDir
          })
        }
      }
    
      if (self.ignore.length)
        all = all.filter(function(m) {
          return !isIgnored(self, m)
        })
    
      self.found = all
    }
    
    function mark (self, p) {
      var abs = makeAbs(self, p)
      var c = self.cache[abs]
      var m = p
      if (c) {
        var isDir = c === 'DIR' || Array.isArray(c)
        var slash = p.slice(-1) === '/'
    
        if (isDir && !slash)
          m += '/'
        else if (!isDir && slash)
          m = m.slice(0, -1)
    
        if (m !== p) {
          var mabs = makeAbs(self, m)
          self.statCache[mabs] = self.statCache[abs]
          self.cache[mabs] = self.cache[abs]
        }
      }
    
      return m
    }
    
    // lotta situps...
    function makeAbs (self, f) {
      var abs = f
      if (f.charAt(0) === '/') {
        abs = path.join(self.root, f)
      } else if (isAbsolute(f) || f === '') {
        abs = f
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f)
      } else {
        abs = path.resolve(f)
      }
    
      if (process.platform === 'win32')
        abs = abs.replace(/\\/g, '/')
    
      return abs
    }
    
    
    // Return true, if pattern ends with globstar '**', for the accompanying parent directory.
    // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
    function isIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
    function childrenIgnored (self, path) {
      if (!self.ignore.length)
        return false
    
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path))
      })
    }
    
  provide("glob/common.js", module.exports);
}(global));

// pakmanager:glob/glob.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    var isIgnored = common.isIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    function extend (origin, add) {
      if (add === null || typeof add !== 'object') {
        return origin
      }
    
      var keys = Object.keys(add)
      var i = keys.length
      while (i--) {
        origin[keys[i]] = add[keys[i]]
      }
      return origin
    }
    
    glob.hasMagic = function (pattern, options_) {
      var options = extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      var sync = true
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
      sync = false
    
      function done () {
        --self._processing
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function () {
              self._finish()
            })
          } else {
            self._finish()
          }
        }
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (isIgnored(this, e))
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
        case 'ENOTDIR': // totally normal. means it *does* exist.
          var abs = this._makeAbs(f)
          this.cache[abs] = 'FILE'
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + ' invalid cwd ' + this.cwd)
            error.path = this.cwd
            error.code = er.code
            this.emit('error', error)
            this.abort()
          }
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob/glob.js", module.exports);
}(global));

// pakmanager:glob/sync.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = globSync
    globSync.GlobSync = GlobSync
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var Glob =  require('glob/glob.js').Glob
    var util = require('util')
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var childrenIgnored = common.childrenIgnored
    
    function globSync (pattern, options) {
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      return new GlobSync(pattern, options).found
    }
    
    function GlobSync (pattern, options) {
      if (!pattern)
        throw new Error('must provide pattern')
    
      if (typeof options === 'function' || arguments.length === 3)
        throw new TypeError('callback provided to sync glob\n'+
                            'See: https://github.com/isaacs/node-glob/issues/167')
    
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options)
    
      setopts(this, pattern, options)
    
      if (this.noprocess)
        return this
    
      var n = this.minimatch.set.length
      this.matches = new Array(n)
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false)
      }
      this._finish()
    }
    
    GlobSync.prototype._finish = function () {
      assert(this instanceof GlobSync)
      if (this.realpath) {
        var self = this
        this.matches.forEach(function (matchset, index) {
          var set = self.matches[index] = Object.create(null)
          for (var p in matchset) {
            try {
              p = self._makeAbs(p)
              var real = fs.realpathSync(p, self.realpathCache)
              set[real] = true
            } catch (er) {
              if (er.syscall === 'stat')
                set[self._makeAbs(p)] = true
              else
                throw er
            }
          }
        })
      }
      common.finish(this)
    }
    
    
    GlobSync.prototype._process = function (pattern, index, inGlobStar) {
      assert(this instanceof GlobSync)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // See if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip processing
      if (childrenIgnored(this, read))
        return
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
    }
    
    
    GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar)
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix.slice(-1) !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this.matches[index][e] = true
        }
        // This was the last one, and no stats were needed
        return
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix)
          newPattern = [prefix, e]
        else
          newPattern = [e]
        this._process(newPattern.concat(remain), index, inGlobStar)
      }
    }
    
    
    GlobSync.prototype._emitMatch = function (index, e) {
      var abs = this._makeAbs(e)
      if (this.mark)
        e = this._mark(e)
    
      if (this.matches[index][e])
        return
    
      if (this.nodir) {
        var c = this.cache[this._makeAbs(e)]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      this.matches[index][e] = true
      if (this.stat)
        this._stat(e)
    }
    
    
    GlobSync.prototype._readdirInGlobStar = function (abs) {
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false)
    
      var entries
      var lstat
      var stat
      try {
        lstat = fs.lstatSync(abs)
      } catch (er) {
        // lstat failed, doesn't exist
        return null
      }
    
      var isSym = lstat.isSymbolicLink()
      this.symlinks[abs] = isSym
    
      // If it's not a symlink or a dir, then it's definitely a regular file.
      // don't bother doing a readdir in that case.
      if (!isSym && !lstat.isDirectory())
        this.cache[abs] = 'FILE'
      else
        entries = this._readdir(abs, false)
    
      return entries
    }
    
    GlobSync.prototype._readdir = function (abs, inGlobStar) {
      var entries
    
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return null
    
        if (Array.isArray(c))
          return c
      }
    
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs))
      } catch (er) {
        this._readdirError(abs, er)
        return null
      }
    }
    
    GlobSync.prototype._readdirEntries = function (abs, entries) {
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
    
      // mark and cache dir-ness
      return entries
    }
    
    GlobSync.prototype._readdirError = function (f, er) {
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
        case 'ENOTDIR': // totally normal. means it *does* exist.
          var abs = this._makeAbs(f)
          this.cache[abs] = 'FILE'
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + ' invalid cwd ' + this.cwd)
            error.path = this.cwd
            error.code = er.code
            throw error
          }
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict)
            throw er
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    }
    
    GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {
    
      var entries = this._readdir(abs, inGlobStar)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false)
    
      var len = entries.length
      var isSym = this.symlinks[abs]
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true)
      }
    }
    
    GlobSync.prototype._processSimple = function (prefix, index) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var exists = this._stat(prefix)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this.matches[index][prefix] = true
    }
    
    // Returns either 'DIR', 'FILE', or false
    GlobSync.prototype._stat = function (f) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return false
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return c
    
        if (needDir && c === 'FILE')
          return false
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (!stat) {
        var lstat
        try {
          lstat = fs.lstatSync(abs)
        } catch (er) {
          return false
        }
    
        if (lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs)
          } catch (er) {
            stat = lstat
          }
        } else {
          stat = lstat
        }
      }
    
      this.statCache[abs] = stat
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return false
    
      return c
    }
    
    GlobSync.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    GlobSync.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
  provide("glob/sync.js", module.exports);
}(global));

// pakmanager:glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Approach:
    //
    // 1. Get the minimatch set
    // 2. For each pattern in the set, PROCESS(pattern, false)
    // 3. Store matches per-set, then uniq them
    //
    // PROCESS(pattern, inGlobStar)
    // Get the first [n] items from pattern that are all strings
    // Join these together.  This is PREFIX.
    //   If there is no more remaining, then stat(PREFIX) and
    //   add to matches if it succeeds.  END.
    //
    // If inGlobStar and PREFIX is symlink and points to dir
    //   set ENTRIES = []
    // else readdir(PREFIX) as ENTRIES
    //   If fail, END
    //
    // with ENTRIES
    //   If pattern[n] is GLOBSTAR
    //     // handle the case where the globstar match is empty
    //     // by pruning it out, and testing the resulting pattern
    //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
    //     // handle other cases.
    //     for ENTRY in ENTRIES (not dotfiles)
    //       // attach globstar + tail onto the entry
    //       // Mark that this entry is a globstar match
    //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
    //
    //   else // not globstar
    //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
    //       Test ENTRY against pattern[n]
    //       If fails, continue
    //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
    //
    // Caveat:
    //   Cache all stats and readdirs results to minimize syscall.  Since all
    //   we ever care about is existence and directory-ness, we can just keep
    //   `true` for files, and [children,...] for directories, or `false` for
    //   things that don't exist.
    
    module.exports = glob
    
    var fs = require('fs')
    var minimatch = require('minimatch')
    var Minimatch = minimatch.Minimatch
    var inherits = require('inherits')
    var EE = require('events').EventEmitter
    var path = require('path')
    var assert = require('assert')
    var isAbsolute = require('path-is-absolute')
    var globSync =  require('glob/sync.js')
    var common =  require('glob/common.js')
    var alphasort = common.alphasort
    var alphasorti = common.alphasorti
    var setopts = common.setopts
    var ownProp = common.ownProp
    var inflight = require('inflight')
    var util = require('util')
    var childrenIgnored = common.childrenIgnored
    var isIgnored = common.isIgnored
    
    var once = require('once')
    
    function glob (pattern, options, cb) {
      if (typeof options === 'function') cb = options, options = {}
      if (!options) options = {}
    
      if (options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return globSync(pattern, options)
      }
    
      return new Glob(pattern, options, cb)
    }
    
    glob.sync = globSync
    var GlobSync = glob.GlobSync = globSync.GlobSync
    
    // old api surface
    glob.glob = glob
    
    function extend (origin, add) {
      if (add === null || typeof add !== 'object') {
        return origin
      }
    
      var keys = Object.keys(add)
      var i = keys.length
      while (i--) {
        origin[keys[i]] = add[keys[i]]
      }
      return origin
    }
    
    glob.hasMagic = function (pattern, options_) {
      var options = extend({}, options_)
      options.noprocess = true
    
      var g = new Glob(pattern, options)
      var set = g.minimatch.set
      if (set.length > 1)
        return true
    
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== 'string')
          return true
      }
    
      return false
    }
    
    glob.Glob = Glob
    inherits(Glob, EE)
    function Glob (pattern, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
    
      if (options && options.sync) {
        if (cb)
          throw new TypeError('callback provided to sync glob')
        return new GlobSync(pattern, options)
      }
    
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb)
    
      setopts(this, pattern, options)
      this._didRealPath = false
    
      // process each pattern in the minimatch set
      var n = this.minimatch.set.length
    
      // The matches are stored as {<filename>: true,...} so that
      // duplicates are automagically pruned.
      // Later, we do an Object.keys() on these.
      // Keep them as a list so we can fill in when nonull is set.
      this.matches = new Array(n)
    
      if (typeof cb === 'function') {
        cb = once(cb)
        this.on('error', cb)
        this.on('end', function (matches) {
          cb(null, matches)
        })
      }
    
      var self = this
      var n = this.minimatch.set.length
      this._processing = 0
      this.matches = new Array(n)
    
      this._emitQueue = []
      this._processQueue = []
      this.paused = false
    
      if (this.noprocess)
        return this
    
      if (n === 0)
        return done()
    
      var sync = true
      for (var i = 0; i < n; i ++) {
        this._process(this.minimatch.set[i], i, false, done)
      }
      sync = false
    
      function done () {
        --self._processing
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function () {
              self._finish()
            })
          } else {
            self._finish()
          }
        }
      }
    }
    
    Glob.prototype._finish = function () {
      assert(this instanceof Glob)
      if (this.aborted)
        return
    
      if (this.realpath && !this._didRealpath)
        return this._realpath()
    
      common.finish(this)
      this.emit('end', this.found)
    }
    
    Glob.prototype._realpath = function () {
      if (this._didRealpath)
        return
    
      this._didRealpath = true
    
      var n = this.matches.length
      if (n === 0)
        return this._finish()
    
      var self = this
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next)
    
      function next () {
        if (--n === 0)
          self._finish()
      }
    }
    
    Glob.prototype._realpathSet = function (index, cb) {
      var matchset = this.matches[index]
      if (!matchset)
        return cb()
    
      var found = Object.keys(matchset)
      var self = this
      var n = found.length
    
      if (n === 0)
        return cb()
    
      var set = this.matches[index] = Object.create(null)
      found.forEach(function (p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p)
        fs.realpath(p, self.realpathCache, function (er, real) {
          if (!er)
            set[real] = true
          else if (er.syscall === 'stat')
            set[p] = true
          else
            self.emit('error', er) // srsly wtf right here
    
          if (--n === 0) {
            self.matches[index] = set
            cb()
          }
        })
      })
    }
    
    Glob.prototype._mark = function (p) {
      return common.mark(this, p)
    }
    
    Glob.prototype._makeAbs = function (f) {
      return common.makeAbs(this, f)
    }
    
    Glob.prototype.abort = function () {
      this.aborted = true
      this.emit('abort')
    }
    
    Glob.prototype.pause = function () {
      if (!this.paused) {
        this.paused = true
        this.emit('pause')
      }
    }
    
    Glob.prototype.resume = function () {
      if (this.paused) {
        this.emit('resume')
        this.paused = false
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0)
          this._emitQueue.length = 0
          for (var i = 0; i < eq.length; i ++) {
            var e = eq[i]
            this._emitMatch(e[0], e[1])
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0)
          this._processQueue.length = 0
          for (var i = 0; i < pq.length; i ++) {
            var p = pq[i]
            this._processing--
            this._process(p[0], p[1], p[2], p[3])
          }
        }
      }
    }
    
    Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob)
      assert(typeof cb === 'function')
    
      if (this.aborted)
        return
    
      this._processing++
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb])
        return
      }
    
      //console.error('PROCESS %d', this._processing, pattern)
    
      // Get the first [n] parts of pattern that are all strings.
      var n = 0
      while (typeof pattern[n] === 'string') {
        n ++
      }
      // now n is the index of the first one that is *not* a string.
    
      // see if there's anything else
      var prefix
      switch (n) {
        // if not, then this is rather simple
        case pattern.length:
          this._processSimple(pattern.join('/'), index, cb)
          return
    
        case 0:
          // pattern *starts* with some non-trivial item.
          // going to readdir(cwd), but not include the prefix in matches.
          prefix = null
          break
    
        default:
          // pattern has some string bits in the front.
          // whatever it starts with, whether that's 'absolute' like /foo/bar,
          // or 'relative' like '../baz'
          prefix = pattern.slice(0, n).join('/')
          break
      }
    
      var remain = pattern.slice(n)
    
      // get the list of entries.
      var read
      if (prefix === null)
        read = '.'
      else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = '/' + prefix
        read = prefix
      } else
        read = prefix
    
      var abs = this._makeAbs(read)
    
      //if ignored, skip _processing
      if (childrenIgnored(this, read))
        return cb()
    
      var isGlobStar = remain[0] === minimatch.GLOBSTAR
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
    }
    
    Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    
      // if the abs isn't a dir, then nothing can match!
      if (!entries)
        return cb()
    
      // It will only match dot entries if it starts with a dot, or if
      // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
      var pn = remain[0]
      var negate = !!this.minimatch.negate
      var rawGlob = pn._glob
      var dotOk = this.dot || rawGlob.charAt(0) === '.'
    
      var matchedEntries = []
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i]
        if (e.charAt(0) !== '.' || dotOk) {
          var m
          if (negate && !prefix) {
            m = !e.match(pn)
          } else {
            m = e.match(pn)
          }
          if (m)
            matchedEntries.push(e)
        }
      }
    
      //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    
      var len = matchedEntries.length
      // If there are no matched entries, then nothing matches.
      if (len === 0)
        return cb()
    
      // if this is the last remaining pattern bit, then no need for
      // an additional stat *unless* the user has specified mark or
      // stat explicitly.  We know they exist, since readdir returned
      // them.
    
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null)
    
        for (var i = 0; i < len; i ++) {
          var e = matchedEntries[i]
          if (prefix) {
            if (prefix !== '/')
              e = prefix + '/' + e
            else
              e = prefix + e
          }
    
          if (e.charAt(0) === '/' && !this.nomount) {
            e = path.join(this.root, e)
          }
          this._emitMatch(index, e)
        }
        // This was the last one, and no stats were needed
        return cb()
      }
    
      // now test all matched entries as stand-ins for that part
      // of the pattern.
      remain.shift()
      for (var i = 0; i < len; i ++) {
        var e = matchedEntries[i]
        var newPattern
        if (prefix) {
          if (prefix !== '/')
            e = prefix + '/' + e
          else
            e = prefix + e
        }
        this._process([e].concat(remain), index, inGlobStar, cb)
      }
      cb()
    }
    
    Glob.prototype._emitMatch = function (index, e) {
      if (this.aborted)
        return
    
      if (this.matches[index][e])
        return
    
      if (isIgnored(this, e))
        return
    
      if (this.paused) {
        this._emitQueue.push([index, e])
        return
      }
    
      var abs = this._makeAbs(e)
    
      if (this.nodir) {
        var c = this.cache[abs]
        if (c === 'DIR' || Array.isArray(c))
          return
      }
    
      if (this.mark)
        e = this._mark(e)
    
      this.matches[index][e] = true
    
      var st = this.statCache[abs]
      if (st)
        this.emit('stat', e, st)
    
      this.emit('match', e)
    }
    
    Glob.prototype._readdirInGlobStar = function (abs, cb) {
      if (this.aborted)
        return
    
      // follow all symlinked directories forever
      // just proceed as if this is a non-globstar situation
      if (this.follow)
        return this._readdir(abs, false, cb)
    
      var lstatkey = 'lstat\0' + abs
      var self = this
      var lstatcb = inflight(lstatkey, lstatcb_)
    
      if (lstatcb)
        fs.lstat(abs, lstatcb)
    
      function lstatcb_ (er, lstat) {
        if (er)
          return cb()
    
        var isSym = lstat.isSymbolicLink()
        self.symlinks[abs] = isSym
    
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && !lstat.isDirectory()) {
          self.cache[abs] = 'FILE'
          cb()
        } else
          self._readdir(abs, false, cb)
      }
    }
    
    Glob.prototype._readdir = function (abs, inGlobStar, cb) {
      if (this.aborted)
        return
    
      cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
      if (!cb)
        return
    
      //console.error('RD %j %j', +inGlobStar, abs)
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb)
    
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs]
        if (!c || c === 'FILE')
          return cb()
    
        if (Array.isArray(c))
          return cb(null, c)
      }
    
      var self = this
      fs.readdir(abs, readdirCb(this, abs, cb))
    }
    
    function readdirCb (self, abs, cb) {
      return function (er, entries) {
        if (er)
          self._readdirError(abs, er, cb)
        else
          self._readdirEntries(abs, entries, cb)
      }
    }
    
    Glob.prototype._readdirEntries = function (abs, entries, cb) {
      if (this.aborted)
        return
    
      // if we haven't asked to stat everything, then just
      // assume that everything in there exists, so we can avoid
      // having to stat it a second time.
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i ++) {
          var e = entries[i]
          if (abs === '/')
            e = abs + e
          else
            e = abs + '/' + e
          this.cache[e] = true
        }
      }
    
      this.cache[abs] = entries
      return cb(null, entries)
    }
    
    Glob.prototype._readdirError = function (f, er, cb) {
      if (this.aborted)
        return
    
      // handle errors, and cache the information
      switch (er.code) {
        case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
        case 'ENOTDIR': // totally normal. means it *does* exist.
          var abs = this._makeAbs(f)
          this.cache[abs] = 'FILE'
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + ' invalid cwd ' + this.cwd)
            error.path = this.cwd
            error.code = er.code
            this.emit('error', error)
            this.abort()
          }
          break
    
        case 'ENOENT': // not terribly unusual
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
          this.cache[this._makeAbs(f)] = false
          break
    
        default: // some unusual error.  Treat as failure.
          this.cache[this._makeAbs(f)] = false
          if (this.strict) {
            this.emit('error', er)
            // If the error is handled, then we abort
            // if not, we threw out of here
            this.abort()
          }
          if (!this.silent)
            console.error('glob error', er)
          break
      }
    
      return cb()
    }
    
    Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this
      this._readdir(abs, inGlobStar, function (er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
      })
    }
    
    
    Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      //console.error('pgs2', prefix, remain[0], entries)
    
      // no entries means not a dir, so it can never have matches
      // foo.txt/** doesn't match foo.txt
      if (!entries)
        return cb()
    
      // test without the globstar, and with every child both below
      // and replacing the globstar.
      var remainWithoutGlobStar = remain.slice(1)
      var gspref = prefix ? [ prefix ] : []
      var noGlobStar = gspref.concat(remainWithoutGlobStar)
    
      // the noGlobStar pattern exits the inGlobStar state
      this._process(noGlobStar, index, false, cb)
    
      var isSym = this.symlinks[abs]
      var len = entries.length
    
      // If it's a symlink, and we're in a globstar, then stop
      if (isSym && inGlobStar)
        return cb()
    
      for (var i = 0; i < len; i++) {
        var e = entries[i]
        if (e.charAt(0) === '.' && !this.dot)
          continue
    
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar)
        this._process(instead, index, true, cb)
    
        var below = gspref.concat(entries[i], remain)
        this._process(below, index, true, cb)
      }
    
      cb()
    }
    
    Glob.prototype._processSimple = function (prefix, index, cb) {
      // XXX review this.  Shouldn't it be doing the mounting etc
      // before doing stat?  kinda weird?
      var self = this
      this._stat(prefix, function (er, exists) {
        self._processSimple2(prefix, index, er, exists, cb)
      })
    }
    Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {
    
      //console.error('ps2', prefix, exists)
    
      if (!this.matches[index])
        this.matches[index] = Object.create(null)
    
      // If it doesn't exist, then just mark the lack of results
      if (!exists)
        return cb()
    
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix)
        if (prefix.charAt(0) === '/') {
          prefix = path.join(this.root, prefix)
        } else {
          prefix = path.resolve(this.root, prefix)
          if (trail)
            prefix += '/'
        }
      }
    
      if (process.platform === 'win32')
        prefix = prefix.replace(/\\/g, '/')
    
      // Mark this as a match
      this._emitMatch(index, prefix)
      cb()
    }
    
    // Returns either 'DIR', 'FILE', or false
    Glob.prototype._stat = function (f, cb) {
      var abs = this._makeAbs(f)
      var needDir = f.slice(-1) === '/'
    
      if (f.length > this.maxLength)
        return cb()
    
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs]
    
        if (Array.isArray(c))
          c = 'DIR'
    
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR')
          return cb(null, c)
    
        if (needDir && c === 'FILE')
          return cb()
    
        // otherwise we have to stat, because maybe c=true
        // if we know it exists, but not what it is.
      }
    
      var exists
      var stat = this.statCache[abs]
      if (stat !== undefined) {
        if (stat === false)
          return cb(null, stat)
        else {
          var type = stat.isDirectory() ? 'DIR' : 'FILE'
          if (needDir && type === 'FILE')
            return cb()
          else
            return cb(null, type, stat)
        }
      }
    
      var self = this
      var statcb = inflight('stat\0' + abs, lstatcb_)
      if (statcb)
        fs.lstat(abs, statcb)
    
      function lstatcb_ (er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          // If it's a symlink, then treat it as the target, unless
          // the target does not exist, then treat it as a file.
          return fs.stat(abs, function (er, stat) {
            if (er)
              self._stat2(f, abs, null, lstat, cb)
            else
              self._stat2(f, abs, er, stat, cb)
          })
        } else {
          self._stat2(f, abs, er, lstat, cb)
        }
      }
    }
    
    Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
      if (er) {
        this.statCache[abs] = false
        return cb()
      }
    
      var needDir = f.slice(-1) === '/'
      this.statCache[abs] = stat
    
      if (abs.slice(-1) === '/' && !stat.isDirectory())
        return cb(null, false, stat)
    
      var c = stat.isDirectory() ? 'DIR' : 'FILE'
      this.cache[abs] = this.cache[abs] || c
    
      if (needDir && c !== 'DIR')
        return cb()
    
      return cb(null, c, stat)
    }
    
  provide("glob", module.exports);
}(global));

// pakmanager:block-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // write data to it, and it'll emit data in 512 byte blocks.
    // if you .end() or .flush(), it'll emit whatever it's got,
    // padded with nulls to 512 bytes.
    
    module.exports = BlockStream
    
    var Stream = require("stream").Stream
      , inherits = require("inherits")
      , assert = require("assert").ok
      , debug = process.env.DEBUG ? console.error : function () {}
    
    function BlockStream (size, opt) {
      this.writable = this.readable = true
      this._opt = opt || {}
      this._chunkSize = size || 512
      this._offset = 0
      this._buffer = []
      this._bufferLength = 0
      if (this._opt.nopad) this._zeroes = false
      else {
        this._zeroes = new Buffer(this._chunkSize)
        for (var i = 0; i < this._chunkSize; i ++) {
          this._zeroes[i] = 0
        }
      }
    }
    
    inherits(BlockStream, Stream)
    
    BlockStream.prototype.write = function (c) {
      // debug("   BS write", c)
      if (this._ended) throw new Error("BlockStream: write after end")
      if (c && !Buffer.isBuffer(c)) c = new Buffer(c + "")
      if (c.length) {
        this._buffer.push(c)
        this._bufferLength += c.length
      }
      // debug("pushed onto buffer", this._bufferLength)
      if (this._bufferLength >= this._chunkSize) {
        if (this._paused) {
          // debug("   BS paused, return false, need drain")
          this._needDrain = true
          return false
        }
        this._emitChunk()
      }
      return true
    }
    
    BlockStream.prototype.pause = function () {
      // debug("   BS pausing")
      this._paused = true
    }
    
    BlockStream.prototype.resume = function () {
      // debug("   BS resume")
      this._paused = false
      return this._emitChunk()
    }
    
    BlockStream.prototype.end = function (chunk) {
      // debug("end", chunk)
      if (typeof chunk === "function") cb = chunk, chunk = null
      if (chunk) this.write(chunk)
      this._ended = true
      this.flush()
    }
    
    BlockStream.prototype.flush = function () {
      this._emitChunk(true)
    }
    
    BlockStream.prototype._emitChunk = function (flush) {
      // debug("emitChunk flush=%j emitting=%j paused=%j", flush, this._emitting, this._paused)
    
      // emit a <chunkSize> chunk
      if (flush && this._zeroes) {
        // debug("    BS push zeroes", this._bufferLength)
        // push a chunk of zeroes
        var padBytes = (this._bufferLength % this._chunkSize)
        if (padBytes !== 0) padBytes = this._chunkSize - padBytes
        if (padBytes > 0) {
          // debug("padBytes", padBytes, this._zeroes.slice(0, padBytes))
          this._buffer.push(this._zeroes.slice(0, padBytes))
          this._bufferLength += padBytes
          // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)
        }
      }
    
      if (this._emitting || this._paused) return
      this._emitting = true
    
      // debug("    BS entering loops")
      var bufferIndex = 0
      while (this._bufferLength >= this._chunkSize &&
             (flush || !this._paused)) {
        // debug("     BS data emission loop", this._bufferLength)
    
        var out
          , outOffset = 0
          , outHas = this._chunkSize
    
        while (outHas > 0 && (flush || !this._paused) ) {
          // debug("    BS data inner emit loop", this._bufferLength)
          var cur = this._buffer[bufferIndex]
            , curHas = cur.length - this._offset
          // debug("cur=", cur)
          // debug("curHas=%j", curHas)
          // If it's not big enough to fill the whole thing, then we'll need
          // to copy multiple buffers into one.  However, if it is big enough,
          // then just slice out the part we want, to save unnecessary copying.
          // Also, need to copy if we've already done some copying, since buffers
          // can't be joined like cons strings.
          if (out || curHas < outHas) {
            out = out || new Buffer(this._chunkSize)
            cur.copy(out, outOffset,
                     this._offset, this._offset + Math.min(curHas, outHas))
          } else if (cur.length === outHas && this._offset === 0) {
            // shortcut -- cur is exactly long enough, and no offset.
            out = cur
          } else {
            // slice out the piece of cur that we need.
            out = cur.slice(this._offset, this._offset + outHas)
          }
    
          if (curHas > outHas) {
            // means that the current buffer couldn't be completely output
            // update this._offset to reflect how much WAS written
            this._offset += outHas
            outHas = 0
          } else {
            // output the entire current chunk.
            // toss it away
            outHas -= curHas
            outOffset += curHas
            bufferIndex ++
            this._offset = 0
          }
        }
    
        this._bufferLength -= this._chunkSize
        assert(out.length === this._chunkSize)
        // debug("emitting data", out)
        // debug("   BS emitting, paused=%j", this._paused, this._bufferLength)
        this.emit("data", out)
        out = null
      }
      // debug("    BS out of loops", this._bufferLength)
    
      // whatever is left, it's not enough to fill up a block, or we're paused
      this._buffer = this._buffer.slice(bufferIndex)
      if (this._paused) {
        // debug("    BS paused, leaving", this._bufferLength)
        this._needsDrain = true
        this._emitting = false
        return
      }
    
      // if flushing, and not using null-padding, then need to emit the last
      // chunk(s) sitting in the queue.  We know that it's not enough to
      // fill up a whole block, because otherwise it would have been emitted
      // above, but there may be some offset.
      var l = this._buffer.length
      if (flush && !this._zeroes && l) {
        if (l === 1) {
          if (this._offset) {
            this.emit("data", this._buffer[0].slice(this._offset))
          } else {
            this.emit("data", this._buffer[0])
          }
        } else {
          var outHas = this._bufferLength
            , out = new Buffer(outHas)
            , outOffset = 0
          for (var i = 0; i < l; i ++) {
            var cur = this._buffer[i]
              , curHas = cur.length - this._offset
            cur.copy(out, outOffset, this._offset)
            this._offset = 0
            outOffset += curHas
            this._bufferLength -= curHas
          }
          this.emit("data", out)
        }
        // truncate
        this._buffer.length = 0
        this._bufferLength = 0
        this._offset = 0
      }
    
      // now either drained or ended
      // debug("either draining, or ended", this._bufferLength, this._ended)
      // means that we've flushed out all that we can so far.
      if (this._needDrain) {
        // debug("emitting drain", this._bufferLength)
        this._needDrain = false
        this.emit("drain")
      }
    
      if ((this._bufferLength === 0) && this._ended && !this._endEmitted) {
        // debug("emitting end", this._bufferLength)
        this._endEmitted = true
        this.emit("end")
      }
    
      this._emitting = false
    
      // debug("    BS no longer emitting", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)
    }
    
  provide("block-stream", module.exports);
}(global));

// pakmanager:inflight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    var reqs = Object.create(null)
    var once = require('once')
    
    module.exports = wrappy(inflight)
    
    function inflight (key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb)
        return null
      } else {
        reqs[key] = [cb]
        return makeres(key)
      }
    }
    
    function makeres (key) {
      return once(function RES () {
        var cbs = reqs[key]
        var len = cbs.length
        var args = slice(arguments)
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args)
        }
        if (cbs.length > len) {
          // added more in the interim.
          // de-zalgo, just in case, but don't call again.
          cbs.splice(0, len)
          process.nextTick(function () {
            RES.apply(null, args)
          })
        } else {
          delete reqs[key]
        }
      })
    }
    
    function slice (args) {
      var length = args.length
      var array = []
    
      for (var i = 0; i < length; i++) array[i] = args[i]
      return array
    }
    
  provide("inflight", module.exports);
}(global));

// pakmanager:once
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wrappy = require('wrappy')
    module.exports = wrappy(once)
    
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, 'once', {
        value: function () {
          return once(this)
        },
        configurable: true
      })
    })
    
    function once (fn) {
      var f = function () {
        if (f.called) return f.value
        f.called = true
        return f.value = fn.apply(this, arguments)
      }
      f.called = false
      return f
    }
    
  provide("once", module.exports);
}(global));

// pakmanager:path-is-absolute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function posix(path) {
    	return path.charAt(0) === '/';
    };
    
    function win32(path) {
    	// https://github.com/joyent/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    	var result = splitDeviceRe.exec(path);
    	var device = result[1] || '';
    	var isUnc = !!device && device.charAt(1) !== ':';
    
    	// UNC paths are always absolute
    	return !!result[2] || isUnc;
    };
    
    module.exports = process.platform === 'win32' ? win32 : posix;
    module.exports.posix = posix;
    module.exports.win32 = win32;
    
  provide("path-is-absolute", module.exports);
}(global));

// pakmanager:kind-of
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isBuffer = require('is-buffer');
    var toString = Object.prototype.toString;
    
    /**
     * Get the native `typeof` a value.
     *
     * @param  {*} `val`
     * @return {*} Native javascript type
     */
    
    module.exports = function kindOf(val) {
      // primitivies
      if (typeof val === 'undefined') {
        return 'undefined';
      }
      if (val === null) {
        return 'null';
      }
      if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
      }
      if (typeof val === 'string' || val instanceof String) {
        return 'string';
      }
      if (typeof val === 'number' || val instanceof Number) {
        return 'number';
      }
    
      // functions
      if (typeof val === 'function' || val instanceof Function) {
        return 'function';
      }
    
      // array
      if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
      }
    
      // check for instances of RegExp and Date before calling `toString`
      if (val instanceof RegExp) {
        return 'regexp';
      }
      if (val instanceof Date) {
        return 'date';
      }
    
      // other objects
      var type = toString.call(val);
    
      if (type === '[object RegExp]') {
        return 'regexp';
      }
      if (type === '[object Date]') {
        return 'date';
      }
      if (type === '[object Arguments]') {
        return 'arguments';
      }
    
      // buffer
      if (typeof Buffer !== 'undefined' && isBuffer(val)) {
        return 'buffer';
      }
    
      // es6: Map, WeakMap, Set, WeakSet
      if (type === '[object Set]') {
        return 'set';
      }
      if (type === '[object WeakSet]') {
        return 'weakset';
      }
      if (type === '[object Map]') {
        return 'map';
      }
      if (type === '[object WeakMap]') {
        return 'weakmap';
      }
      if (type === '[object Symbol]') {
        return 'symbol';
      }
    
      // typed arrays
      if (type === '[object Int8Array]') {
        return 'int8array';
      }
      if (type === '[object Uint8Array]') {
        return 'uint8array';
      }
      if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
      }
      if (type === '[object Int16Array]') {
        return 'int16array';
      }
      if (type === '[object Uint16Array]') {
        return 'uint16array';
      }
      if (type === '[object Int32Array]') {
        return 'int32array';
      }
      if (type === '[object Uint32Array]') {
        return 'uint32array';
      }
      if (type === '[object Float32Array]') {
        return 'float32array';
      }
      if (type === '[object Float64Array]') {
        return 'float64array';
      }
    
      // must be a plain object
      return 'object';
    };
    
  provide("kind-of", module.exports);
}(global));

// pakmanager:is-number
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var typeOf = require('kind-of');
    
    module.exports = function isNumber(num) {
      var type = typeOf(num);
      if (type !== 'number' && type !== 'string') {
        return false;
      }
      var n = +num;
      return (n - n + 1) >= 0 && num !== '';
    };
    
  provide("is-number", module.exports);
}(global));

// pakmanager:callsite
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = function(){
      var orig = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack){ return stack; };
      var err = new Error;
      Error.captureStackTrace(err, arguments.callee);
      var stack = err.stack;
      Error.prepareStackTrace = orig;
      return stack;
    };
    
  provide("callsite", module.exports);
}(global));

// pakmanager:balanced-match
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = balanced;
    function balanced(a, b, str) {
      var r = range(a, b, str);
    
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
    
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
    
        while (i < str.length && i >= 0 && ! result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [ begs.pop(), bi ];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
    
            bi = str.indexOf(b, i + 1);
          }
    
          i = ai < bi && ai >= 0 ? ai : bi;
        }
    
        if (begs.length) {
          result = [ left, right ];
        }
      }
    
      return result;
    }
    
  provide("balanced-match", module.exports);
}(global));

// pakmanager:concat-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x)) res.push.apply(res, x);
            else res.push(x);
        }
        return res;
    };
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
  provide("concat-map", module.exports);
}(global));

// pakmanager:brace-expansion
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var concatMap = require('concat-map');
    var balanced = require('balanced-match');
    
    module.exports = expandTop;
    
    var escSlash = '\0SLASH'+Math.random()+'\0';
    var escOpen = '\0OPEN'+Math.random()+'\0';
    var escClose = '\0CLOSE'+Math.random()+'\0';
    var escComma = '\0COMMA'+Math.random()+'\0';
    var escPeriod = '\0PERIOD'+Math.random()+'\0';
    
    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }
    
    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
                .split('\\{').join(escOpen)
                .split('\\}').join(escClose)
                .split('\\,').join(escComma)
                .split('\\.').join(escPeriod);
    }
    
    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
                .split(escOpen).join('{')
                .split(escClose).join('}')
                .split(escComma).join(',')
                .split(escPeriod).join('.');
    }
    
    
    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];
    
      var parts = [];
      var m = balanced('{', '}', str);
    
      if (!m)
        return str.split(',');
    
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');
    
      p[p.length-1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length-1] += postParts.shift();
        p.push.apply(p, postParts);
      }
    
      parts.push.apply(parts, p);
    
      return parts;
    }
    
    function expandTop(str) {
      if (!str)
        return [];
    
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    
    function identity(e) {
      return e;
    }
    
    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    
    function expand(str, isTop) {
      var expansions = [];
    
      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];
    
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = /^(.*,)+(.+)?$/.test(m.body);
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*\}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
    
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand(m.post, false)
              : [''];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
    
      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.
    
      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand(m.post, false)
        : [''];
    
      var N;
    
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length)
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
    
        N = [];
    
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) { return expand(el, false) });
      }
    
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    
      return expansions;
    }
    
    
  provide("brace-expansion", module.exports);
}(global));

// pakmanager:buffer-crc32
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Buffer = require('buffer').Buffer;
    
    var CRC_TABLE = [
      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
      0x2d02ef8d
    ];
    
    if (typeof Int32Array !== 'undefined')
      CRC_TABLE = new Int32Array(CRC_TABLE);
    
    function bufferizeInt(num) {
      var tmp = Buffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    
    function _crc32(buf, previous) {
      if (!Buffer.isBuffer(buf)) {
        buf = Buffer(buf);
      }
      if (Buffer.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ (crc >>> 8);
      }
      return (crc ^ -1);
    }
    
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function () {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function () {
      return _crc32.apply(null, arguments) >>> 0;
    };
    
    module.exports = crc32;
    
  provide("buffer-crc32", module.exports);
}(global));

// pakmanager:color-convert/css-keywords
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = {
    	aliceblue: [240, 248, 255],
    	antiquewhite: [250, 235, 215],
    	aqua: [0, 255, 255],
    	aquamarine: [127, 255, 212],
    	azure: [240, 255, 255],
    	beige: [245, 245, 220],
    	bisque: [255, 228, 196],
    	black: [0, 0, 0],
    	blanchedalmond: [255, 235, 205],
    	blue: [0, 0, 255],
    	blueviolet: [138, 43, 226],
    	brown: [165, 42, 42],
    	burlywood: [222, 184, 135],
    	cadetblue: [95, 158, 160],
    	chartreuse: [127, 255, 0],
    	chocolate: [210, 105, 30],
    	coral: [255, 127, 80],
    	cornflowerblue: [100, 149, 237],
    	cornsilk: [255, 248, 220],
    	crimson: [220, 20, 60],
    	cyan: [0, 255, 255],
    	darkblue: [0, 0, 139],
    	darkcyan: [0, 139, 139],
    	darkgoldenrod: [184, 134, 11],
    	darkgray: [169, 169, 169],
    	darkgreen: [0, 100, 0],
    	darkgrey: [169, 169, 169],
    	darkkhaki: [189, 183, 107],
    	darkmagenta: [139, 0, 139],
    	darkolivegreen: [85, 107, 47],
    	darkorange: [255, 140, 0],
    	darkorchid: [153, 50, 204],
    	darkred: [139, 0, 0],
    	darksalmon: [233, 150, 122],
    	darkseagreen: [143, 188, 143],
    	darkslateblue: [72, 61, 139],
    	darkslategray: [47, 79, 79],
    	darkslategrey: [47, 79, 79],
    	darkturquoise: [0, 206, 209],
    	darkviolet: [148, 0, 211],
    	deeppink: [255, 20, 147],
    	deepskyblue: [0, 191, 255],
    	dimgray: [105, 105, 105],
    	dimgrey: [105, 105, 105],
    	dodgerblue: [30, 144, 255],
    	firebrick: [178, 34, 34],
    	floralwhite: [255, 250, 240],
    	forestgreen: [34, 139, 34],
    	fuchsia: [255, 0, 255],
    	gainsboro: [220, 220, 220],
    	ghostwhite: [248, 248, 255],
    	gold: [255, 215, 0],
    	goldenrod: [218, 165, 32],
    	gray: [128, 128, 128],
    	green: [0, 128, 0],
    	greenyellow: [173, 255, 47],
    	grey: [128, 128, 128],
    	honeydew: [240, 255, 240],
    	hotpink: [255, 105, 180],
    	indianred: [205, 92, 92],
    	indigo: [75, 0, 130],
    	ivory: [255, 255, 240],
    	khaki: [240, 230, 140],
    	lavender: [230, 230, 250],
    	lavenderblush: [255, 240, 245],
    	lawngreen: [124, 252, 0],
    	lemonchiffon: [255, 250, 205],
    	lightblue: [173, 216, 230],
    	lightcoral: [240, 128, 128],
    	lightcyan: [224, 255, 255],
    	lightgoldenrodyellow: [250, 250, 210],
    	lightgray: [211, 211, 211],
    	lightgreen: [144, 238, 144],
    	lightgrey: [211, 211, 211],
    	lightpink: [255, 182, 193],
    	lightsalmon: [255, 160, 122],
    	lightseagreen: [32, 178, 170],
    	lightskyblue: [135, 206, 250],
    	lightslategray: [119, 136, 153],
    	lightslategrey: [119, 136, 153],
    	lightsteelblue: [176, 196, 222],
    	lightyellow: [255, 255, 224],
    	lime: [0, 255, 0],
    	limegreen: [50, 205, 50],
    	linen: [250, 240, 230],
    	magenta: [255, 0, 255],
    	maroon: [128, 0, 0],
    	mediumaquamarine: [102, 205, 170],
    	mediumblue: [0, 0, 205],
    	mediumorchid: [186, 85, 211],
    	mediumpurple: [147, 112, 219],
    	mediumseagreen: [60, 179, 113],
    	mediumslateblue: [123, 104, 238],
    	mediumspringgreen: [0, 250, 154],
    	mediumturquoise: [72, 209, 204],
    	mediumvioletred: [199, 21, 133],
    	midnightblue: [25, 25, 112],
    	mintcream: [245, 255, 250],
    	mistyrose: [255, 228, 225],
    	moccasin: [255, 228, 181],
    	navajowhite: [255, 222, 173],
    	navy: [0, 0, 128],
    	oldlace: [253, 245, 230],
    	olive: [128, 128, 0],
    	olivedrab: [107, 142, 35],
    	orange: [255, 165, 0],
    	orangered: [255, 69, 0],
    	orchid: [218, 112, 214],
    	palegoldenrod: [238, 232, 170],
    	palegreen: [152, 251, 152],
    	paleturquoise: [175, 238, 238],
    	palevioletred: [219, 112, 147],
    	papayawhip: [255, 239, 213],
    	peachpuff: [255, 218, 185],
    	peru: [205, 133, 63],
    	pink: [255, 192, 203],
    	plum: [221, 160, 221],
    	powderblue: [176, 224, 230],
    	purple: [128, 0, 128],
    	rebeccapurple: [102, 51, 153],
    	red: [255, 0, 0],
    	rosybrown: [188, 143, 143],
    	royalblue: [65, 105, 225],
    	saddlebrown: [139, 69, 19],
    	salmon: [250, 128, 114],
    	sandybrown: [244, 164, 96],
    	seagreen: [46, 139, 87],
    	seashell: [255, 245, 238],
    	sienna: [160, 82, 45],
    	silver: [192, 192, 192],
    	skyblue: [135, 206, 235],
    	slateblue: [106, 90, 205],
    	slategray: [112, 128, 144],
    	slategrey: [112, 128, 144],
    	snow: [255, 250, 250],
    	springgreen: [0, 255, 127],
    	steelblue: [70, 130, 180],
    	tan: [210, 180, 140],
    	teal: [0, 128, 128],
    	thistle: [216, 191, 216],
    	tomato: [255, 99, 71],
    	turquoise: [64, 224, 208],
    	violet: [238, 130, 238],
    	wheat: [245, 222, 179],
    	white: [255, 255, 255],
    	whitesmoke: [245, 245, 245],
    	yellow: [255, 255, 0],
    	yellowgreen: [154, 205, 50]
    };
    
    
  provide("color-convert/css-keywords", module.exports);
}(global));

// pakmanager:color-convert/conversions
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* MIT license */
    var cssKeywords =  require('color-convert/css-keywords');
    
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    
    var reverseKeywords = {};
    for (var key in cssKeywords) {
    	if (cssKeywords.hasOwnProperty(key)) {
    		reverseKeywords[cssKeywords[key].join()] = key;
    	}
    }
    
    var convert = module.exports = {
    	rgb: {},
    	hsl: {},
    	hsv: {},
    	hwb: {},
    	cmyk: {},
    	xyz: {},
    	lab: {},
    	lch: {},
    	hex: {},
    	keyword: {},
    	ansi16: {},
    	ansi256: {}
    };
    
    convert.rgb.hsl = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var min = Math.min(r, g, b);
    	var max = Math.max(r, g, b);
    	var delta = max - min;
    	var h;
    	var s;
    	var l;
    
    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}
    
    	h = Math.min(h * 60, 360);
    
    	if (h < 0) {
    		h += 360;
    	}
    
    	l = (min + max) / 2;
    
    	if (max === min) {
    		s = 0;
    	} else if (l <= 0.5) {
    		s = delta / (max + min);
    	} else {
    		s = delta / (2 - max - min);
    	}
    
    	return [h, s * 100, l * 100];
    };
    
    convert.rgb.hsv = function (rgb) {
    	var r = rgb[0];
    	var g = rgb[1];
    	var b = rgb[2];
    	var min = Math.min(r, g, b);
    	var max = Math.max(r, g, b);
    	var delta = max - min;
    	var h;
    	var s;
    	var v;
    
    	if (max === 0) {
    		s = 0;
    	} else {
    		s = (delta / max * 1000) / 10;
    	}
    
    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}
    
    	h = Math.min(h * 60, 360);
    
    	if (h < 0) {
    		h += 360;
    	}
    
    	v = ((max / 255) * 1000) / 10;
    
    	return [h, s, v];
    };
    
    convert.rgb.hwb = function (rgb) {
    	var r = rgb[0];
    	var g = rgb[1];
    	var b = rgb[2];
    	var h = convert.rgb.hsl(rgb)[0];
    	var w = 1 / 255 * Math.min(r, Math.min(g, b));
    
    	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    
    	return [h, w * 100, b * 100];
    };
    
    convert.rgb.cmyk = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var c;
    	var m;
    	var y;
    	var k;
    
    	k = Math.min(1 - r, 1 - g, 1 - b);
    	c = (1 - r - k) / (1 - k) || 0;
    	m = (1 - g - k) / (1 - k) || 0;
    	y = (1 - b - k) / (1 - k) || 0;
    
    	return [c * 100, m * 100, y * 100, k * 100];
    };
    
    convert.rgb.keyword = function (rgb) {
    	return reverseKeywords[rgb.join()];
    };
    
    convert.keyword.rgb = function (keyword) {
    	return cssKeywords[keyword];
    };
    
    convert.rgb.xyz = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    
    	// assume sRGB
    	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
    	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
    	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
    
    	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
    
    	return [x * 100, y * 100, z * 100];
    };
    
    convert.rgb.lab = function (rgb) {
    	var xyz = convert.rgb.xyz(rgb);
    	var x = xyz[0];
    	var y = xyz[1];
    	var z = xyz[2];
    	var l;
    	var a;
    	var b;
    
    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;
    
    	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
    
    	l = (116 * y) - 16;
    	a = 500 * (x - y);
    	b = 200 * (y - z);
    
    	return [l, a, b];
    };
    
    convert.hsl.rgb = function (hsl) {
    	var h = hsl[0] / 360;
    	var s = hsl[1] / 100;
    	var l = hsl[2] / 100;
    	var t1;
    	var t2;
    	var t3;
    	var rgb;
    	var val;
    
    	if (s === 0) {
    		val = l * 255;
    		return [val, val, val];
    	}
    
    	if (l < 0.5) {
    		t2 = l * (1 + s);
    	} else {
    		t2 = l + s - l * s;
    	}
    
    	t1 = 2 * l - t2;
    
    	rgb = [0, 0, 0];
    	for (var i = 0; i < 3; i++) {
    		t3 = h + 1 / 3 * -(i - 1);
    		if (t3 < 0) {
    			t3++;
    		}
    		if (t3 > 1) {
    			t3--;
    		}
    
    		if (6 * t3 < 1) {
    			val = t1 + (t2 - t1) * 6 * t3;
    		} else if (2 * t3 < 1) {
    			val = t2;
    		} else if (3 * t3 < 2) {
    			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    		} else {
    			val = t1;
    		}
    
    		rgb[i] = val * 255;
    	}
    
    	return rgb;
    };
    
    convert.hsl.hsv = function (hsl) {
    	var h = hsl[0];
    	var s = hsl[1] / 100;
    	var l = hsl[2] / 100;
    	var sv;
    	var v;
    
    	if (l === 0) {
    		// no need to do calc on black
    		// also avoids divide by 0 error
    		return [0, 0, 0];
    	}
    
    	l *= 2;
    	s *= (l <= 1) ? l : 2 - l;
    	v = (l + s) / 2;
    	sv = (2 * s) / (l + s);
    
    	return [h, sv * 100, v * 100];
    };
    
    convert.hsv.rgb = function (hsv) {
    	var h = hsv[0] / 60;
    	var s = hsv[1] / 100;
    	var v = hsv[2] / 100;
    	var hi = Math.floor(h) % 6;
    
    	var f = h - Math.floor(h);
    	var p = 255 * v * (1 - s);
    	var q = 255 * v * (1 - (s * f));
    	var t = 255 * v * (1 - (s * (1 - f)));
    	v *= 255;
    
    	switch (hi) {
    		case 0:
    			return [v, t, p];
    		case 1:
    			return [q, v, p];
    		case 2:
    			return [p, v, t];
    		case 3:
    			return [p, q, v];
    		case 4:
    			return [t, p, v];
    		case 5:
    			return [v, p, q];
    	}
    };
    
    convert.hsv.hsl = function (hsv) {
    	var h = hsv[0];
    	var s = hsv[1] / 100;
    	var v = hsv[2] / 100;
    	var sl;
    	var l;
    
    	l = (2 - s) * v;
    	sl = s * v;
    	sl /= (l <= 1) ? l : 2 - l;
    	sl = sl || 0;
    	l /= 2;
    
    	return [h, sl * 100, l * 100];
    };
    
    // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    convert.hwb.rgb = function (hwb) {
    	var h = hwb[0] / 360;
    	var wh = hwb[1] / 100;
    	var bl = hwb[2] / 100;
    	var ratio = wh + bl;
    	var i;
    	var v;
    	var f;
    	var n;
    
    	// wh + bl cant be > 1
    	if (ratio > 1) {
    		wh /= ratio;
    		bl /= ratio;
    	}
    
    	i = Math.floor(6 * h);
    	v = 1 - bl;
    	f = 6 * h - i;
    
    	if ((i & 0x01) !== 0) {
    		f = 1 - f;
    	}
    
    	n = wh + f * (v - wh); // linear interpolation
    
    	var r;
    	var g;
    	var b;
    	switch (i) {
    		default:
    		case 6:
    		case 0: r = v; g = n; b = wh; break;
    		case 1: r = n; g = v; b = wh; break;
    		case 2: r = wh; g = v; b = n; break;
    		case 3: r = wh; g = n; b = v; break;
    		case 4: r = n; g = wh; b = v; break;
    		case 5: r = v; g = wh; b = n; break;
    	}
    
    	return [r * 255, g * 255, b * 255];
    };
    
    convert.cmyk.rgb = function (cmyk) {
    	var c = cmyk[0] / 100;
    	var m = cmyk[1] / 100;
    	var y = cmyk[2] / 100;
    	var k = cmyk[3] / 100;
    	var r;
    	var g;
    	var b;
    
    	r = 1 - Math.min(1, c * (1 - k) + k);
    	g = 1 - Math.min(1, m * (1 - k) + k);
    	b = 1 - Math.min(1, y * (1 - k) + k);
    
    	return [r * 255, g * 255, b * 255];
    };
    
    convert.xyz.rgb = function (xyz) {
    	var x = xyz[0] / 100;
    	var y = xyz[1] / 100;
    	var z = xyz[2] / 100;
    	var r;
    	var g;
    	var b;
    
    	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
    
    	// assume sRGB
    	r = r > 0.0031308
    		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    		: r *= 12.92;
    
    	g = g > 0.0031308
    		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    		: g *= 12.92;
    
    	b = b > 0.0031308
    		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    		: b *= 12.92;
    
    	r = Math.min(Math.max(0, r), 1);
    	g = Math.min(Math.max(0, g), 1);
    	b = Math.min(Math.max(0, b), 1);
    
    	return [r * 255, g * 255, b * 255];
    };
    
    convert.xyz.lab = function (xyz) {
    	var x = xyz[0];
    	var y = xyz[1];
    	var z = xyz[2];
    	var l;
    	var a;
    	var b;
    
    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;
    
    	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);
    
    	l = (116 * y) - 16;
    	a = 500 * (x - y);
    	b = 200 * (y - z);
    
    	return [l, a, b];
    };
    
    convert.lab.xyz = function (lab) {
    	var l = lab[0];
    	var a = lab[1];
    	var b = lab[2];
    	var x;
    	var y;
    	var z;
    	var y2;
    
    	if (l <= 8) {
    		y = (l * 100) / 903.3;
    		y2 = (7.787 * (y / 100)) + (16 / 116);
    	} else {
    		y = 100 * Math.pow((l + 16) / 116, 3);
    		y2 = Math.pow(y / 100, 1 / 3);
    	}
    
    	x = x / 95.047 <= 0.008856
    		? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787
    		: 95.047 * Math.pow((a / 500) + y2, 3);
    	z = z / 108.883 <= 0.008859
    		? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787
    		: 108.883 * Math.pow(y2 - (b / 200), 3);
    
    	return [x, y, z];
    };
    
    convert.lab.lch = function (lab) {
    	var l = lab[0];
    	var a = lab[1];
    	var b = lab[2];
    	var hr;
    	var h;
    	var c;
    
    	hr = Math.atan2(b, a);
    	h = hr * 360 / 2 / Math.PI;
    
    	if (h < 0) {
    		h += 360;
    	}
    
    	c = Math.sqrt(a * a + b * b);
    
    	return [l, c, h];
    };
    
    convert.lch.lab = function (lch) {
    	var l = lch[0];
    	var c = lch[1];
    	var h = lch[2];
    	var a;
    	var b;
    	var hr;
    
    	hr = h / 360 * 2 * Math.PI;
    	a = c * Math.cos(hr);
    	b = c * Math.sin(hr);
    
    	return [l, a, b];
    };
    
    convert.rgb.ansi16 = function (args) {
    	var r = args[0];
    	var g = args[1];
    	var b = args[2];
    	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization
    
    	value = Math.round(value / 50);
    
    	if (value === 0) {
    		return 30;
    	}
    
    	var ansi = 30
    		+ ((Math.round(b / 255) << 2)
    		| (Math.round(g / 255) << 1)
    		| Math.round(r / 255));
    
    	if (value === 2) {
    		ansi += 60;
    	}
    
    	return ansi;
    };
    
    convert.hsv.ansi16 = function (args) {
    	// optimization here; we already know the value and don't need to get
    	// it converted for us.
    	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    
    convert.rgb.ansi256 = function (args) {
    	var r = args[0];
    	var g = args[1];
    	var b = args[2];
    
    	// we use the extended greyscale palette here, with the exception of
    	// black and white. normal palette only has 4 greyscale shades.
    	if (r === g && g === b) {
    		if (r < 8) {
    			return 16;
    		}
    
    		if (r > 248) {
    			return 231;
    		}
    
    		return Math.round(((r - 8) / 247) * 24) + 232;
    	}
    
    	var ansi = 16
    		+ (36 * Math.round(r / 255 * 5))
    		+ (6 * Math.round(g / 255 * 5))
    		+ Math.round(b / 255 * 5);
    
    	return ansi;
    };
    
    convert.ansi16.rgb = function (args) {
    	var color = args % 10;
    
    	// handle greyscale
    	if (color === 0 || color === 7) {
    		if (args > 50) {
    			color += 3.5;
    		}
    
    		color = color / 10.5 * 255;
    
    		return [color, color, color];
    	}
    
    	var mult = (~~(args > 50) + 1) * 0.5;
    	var r = ((color & 1) * mult) * 255;
    	var g = (((color >> 1) & 1) * mult) * 255;
    	var b = (((color >> 2) & 1) * mult) * 255;
    
    	return [r, g, b];
    };
    
    convert.ansi256.rgb = function (args) {
    	// handle greyscale
    	if (args >= 232) {
    		var c = (args - 232) * 10 + 8;
    		return [c, c, c];
    	}
    
    	args -= 16;
    
    	var rem;
    	var r = Math.floor(args / 36) / 5 * 255;
    	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    	var b = (rem % 6) / 5 * 255;
    
    	return [r, g, b];
    };
    
    convert.rgb.hex = function (args) {
    	var integer = ((Math.round(args[0]) & 0xFF) << 16)
    		+ ((Math.round(args[1]) & 0xFF) << 8)
    		+ (Math.round(args[2]) & 0xFF);
    
    	var string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };
    
    convert.hex.rgb = function (args) {
    	var match = args.toString(16).match(/[a-f0-9]{6}/i);
    	if (!match) {
    		return [0, 0, 0];
    	}
    
    	var integer = parseInt(match[0], 16);
    	var r = (integer >> 16) & 0xFF;
    	var g = (integer >> 8) & 0xFF;
    	var b = integer & 0xFF;
    
    	return [r, g, b];
    };
    
  provide("color-convert/conversions", module.exports);
}(global));

// pakmanager:color-convert/route
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var conversions =  require('color-convert/conversions');
    
    /*
    	this function routes a model to all other models.
    
    	all functions that are routed have a property `.conversion` attached
    	to the returned synthetic function. This property is an array
    	of strings, each with the steps in between the 'from' and 'to'
    	color models (inclusive).
    
    	conversions that are not possible simply are not included.
    */
    
    // https://jsperf.com/object-keys-vs-for-in-with-closure/3
    var models = Object.keys(conversions);
    
    function buildGraph() {
    	var graph = {};
    
    	for (var len = models.length, i = 0; i < len; i++) {
    		graph[models[i]] = {
    			// http://jsperf.com/1-vs-infinity
    			// micro-opt, but this is simple.
    			distance: -1,
    			parent: null
    		};
    	}
    
    	return graph;
    }
    
    // https://en.wikipedia.org/wiki/Breadth-first_search
    function deriveBFS(fromModel) {
    	var graph = buildGraph();
    	var queue = [fromModel]; // unshift -> queue -> pop
    
    	graph[fromModel].distance = 0;
    
    	while (queue.length) {
    		var current = queue.pop();
    		var adjacents = Object.keys(conversions[current]);
    
    		for (var len = adjacents.length, i = 0; i < len; i++) {
    			var adjacent = adjacents[i];
    			var node = graph[adjacent];
    
    			if (node.distance === -1) {
    				node.distance = graph[current].distance + 1;
    				node.parent = current;
    				queue.unshift(adjacent);
    			}
    		}
    	}
    
    	return graph;
    }
    
    function link(from, to) {
    	return function (args) {
    		return to(from(args));
    	};
    }
    
    function wrapConversion(toModel, graph) {
    	var path = [graph[toModel].parent, toModel];
    	var fn = conversions[graph[toModel].parent][toModel];
    
    	var cur = graph[toModel].parent;
    	while (graph[cur].parent) {
    		path.unshift(graph[cur].parent);
    		fn = link(conversions[graph[cur].parent][cur], fn);
    		cur = graph[cur].parent;
    	}
    
    	fn.conversion = path;
    	return fn;
    }
    
    module.exports = function (fromModel) {
    	var graph = deriveBFS(fromModel);
    	var conversion = {};
    
    	var models = Object.keys(graph);
    	for (var len = models.length, i = 0; i < len; i++) {
    		var toModel = models[i];
    		var node = graph[toModel];
    
    		if (node.parent === null) {
    			// no possible conversion, or this node is the source model.
    			continue;
    		}
    
    		conversion[toModel] = wrapConversion(toModel, graph);
    	}
    
    	return conversion;
    };
    
    
  provide("color-convert/route", module.exports);
}(global));

// pakmanager:color-convert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var conversions =  require('color-convert/conversions');
    var route =  require('color-convert/route');
    
    var convert = {};
    
    var models = Object.keys(conversions);
    
    function wrapRaw(fn) {
    	var wrappedFn = function (args) {
    		if (args === undefined || args === null) {
    			return args;
    		}
    
    		if (arguments.length > 1) {
    			args = Array.prototype.slice.call(arguments);
    		}
    
    		return fn(args);
    	};
    
    	// preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}
    
    	return wrappedFn;
    }
    
    function wrapRounded(fn) {
    	var wrappedFn = function (args) {
    		if (args === undefined || args === null) {
    			return args;
    		}
    
    		if (arguments.length > 1) {
    			args = Array.prototype.slice.call(arguments);
    		}
    
    		var result = fn(args);
    
    		// we're assuming the result is an array here.
    		// see notice in conversions.js; don't use box types
    		// in conversion functions.
    		if (typeof result === 'object') {
    			for (var len = result.length, i = 0; i < len; i++) {
    				result[i] = Math.round(result[i]);
    			}
    		}
    
    		return result;
    	};
    
    	// preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}
    
    	return wrappedFn;
    }
    
    models.forEach(function (fromModel) {
    	convert[fromModel] = {};
    
    	var routes = route(fromModel);
    	var routeModels = Object.keys(routes);
    
    	routeModels.forEach(function (toModel) {
    		var fn = routes[toModel];
    
    		convert[fromModel][toModel] = wrapRounded(fn);
    		convert[fromModel][toModel].raw = wrapRaw(fn);
    	});
    });
    
    module.exports = convert;
    
  provide("color-convert", module.exports);
}(global));

// pakmanager:ansi-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function () {
    	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
    };
    
  provide("ansi-regex", module.exports);
}(global));

// pakmanager:has-flag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (flag, argv) {
    	argv = argv || process.argv;
    
    	var terminatorPos = argv.indexOf('--');
    	var prefix = /^--/.test(flag) ? '' : '--';
    	var pos = argv.indexOf(prefix + flag);
    
    	return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);
    };
    
  provide("has-flag", module.exports);
}(global));

// pakmanager:is-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    function isProperty(str) {
      return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
    }
    module.exports = isProperty
  provide("is-property", module.exports);
}(global));

// pakmanager:jsbn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(){
    
        // Copyright (c) 2005  Tom Wu
        // All Rights Reserved.
        // See "LICENSE" for details.
    
        // Basic JavaScript BN library - subset useful for RSA encryption.
    
        // Bits per digit
        var dbits;
    
        // JavaScript engine analysis
        var canary = 0xdeadbeefcafe;
        var j_lm = ((canary&0xffffff)==0xefcafe);
    
        // (public) Constructor
        function BigInteger(a,b,c) {
          if(a != null)
            if("number" == typeof a) this.fromNumber(a,b,c);
            else if(b == null && "string" != typeof a) this.fromString(a,256);
            else this.fromString(a,b);
        }
    
        // return new, unset BigInteger
        function nbi() { return new BigInteger(null); }
    
        // am: Compute w_j += (x*this_i), propagate carries,
        // c is initial carry, returns final carry.
        // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
        // We need to select the fastest one that works in this environment.
    
        // am1: use a single mult and divide to get the high bits,
        // max digit bits should be 26 because
        // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
        function am1(i,x,w,j,c,n) {
          while(--n >= 0) {
            var v = x*this[i++]+w[j]+c;
            c = Math.floor(v/0x4000000);
            w[j++] = v&0x3ffffff;
          }
          return c;
        }
        // am2 avoids a big mult-and-extract completely.
        // Max digit bits should be <= 30 because we do bitwise ops
        // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
        function am2(i,x,w,j,c,n) {
          var xl = x&0x7fff, xh = x>>15;
          while(--n >= 0) {
            var l = this[i]&0x7fff;
            var h = this[i++]>>15;
            var m = xh*l+h*xl;
            l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
            c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
            w[j++] = l&0x3fffffff;
          }
          return c;
        }
        // Alternately, set max digit bits to 28 since some
        // browsers slow down when dealing with 32-bit numbers.
        function am3(i,x,w,j,c,n) {
          var xl = x&0x3fff, xh = x>>14;
          while(--n >= 0) {
            var l = this[i]&0x3fff;
            var h = this[i++]>>14;
            var m = xh*l+h*xl;
            l = xl*l+((m&0x3fff)<<14)+w[j]+c;
            c = (l>>28)+(m>>14)+xh*h;
            w[j++] = l&0xfffffff;
          }
          return c;
        }
        var inBrowser = typeof navigator !== "undefined";
        if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
          BigInteger.prototype.am = am2;
          dbits = 30;
        }
        else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
          BigInteger.prototype.am = am1;
          dbits = 26;
        }
        else { // Mozilla/Netscape seems to prefer am3
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
    
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = ((1<<dbits)-1);
        BigInteger.prototype.DV = (1<<dbits);
    
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2,BI_FP);
        BigInteger.prototype.F1 = BI_FP-dbits;
        BigInteger.prototype.F2 = 2*dbits-BI_FP;
    
        // Digit conversions
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr,vv;
        rr = "0".charCodeAt(0);
        for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    
        function int2char(n) { return BI_RM.charAt(n); }
        function intAt(s,i) {
          var c = BI_RC[s.charCodeAt(i)];
          return (c==null)?-1:c;
        }
    
        // (protected) copy this to r
        function bnpCopyTo(r) {
          for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
          r.t = this.t;
          r.s = this.s;
        }
    
        // (protected) set from integer value x, -DV <= x < DV
        function bnpFromInt(x) {
          this.t = 1;
          this.s = (x<0)?-1:0;
          if(x > 0) this[0] = x;
          else if(x < -1) this[0] = x+this.DV;
          else this.t = 0;
        }
    
        // return bigint initialized to value
        function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
    
        // (protected) set from string and radix
        function bnpFromString(s,b) {
          var k;
          if(b == 16) k = 4;
          else if(b == 8) k = 3;
          else if(b == 256) k = 8; // byte array
          else if(b == 2) k = 1;
          else if(b == 32) k = 5;
          else if(b == 4) k = 2;
          else { this.fromRadix(s,b); return; }
          this.t = 0;
          this.s = 0;
          var i = s.length, mi = false, sh = 0;
          while(--i >= 0) {
            var x = (k==8)?s[i]&0xff:intAt(s,i);
            if(x < 0) {
              if(s.charAt(i) == "-") mi = true;
              continue;
            }
            mi = false;
            if(sh == 0)
              this[this.t++] = x;
            else if(sh+k > this.DB) {
              this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
              this[this.t++] = (x>>(this.DB-sh));
            }
            else
              this[this.t-1] |= x<<sh;
            sh += k;
            if(sh >= this.DB) sh -= this.DB;
          }
          if(k == 8 && (s[0]&0x80) != 0) {
            this.s = -1;
            if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
          }
          this.clamp();
          if(mi) BigInteger.ZERO.subTo(this,this);
        }
    
        // (protected) clamp off excess high words
        function bnpClamp() {
          var c = this.s&this.DM;
          while(this.t > 0 && this[this.t-1] == c) --this.t;
        }
    
        // (public) return string representation in given radix
        function bnToString(b) {
          if(this.s < 0) return "-"+this.negate().toString(b);
          var k;
          if(b == 16) k = 4;
          else if(b == 8) k = 3;
          else if(b == 2) k = 1;
          else if(b == 32) k = 5;
          else if(b == 4) k = 2;
          else return this.toRadix(b);
          var km = (1<<k)-1, d, m = false, r = "", i = this.t;
          var p = this.DB-(i*this.DB)%k;
          if(i-- > 0) {
            if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
            while(i >= 0) {
              if(p < k) {
                d = (this[i]&((1<<p)-1))<<(k-p);
                d |= this[--i]>>(p+=this.DB-k);
              }
              else {
                d = (this[i]>>(p-=k))&km;
                if(p <= 0) { p += this.DB; --i; }
              }
              if(d > 0) m = true;
              if(m) r += int2char(d);
            }
          }
          return m?r:"0";
        }
    
        // (public) -this
        function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }
    
        // (public) |this|
        function bnAbs() { return (this.s<0)?this.negate():this; }
    
        // (public) return + if this > a, - if this < a, 0 if equal
        function bnCompareTo(a) {
          var r = this.s-a.s;
          if(r != 0) return r;
          var i = this.t;
          r = i-a.t;
          if(r != 0) return (this.s<0)?-r:r;
          while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
          return 0;
        }
    
        // returns bit length of the integer x
        function nbits(x) {
          var r = 1, t;
          if((t=x>>>16) != 0) { x = t; r += 16; }
          if((t=x>>8) != 0) { x = t; r += 8; }
          if((t=x>>4) != 0) { x = t; r += 4; }
          if((t=x>>2) != 0) { x = t; r += 2; }
          if((t=x>>1) != 0) { x = t; r += 1; }
          return r;
        }
    
        // (public) return the number of bits in "this"
        function bnBitLength() {
          if(this.t <= 0) return 0;
          return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
        }
    
        // (protected) r = this << n*DB
        function bnpDLShiftTo(n,r) {
          var i;
          for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
          for(i = n-1; i >= 0; --i) r[i] = 0;
          r.t = this.t+n;
          r.s = this.s;
        }
    
        // (protected) r = this >> n*DB
        function bnpDRShiftTo(n,r) {
          for(var i = n; i < this.t; ++i) r[i-n] = this[i];
          r.t = Math.max(this.t-n,0);
          r.s = this.s;
        }
    
        // (protected) r = this << n
        function bnpLShiftTo(n,r) {
          var bs = n%this.DB;
          var cbs = this.DB-bs;
          var bm = (1<<cbs)-1;
          var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
          for(i = this.t-1; i >= 0; --i) {
            r[i+ds+1] = (this[i]>>cbs)|c;
            c = (this[i]&bm)<<bs;
          }
          for(i = ds-1; i >= 0; --i) r[i] = 0;
          r[ds] = c;
          r.t = this.t+ds+1;
          r.s = this.s;
          r.clamp();
        }
    
        // (protected) r = this >> n
        function bnpRShiftTo(n,r) {
          r.s = this.s;
          var ds = Math.floor(n/this.DB);
          if(ds >= this.t) { r.t = 0; return; }
          var bs = n%this.DB;
          var cbs = this.DB-bs;
          var bm = (1<<bs)-1;
          r[0] = this[ds]>>bs;
          for(var i = ds+1; i < this.t; ++i) {
            r[i-ds-1] |= (this[i]&bm)<<cbs;
            r[i-ds] = this[i]>>bs;
          }
          if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
          r.t = this.t-ds;
          r.clamp();
        }
    
        // (protected) r = this - a
        function bnpSubTo(a,r) {
          var i = 0, c = 0, m = Math.min(a.t,this.t);
          while(i < m) {
            c += this[i]-a[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          if(a.t < this.t) {
            c -= a.s;
            while(i < this.t) {
              c += this[i];
              r[i++] = c&this.DM;
              c >>= this.DB;
            }
            c += this.s;
          }
          else {
            c += this.s;
            while(i < a.t) {
              c -= a[i];
              r[i++] = c&this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = (c<0)?-1:0;
          if(c < -1) r[i++] = this.DV+c;
          else if(c > 0) r[i++] = c;
          r.t = i;
          r.clamp();
        }
    
        // (protected) r = this * a, r != this,a (HAC 14.12)
        // "this" should be the larger one if appropriate.
        function bnpMultiplyTo(a,r) {
          var x = this.abs(), y = a.abs();
          var i = x.t;
          r.t = i+y.t;
          while(--i >= 0) r[i] = 0;
          for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
          r.s = 0;
          r.clamp();
          if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
        }
    
        // (protected) r = this^2, r != this (HAC 14.16)
        function bnpSquareTo(r) {
          var x = this.abs();
          var i = r.t = 2*x.t;
          while(--i >= 0) r[i] = 0;
          for(i = 0; i < x.t-1; ++i) {
            var c = x.am(i,x[i],r,2*i,0,1);
            if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
              r[i+x.t] -= x.DV;
              r[i+x.t+1] = 1;
            }
          }
          if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
          r.s = 0;
          r.clamp();
        }
    
        // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
        // r != q, this != m.  q or r may be null.
        function bnpDivRemTo(m,q,r) {
          var pm = m.abs();
          if(pm.t <= 0) return;
          var pt = this.abs();
          if(pt.t < pm.t) {
            if(q != null) q.fromInt(0);
            if(r != null) this.copyTo(r);
            return;
          }
          if(r == null) r = nbi();
          var y = nbi(), ts = this.s, ms = m.s;
          var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
          if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
          else { pm.copyTo(y); pt.copyTo(r); }
          var ys = y.t;
          var y0 = y[ys-1];
          if(y0 == 0) return;
          var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
          var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
          var i = r.t, j = i-ys, t = (q==null)?nbi():q;
          y.dlShiftTo(j,t);
          if(r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t,r);
          }
          BigInteger.ONE.dlShiftTo(ys,t);
          t.subTo(y,y);  // "negative" y so we can replace sub with am later
          while(y.t < ys) y[y.t++] = 0;
          while(--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
            if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
              y.dlShiftTo(j,t);
              r.subTo(t,r);
              while(r[i] < --qd) r.subTo(t,r);
            }
          }
          if(q != null) {
            r.drShiftTo(ys,q);
            if(ts != ms) BigInteger.ZERO.subTo(q,q);
          }
          r.t = ys;
          r.clamp();
          if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
          if(ts < 0) BigInteger.ZERO.subTo(r,r);
        }
    
        // (public) this mod a
        function bnMod(a) {
          var r = nbi();
          this.abs().divRemTo(a,null,r);
          if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
          return r;
        }
    
        // Modular reduction using "classic" algorithm
        function Classic(m) { this.m = m; }
        function cConvert(x) {
          if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
          else return x;
        }
        function cRevert(x) { return x; }
        function cReduce(x) { x.divRemTo(this.m,null,x); }
        function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
        function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
    
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
    
        // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
        // justification:
        //         xy == 1 (mod m)
        //         xy =  1+km
        //   xy(2-xy) = (1+km)(1-km)
        // x[y(2-xy)] = 1-k^2m^2
        // x[y(2-xy)] == 1 (mod m^2)
        // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
        // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
        // JS multiply "overflows" differently from C/C++, so care is needed here.
        function bnpInvDigit() {
          if(this.t < 1) return 0;
          var x = this[0];
          if((x&1) == 0) return 0;
          var y = x&3;       // y == 1/x mod 2^2
          y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
          y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
          y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
          // last step - calculate inverse mod DV directly;
          // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
          y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
          // we really want the negative inverse, and -DV < y < DV
          return (y>0)?this.DV-y:-y;
        }
    
        // Montgomery reduction
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp&0x7fff;
          this.mph = this.mp>>15;
          this.um = (1<<(m.DB-15))-1;
          this.mt2 = 2*m.t;
        }
    
        // xR mod m
        function montConvert(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t,r);
          r.divRemTo(this.m,null,r);
          if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
          return r;
        }
    
        // x/R mod m
        function montRevert(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
    
        // x = x/R mod m (HAC 14.32)
        function montReduce(x) {
          while(x.t <= this.mt2) // pad x so am has enough room later
            x[x.t++] = 0;
          for(var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i]&0x7fff;
            var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i+this.m.t;
            x[j] += this.m.am(0,u0,x,i,0,this.m.t);
            // propagate carry
            while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
          }
          x.clamp();
          x.drShiftTo(this.m.t,x);
          if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
        }
    
        // r = "x^2/R mod m"; x != r
        function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
    
        // r = "xy/R mod m"; x,y != r
        function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
    
        // (protected) true iff this is even
        function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }
    
        // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
        function bnpExp(e,z) {
          if(e > 0xffffffff || e < 1) return BigInteger.ONE;
          var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
          g.copyTo(r);
          while(--i >= 0) {
            z.sqrTo(r,r2);
            if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
            else { var t = r; r = r2; r2 = t; }
          }
          return z.revert(r);
        }
    
        // (public) this^e % m, 0 <= e < 2^32
        function bnModPowInt(e,m) {
          var z;
          if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
          return this.exp(e,z);
        }
    
        // protected
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
    
        // public
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
    
        // "constants"
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
    
        // Copyright (c) 2005-2009  Tom Wu
        // All Rights Reserved.
        // See "LICENSE" for details.
    
        // Extended JavaScript BN functions, required for RSA private ops.
    
        // Version 1.1: new BigInteger("0", 10) returns "proper" zero
        // Version 1.2: square() API, isProbablePrime fix
    
        // (public)
        function bnClone() { var r = nbi(); this.copyTo(r); return r; }
    
        // (public) return value as integer
        function bnIntValue() {
          if(this.s < 0) {
            if(this.t == 1) return this[0]-this.DV;
            else if(this.t == 0) return -1;
          }
          else if(this.t == 1) return this[0];
          else if(this.t == 0) return 0;
          // assumes 16 < DB < 32
          return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
        }
    
        // (public) return value as byte
        function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }
    
        // (public) return value as short (assumes DB>=16)
        function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }
    
        // (protected) return x s.t. r^x < DV
        function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }
    
        // (public) 0 if this == 0, 1 if this > 0
        function bnSigNum() {
          if(this.s < 0) return -1;
          else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
          else return 1;
        }
    
        // (protected) convert to radix string
        function bnpToRadix(b) {
          if(b == null) b = 10;
          if(this.signum() == 0 || b < 2 || b > 36) return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b,cs);
          var d = nbv(a), y = nbi(), z = nbi(), r = "";
          this.divRemTo(d,y,z);
          while(y.signum() > 0) {
            r = (a+z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d,y,z);
          }
          return z.intValue().toString(b) + r;
        }
    
        // (protected) convert from radix string
        function bnpFromRadix(s,b) {
          this.fromInt(0);
          if(b == null) b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
          for(var i = 0; i < s.length; ++i) {
            var x = intAt(s,i);
            if(x < 0) {
              if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
              continue;
            }
            w = b*w+x;
            if(++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w,0);
              j = 0;
              w = 0;
            }
          }
          if(j > 0) {
            this.dMultiply(Math.pow(b,j));
            this.dAddOffset(w,0);
          }
          if(mi) BigInteger.ZERO.subTo(this,this);
        }
    
        // (protected) alternate constructor
        function bnpFromNumber(a,b,c) {
          if("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if(a < 2) this.fromInt(1);
            else {
              this.fromNumber(a,c);
              if(!this.testBit(a-1))	// force MSB set
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
              if(this.isEven()) this.dAddOffset(1,0); // force odd
              while(!this.isProbablePrime(b)) {
                this.dAddOffset(2,0);
                if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
              }
            }
          }
          else {
            // new BigInteger(int,RNG)
            var x = new Array(), t = a&7;
            x.length = (a>>3)+1;
            b.nextBytes(x);
            if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
            this.fromString(x,256);
          }
        }
    
        // (public) convert to bigendian byte array
        function bnToByteArray() {
          var i = this.t, r = new Array();
          r[0] = this.s;
          var p = this.DB-(i*this.DB)%8, d, k = 0;
          if(i-- > 0) {
            if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
              r[k++] = d|(this.s<<(this.DB-p));
            while(i >= 0) {
              if(p < 8) {
                d = (this[i]&((1<<p)-1))<<(8-p);
                d |= this[--i]>>(p+=this.DB-8);
              }
              else {
                d = (this[i]>>(p-=8))&0xff;
                if(p <= 0) { p += this.DB; --i; }
              }
              if((d&0x80) != 0) d |= -256;
              if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
              if(k > 0 || d != this.s) r[k++] = d;
            }
          }
          return r;
        }
    
        function bnEquals(a) { return(this.compareTo(a)==0); }
        function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
        function bnMax(a) { return(this.compareTo(a)>0)?this:a; }
    
        // (protected) r = this op a (bitwise)
        function bnpBitwiseTo(a,op,r) {
          var i, f, m = Math.min(a.t,this.t);
          for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
          if(a.t < this.t) {
            f = a.s&this.DM;
            for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
            r.t = this.t;
          }
          else {
            f = this.s&this.DM;
            for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
            r.t = a.t;
          }
          r.s = op(this.s,a.s);
          r.clamp();
        }
    
        // (public) this & a
        function op_and(x,y) { return x&y; }
        function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }
    
        // (public) this | a
        function op_or(x,y) { return x|y; }
        function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }
    
        // (public) this ^ a
        function op_xor(x,y) { return x^y; }
        function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }
    
        // (public) this & ~a
        function op_andnot(x,y) { return x&~y; }
        function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }
    
        // (public) ~this
        function bnNot() {
          var r = nbi();
          for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
    
        // (public) this << n
        function bnShiftLeft(n) {
          var r = nbi();
          if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
          return r;
        }
    
        // (public) this >> n
        function bnShiftRight(n) {
          var r = nbi();
          if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
          return r;
        }
    
        // return index of lowest 1-bit in x, x < 2^31
        function lbit(x) {
          if(x == 0) return -1;
          var r = 0;
          if((x&0xffff) == 0) { x >>= 16; r += 16; }
          if((x&0xff) == 0) { x >>= 8; r += 8; }
          if((x&0xf) == 0) { x >>= 4; r += 4; }
          if((x&3) == 0) { x >>= 2; r += 2; }
          if((x&1) == 0) ++r;
          return r;
        }
    
        // (public) returns index of lowest 1-bit (or -1 if none)
        function bnGetLowestSetBit() {
          for(var i = 0; i < this.t; ++i)
            if(this[i] != 0) return i*this.DB+lbit(this[i]);
          if(this.s < 0) return this.t*this.DB;
          return -1;
        }
    
        // return number of 1 bits in x
        function cbit(x) {
          var r = 0;
          while(x != 0) { x &= x-1; ++r; }
          return r;
        }
    
        // (public) return number of set bits
        function bnBitCount() {
          var r = 0, x = this.s&this.DM;
          for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
          return r;
        }
    
        // (public) true iff nth bit is set
        function bnTestBit(n) {
          var j = Math.floor(n/this.DB);
          if(j >= this.t) return(this.s!=0);
          return((this[j]&(1<<(n%this.DB)))!=0);
        }
    
        // (protected) this op (1<<n)
        function bnpChangeBit(n,op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r,op,r);
          return r;
        }
    
        // (public) this | (1<<n)
        function bnSetBit(n) { return this.changeBit(n,op_or); }
    
        // (public) this & ~(1<<n)
        function bnClearBit(n) { return this.changeBit(n,op_andnot); }
    
        // (public) this ^ (1<<n)
        function bnFlipBit(n) { return this.changeBit(n,op_xor); }
    
        // (protected) r = this + a
        function bnpAddTo(a,r) {
          var i = 0, c = 0, m = Math.min(a.t,this.t);
          while(i < m) {
            c += this[i]+a[i];
            r[i++] = c&this.DM;
            c >>= this.DB;
          }
          if(a.t < this.t) {
            c += a.s;
            while(i < this.t) {
              c += this[i];
              r[i++] = c&this.DM;
              c >>= this.DB;
            }
            c += this.s;
          }
          else {
            c += this.s;
            while(i < a.t) {
              c += a[i];
              r[i++] = c&this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = (c<0)?-1:0;
          if(c > 0) r[i++] = c;
          else if(c < -1) r[i++] = this.DV+c;
          r.t = i;
          r.clamp();
        }
    
        // (public) this + a
        function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }
    
        // (public) this - a
        function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }
    
        // (public) this * a
        function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
    
        // (public) this^2
        function bnSquare() { var r = nbi(); this.squareTo(r); return r; }
    
        // (public) this / a
        function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }
    
        // (public) this % a
        function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }
    
        // (public) [this/a,this%a]
        function bnDivideAndRemainder(a) {
          var q = nbi(), r = nbi();
          this.divRemTo(a,q,r);
          return new Array(q,r);
        }
    
        // (protected) this *= n, this >= 0, 1 < n < DV
        function bnpDMultiply(n) {
          this[this.t] = this.am(0,n-1,this,0,0,this.t);
          ++this.t;
          this.clamp();
        }
    
        // (protected) this += n << w words, this >= 0
        function bnpDAddOffset(n,w) {
          if(n == 0) return;
          while(this.t <= w) this[this.t++] = 0;
          this[w] += n;
          while(this[w] >= this.DV) {
            this[w] -= this.DV;
            if(++w >= this.t) this[this.t++] = 0;
            ++this[w];
          }
        }
    
        // A "null" reducer
        function NullExp() {}
        function nNop(x) { return x; }
        function nMulTo(x,y,r) { x.multiplyTo(y,r); }
        function nSqrTo(x,r) { x.squareTo(r); }
    
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
    
        // (public) this^e
        function bnPow(e) { return this.exp(e,new NullExp()); }
    
        // (protected) r = lower n words of "this * a", a.t <= n
        // "this" should be the larger one if appropriate.
        function bnpMultiplyLowerTo(a,n,r) {
          var i = Math.min(this.t+a.t,n);
          r.s = 0; // assumes a,this >= 0
          r.t = i;
          while(i > 0) r[--i] = 0;
          var j;
          for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
          for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
          r.clamp();
        }
    
        // (protected) r = "this * a" without lower n words, n > 0
        // "this" should be the larger one if appropriate.
        function bnpMultiplyUpperTo(a,n,r) {
          --n;
          var i = r.t = this.t+a.t-n;
          r.s = 0; // assumes a,this >= 0
          while(--i >= 0) r[i] = 0;
          for(i = Math.max(n-this.t,0); i < a.t; ++i)
            r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
          r.clamp();
          r.drShiftTo(1,r);
        }
    
        // Barrett modular reduction
        function Barrett(m) {
          // setup Barrett
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
    
        function barrettConvert(x) {
          if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
          else if(x.compareTo(this.m) < 0) return x;
          else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
        }
    
        function barrettRevert(x) { return x; }
    
        // x = x mod m (HAC 14.42)
        function barrettReduce(x) {
          x.drShiftTo(this.m.t-1,this.r2);
          if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
          this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
          this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
          while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
          x.subTo(this.r2,x);
          while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
        }
    
        // r = x^2 mod m; x != r
        function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
    
        // r = x*y mod m; x,y != r
        function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
    
        // (public) this^e % m (HAC 14.85)
        function bnModPow(e,m) {
          var i = e.bitLength(), k, r = nbv(1), z;
          if(i <= 0) return r;
          else if(i < 18) k = 1;
          else if(i < 48) k = 3;
          else if(i < 144) k = 4;
          else if(i < 768) k = 5;
          else k = 6;
          if(i < 8)
            z = new Classic(m);
          else if(m.isEven())
            z = new Barrett(m);
          else
            z = new Montgomery(m);
    
          // precomputation
          var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
          g[1] = z.convert(this);
          if(k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1],g2);
            while(n <= km) {
              g[n] = nbi();
              z.mulTo(g2,g[n-2],g[n]);
              n += 2;
            }
          }
    
          var j = e.t-1, w, is1 = true, r2 = nbi(), t;
          i = nbits(e[j])-1;
          while(j >= 0) {
            if(i >= k1) w = (e[j]>>(i-k1))&km;
            else {
              w = (e[j]&((1<<(i+1))-1))<<(k1-i);
              if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
            }
    
            n = k;
            while((w&1) == 0) { w >>= 1; --n; }
            if((i -= n) < 0) { i += this.DB; --j; }
            if(is1) {	// ret == 1, don't bother squaring or multiplying it
              g[w].copyTo(r);
              is1 = false;
            }
            else {
              while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
              if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
              z.mulTo(r2,g[w],r);
            }
    
            while(j >= 0 && (e[j]&(1<<i)) == 0) {
              z.sqrTo(r,r2); t = r; r = r2; r2 = t;
              if(--i < 0) { i = this.DB-1; --j; }
            }
          }
          return z.revert(r);
        }
    
        // (public) gcd(this,a) (HAC 14.54)
        function bnGCD(a) {
          var x = (this.s<0)?this.negate():this.clone();
          var y = (a.s<0)?a.negate():a.clone();
          if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
          var i = x.getLowestSetBit(), g = y.getLowestSetBit();
          if(g < 0) return x;
          if(i < g) g = i;
          if(g > 0) {
            x.rShiftTo(g,x);
            y.rShiftTo(g,y);
          }
          while(x.signum() > 0) {
            if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
            if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
            if(x.compareTo(y) >= 0) {
              x.subTo(y,x);
              x.rShiftTo(1,x);
            }
            else {
              y.subTo(x,y);
              y.rShiftTo(1,y);
            }
          }
          if(g > 0) y.lShiftTo(g,y);
          return y;
        }
    
        // (protected) this % n, n < 2^26
        function bnpModInt(n) {
          if(n <= 0) return 0;
          var d = this.DV%n, r = (this.s<0)?n-1:0;
          if(this.t > 0)
            if(d == 0) r = this[0]%n;
            else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
          return r;
        }
    
        // (public) 1/this % m (HAC 14.61)
        function bnModInverse(m) {
          var ac = m.isEven();
          if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
          var u = m.clone(), v = this.clone();
          var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
          while(u.signum() != 0) {
            while(u.isEven()) {
              u.rShiftTo(1,u);
              if(ac) {
                if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
                a.rShiftTo(1,a);
              }
              else if(!b.isEven()) b.subTo(m,b);
              b.rShiftTo(1,b);
            }
            while(v.isEven()) {
              v.rShiftTo(1,v);
              if(ac) {
                if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
                c.rShiftTo(1,c);
              }
              else if(!d.isEven()) d.subTo(m,d);
              d.rShiftTo(1,d);
            }
            if(u.compareTo(v) >= 0) {
              u.subTo(v,u);
              if(ac) a.subTo(c,a);
              b.subTo(d,b);
            }
            else {
              v.subTo(u,v);
              if(ac) c.subTo(a,c);
              d.subTo(b,d);
            }
          }
          if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
          if(d.compareTo(m) >= 0) return d.subtract(m);
          if(d.signum() < 0) d.addTo(m,d); else return d;
          if(d.signum() < 0) return d.add(m); else return d;
        }
    
        var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
        var lplim = (1<<26)/lowprimes[lowprimes.length-1];
    
        // (public) test primality with certainty >= 1-.5^t
        function bnIsProbablePrime(t) {
          var i, x = this.abs();
          if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
            for(i = 0; i < lowprimes.length; ++i)
              if(x[0] == lowprimes[i]) return true;
            return false;
          }
          if(x.isEven()) return false;
          i = 1;
          while(i < lowprimes.length) {
            var m = lowprimes[i], j = i+1;
            while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while(i < j) if(m%lowprimes[i++] == 0) return false;
          }
          return x.millerRabin(t);
        }
    
        // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if(k <= 0) return false;
          var r = n1.shiftRight(k);
          t = (t+1)>>1;
          if(t > lowprimes.length) t = lowprimes.length;
          var a = nbi();
          for(var i = 0; i < t; ++i) {
            //Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
            var y = a.modPow(r,this);
            if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while(j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2,this);
                if(y.compareTo(BigInteger.ONE) == 0) return false;
              }
              if(y.compareTo(n1) != 0) return false;
            }
          }
          return true;
        }
    
        // protected
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
    
        // public
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    
        // JSBN-specific extension
        BigInteger.prototype.square = bnSquare;
    
        // Expose the Barrett function
        BigInteger.prototype.Barrett = Barrett
    
        // BigInteger interfaces not implemented in jsbn:
    
        // BigInteger(int signum, byte[] magnitude)
        // double doubleValue()
        // float floatValue()
        // int hashCode()
        // long longValue()
        // static BigInteger valueOf(long val)
    
    	// Random number generator - requires a PRNG backend, e.g. prng4.js
    
    	// For best results, put code like
    	// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
    	// in your main HTML document.
    
    	var rng_state;
    	var rng_pool;
    	var rng_pptr;
    
    	// Mix in a 32-bit integer into the pool
    	function rng_seed_int(x) {
    	  rng_pool[rng_pptr++] ^= x & 255;
    	  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
    	  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
    	  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
    	  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
    	}
    
    	// Mix in the current time (w/milliseconds) into the pool
    	function rng_seed_time() {
    	  rng_seed_int(new Date().getTime());
    	}
    
    	// Initialize the pool with junk if needed.
    	if(rng_pool == null) {
    	  rng_pool = new Array();
    	  rng_pptr = 0;
    	  var t;
    	  if(typeof window !== "undefined" && window.crypto) {
    		if (window.crypto.getRandomValues) {
    		  // Use webcrypto if available
    		  var ua = new Uint8Array(32);
    		  window.crypto.getRandomValues(ua);
    		  for(t = 0; t < 32; ++t)
    			rng_pool[rng_pptr++] = ua[t];
    		}
    		else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
    		  // Extract entropy (256 bits) from NS4 RNG if available
    		  var z = window.crypto.random(32);
    		  for(t = 0; t < z.length; ++t)
    			rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
    		}
    	  }
    	  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
    		t = Math.floor(65536 * Math.random());
    		rng_pool[rng_pptr++] = t >>> 8;
    		rng_pool[rng_pptr++] = t & 255;
    	  }
    	  rng_pptr = 0;
    	  rng_seed_time();
    	  //rng_seed_int(window.screenX);
    	  //rng_seed_int(window.screenY);
    	}
    
    	function rng_get_byte() {
    	  if(rng_state == null) {
    		rng_seed_time();
    		rng_state = prng_newstate();
    		rng_state.init(rng_pool);
    		for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
    		  rng_pool[rng_pptr] = 0;
    		rng_pptr = 0;
    		//rng_pool = null;
    	  }
    	  // TODO: allow reseeding after first request
    	  return rng_state.next();
    	}
    
    	function rng_get_bytes(ba) {
    	  var i;
    	  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
    	}
    
    	function SecureRandom() {}
    
    	SecureRandom.prototype.nextBytes = rng_get_bytes;
    
    	// prng4.js - uses Arcfour as a PRNG
    
    	function Arcfour() {
    	  this.i = 0;
    	  this.j = 0;
    	  this.S = new Array();
    	}
    
    	// Initialize arcfour context from key, an array of ints, each from [0..255]
    	function ARC4init(key) {
    	  var i, j, t;
    	  for(i = 0; i < 256; ++i)
    		this.S[i] = i;
    	  j = 0;
    	  for(i = 0; i < 256; ++i) {
    		j = (j + this.S[i] + key[i % key.length]) & 255;
    		t = this.S[i];
    		this.S[i] = this.S[j];
    		this.S[j] = t;
    	  }
    	  this.i = 0;
    	  this.j = 0;
    	}
    
    	function ARC4next() {
    	  var t;
    	  this.i = (this.i + 1) & 255;
    	  this.j = (this.j + this.S[this.i]) & 255;
    	  t = this.S[this.i];
    	  this.S[this.i] = this.S[this.j];
    	  this.S[this.j] = t;
    	  return this.S[(t + this.S[this.i]) & 255];
    	}
    
    	Arcfour.prototype.init = ARC4init;
    	Arcfour.prototype.next = ARC4next;
    
    	// Plug in your RNG constructor here
    	function prng_newstate() {
    	  return new Arcfour();
    	}
    
    	// Pool size must be a multiple of 4 and greater than 32.
    	// An array of bytes the size of the pool will be passed to init()
    	var rng_psize = 256;
    
        if (typeof exports !== 'undefined') {
            exports = module.exports = {
    			BigInteger: BigInteger,
    			SecureRandom: SecureRandom,
    		};
        } else {
            this.BigInteger = BigInteger;
            this.SecureRandom = SecureRandom;
        }
    
    }).call(this);
    
  provide("jsbn", module.exports);
}(global));

// pakmanager:isobject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * isobject <https://github.com/jonschlinkert/isobject>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isArray = require('isarray');
    
    module.exports = function isObject(o) {
      return o != null && typeof o === 'object' && !isArray(o);
    };
    
  provide("isobject", module.exports);
}(global));

// pakmanager:randomatic
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * randomatic <https://github.com/jonschlinkert/randomatic>
     *
     * This was originally inspired by <http://stackoverflow.com/a/10727155/1267639>
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License (MIT)
     */
    
    'use strict';
    
    var isNumber = require('is-number');
    var typeOf = require('kind-of');
    
    /**
     * Expose `randomatic`
     */
    
    module.exports = randomatic;
    
    /**
     * Available mask characters
     */
    
    var type = {
      lower: 'abcdefghijklmnopqrstuvwxyz',
      upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
      number: '0123456789',
      special: '~!@#$%^&()_+-={}[];\',.'
    };
    
    type.all = type.lower + type.upper + type.number;
    
    /**
     * Generate random character sequences of a specified `length`,
     * based on the given `pattern`.
     *
     * @param {String} `pattern` The pattern to use for generating the random string.
     * @param {String} `length` The length of the string to generate.
     * @param {String} `options`
     * @return {String}
     * @api public
     */
    
    function randomatic(pattern, length, options) {
      if (typeof pattern === 'undefined') {
        throw new Error('randomatic expects a string or number.');
      }
    
      var custom = false;
      if (arguments.length === 1) {
        if (typeof pattern === 'string') {
          length = pattern.length;
    
        } else if (isNumber(pattern)) {
          options = {}; length = pattern; pattern = '*';
        }
      }
    
      if (typeOf(length) === 'object' && length.hasOwnProperty('chars')) {
        options = length;
        pattern = options.chars;
        length = pattern.length;
        custom = true;
      }
    
      var opts = options || {};
      var mask = '';
      var res = '';
    
      // Characters to be used
      if (pattern.indexOf('?') !== -1) mask += opts.chars;
      if (pattern.indexOf('a') !== -1) mask += type.lower;
      if (pattern.indexOf('A') !== -1) mask += type.upper;
      if (pattern.indexOf('0') !== -1) mask += type.number;
      if (pattern.indexOf('!') !== -1) mask += type.special;
      if (pattern.indexOf('*') !== -1) mask += type.all;
      if (custom) mask += pattern;
    
      while (length--) {
        res += mask.charAt(parseInt(Math.random() * mask.length, 10));
      }
      return res;
    };
    
  provide("randomatic", module.exports);
}(global));

// pakmanager:repeat-element
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-element <https://github.com/jonschlinkert/repeat-element>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    module.exports = function repeat(ele, num) {
      var arr = new Array(num);
    
      for (var i = 0; i < num; i++) {
        arr[i] = ele;
      }
    
      return arr;
    };
    
  provide("repeat-element", module.exports);
}(global));

// pakmanager:repeat-string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Results cache
     */
    
    var res = '';
    var cache;
    
    /**
     * Expose `repeat`
     */
    
    module.exports = repeat;
    
    /**
     * Repeat the given `string` the specified `number`
     * of times.
     *
     * **Example:**
     *
     * ```js
     * var repeat =  require('repeat-string');
     * repeat('A', 5);
     * //=> AAAAA
     * ```
     *
     * @param {String} `string` The string to repeat
     * @param {Number} `number` The number of times to repeat the string
     * @return {String} Repeated string
     * @api public
     */
    
    function repeat(str, num) {
      if (typeof str !== 'string') {
        throw new TypeError('repeat-string expects a string.');
      }
    
      // cover common, quick use cases
      if (num === 1) return str;
      if (num === 2) return str + str;
    
      var max = str.length * num;
      if (cache !== str || typeof cache === 'undefined') {
        cache = str;
        res = '';
      }
    
      while (max > res.length && num > 0) {
        if (num & 1) {
          res += str;
        }
    
        num >>= 1;
        if (!num) break;
        str += str;
      }
    
      return res.substr(0, max);
    }
    
    
  provide("repeat-string", module.exports);
}(global));

// pakmanager:lodash.repeat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var toString = require('lodash.tostring');
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor;
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3');
     * // => 3
     */
    function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      string = toString(string);
      n = toInteger(n);
    
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        string += string;
      } while (n);
    
      return result;
    }
    
    module.exports = repeat;
    
  provide("lodash.repeat", module.exports);
}(global));

// pakmanager:lodash.tostring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.2 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;
    
    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var Symbol = root.Symbol;
    
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }
    
    /**
     * Converts `value` to a string if it's not one. An empty string is returned
     * for `null` and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (value == null) {
        return '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }
    
    module.exports = toString;
    
  provide("lodash.tostring", module.exports);
}(global));

// pakmanager:pseudomap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if (process.env.npm_package_name === 'pseudomap' &&
        process.env.npm_lifecycle_script === 'test')
      process.env.TEST_PSEUDOMAP = 'true'
    
    if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
      module.exports = Map
    } else {
      module.exports =   require('pseudomap')
    }
    
  provide("pseudomap", module.exports);
}(global));

// pakmanager:yallist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Yallist
    
    Yallist.Node = Node
    Yallist.create = Yallist
    
    function Yallist (list) {
      var self = this
      if (!(self instanceof Yallist)) {
        self = new Yallist()
      }
    
      self.tail = null
      self.head = null
      self.length = 0
    
      if (list && typeof list.forEach === 'function') {
        list.forEach(function (item) {
          self.push(item)
        })
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i])
        }
      }
    
      return self
    }
    
    Yallist.prototype.removeNode = function (node) {
      if (node.list !== this) {
        throw new Error('removing node which does not belong to this list')
      }
    
      var next = node.next
      var prev = node.prev
    
      if (next) {
        next.prev = prev
      }
    
      if (prev) {
        prev.next = next
      }
    
      if (node === this.head) {
        this.head = next
      }
      if (node === this.tail) {
        this.tail = prev
      }
    
      node.list.length --
      node.next = null
      node.prev = null
      node.list = null
    }
    
    Yallist.prototype.unshiftNode = function (node) {
      if (node === this.head) {
        return
      }
    
      if (node.list) {
        node.list.removeNode(node)
      }
    
      var head = this.head
      node.list = this
      node.next = head
      if (head) {
        head.prev = node
      }
    
      this.head = node
      if (!this.tail) {
        this.tail = node
      }
      this.length ++
    }
    
    Yallist.prototype.pushNode = function (node) {
      if (node === this.tail) {
        return
      }
    
      if (node.list) {
        node.list.removeNode(node)
      }
    
      var tail = this.tail
      node.list = this
      node.prev = tail
      if (tail) {
        tail.next = node
      }
    
      this.tail = node
      if (!this.head) {
        this.head = node
      }
      this.length ++
    }
    
    Yallist.prototype.push = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i])
      }
      return this.length
    }
    
    Yallist.prototype.unshift = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i])
      }
      return this.length
    }
    
    Yallist.prototype.pop = function () {
      if (!this.tail)
        return undefined
    
      var res = this.tail.value
      this.tail = this.tail.prev
      this.tail.next = null
      this.length --
      return res
    }
    
    Yallist.prototype.shift = function () {
      if (!this.head)
        return undefined
    
      var res = this.head.value
      this.head = this.head.next
      this.head.prev = null
      this.length --
      return res
    }
    
    Yallist.prototype.forEach = function (fn, thisp) {
      thisp = thisp || this
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this)
        walker = walker.next
      }
    }
    
    Yallist.prototype.forEachReverse = function (fn, thisp) {
      thisp = thisp || this
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this)
        walker = walker.prev
      }
    }
    
    Yallist.prototype.get = function (n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.next
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    }
    
    Yallist.prototype.getReverse = function (n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.prev
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    }
    
    Yallist.prototype.map = function (fn, thisp) {
      thisp = thisp || this
      var res = new Yallist()
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this))
        walker = walker.next
      }
      return res
    }
    
    Yallist.prototype.mapReverse = function (fn, thisp) {
      thisp = thisp || this
      var res = new Yallist()
      for (var walker = this.tail; walker !== null;) {
        res.push(fn.call(thisp, walker.value, this))
        walker = walker.prev
      }
      return res
    }
    
    Yallist.prototype.reduce = function (fn, initial) {
      var acc
      var walker = this.head
      if (arguments.length > 1) {
        acc = initial
      } else if (this.head) {
        walker = this.head.next
        acc = this.head.value
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }
    
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i)
        walker = walker.next
      }
    
      return acc
    }
    
    Yallist.prototype.reduceReverse = function (fn, initial) {
      var acc
      var walker = this.tail
      if (arguments.length > 1) {
        acc = initial
      } else if (this.tail) {
        walker = this.tail.prev
        acc = this.tail.value
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }
    
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i)
        walker = walker.prev
      }
    
      return acc
    }
    
    Yallist.prototype.toArray = function () {
      var arr = new Array(this.length)
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value
        walker = walker.next
      }
      return arr
    }
    
    Yallist.prototype.toArrayReverse = function () {
      var arr = new Array(this.length)
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value
        walker = walker.prev
      }
      return arr
    }
    
    Yallist.prototype.slice = function (from, to) {
      to = to || this.length
      if (to < 0) {
        to += this.length
      }
      from = from || 0
      if (from < 0) {
        from += this.length
      }
      var ret = new Yallist()
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0
      }
      if (to > this.length) {
        to = this.length
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value)
      }
      return ret
    }
    
    Yallist.prototype.sliceReverse = function (from, to) {
      to = to || this.length
      if (to < 0) {
        to += this.length
      }
      from = from || 0
      if (from < 0) {
        from += this.length
      }
      var ret = new Yallist()
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0
      }
      if (to > this.length) {
        to = this.length
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value)
      }
      return ret
    }
    
    Yallist.prototype.reverse = function () {
      var head = this.head
      var tail = this.tail
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev
        walker.prev = walker.next
        walker.next = p
      }
      this.head = tail
      this.tail = head
      return this
    }
    
    function push (self, item) {
      self.tail = new Node(item, self.tail, null, self)
      if (!self.head) {
        self.head = self.tail
      }
      self.length ++
    }
    
    function unshift (self, item) {
      self.head = new Node(item, null, self.head, self)
      if (!self.tail) {
        self.tail = self.head
      }
      self.length ++
    }
    
    function Node (value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list)
      }
    
      this.list = list
      this.value = value
    
      if (prev) {
        prev.next = this
        this.prev = prev
      } else {
        this.prev = null
      }
    
      if (next) {
        next.prev = this
        this.next = next
      } else {
        this.next = null
      }
    }
    
  provide("yallist", module.exports);
}(global));

// pakmanager:ansi-styles
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var colorConvert = require('color-convert');
    
    function wrapAnsi16(fn, offset) {
    	return function () {
    		var code = fn.apply(colorConvert, arguments);
    		return '\u001b[' + (code + offset) + 'm';
    	};
    }
    
    function wrapAnsi256(fn, offset) {
    	return function () {
    		var code = fn.apply(colorConvert, arguments);
    		return '\u001b[' + (38 + offset) + ';5;' + code + 'm';
    	};
    }
    
    function wrapAnsi16m(fn, offset) {
    	return function () {
    		var rgb = fn.apply(colorConvert, arguments);
    		return '\u001b[' + (38 + offset) + ';2;' +
    			rgb[0] + ';' + rgb[1] + ';' + rgb[2] + 'm';
    	};
    }
    
    function assembleStyles() {
    	var styles = {
    		modifier: {
    			reset: [0, 0],
    			// 21 isn't widely supported and 22 does the same thing
    			bold: [1, 22],
    			dim: [2, 22],
    			italic: [3, 23],
    			underline: [4, 24],
    			inverse: [7, 27],
    			hidden: [8, 28],
    			strikethrough: [9, 29]
    		},
    		color: {
    			black: [30, 39],
    			red: [31, 39],
    			green: [32, 39],
    			yellow: [33, 39],
    			blue: [34, 39],
    			magenta: [35, 39],
    			cyan: [36, 39],
    			white: [37, 39],
    			gray: [90, 39]
    		},
    		bgColor: {
    			bgBlack: [40, 49],
    			bgRed: [41, 49],
    			bgGreen: [42, 49],
    			bgYellow: [43, 49],
    			bgBlue: [44, 49],
    			bgMagenta: [45, 49],
    			bgCyan: [46, 49],
    			bgWhite: [47, 49]
    		}
    	};
    
    	// fix humans
    	styles.color.grey = styles.color.gray;
    
    	Object.keys(styles).forEach(function (groupName) {
    		var group = styles[groupName];
    
    		Object.keys(group).forEach(function (styleName) {
    			var style = group[styleName];
    
    			styles[styleName] = group[styleName] = {
    				open: '\u001b[' + style[0] + 'm',
    				close: '\u001b[' + style[1] + 'm'
    			};
    		});
    
    		Object.defineProperty(styles, groupName, {
    			value: group,
    			enumerable: false
    		});
    	});
    
    	function rgb2rgb(r, g, b) {
    		return [r, g, b];
    	}
    
    	styles.color.close = '\u001b[39m';
    	styles.bgColor.close = '\u001b[49m';
    
    	styles.color.ansi = {};
    	styles.color.ansi256 = {};
    	styles.color.ansi16m = {
    		rgb: wrapAnsi16m(rgb2rgb, 0)
    	};
    
    	styles.bgColor.ansi = {};
    	styles.bgColor.ansi256 = {};
    	styles.bgColor.ansi16m = {
    		rgb: wrapAnsi16m(rgb2rgb, 10)
    	};
    
    	for (var key in colorConvert) {
    		if (!colorConvert.hasOwnProperty(key) || typeof colorConvert[key] !== 'object') {
    			continue;
    		}
    
    		var suite = colorConvert[key];
    
    		if ('ansi16' in suite) {
    			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
    			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
    		}
    
    		if ('ansi256' in suite) {
    			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
    			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
    		}
    
    		if ('rgb' in suite) {
    			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
    			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
    		}
    	}
    
    	return styles;
    }
    
    Object.defineProperty(module, 'exports', {
    	enumerable: true,
    	get: assembleStyles
    });
    
  provide("ansi-styles", module.exports);
}(global));

// pakmanager:escape-string-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return str.replace(matchOperatorsRe, '\\$&');
    };
    
  provide("escape-string-regexp", module.exports);
}(global));

// pakmanager:has-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex');
    var re = new RegExp(ansiRegex().source); // remove the `g` flag
    module.exports = re.test.bind(re);
    
  provide("has-ansi", module.exports);
}(global));

// pakmanager:strip-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var ansiRegex = require('ansi-regex')();
    
    module.exports = function (str) {
    	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
    };
    
  provide("strip-ansi", module.exports);
}(global));

// pakmanager:supports-color
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var hasFlag = require('has-flag');
    
    var support = function (level) {
    	if (level === 0) {
    		return false;
    	}
    
    	return {
    		level: level,
    		hasBasic: true,
    		has256: level >= 2,
    		has16m: level >= 3
    	};
    };
    
    var supportLevel = (function () {
    	if (hasFlag('no-color') ||
    		hasFlag('no-colors') ||
    		hasFlag('color=false')) {
    		return 0;
    	}
    
    	if (hasFlag('color=16m') ||
    		hasFlag('color=full') ||
    		hasFlag('color=truecolor')) {
    		return 3;
    	}
    
    	if (hasFlag('color=256')) {
    		return 2;
    	}
    
    	if (hasFlag('color') ||
    		hasFlag('colors') ||
    		hasFlag('color=true') ||
    		hasFlag('color=always')) {
    		return 1;
    	}
    
    	if (process.stdout && !process.stdout.isTTY) {
    		return 0;
    	}
    
    	if (process.platform === 'win32') {
    		return 1;
    	}
    
    	if ('COLORTERM' in process.env) {
    		return 1;
    	}
    
    	if (process.env.TERM === 'dumb') {
    		return 0;
    	}
    
    	if (/^xterm-256(?:color)?/.test(process.env.TERM)) {
    		return 2;
    	}
    
    	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
    		return 1;
    	}
    
    	return 0;
    })();
    
    if (supportLevel === 0 && 'FORCE_COLOR' in process.env) {
    	supportLevel = 1;
    }
    
    module.exports = process && support(supportLevel);
    
  provide("supports-color", module.exports);
}(global));

// pakmanager:graceful-readlink
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
      , lstat = fs.lstatSync;
    
    exports.readlinkSync = function (p) {
      if (lstat(p).isSymbolicLink()) {
        return fs.readlinkSync(p);
      } else {
        return p;
      }
    };
    
    
    
  provide("graceful-readlink", module.exports);
}(global));

// pakmanager:generate-function
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    
    var INDENT_START = /[\{\[]/
    var INDENT_END = /[\}\]]/
    
    module.exports = function() {
      var lines = []
      var indent = 0
    
      var push = function(str) {
        var spaces = ''
        while (spaces.length < indent*2) spaces += '  '
        lines.push(spaces+str)
      }
    
      var line = function(fmt) {
        if (!fmt) return line
    
        if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
          indent--
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_START.test(fmt[fmt.length-1])) {
          push(util.format.apply(util, arguments))
          indent++
          return line
        }
        if (INDENT_END.test(fmt.trim()[0])) {
          indent--
          push(util.format.apply(util, arguments))
          return line
        }
    
        push(util.format.apply(util, arguments))
        return line
      }
    
      line.toString = function() {
        return lines.join('\n')
      }
    
      line.toFunction = function(scope) {
        var src = 'return ('+line.toString()+')'
    
        var keys = Object.keys(scope || {}).map(function(key) {
          return key
        })
    
        var vals = keys.map(function(key) {
          return scope[key]
        })
    
        return Function.apply(null, keys.concat(src)).apply(null, vals)
      }
    
      if (arguments.length) line.apply(null, arguments)
    
      return line
    }
    
  provide("generate-function", module.exports);
}(global));

// pakmanager:generate-object-property
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isProperty = require('is-property')
    
    var gen = function(obj, prop) {
      return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
    }
    
    gen.valid = isProperty
    gen.property = function (prop) {
     return isProperty(prop) ? prop : JSON.stringify(prop)
    }
    
    module.exports = gen
    
  provide("generate-object-property", module.exports);
}(global));

// pakmanager:jsonpointer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var untilde = function (str) {
      return str.replace(/~./g, function (m) {
        switch (m) {
          case '~0': return '~'
          case '~1': return '/'
        }
        throw new Error('Invalid tilde escape: ' + m)
      })
    }
    
    var traverse = function (obj, pointer, value) {
      var part = untilde(pointer.shift())
      var isJustReading = arguments.length === 2
    
      if (obj[part] == null) {
        if (isJustReading) return null
    
        // support setting of /-
        if (part === '-' && obj instanceof Array) {
          part = obj.length
        }
    
        // support nested objects/array when setting values
        var nextPart = pointer[0]
        if (nextPart === '-' || !isNaN(nextPart)) {
          obj[part] = []
        } else if (nextPart) {
          obj[part] = {}
        }
      }
    
      // keep traversing
      if (pointer.length !== 0) {
        if (isJustReading) {
          return traverse(obj[part], pointer)
        } else {
          return traverse(obj[part], pointer, value)
        }
      }
    
      // we're done
      if (isJustReading) {
        return obj[part]
      }
    
      // set new value, return old value
      var oldValue = obj[part]
      if (value === null) {
        delete obj[part]
      } else {
        obj[part] = value
      }
      return oldValue
    }
    
    var compilePointer = function (pointer) {
      if (pointer === '') {
        return []
      }
    
      if (!pointer) {
        throw new Error('Invalid JSON pointer.')
      }
    
      if (!(pointer instanceof Array)) {
        pointer = pointer.split('/')
        if (pointer.shift() !== '') throw new Error('Invalid JSON pointer.')
      } else {
        // Clone the pointer array
        var newPointer = []
        for (var i = 0; i < pointer.length; i++) newPointer[i] = pointer[i]
        pointer = newPointer
      }
    
      return pointer
    }
    
    var validateInput = function (obj, pointer) {
      if (typeof obj !== 'object') {
        throw new Error('Invalid input object.')
      }
    
      return compilePointer(pointer)
    }
    
    var get = function (obj, pointer) {
      pointer = validateInput(obj, pointer)
      if (pointer.length === 0) {
        return obj
      }
      return traverse(obj, pointer)
    }
    
    var set = function (obj, pointer, value) {
      pointer = validateInput(obj, pointer)
      if (pointer.length === 0) {
        throw new Error('Invalid JSON pointer for set.')
      }
      return traverse(obj, pointer, value)
    }
    
    var compile = function (pointer) {
      var compiled = compilePointer(pointer)
      return {
        get: function (object) {
          return get(object, compiled)
        },
        set: function (object, value) {
          return set(object, compiled, value)
        }
      }
    }
    
    exports.get = get
    exports.set = set
    exports.compile = compile
    
  provide("jsonpointer", module.exports);
}(global));

// pakmanager:xtend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = extend
    
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    
    function extend() {
        var target = {}
    
        for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i]
    
            for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                    target[key] = source[key]
                }
            }
        }
    
        return target
    }
    
  provide("xtend", module.exports);
}(global));

// pakmanager:tweetnacl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function(nacl) {
    'use strict';
    
    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/
    
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };
    
    //  Pluggable, initialized in high-level API below.
    var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };
    
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32); _9[0] = 9;
    
    var gf0 = gf(),
        gf1 = gf([1]),
        _121665 = gf([0xdb41, 1]),
        D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
        D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
        X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
        Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
        I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);
    
    function ts64(x, i, h, l) {
      x[i]   = (h >> 24) & 0xff;
      x[i+1] = (h >> 16) & 0xff;
      x[i+2] = (h >>  8) & 0xff;
      x[i+3] = h & 0xff;
      x[i+4] = (l >> 24)  & 0xff;
      x[i+5] = (l >> 16)  & 0xff;
      x[i+6] = (l >>  8)  & 0xff;
      x[i+7] = l & 0xff;
    }
    
    function vn(x, xi, y, yi, n) {
      var i,d = 0;
      for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
      return (1 & ((d - 1) >>> 8)) - 1;
    }
    
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x,xi,y,yi,16);
    }
    
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x,xi,y,yi,32);
    }
    
    function core_salsa20(o, p, k, c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
    
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;
    
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);
    
        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);
    
        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);
    
        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);
    
        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);
    
        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);
    
        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);
    
        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }
       x0 =  x0 +  j0 | 0;
       x1 =  x1 +  j1 | 0;
       x2 =  x2 +  j2 | 0;
       x3 =  x3 +  j3 | 0;
       x4 =  x4 +  j4 | 0;
       x5 =  x5 +  j5 | 0;
       x6 =  x6 +  j6 | 0;
       x7 =  x7 +  j7 | 0;
       x8 =  x8 +  j8 | 0;
       x9 =  x9 +  j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
    
      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;
    
      o[ 4] = x1 >>>  0 & 0xff;
      o[ 5] = x1 >>>  8 & 0xff;
      o[ 6] = x1 >>> 16 & 0xff;
      o[ 7] = x1 >>> 24 & 0xff;
    
      o[ 8] = x2 >>>  0 & 0xff;
      o[ 9] = x2 >>>  8 & 0xff;
      o[10] = x2 >>> 16 & 0xff;
      o[11] = x2 >>> 24 & 0xff;
    
      o[12] = x3 >>>  0 & 0xff;
      o[13] = x3 >>>  8 & 0xff;
      o[14] = x3 >>> 16 & 0xff;
      o[15] = x3 >>> 24 & 0xff;
    
      o[16] = x4 >>>  0 & 0xff;
      o[17] = x4 >>>  8 & 0xff;
      o[18] = x4 >>> 16 & 0xff;
      o[19] = x4 >>> 24 & 0xff;
    
      o[20] = x5 >>>  0 & 0xff;
      o[21] = x5 >>>  8 & 0xff;
      o[22] = x5 >>> 16 & 0xff;
      o[23] = x5 >>> 24 & 0xff;
    
      o[24] = x6 >>>  0 & 0xff;
      o[25] = x6 >>>  8 & 0xff;
      o[26] = x6 >>> 16 & 0xff;
      o[27] = x6 >>> 24 & 0xff;
    
      o[28] = x7 >>>  0 & 0xff;
      o[29] = x7 >>>  8 & 0xff;
      o[30] = x7 >>> 16 & 0xff;
      o[31] = x7 >>> 24 & 0xff;
    
      o[32] = x8 >>>  0 & 0xff;
      o[33] = x8 >>>  8 & 0xff;
      o[34] = x8 >>> 16 & 0xff;
      o[35] = x8 >>> 24 & 0xff;
    
      o[36] = x9 >>>  0 & 0xff;
      o[37] = x9 >>>  8 & 0xff;
      o[38] = x9 >>> 16 & 0xff;
      o[39] = x9 >>> 24 & 0xff;
    
      o[40] = x10 >>>  0 & 0xff;
      o[41] = x10 >>>  8 & 0xff;
      o[42] = x10 >>> 16 & 0xff;
      o[43] = x10 >>> 24 & 0xff;
    
      o[44] = x11 >>>  0 & 0xff;
      o[45] = x11 >>>  8 & 0xff;
      o[46] = x11 >>> 16 & 0xff;
      o[47] = x11 >>> 24 & 0xff;
    
      o[48] = x12 >>>  0 & 0xff;
      o[49] = x12 >>>  8 & 0xff;
      o[50] = x12 >>> 16 & 0xff;
      o[51] = x12 >>> 24 & 0xff;
    
      o[52] = x13 >>>  0 & 0xff;
      o[53] = x13 >>>  8 & 0xff;
      o[54] = x13 >>> 16 & 0xff;
      o[55] = x13 >>> 24 & 0xff;
    
      o[56] = x14 >>>  0 & 0xff;
      o[57] = x14 >>>  8 & 0xff;
      o[58] = x14 >>> 16 & 0xff;
      o[59] = x14 >>> 24 & 0xff;
    
      o[60] = x15 >>>  0 & 0xff;
      o[61] = x15 >>>  8 & 0xff;
      o[62] = x15 >>> 16 & 0xff;
      o[63] = x15 >>> 24 & 0xff;
    }
    
    function core_hsalsa20(o,p,k,c) {
      var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
          j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
          j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
          j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
          j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
          j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
          j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
          j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
          j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
          j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
          j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
          j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
          j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
          j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
          j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
          j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;
    
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
          x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
          x15 = j15, u;
    
      for (var i = 0; i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u<<7 | u>>>(32-7);
        u = x4 + x0 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x4 | 0;
        x12 ^= u<<13 | u>>>(32-13);
        u = x12 + x8 | 0;
        x0 ^= u<<18 | u>>>(32-18);
    
        u = x5 + x1 | 0;
        x9 ^= u<<7 | u>>>(32-7);
        u = x9 + x5 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x9 | 0;
        x1 ^= u<<13 | u>>>(32-13);
        u = x1 + x13 | 0;
        x5 ^= u<<18 | u>>>(32-18);
    
        u = x10 + x6 | 0;
        x14 ^= u<<7 | u>>>(32-7);
        u = x14 + x10 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x14 | 0;
        x6 ^= u<<13 | u>>>(32-13);
        u = x6 + x2 | 0;
        x10 ^= u<<18 | u>>>(32-18);
    
        u = x15 + x11 | 0;
        x3 ^= u<<7 | u>>>(32-7);
        u = x3 + x15 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x3 | 0;
        x11 ^= u<<13 | u>>>(32-13);
        u = x11 + x7 | 0;
        x15 ^= u<<18 | u>>>(32-18);
    
        u = x0 + x3 | 0;
        x1 ^= u<<7 | u>>>(32-7);
        u = x1 + x0 | 0;
        x2 ^= u<<9 | u>>>(32-9);
        u = x2 + x1 | 0;
        x3 ^= u<<13 | u>>>(32-13);
        u = x3 + x2 | 0;
        x0 ^= u<<18 | u>>>(32-18);
    
        u = x5 + x4 | 0;
        x6 ^= u<<7 | u>>>(32-7);
        u = x6 + x5 | 0;
        x7 ^= u<<9 | u>>>(32-9);
        u = x7 + x6 | 0;
        x4 ^= u<<13 | u>>>(32-13);
        u = x4 + x7 | 0;
        x5 ^= u<<18 | u>>>(32-18);
    
        u = x10 + x9 | 0;
        x11 ^= u<<7 | u>>>(32-7);
        u = x11 + x10 | 0;
        x8 ^= u<<9 | u>>>(32-9);
        u = x8 + x11 | 0;
        x9 ^= u<<13 | u>>>(32-13);
        u = x9 + x8 | 0;
        x10 ^= u<<18 | u>>>(32-18);
    
        u = x15 + x14 | 0;
        x12 ^= u<<7 | u>>>(32-7);
        u = x12 + x15 | 0;
        x13 ^= u<<9 | u>>>(32-9);
        u = x13 + x12 | 0;
        x14 ^= u<<13 | u>>>(32-13);
        u = x14 + x13 | 0;
        x15 ^= u<<18 | u>>>(32-18);
      }
    
      o[ 0] = x0 >>>  0 & 0xff;
      o[ 1] = x0 >>>  8 & 0xff;
      o[ 2] = x0 >>> 16 & 0xff;
      o[ 3] = x0 >>> 24 & 0xff;
    
      o[ 4] = x5 >>>  0 & 0xff;
      o[ 5] = x5 >>>  8 & 0xff;
      o[ 6] = x5 >>> 16 & 0xff;
      o[ 7] = x5 >>> 24 & 0xff;
    
      o[ 8] = x10 >>>  0 & 0xff;
      o[ 9] = x10 >>>  8 & 0xff;
      o[10] = x10 >>> 16 & 0xff;
      o[11] = x10 >>> 24 & 0xff;
    
      o[12] = x15 >>>  0 & 0xff;
      o[13] = x15 >>>  8 & 0xff;
      o[14] = x15 >>> 16 & 0xff;
      o[15] = x15 >>> 24 & 0xff;
    
      o[16] = x6 >>>  0 & 0xff;
      o[17] = x6 >>>  8 & 0xff;
      o[18] = x6 >>> 16 & 0xff;
      o[19] = x6 >>> 24 & 0xff;
    
      o[20] = x7 >>>  0 & 0xff;
      o[21] = x7 >>>  8 & 0xff;
      o[22] = x7 >>> 16 & 0xff;
      o[23] = x7 >>> 24 & 0xff;
    
      o[24] = x8 >>>  0 & 0xff;
      o[25] = x8 >>>  8 & 0xff;
      o[26] = x8 >>> 16 & 0xff;
      o[27] = x8 >>> 24 & 0xff;
    
      o[28] = x9 >>>  0 & 0xff;
      o[29] = x9 >>>  8 & 0xff;
      o[30] = x9 >>> 16 & 0xff;
      o[31] = x9 >>> 24 & 0xff;
    }
    
    function crypto_core_salsa20(out,inp,k,c) {
      core_salsa20(out,inp,k,c);
    }
    
    function crypto_core_hsalsa20(out,inp,k,c) {
      core_hsalsa20(out,inp,k,c);
    }
    
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
                // "expand 32-byte k"
    
    function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
      }
      return 0;
    }
    
    function crypto_stream_salsa20(c,cpos,b,n,k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < 64; i++) c[cpos+i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = u + (z[i] & 0xff) | 0;
          z[i] = u & 0xff;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x,z,k,sigma);
        for (i = 0; i < b; i++) c[cpos+i] = x[i];
      }
      return 0;
    }
    
    function crypto_stream(c,cpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20(c,cpos,d,sn,s);
    }
    
    function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s,n,k,sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i+16];
      return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
    }
    
    /*
    * Port of Andrew Moon's Poly1305-donna-16. Public domain.
    * https://github.com/floodyberry/poly1305-donna
    */
    
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
    
      var t0, t1, t2, t3, t4, t5, t6, t7;
    
      t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
      t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
      t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
      t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
      t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
      this.r[5] = ((t4 >>>  1)) & 0x1ffe;
      t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
      t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
      t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
      this.r[9] = ((t7 >>>  5)) & 0x007f;
    
      this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
      this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
      this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
      this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
      this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
      this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
      this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
      this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };
    
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : (1 << 11);
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
    
      var h0 = this.h[0],
          h1 = this.h[1],
          h2 = this.h[2],
          h3 = this.h[3],
          h4 = this.h[4],
          h5 = this.h[5],
          h6 = this.h[6],
          h7 = this.h[7],
          h8 = this.h[8],
          h9 = this.h[9];
    
      var r0 = this.r[0],
          r1 = this.r[1],
          r2 = this.r[2],
          r3 = this.r[3],
          r4 = this.r[4],
          r5 = this.r[5],
          r6 = this.r[6],
          r7 = this.r[7],
          r8 = this.r[8],
          r9 = this.r[9];
    
      while (bytes >= 16) {
        t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
        t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
        t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
        t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
        t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
        h5 += ((t4 >>>  1)) & 0x1fff;
        t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
        t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
        t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
        h9 += ((t7 >>> 5)) | hibit;
    
        c = 0;
    
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = (d0 >>> 13); d0 &= 0x1fff;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += (d0 >>> 13); d0 &= 0x1fff;
    
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = (d1 >>> 13); d1 &= 0x1fff;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += (d1 >>> 13); d1 &= 0x1fff;
    
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = (d2 >>> 13); d2 &= 0x1fff;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += (d2 >>> 13); d2 &= 0x1fff;
    
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = (d3 >>> 13); d3 &= 0x1fff;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += (d3 >>> 13); d3 &= 0x1fff;
    
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = (d4 >>> 13); d4 &= 0x1fff;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += (d4 >>> 13); d4 &= 0x1fff;
    
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = (d5 >>> 13); d5 &= 0x1fff;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += (d5 >>> 13); d5 &= 0x1fff;
    
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = (d6 >>> 13); d6 &= 0x1fff;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += (d6 >>> 13); d6 &= 0x1fff;
    
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = (d7 >>> 13); d7 &= 0x1fff;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += (d7 >>> 13); d7 &= 0x1fff;
    
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = (d8 >>> 13); d8 &= 0x1fff;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += (d8 >>> 13); d8 &= 0x1fff;
    
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = (d9 >>> 13); d9 &= 0x1fff;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += (d9 >>> 13); d9 &= 0x1fff;
    
        c = (((c << 2) + c)) | 0;
        c = (c + d0) | 0;
        d0 = c & 0x1fff;
        c = (c >>> 13);
        d1 += c;
    
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
    
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
    
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
    
      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 0x1fff;
      }
      this.h[0] += (c * 5);
      c = this.h[0] >>> 13;
      this.h[0] &= 0x1fff;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 0x1fff;
      this.h[2] += c;
    
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 0x1fff;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 0x1fff;
      }
      g[9] -= (1 << 13);
    
      mask = (g[9] >>> ((2 * 8) - 1)) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
    
      this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
      this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
      this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
      this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
      this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
      this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
      this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
      this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;
    
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 0xffff;
      for (i = 1; i < 8; i++) {
        f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
        this.h[i] = f & 0xffff;
      }
    
      mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
      mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
      mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
      mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
      mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
      mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
      mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
      mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
      mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
      mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
      mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
      mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
      mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
      mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
      mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
      mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
    };
    
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
    
      if (this.leftover) {
        want = (16 - this.leftover);
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
    
      if (bytes >= 16) {
        want = bytes - (bytes % 16);
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
    
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos+i];
        this.leftover += bytes;
      }
    };
    
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x,0,m,mpos,n,k);
      return crypto_verify_16(h,hpos,x,0);
    }
    
    function crypto_secretbox(c,m,d,n,k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c,0,m,0,d,n,k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }
    
    function crypto_secretbox_open(m,c,d,n,k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x,0,32,n,k);
      if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
      crypto_stream_xor(m,0,c,0,d,n,k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }
    
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i]|0;
    }
    
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c-1 + 37 * (c-1);
    }
    
    function sel25519(p, q, b) {
      var t, c = ~(b-1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
          m[i-1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
        b = (m[15]>>16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1-b);
      }
      for (i = 0; i < 16; i++) {
        o[2*i] = t[i] & 0xff;
        o[2*i+1] = t[i]>>8;
      }
    }
    
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
      o[15] &= 0x7fff;
    }
    
    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    
    function M(o, a, b) {
      var v, c,
         t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
         t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
        t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
        t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
        b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11],
        b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
    
      t0  += 38 * t16;
      t1  += 38 * t17;
      t2  += 38 * t18;
      t3  += 38 * t19;
      t4  += 38 * t20;
      t5  += 38 * t21;
      t6  += 38 * t22;
      t7  += 38 * t23;
      t8  += 38 * t24;
      t9  += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      // t15 left as is
    
      // first car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);
    
      // second car
      c = 1;
      v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
      v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
      v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
      v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
      v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
      v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
      v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
      v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
      v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
      v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
      v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
      v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
      v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
      v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
      v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
      v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
      t0 += c-1 + 37 * (c-1);
    
      o[ 0] = t0;
      o[ 1] = t1;
      o[ 2] = t2;
      o[ 3] = t3;
      o[ 4] = t4;
      o[ 5] = t5;
      o[ 6] = t6;
      o[ 7] = t7;
      o[ 8] = t8;
      o[ 9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    
    function S(o, a) {
      M(o, a, a);
    }
    
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if(a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
          S(c, c);
          if(a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    
    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf();
      for (i = 0; i < 31; i++) z[i] = n[i];
      z[31]=(n[31]&127)|64;
      z[0]&=248;
      unpack25519(x,p);
      for (i = 0; i < 16; i++) {
        b[i]=x[i];
        d[i]=a[i]=c[i]=0;
      }
      a[0]=d[0]=1;
      for (i=254; i>=0; --i) {
        r=(z[i>>>3]>>>(i&7))&1;
        sel25519(a,b,r);
        sel25519(c,d,r);
        A(e,a,c);
        Z(a,a,c);
        A(c,b,d);
        Z(b,b,d);
        S(d,e);
        S(f,a);
        M(a,c,a);
        M(c,b,e);
        A(e,a,c);
        Z(a,a,c);
        S(b,a);
        Z(c,d,f);
        M(a,c,_121665);
        A(a,a,d);
        M(c,c,a);
        M(a,d,f);
        M(d,b,x);
        S(b,e);
        sel25519(a,b,r);
        sel25519(c,d,r);
      }
      for (i = 0; i < 16; i++) {
        x[i+16]=a[i];
        x[i+32]=c[i];
        x[i+48]=b[i];
        x[i+64]=d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32,x32);
      M(x16,x16,x32);
      pack25519(q,x16);
      return 0;
    }
    
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    
    var K = [
      0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
      0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
      0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
      0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
      0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
      0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
      0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
      0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
      0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
      0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
      0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
      0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
      0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
      0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
      0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
      0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
      0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
      0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
      0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
      0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
      0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
      0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
      0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
      0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
      0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
      0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
      0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
      0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
      0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
      0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
      0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
      0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
      0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
      0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
      0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
      0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
      0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
      0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
      0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
      0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
    ];
    
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16),
          bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
          bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
          th, tl, i, j, h, l, a, b, c, d;
    
      var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],
    
          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];
    
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
          wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
    
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
    
          // add
          h = ah7;
          l = al7;
    
          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;
    
          // Sigma1
          h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
          l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          // Ch
          h = (ah4 & ah5) ^ (~ah4 & ah6);
          l = (al4 & al5) ^ (~al4 & al6);
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          // K
          h = K[i*2];
          l = K[i*2+1];
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          // w
          h = wh[i%16];
          l = wl[i%16];
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
    
          th = c & 0xffff | d << 16;
          tl = a & 0xffff | b << 16;
    
          // add
          h = th;
          l = tl;
    
          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;
    
          // Sigma0
          h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
          l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          // Maj
          h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
          l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
    
          bh7 = (c & 0xffff) | (d << 16);
          bl7 = (a & 0xffff) | (b << 16);
    
          // add
          h = bh3;
          l = bl3;
    
          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;
    
          h = th;
          l = tl;
    
          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;
    
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
    
          bh3 = (c & 0xffff) | (d << 16);
          bl3 = (a & 0xffff) | (b << 16);
    
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
    
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
    
          if (i%16 === 15) {
            for (j = 0; j < 16; j++) {
              // add
              h = wh[j];
              l = wl[j];
    
              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;
    
              h = wh[(j+9)%16];
              l = wl[(j+9)%16];
    
              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;
    
              // sigma0
              th = wh[(j+1)%16];
              tl = wl[(j+1)%16];
              h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
              l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));
    
              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;
    
              // sigma1
              th = wh[(j+14)%16];
              tl = wl[(j+14)%16];
              h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
              l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));
    
              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;
    
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
    
              wh[j] = (c & 0xffff) | (d << 16);
              wl[j] = (a & 0xffff) | (b << 16);
            }
          }
        }
    
        // add
        h = ah0;
        l = al0;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[0];
        l = hl[0];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);
    
        h = ah1;
        l = al1;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[1];
        l = hl[1];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);
    
        h = ah2;
        l = al2;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[2];
        l = hl[2];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);
    
        h = ah3;
        l = al3;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[3];
        l = hl[3];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);
    
        h = ah4;
        l = al4;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[4];
        l = hl[4];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);
    
        h = ah5;
        l = al5;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[5];
        l = hl[5];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);
    
        h = ah6;
        l = al6;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[6];
        l = hl[6];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);
    
        h = ah7;
        l = al7;
    
        a = l & 0xffff; b = l >>> 16;
        c = h & 0xffff; d = h >>> 16;
    
        h = hh[7];
        l = hl[7];
    
        a += l & 0xffff; b += l >>> 16;
        c += h & 0xffff; d += h >>> 16;
    
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
    
        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);
    
        pos += 128;
        n -= 128;
      }
    
      return n;
    }
    
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8),
          hl = new Int32Array(8),
          x = new Uint8Array(256),
          i, b = n;
    
      hh[0] = 0x6a09e667;
      hh[1] = 0xbb67ae85;
      hh[2] = 0x3c6ef372;
      hh[3] = 0xa54ff53a;
      hh[4] = 0x510e527f;
      hh[5] = 0x9b05688c;
      hh[6] = 0x1f83d9ab;
      hh[7] = 0x5be0cd19;
    
      hl[0] = 0xf3bcc908;
      hl[1] = 0x84caa73b;
      hl[2] = 0xfe94f82b;
      hl[3] = 0x5f1d36f1;
      hl[4] = 0xade682d1;
      hl[5] = 0x2b3e6c1f;
      hl[6] = 0xfb41bd6b;
      hl[7] = 0x137e2179;
    
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
    
      for (i = 0; i < n; i++) x[i] = m[b-n+i];
      x[n] = 128;
    
      n = 256-128*(n<112?1:0);
      x[n-9] = 0;
      ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
    
      for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);
    
      return 0;
    }
    
    function add(p, q) {
      var a = gf(), b = gf(), c = gf(),
          d = gf(), e = gf(), f = gf(),
          g = gf(), h = gf(), t = gf();
    
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
    
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    
    function cswap(p, q, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = (s[(i/8)|0] >> (i&7)) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
    
      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
    
      scalarbase(p, d);
      pack(pk, p);
    
      for (i = 0; i < 32; i++) sk[i+32] = pk[i];
      return 0;
    }
    
    var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
    
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = (x[j] + 128) >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i+1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    
    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
    
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
    
      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
    
      crypto_hash(r, sm.subarray(32), n+32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
    
      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
    
      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i+j] += h[i] * d[j];
        }
      }
    
      modL(sm.subarray(32), x);
      return smlen;
    }
    
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(),
          den = gf(), den2 = gf(), den4 = gf(),
          den6 = gf();
    
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
    
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
    
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
    
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);
    
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;
    
      if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);
    
      M(r[3], r[0], r[1]);
      return 0;
    }
    
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()],
          q = [gf(), gf(), gf(), gf()];
    
      mlen = -1;
      if (n < 64) return -1;
    
      if (unpackneg(q, pk)) return -1;
    
      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i+32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
    
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);
    
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }
    
      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    
    var crypto_secretbox_KEYBYTES = 32,
        crypto_secretbox_NONCEBYTES = 24,
        crypto_secretbox_ZEROBYTES = 32,
        crypto_secretbox_BOXZEROBYTES = 16,
        crypto_scalarmult_BYTES = 32,
        crypto_scalarmult_SCALARBYTES = 32,
        crypto_box_PUBLICKEYBYTES = 32,
        crypto_box_SECRETKEYBYTES = 32,
        crypto_box_BEFORENMBYTES = 32,
        crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
        crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
        crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
        crypto_sign_BYTES = 64,
        crypto_sign_PUBLICKEYBYTES = 32,
        crypto_sign_SECRETKEYBYTES = 64,
        crypto_sign_SEEDBYTES = 32,
        crypto_hash_BYTES = 64;
    
    nacl.lowlevel = {
      crypto_core_hsalsa20: crypto_core_hsalsa20,
      crypto_stream_xor: crypto_stream_xor,
      crypto_stream: crypto_stream,
      crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
      crypto_stream_salsa20: crypto_stream_salsa20,
      crypto_onetimeauth: crypto_onetimeauth,
      crypto_onetimeauth_verify: crypto_onetimeauth_verify,
      crypto_verify_16: crypto_verify_16,
      crypto_verify_32: crypto_verify_32,
      crypto_secretbox: crypto_secretbox,
      crypto_secretbox_open: crypto_secretbox_open,
      crypto_scalarmult: crypto_scalarmult,
      crypto_scalarmult_base: crypto_scalarmult_base,
      crypto_box_beforenm: crypto_box_beforenm,
      crypto_box_afternm: crypto_box_afternm,
      crypto_box: crypto_box,
      crypto_box_open: crypto_box_open,
      crypto_box_keypair: crypto_box_keypair,
      crypto_hash: crypto_hash,
      crypto_sign: crypto_sign,
      crypto_sign_keypair: crypto_sign_keypair,
      crypto_sign_open: crypto_sign_open,
    
      crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES: crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
      crypto_hash_BYTES: crypto_hash_BYTES
    };
    
    /* High-level API */
    
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
      if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    }
    
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
      if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    }
    
    function checkArrayTypes() {
      var t, i;
      for (i = 0; i < arguments.length; i++) {
         if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
           throw new TypeError('unexpected type ' + t + ', use Uint8Array');
      }
    }
    
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }
    
    // TODO: Completely remove this in v0.15.
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
      };
    }
    
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };
    
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    
    nacl.box.after = nacl.secretbox;
    
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    
    nacl.box.open.after = nacl.secretbox.open;
    
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    
    nacl.sign.open = function(signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };
    
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };
    
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error('bad signature size');
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
      return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
    };
    
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return {publicKey: pk, secretKey: sk};
    };
    
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
      return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
    };
    
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error('bad seed size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return {publicKey: pk, secretKey: sk};
    };
    
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    
    nacl.hash.hashLength = crypto_hash_BYTES;
    
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      // Zero length arguments are considered not equal.
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
    };
    
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    
    (function() {
      // Initialize PRNG if environment provides CSPRNG.
      // If not, methods calling randombytes will throw.
      var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
      if (crypto && crypto.getRandomValues) {
        // Browsers.
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (typeof require !== 'undefined') {
        // Node.js.
        crypto = require('crypto');
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto.randomBytes(n);
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
    
    })(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));
    
  provide("tweetnacl", module.exports);
}(global));

// pakmanager:jodid25519
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    /*
     * Copyright (c) 2014 Mega Limited
     * under the MIT License.
     * 
     * Authors: Guy K. Kloss
     * 
     * You should have received a copy of the license along with this program.
     */
    
    var dh = require('./lib/dh');
    var eddsa = require('./lib/eddsa');
    var curve255 = require('./lib/curve255');
    var utils = require('./lib/utils');
        
        /**
         * @exports jodid25519
         * Curve 25519-based cryptography collection.
         *
         * @description
         * EC Diffie-Hellman (ECDH) based on Curve25519 and digital signatures
         * (EdDSA) based on Ed25519.
         */
        var ns = {};
        
        /** Module version indicator as string (format: [major.minor.patch]). */
        ns.VERSION = '0.7.1';
    
        ns.dh = dh;
        ns.eddsa = eddsa;
        ns.curve255 = curve255;
        ns.utils = utils;
    
    module.exports = ns;
    
  provide("jodid25519", module.exports);
}(global));

// pakmanager:ecc-jsbn
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require("crypto");
    var BigInteger = require("jsbn").BigInteger;
    var ECPointFp = require("./lib/ec.js").ECPointFp;
    exports.ECCurves = require("./lib/sec.js");
    
    // zero prepad
    function unstupid(hex,len)
    {
    	return (hex.length >= len) ? hex : unstupid("0"+hex,len);
    }
    
    exports.ECKey = function(curve, key, isPublic)
    {
      var priv;
    	var c = curve();
    	var n = c.getN();
      var bytes = Math.floor(n.bitLength()/8);
    
      if(key)
      {
        if(isPublic)
        {
          var curve = c.getCurve();
    //      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format
    //      var y = key.slice(bytes+1);
    //      this.P = new ECPointFp(curve,
    //        curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)),
    //        curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));      
          this.P = curve.decodePointHex(key.toString("hex"));
        }else{
          if(key.length != bytes) return false;
          priv = new BigInteger(key.toString("hex"), 16);      
        }
      }else{
        var n1 = n.subtract(BigInteger.ONE);
        var r = new BigInteger(crypto.randomBytes(n.bitLength()));
        priv = r.mod(n1).add(BigInteger.ONE);
        this.P = c.getG().multiply(priv);
      }
      if(this.P)
      {
    //  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);
    //  this.PublicKey = new Buffer("04"+pubhex,"hex");
        this.PublicKey = new Buffer(c.getCurve().encodeCompressedPointHex(this.P),"hex");
      }
      if(priv)
      {
        this.PrivateKey = new Buffer(unstupid(priv.toString(16),bytes*2),"hex");
        this.deriveSharedSecret = function(key)
        {
          if(!key || !key.P) return false;
          var S = key.P.multiply(priv);
          return new Buffer(unstupid(S.getX().toBigInteger().toString(16),bytes*2),"hex");
       }     
      }
    }
    
    
  provide("ecc-jsbn", module.exports);
}(global));

// pakmanager:minimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (args, opts) {
        if (!opts) opts = {};
        
        var flags = { bools : {}, strings : {}, unknownFn: null };
    
        if (typeof opts['unknown'] === 'function') {
            flags.unknownFn = opts['unknown'];
        }
    
        if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
          flags.allBools = true;
        } else {
          [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
              flags.bools[key] = true;
          });
        }
        
        var aliases = {};
        Object.keys(opts.alias || {}).forEach(function (key) {
            aliases[key] = [].concat(opts.alias[key]);
            aliases[key].forEach(function (x) {
                aliases[x] = [key].concat(aliases[key].filter(function (y) {
                    return x !== y;
                }));
            });
        });
    
        [].concat(opts.string).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            if (aliases[key]) {
                flags.strings[aliases[key]] = true;
            }
         });
    
        var defaults = opts['default'] || {};
        
        var argv = { _ : [] };
        Object.keys(flags.bools).forEach(function (key) {
            setArg(key, defaults[key] === undefined ? false : defaults[key]);
        });
        
        var notFlags = [];
    
        if (args.indexOf('--') !== -1) {
            notFlags = args.slice(args.indexOf('--')+1);
            args = args.slice(0, args.indexOf('--'));
        }
    
        function argDefined(key, arg) {
            return (flags.allBools && /^--[^=]+$/.test(arg)) ||
                flags.strings[key] || flags.bools[key] || aliases[key];
        }
    
        function setArg (key, val, arg) {
            if (arg && flags.unknownFn && !argDefined(key, arg)) {
                if (flags.unknownFn(arg) === false) return;
            }
    
            var value = !flags.strings[key] && isNumber(val)
                ? Number(val) : val
            ;
            setKey(argv, key.split('.'), value);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), value);
            });
        }
    
        function setKey (obj, keys, value) {
            var o = obj;
            keys.slice(0,-1).forEach(function (key) {
                if (o[key] === undefined) o[key] = {};
                o = o[key];
            });
    
            var key = keys[keys.length - 1];
            if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
                o[key] = value;
            }
            else if (Array.isArray(o[key])) {
                o[key].push(value);
            }
            else {
                o[key] = [ o[key], value ];
            }
        }
        
        function aliasIsBoolean(key) {
          return aliases[key].some(function (x) {
              return flags.bools[x];
          });
        }
    
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            
            if (/^--.+=/.test(arg)) {
                // Using [\s\S] instead of . because js doesn't support the
                // 'dotall' regex modifier. See:
                // http://stackoverflow.com/a/1068308/13216
                var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
                var key = m[1];
                var value = m[2];
                if (flags.bools[key]) {
                    value = value !== 'false';
                }
                setArg(key, value, arg);
            }
            else if (/^--no-.+/.test(arg)) {
                var key = arg.match(/^--no-(.+)/)[1];
                setArg(key, false, arg);
            }
            else if (/^--.+/.test(arg)) {
                var key = arg.match(/^--(.+)/)[1];
                var next = args[i + 1];
                if (next !== undefined && !/^-/.test(next)
                && !flags.bools[key]
                && !flags.allBools
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, next, arg);
                    i++;
                }
                else if (/^(true|false)$/.test(next)) {
                    setArg(key, next === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
            else if (/^-[^-]+/.test(arg)) {
                var letters = arg.slice(1,-1).split('');
                
                var broken = false;
                for (var j = 0; j < letters.length; j++) {
                    var next = arg.slice(j+2);
                    
                    if (next === '-') {
                        setArg(letters[j], next, arg)
                        continue;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                        setArg(letters[j], next.split('=')[1], arg);
                        broken = true;
                        break;
                    }
                    
                    if (/[A-Za-z]/.test(letters[j])
                    && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                        setArg(letters[j], next, arg);
                        broken = true;
                        break;
                    }
                    
                    if (letters[j+1] && letters[j+1].match(/\W/)) {
                        setArg(letters[j], arg.slice(j+2), arg);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                    }
                }
                
                var key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                    && !flags.bools[key]
                    && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                        setArg(key, args[i+1], arg);
                        i++;
                    }
                    else if (args[i+1] && /true|false/.test(args[i+1])) {
                        setArg(key, args[i+1] === 'true', arg);
                        i++;
                    }
                    else {
                        setArg(key, flags.strings[key] ? '' : true, arg);
                    }
                }
            }
            else {
                if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                    argv._.push(
                        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                    );
                }
                if (opts.stopEarly) {
                    argv._.push.apply(argv._, args.slice(i + 1));
                    break;
                }
            }
        }
        
        Object.keys(defaults).forEach(function (key) {
            if (!hasKey(argv, key.split('.'))) {
                setKey(argv, key.split('.'), defaults[key]);
                
                (aliases[key] || []).forEach(function (x) {
                    setKey(argv, x.split('.'), defaults[key]);
                });
            }
        });
        
        if (opts['--']) {
            argv['--'] = new Array();
            notFlags.forEach(function(key) {
                argv['--'].push(key);
            });
        }
        else {
            notFlags.forEach(function(key) {
                argv._.push(key);
            });
        }
    
        return argv;
    };
    
    function hasKey (obj, keys) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            o = (o[key] || {});
        });
    
        var key = keys[keys.length - 1];
        return key in o;
    }
    
    function isNumber (x) {
        if (typeof x === 'number') return true;
        if (/^0x[0-9a-f]+$/i.test(x)) return true;
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    
    
  provide("minimist", module.exports);
}(global));

// pakmanager:is-buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Determine if an object is Buffer
     *
     * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * License:  MIT
     *
     * `npm install is-buffer`
     */
    
    module.exports = function (obj) {
      return !!(obj != null &&
        (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
          (obj.constructor &&
          typeof obj.constructor.isBuffer === 'function' &&
          obj.constructor.isBuffer(obj))
        ))
    }
    
  provide("is-buffer", module.exports);
}(global));

// pakmanager:is-arrayish
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function isArrayish(obj) {
    	if (!obj) {
    		return false;
    	}
    
    	return obj instanceof Array || Array.isArray(obj) ||
    		(obj.length >= 0 && (obj.splice instanceof Function ||
    			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
    };
    
  provide("is-arrayish", module.exports);
}(global));

// pakmanager:minimalistic-assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = assert;
    
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || 'Assertion failed');
    }
    
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
    };
    
  provide("minimalistic-assert", module.exports);
}(global));

// pakmanager:buffer-xor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function xor (a, b) {
      var length = Math.max(a.length, b.length)
      var buffer = new Buffer(length)
    
      for (var i = 0; i < length; ++i) {
        buffer[i] = a[i] ^ b[i]
      }
    
      return buffer
    }
    
  provide("buffer-xor", module.exports);
}(global));

// pakmanager:evp_bytestokey
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var md5 = require('create-hash/md5')
    module.exports = EVP_BytesToKey
    function EVP_BytesToKey (password, salt, keyLen, ivLen) {
      if (!Buffer.isBuffer(password)) {
        password = new Buffer(password, 'binary')
      }
      if (salt && !Buffer.isBuffer(salt)) {
        salt = new Buffer(salt, 'binary')
      }
      keyLen = keyLen / 8
      ivLen = ivLen || 0
      var ki = 0
      var ii = 0
      var key = new Buffer(keyLen)
      var iv = new Buffer(ivLen)
      var addmd = 0
      var md_buf
      var i
      var bufs = []
      while (true) {
        if (addmd++ > 0) {
          bufs.push(md_buf)
        }
        bufs.push(password)
        if (salt) {
          bufs.push(salt)
        }
        md_buf = md5(Buffer.concat(bufs))
        bufs = []
        i = 0
        if (keyLen > 0) {
          while (true) {
            if (keyLen === 0) {
              break
            }
            if (i === md_buf.length) {
              break
            }
            key[ki++] = md_buf[i]
            keyLen--
            i++
          }
        }
        if (ivLen > 0 && i !== md_buf.length) {
          while (true) {
            if (ivLen === 0) {
              break
            }
            if (i === md_buf.length) {
              break
            }
            iv[ii++] = md_buf[i]
            ivLen--
            i++
          }
        }
        if (keyLen === 0 && ivLen === 0) {
          break
        }
      }
      for (i = 0; i < md_buf.length; i++) {
        md_buf[i] = 0
      }
      return {
        key: key,
        iv: iv
      }
    }
    
  provide("evp_bytestokey", module.exports);
}(global));

// pakmanager:create-hmac
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('crypto').createHmac;
  provide("create-hmac", module.exports);
}(global));

// pakmanager:arr-flatten
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function flatten(arr) {
      return flat(arr, []);
    };
    
    function flat(arr, res) {
      var len = arr.length;
      var i = -1;
    
      while (len--) {
        var cur = arr[++i];
        if (Array.isArray(cur)) {
          flat(cur, res);
        } else {
          res.push(cur);
        }
      }
      return res;
    }
  provide("arr-flatten", module.exports);
}(global));

// pakmanager:expand-range
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * expand-range <https://github.com/jonschlinkert/expand-range>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    var fill = require('fill-range');
    
    module.exports = function expandRange(str, options, fn) {
      if (typeof str !== 'string') {
        throw new TypeError('expand-range expects a string.');
      }
    
      if (typeof options === 'function') {
        fn = options;
        options = {};
      }
    
      if (typeof options === 'boolean') {
        options = {};
        options.makeRe = true;
      }
    
      // create arguments to pass to fill-range
      var opts = options || {};
      var args = str.split('..');
      var len = args.length;
      if (len > 3) { return str; }
    
      // if only one argument, it can't expand so return it
      if (len === 1) { return args; }
    
      // if `true`, tell fill-range to regexify the string
      if (typeof fn === 'boolean' && fn === true) {
        opts.makeRe = true;
      }
    
      args.push(opts);
      return fill.apply(fill, args.concat(fn));
    };
    
  provide("expand-range", module.exports);
}(global));

// pakmanager:preserve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * preserve <https://github.com/jonschlinkert/preserve>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * Replace tokens in `str` with a temporary, heuristic placeholder.
     *
     * ```js
     * tokens.before('{a\\,b}');
     * //=> '{__ID1__}'
     * ```
     *
     * @param  {String} `str`
     * @return {String} String with placeholders.
     * @api public
     */
    
    exports.before = function before(str, re) {
      return str.replace(re, function (match) {
        var id = randomize();
        cache[id] = match;
        return '__ID' + id + '__';
      });
    };
    
    /**
     * Replace placeholders in `str` with original tokens.
     *
     * ```js
     * tokens.after('{__ID1__}');
     * //=> '{a\\,b}'
     * ```
     *
     * @param  {String} `str` String with placeholders
     * @return {String} `str` String with original tokens.
     * @api public
     */
    
    exports.after = function after(str) {
      return str.replace(/__ID(.{5})__/g, function (_, id) {
        return cache[id];
      });
    };
    
    function randomize() {
      return Math.random().toString().slice(2, 7);
    }
    
    var cache = {};
  provide("preserve", module.exports);
}(global));

// pakmanager:for-own
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * for-own <https://github.com/jonschlinkert/for-own>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var forIn = require('for-in');
    var hasOwn = Object.prototype.hasOwnProperty;
    
    module.exports = function forOwn(o, fn, thisArg) {
      forIn(o, function (val, key) {
        if (hasOwn.call(o, key)) {
          return fn.call(thisArg, o[key], key, o);
        }
      });
    };
    
  provide("for-own", module.exports);
}(global));

// pakmanager:is-extendable
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-extendable <https://github.com/jonschlinkert/is-extendable>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function isExtendable(val) {
      return typeof val !== 'undefined' && val !== null
        && (typeof val === 'object' || typeof val === 'function');
    };
    
  provide("is-extendable", module.exports);
}(global));

// pakmanager:glob-base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * glob-base <https://github.com/jonschlinkert/glob-base>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var path = require('path');
    var parent = require('glob-parent');
    var isGlob = require('is-glob');
    
    module.exports = function globBase(pattern) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob-base expects a string.');
      }
    
      var res = {};
      res.base = parent(pattern);
      res.isGlob = isGlob(pattern);
    
      if (res.base !== '.') {
        res.glob = pattern.substr(res.base.length);
        if (res.glob.charAt(0) === '/') {
          res.glob = res.glob.substr(1);
        }
      } else {
        res.glob = pattern;
      }
    
      if (!res.isGlob) {
        res.base = dirname(pattern);
        res.glob = res.base !== '.'
          ? pattern.substr(res.base.length)
          : pattern;
      }
    
      if (res.glob.substr(0, 2) === './') {
        res.glob = res.glob.substr(2);
      }
      if (res.glob.charAt(0) === '/') {
        res.glob = res.glob.substr(1);
      }
      return res;
    };
    
    function dirname(glob) {
      if (glob.slice(-1) === '/') return glob;
      return path.dirname(glob);
    }
    
  provide("glob-base", module.exports);
}(global));

// pakmanager:is-dotfile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-dotfile <https://github.com/regexps/is-dotfile>
     *
     * Copyright (c) 2015 Jon Schlinkert, contributors.
     * Licensed under the MIT license.
     */
    
    module.exports = function(str) {
      if (str.charCodeAt(0) === 46 /* . */ && str.indexOf('/', 1) === -1) {
        return true;
      }
    
      var last = str.lastIndexOf('/');
      return last !== -1 ? str.charCodeAt(last + 1) === 46  /* . */ : false;
    };
    
  provide("is-dotfile", module.exports);
}(global));

// pakmanager:is-equal-shallow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isPrimitive = require('is-primitive');
    
    module.exports = function isEqual(a, b) {
      if (!a && !b) { return true; }
      if (!a && b || a && !b) { return false; }
    
      var numKeysA = 0, numKeysB = 0, key;
      for (key in b) {
        numKeysB++;
        if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {
          return false;
        }
      }
      for (key in a) {
        numKeysA++;
      }
      return numKeysA === numKeysB;
    };
    
  provide("is-equal-shallow", module.exports);
}(global));

// pakmanager:abbrev
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = exports = abbrev.abbrev = abbrev
    
    abbrev.monkeyPatch = monkeyPatch
    
    function monkeyPatch () {
      Object.defineProperty(Array.prototype, 'abbrev', {
        value: function () { return abbrev(this) },
        enumerable: false, configurable: true, writable: true
      })
    
      Object.defineProperty(Object.prototype, 'abbrev', {
        value: function () { return abbrev(Object.keys(this)) },
        enumerable: false, configurable: true, writable: true
      })
    }
    
    function abbrev (list) {
      if (arguments.length !== 1 || !Array.isArray(list)) {
        list = Array.prototype.slice.call(arguments, 0)
      }
      for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {
        args[i] = typeof list[i] === "string" ? list[i] : String(list[i])
      }
    
      // sort them lexicographically, so that they're next to their nearest kin
      args = args.sort(lexSort)
    
      // walk through each, seeing how much it has in common with the next and previous
      var abbrevs = {}
        , prev = ""
      for (var i = 0, l = args.length ; i < l ; i ++) {
        var current = args[i]
          , next = args[i + 1] || ""
          , nextMatches = true
          , prevMatches = true
        if (current === next) continue
        for (var j = 0, cl = current.length ; j < cl ; j ++) {
          var curChar = current.charAt(j)
          nextMatches = nextMatches && curChar === next.charAt(j)
          prevMatches = prevMatches && curChar === prev.charAt(j)
          if (!nextMatches && !prevMatches) {
            j ++
            break
          }
        }
        prev = current
        if (j === cl) {
          abbrevs[current] = current
          continue
        }
        for (var a = current.substr(0, j) ; j <= cl ; j ++) {
          abbrevs[a] = current
          a += current.charAt(j)
        }
      }
      return abbrevs
    }
    
    function lexSort (a, b) {
      return a === b ? 0 : a > b ? 1 : -1
    }
    
  provide("abbrev", module.exports);
}(global));

// pakmanager:are-we-there-yet/tracker-base.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var EventEmitter = require('events').EventEmitter
    var util = require('util')
    
    var trackerId = 0
    var TrackerBase = module.exports = function (name) {
      EventEmitter.call(this)
      this.id = ++trackerId
      this.name = name
    }
    util.inherits(TrackerBase, EventEmitter)
    
  provide("are-we-there-yet/tracker-base.js", module.exports);
}(global));

// pakmanager:are-we-there-yet/tracker.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var util = require('util')
    var TrackerBase =  require('are-we-there-yet/tracker-base.js')
    
    var Tracker = module.exports = function (name, todo) {
      TrackerBase.call(this, name)
      this.workDone = 0
      this.workTodo = todo || 0
    }
    util.inherits(Tracker, TrackerBase)
    
    Tracker.prototype.completed = function () {
      return this.workTodo === 0 ? 0 : this.workDone / this.workTodo
    }
    
    Tracker.prototype.addWork = function (work) {
      this.workTodo += work
      this.emit('change', this.name, this.completed(), this)
    }
    
    Tracker.prototype.completeWork = function (work) {
      this.workDone += work
      if (this.workDone > this.workTodo) this.workDone = this.workTodo
      this.emit('change', this.name, this.completed(), this)
    }
    
    Tracker.prototype.finish = function () {
      this.workTodo = this.workDone = 1
      this.emit('change', this.name, 1, this)
    }
    
  provide("are-we-there-yet/tracker.js", module.exports);
}(global));

// pakmanager:are-we-there-yet/tracker-stream.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var util = require('util')
    var stream = require('readable-stream')
    var delegate = require('delegates')
    var Tracker =  require('are-we-there-yet/tracker.js')
    
    var TrackerStream = module.exports = function (name, size, options) {
      stream.Transform.call(this, options)
      this.tracker = new Tracker(name, size)
      this.name = name
      this.id = this.tracker.id
      this.tracker.on('change', delegateChange(this))
    }
    util.inherits(TrackerStream, stream.Transform)
    
    function delegateChange (trackerStream) {
      return function (name, completion, tracker) {
        trackerStream.emit('change', name, completion, trackerStream)
      }
    }
    
    TrackerStream.prototype._transform = function (data, encoding, cb) {
      this.tracker.completeWork(data.length ? data.length : 1)
      this.push(data)
      cb()
    }
    
    TrackerStream.prototype._flush = function (cb) {
      this.tracker.finish()
      cb()
    }
    
    delegate(TrackerStream.prototype, 'tracker')
      .method('completed')
      .method('addWork')
    
  provide("are-we-there-yet/tracker-stream.js", module.exports);
}(global));

// pakmanager:are-we-there-yet/tracker-group.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var util = require('util')
    var TrackerBase =  require('are-we-there-yet/tracker-base.js')
    var Tracker =  require('are-we-there-yet/tracker.js')
    var TrackerStream =  require('are-we-there-yet/tracker-stream.js')
    
    var TrackerGroup = module.exports = function (name) {
      TrackerBase.call(this, name)
      this.parentGroup = null
      this.trackers = []
      this.completion = {}
      this.weight = {}
      this.totalWeight = 0
      this.finished = false
      this.bubbleChange = bubbleChange(this)
    }
    util.inherits(TrackerGroup, TrackerBase)
    
    function bubbleChange (trackerGroup) {
      return function (name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed
        if (trackerGroup.finished) return
        trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup)
      }
    }
    
    TrackerGroup.prototype.nameInTree = function () {
      var names = []
      var from = this
      while (from) {
        names.unshift(from.name)
        from = from.parentGroup
      }
      return names.join('/')
    }
    
    TrackerGroup.prototype.addUnit = function (unit, weight) {
      if (unit.addUnit) {
        var toTest = this
        while (toTest) {
          if (unit === toTest) {
            throw new Error(
              'Attempted to add tracker group ' +
              unit.name + ' to tree that already includes it ' +
              this.nameInTree(this))
          }
          toTest = toTest.parentGroup
        }
        unit.parentGroup = this
      }
      this.weight[unit.id] = weight || 1
      this.totalWeight += this.weight[unit.id]
      this.trackers.push(unit)
      this.completion[unit.id] = unit.completed()
      unit.on('change', this.bubbleChange)
      if (!this.finished) this.emit('change', unit.name, this.completion[unit.id], unit)
      return unit
    }
    
    TrackerGroup.prototype.completed = function () {
      if (this.trackers.length === 0) return 0
      var valPerWeight = 1 / this.totalWeight
      var completed = 0
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var trackerId = this.trackers[ii].id
        completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId]
      }
      return completed
    }
    
    TrackerGroup.prototype.newGroup = function (name, weight) {
      return this.addUnit(new TrackerGroup(name), weight)
    }
    
    TrackerGroup.prototype.newItem = function (name, todo, weight) {
      return this.addUnit(new Tracker(name, todo), weight)
    }
    
    TrackerGroup.prototype.newStream = function (name, todo, weight) {
      return this.addUnit(new TrackerStream(name, todo), weight)
    }
    
    TrackerGroup.prototype.finish = function () {
      this.finished = true
      if (!this.trackers.length) this.addUnit(new Tracker(), 1, true)
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var tracker = this.trackers[ii]
        tracker.finish()
        tracker.removeListener('change', this.bubbleChange)
      }
      this.emit('change', this.name, 1, this)
    }
    
    var buffer = '                                  '
    TrackerGroup.prototype.debug = function (depth) {
      depth = depth || 0
      var indent = depth ? buffer.substr(0, depth) : ''
      var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n'
      this.trackers.forEach(function (tracker) {
        if (tracker instanceof TrackerGroup) {
          output += tracker.debug(depth + 1)
        } else {
          output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n'
        }
      })
      return output
    }
    
  provide("are-we-there-yet/tracker-group.js", module.exports);
}(global));

// pakmanager:are-we-there-yet
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    exports.TrackerGroup =  require('are-we-there-yet/tracker-group.js')
    exports.Tracker =  require('are-we-there-yet/tracker.js')
    exports.TrackerStream =  require('are-we-there-yet/tracker-stream.js')
    
  provide("are-we-there-yet", module.exports);
}(global));

// pakmanager:gauge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    var hasUnicode = require("has-unicode")
    var ansi = require("ansi")
    var align = {
      center: require("lodash.pad"),
      left:   require("lodash.padend"),
      right:  require("lodash.padstart")
    }
    var defaultStream = process.stderr
    function isTTY() {
      return process.stderr.isTTY
    }
    function getWritableTTYColumns() {
      // Writing to the final column wraps the line
      // We have to use stdout here, because Node's magic SIGWINCH handler only
      // updates process.stdout, not process.stderr
      return process.stdout.columns - 1
    }
    
    var ProgressBar = module.exports = function (options, cursor) {
      if (! options) options = {}
      if (! cursor && options.write) {
        cursor = options
        options = {}
      }
      if (! cursor) {
        cursor = ansi(defaultStream)
      }
      this.cursor = cursor
      this.showing = false
      this.theme = options.theme || (hasUnicode() ? ProgressBar.unicode : ProgressBar.ascii)
      this.template = options.template || [
        {type: "name", separated: true, length: 25},
        {type: "spinner", separated: true},
        {type: "startgroup"},
        {type: "completionbar"},
        {type: "endgroup"}
      ]
      this.updatefreq = options.maxUpdateFrequency == null ? 50 : options.maxUpdateFrequency
      this.lastName = ""
      this.lastCompleted = 0
      this.spun = 0
      this.last = new Date(0)
    
      var self = this
      this._handleSizeChange = function () {
        if (!self.showing) return
        self.hide()
        self.show()
      }
    }
    ProgressBar.prototype = {}
    
    ProgressBar.unicode = {
      startgroup: "╢",
      endgroup: "╟",
      complete: "█",
      incomplete: "░",
      spinner: "▀▐▄▌",
      subsection: "→"
    }
    
    ProgressBar.ascii = {
      startgroup: "|",
      endgroup: "|",
      complete: "#",
      incomplete: "-",
      spinner: "-\\|/",
      subsection: "->"
    }
    
    ProgressBar.prototype.setTheme = function(theme) {
      this.theme = theme
    }
    
    ProgressBar.prototype.setTemplate = function(template) {
      this.template = template
    }
    
    ProgressBar.prototype._enableResizeEvents = function() {
      process.stdout.on('resize', this._handleSizeChange)
    }
    
    ProgressBar.prototype._disableResizeEvents = function() {
      process.stdout.removeListener('resize', this._handleSizeChange)
    }
    
    ProgressBar.prototype.disable = function() {
      this.hide()
      this.disabled = true
    }
    
    ProgressBar.prototype.enable = function() {
      this.disabled = false
      this.show()
    }
    
    ProgressBar.prototype.hide = function() {
      if (!isTTY()) return
      if (this.disabled) return
      this.cursor.show()
      if (this.showing) this.cursor.up(1)
      this.cursor.horizontalAbsolute(0).eraseLine()
      this.showing = false
    }
    
    var repeat = function (str, count) {
      var out = ""
      for (var ii=0; ii<count; ++ii) out += str
      return out
    }
    
    ProgressBar.prototype.pulse = function(name) {
      ++ this.spun
      if (! this.showing) return
      if (this.disabled) return
    
      var baseName = this.lastName
      name = name
           ? ( baseName
             ? baseName + " " + this.theme.subsection + " " + name
             : null )
           : baseName
      this.show(name)
      this.lastName = baseName
    }
    
    ProgressBar.prototype.show = function(name, completed) {
      name = this.lastName = name || this.lastName
      completed = this.lastCompleted = completed || this.lastCompleted
    
      if (!isTTY()) return
      if (this.disabled) return
      if (! this.spun && ! completed) return
      if (this.tryAgain) return
      var self = this
    
      if (this.showing && new Date() - this.last < this.updatefreq) {
        this.tryAgain = setTimeout(function () {
          self.tryAgain = null
          if (self.disabled) return
          if (! self.spun && ! completed) return
          drawBar()
        }, this.updatefreq - (new Date() - this.last))
        return
      }
    
      return drawBar()
    
      function drawBar() {
        var values = {
          name: name,
          spinner: self.spun,
          completed: completed
        }
    
        self.last = new Date()
    
        var statusline = self.renderTemplate(self.theme, self.template, values)
    
        if (self.showing) self.cursor.up(1)
        self.cursor
            .hide()
            .horizontalAbsolute(0)
            .write(statusline.substr(0, getWritableTTYColumns()) + "\n")
            .show()
    
        self.showing = true
      }
    }
    
    ProgressBar.prototype.renderTemplate = function (theme, template, values) {
      values.startgroup = theme.startgroup
      values.endgroup = theme.endgroup
      values.spinner = values.spinner
        ? theme.spinner.substr(values.spinner % theme.spinner.length,1)
        : ""
    
      var output = {prebar: "", postbar: ""}
      var status = "prebar"
      var self = this
      template.forEach(function(T) {
        if (typeof T === "string") {
          output[status] += T
          return
        }
        if (T.type === "completionbar") {
          status = "postbar"
          return
        }
        if (!values.hasOwnProperty(T.type)) throw new Error("Unknown template value '"+T.type+"'")
        var value = self.renderValue(T, values[T.type])
        if (value === "") return
        var sofar = output[status].length
        var lastChar = sofar ? output[status][sofar-1] : null
        if (T.separated && sofar && lastChar !== " ") {
          output[status] += " "
        }
        output[status] += value
        if (T.separated) output[status] += " "
      })
    
      var bar = ""
      if (status === "postbar") {
        var nonBarLen = output.prebar.length + output.postbar.length
    
        var barLen = getWritableTTYColumns() - nonBarLen
        var sofar = Math.round(barLen * Math.max(0,Math.min(1,values.completed||0)))
        var rest = barLen - sofar
        bar = repeat(theme.complete, sofar)
            + repeat(theme.incomplete, rest)
      }
    
      return output.prebar + bar + output.postbar
    }
    ProgressBar.prototype.renderValue = function (template, value) {
      if (value == null || value === "") return ""
      var maxLength = template.maxLength || template.length
      var minLength = template.minLength || template.length
      var alignWith = align[template.align] || align.left
    //  if (maxLength) value = value.substr(-1 * maxLength)
      if (maxLength) value = value.substr(0, maxLength)
      if (minLength) value = alignWith(value, minLength)
      return value
    }
    
  provide("gauge", module.exports);
}(global));

// pakmanager:aws-sign2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /*!
     *  Copyright 2010 LearnBoost <dev@learnboost.com>
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    /**
     * Module dependencies.
     */
    
    var crypto = require('crypto')
      , parse = require('url').parse
      ;
    
    /**
     * Valid keys.
     */
    
    var keys = 
      [ 'acl'
      , 'location'
      , 'logging'
      , 'notification'
      , 'partNumber'
      , 'policy'
      , 'requestPayment'
      , 'torrent'
      , 'uploadId'
      , 'uploads'
      , 'versionId'
      , 'versioning'
      , 'versions'
      , 'website'
      ]
    
    /**
     * Return an "Authorization" header value with the given `options`
     * in the form of "AWS <key>:<signature>"
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function authorization (options) {
      return 'AWS ' + options.key + ':' + sign(options)
    }
    
    module.exports = authorization
    module.exports.authorization = authorization
    
    /**
     * Simple HMAC-SHA1 Wrapper
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */ 
    
    function hmacSha1 (options) {
      return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
    }
    
    module.exports.hmacSha1 = hmacSha1
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function sign (options) {
      options.message = stringToSign(options)
      return hmacSha1(options)
    }
    module.exports.sign = sign
    
    /**
     * Create a base64 sha1 HMAC for `options`. 
     *
     * Specifically to be used with S3 presigned URLs
     * 
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function signQuery (options) {
      options.message = queryStringToSign(options)
      return hmacSha1(options)
    }
    module.exports.signQuery= signQuery
    
    /**
     * Return a string for sign() with the given `options`.
     *
     * Spec:
     * 
     *    <verb>\n
     *    <md5>\n
     *    <content-type>\n
     *    <date>\n
     *    [headers\n]
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function stringToSign (options) {
      var headers = options.amazonHeaders || ''
      if (headers) headers += '\n'
      var r = 
        [ options.verb
        , options.md5
        , options.contentType
        , options.date ? options.date.toUTCString() : ''
        , headers + options.resource
        ]
      return r.join('\n')
    }
    module.exports.queryStringToSign = stringToSign
    
    /**
     * Return a string for sign() with the given `options`, but is meant exclusively
     * for S3 presigned URLs
     *
     * Spec:
     * 
     *    <date>\n
     *    <resource>
     *
     * @param {Object} options
     * @return {String}
     * @api private
     */
    
    function queryStringToSign (options){
      return 'GET\n\n\n' + options.date + '\n' + options.resource
    }
    module.exports.queryStringToSign = queryStringToSign
    
    /**
     * Perform the following:
     *
     *  - ignore non-amazon headers
     *  - lowercase fields
     *  - sort lexicographically
     *  - trim whitespace between ":"
     *  - join with newline
     *
     * @param {Object} headers
     * @return {String}
     * @api private
     */
    
    function canonicalizeHeaders (headers) {
      var buf = []
        , fields = Object.keys(headers)
        ;
      for (var i = 0, len = fields.length; i < len; ++i) {
        var field = fields[i]
          , val = headers[field]
          , field = field.toLowerCase()
          ;
        if (0 !== field.indexOf('x-amz')) continue
        buf.push(field + ':' + val)
      }
      return buf.sort().join('\n')
    }
    module.exports.canonicalizeHeaders = canonicalizeHeaders
    
    /**
     * Perform the following:
     *
     *  - ignore non sub-resources
     *  - sort lexicographically
     *
     * @param {String} resource
     * @return {String}
     * @api private
     */
    
    function canonicalizeResource (resource) {
      var url = parse(resource, true)
        , path = url.pathname
        , buf = []
        ;
    
      Object.keys(url.query).forEach(function(key){
        if (!~keys.indexOf(key)) return
        var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
        buf.push(key + val)
      })
    
      return path + (buf.length ? '?' + buf.sort().join('&') : '')
    }
    module.exports.canonicalizeResource = canonicalizeResource
    
  provide("aws-sign2", module.exports);
}(global));

// pakmanager:aws4
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var aws4 = exports,
        url = require('url'),
        querystring = require('querystring'),
        crypto = require('crypto'),
        lru = require('lru-cache'),
        credentialsCache = lru(1000)
    
    // http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html
    
    function hmac(key, string, encoding) {
      return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
    }
    
    function hash(string, encoding) {
      return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)
    }
    
    // This function assumes the string has already been percent encoded
    function encodeRfc3986(urlEncodedString) {
      return urlEncodedString.replace(/[!'()*]/g, function(c) {
        return '%' + c.charCodeAt(0).toString(16).toUpperCase()
      })
    }
    
    // request: { path | body, [host], [method], [headers], [service], [region] }
    // credentials: { accessKeyId, secretAccessKey, [sessionToken] }
    function RequestSigner(request, credentials) {
    
      if (typeof request === 'string') request = url.parse(request)
    
      var headers = request.headers = (request.headers || {}),
          hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host)
    
      this.request = request
      this.credentials = credentials || this.defaultCredentials()
    
      this.service = request.service || hostParts[0] || ''
      this.region = request.region || hostParts[1] || 'us-east-1'
    
      // SES uses a different domain from the service name
      if (this.service === 'email') this.service = 'ses'
    
      if (!request.method && request.body)
        request.method = 'POST'
    
      if (!headers.Host && !headers.host) {
        headers.Host = request.hostname || request.host || this.createHost()
    
        // If a port is specified explicitly, use it as is
        if (request.port)
          headers.Host += ':' + request.port
      }
      if (!request.hostname && !request.host)
        request.hostname = headers.Host || headers.host
    }
    
    RequestSigner.prototype.matchHost = function(host) {
      var match = (host || '').match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com$/)
      var hostParts = (match || []).slice(1, 3)
    
      // ES's hostParts are sometimes the other way round, if the value that is expected
      // to be region equals ‘es’ switch them back
      // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com
      if (hostParts[1] === 'es')
        hostParts = hostParts.reverse()
    
      return hostParts
    }
    
    // http://docs.aws.amazon.com/general/latest/gr/rande.html
    RequestSigner.prototype.isSingleRegion = function() {
      // Special case for S3 and SimpleDB in us-east-1
      if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true
    
      return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']
        .indexOf(this.service) >= 0
    }
    
    RequestSigner.prototype.createHost = function() {
      var region = this.isSingleRegion() ? '' :
            (this.service === 's3' && this.region !== 'us-east-1' ? '-' : '.') + this.region,
          service = this.service === 'ses' ? 'email' : this.service
      return service + region + '.amazonaws.com'
    }
    
    RequestSigner.prototype.prepareRequest = function() {
      this.parsePath()
    
      var request = this.request, headers = request.headers, query
    
      if (request.signQuery) {
    
        this.parsedPath.query = query = this.parsedPath.query || {}
    
        if (this.credentials.sessionToken)
          query['X-Amz-Security-Token'] = this.credentials.sessionToken
    
        if (this.service === 's3' && !query['X-Amz-Expires'])
          query['X-Amz-Expires'] = 86400
    
        if (query['X-Amz-Date'])
          this.datetime = query['X-Amz-Date']
        else
          query['X-Amz-Date'] = this.getDateTime()
    
        query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'
        query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()
        query['X-Amz-SignedHeaders'] = this.signedHeaders()
    
      } else {
    
        if (!request.doNotModifyHeaders) {
          if (request.body && !headers['Content-Type'] && !headers['content-type'])
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'
    
          if (request.body && !headers['Content-Length'] && !headers['content-length'])
            headers['Content-Length'] = Buffer.byteLength(request.body)
    
          if (this.credentials.sessionToken)
            headers['X-Amz-Security-Token'] = this.credentials.sessionToken
    
          if (this.service === 's3')
            headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')
    
          if (headers['X-Amz-Date'])
            this.datetime = headers['X-Amz-Date']
          else
            headers['X-Amz-Date'] = this.getDateTime()
        }
    
        delete headers.Authorization
        delete headers.authorization
      }
    }
    
    RequestSigner.prototype.sign = function() {
      if (!this.parsedPath) this.prepareRequest()
    
      if (this.request.signQuery) {
        this.parsedPath.query['X-Amz-Signature'] = this.signature()
      } else {
        this.request.headers.Authorization = this.authHeader()
      }
    
      this.request.path = this.formatPath()
    
      return this.request
    }
    
    RequestSigner.prototype.getDateTime = function() {
      if (!this.datetime) {
        var headers = this.request.headers,
          date = new Date(headers.Date || headers.date || new Date)
    
        this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '')
      }
      return this.datetime
    }
    
    RequestSigner.prototype.getDate = function() {
      return this.getDateTime().substr(0, 8)
    }
    
    RequestSigner.prototype.authHeader = function() {
      return [
        'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
        'SignedHeaders=' + this.signedHeaders(),
        'Signature=' + this.signature(),
      ].join(', ')
    }
    
    RequestSigner.prototype.signature = function() {
      var date = this.getDate(),
          cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
          kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)
      if (!kCredentials) {
        kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)
        kRegion = hmac(kDate, this.region)
        kService = hmac(kRegion, this.service)
        kCredentials = hmac(kService, 'aws4_request')
        credentialsCache.set(cacheKey, kCredentials)
      }
      return hmac(kCredentials, this.stringToSign(), 'hex')
    }
    
    RequestSigner.prototype.stringToSign = function() {
      return [
        'AWS4-HMAC-SHA256',
        this.getDateTime(),
        this.credentialString(),
        hash(this.canonicalString(), 'hex'),
      ].join('\n')
    }
    
    RequestSigner.prototype.canonicalString = function() {
      if (!this.parsedPath) this.prepareRequest()
    
      var pathStr = this.parsedPath.path,
          query = this.parsedPath.query,
          queryStr = '',
          normalizePath = this.service !== 's3',
          decodePath = this.service === 's3' || this.request.doNotEncodePath,
          decodeSlashesInPath = this.service === 's3',
          firstValOnly = this.service === 's3',
          bodyHash = this.service === 's3' && this.request.signQuery ?
            'UNSIGNED-PAYLOAD' : hash(this.request.body || '', 'hex')
    
      if (query) {
        queryStr = encodeRfc3986(querystring.stringify(Object.keys(query).sort().reduce(function(obj, key) {
          if (!key) return obj
          obj[key] = !Array.isArray(query[key]) ? query[key] :
            (firstValOnly ? query[key][0] : query[key].slice().sort())
          return obj
        }, {})))
      }
      if (pathStr !== '/') {
        if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/')
        pathStr = pathStr.split('/').reduce(function(path, piece) {
          if (normalizePath && piece === '..') {
            path.pop()
          } else if (!normalizePath || piece !== '.') {
            if (decodePath) piece = querystring.unescape(piece)
            path.push(encodeRfc3986(querystring.escape(piece)))
          }
          return path
        }, []).join('/')
        if (pathStr[0] !== '/') pathStr = '/' + pathStr
        if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')
      }
    
      return [
        this.request.method || 'GET',
        pathStr,
        queryStr,
        this.canonicalHeaders() + '\n',
        this.signedHeaders(),
        bodyHash,
      ].join('\n')
    }
    
    RequestSigner.prototype.canonicalHeaders = function() {
      var headers = this.request.headers
      function trimAll(header) {
        return header.toString().trim().replace(/\s+/g, ' ')
      }
      return Object.keys(headers)
        .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })
        .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })
        .join('\n')
    }
    
    RequestSigner.prototype.signedHeaders = function() {
      return Object.keys(this.request.headers)
        .map(function(key) { return key.toLowerCase() })
        .sort()
        .join(';')
    }
    
    RequestSigner.prototype.credentialString = function() {
      return [
        this.getDate(),
        this.region,
        this.service,
        'aws4_request',
      ].join('/')
    }
    
    RequestSigner.prototype.defaultCredentials = function() {
      var env = process.env
      return {
        accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
        sessionToken: env.AWS_SESSION_TOKEN,
      }
    }
    
    RequestSigner.prototype.parsePath = function() {
      var path = this.request.path || '/',
          queryIx = path.indexOf('?'),
          query = null
    
      if (queryIx >= 0) {
        query = querystring.parse(path.slice(queryIx + 1))
        path = path.slice(0, queryIx)
      }
    
      // S3 doesn't always encode characters > 127 correctly and
      // all services don't encode characters > 255 correctly
      // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
      if (/[^0-9A-Za-z!'()*\-._~%/]/.test(path)) {
        path = path.split('/').map(function(piece) {
          return querystring.escape(querystring.unescape(piece))
        }).join('/')
      }
    
      this.parsedPath = {
        path: path,
        query: query,
      }
    }
    
    RequestSigner.prototype.formatPath = function() {
      var path = this.parsedPath.path,
          query = this.parsedPath.query
    
      if (!query) return path
    
      // Services don't support empty query string keys
      if (query[''] != null) delete query['']
    
      return path + '?' + encodeRfc3986(querystring.stringify(query))
    }
    
    aws4.RequestSigner = RequestSigner
    
    aws4.sign = function(request, credentials) {
      return new RequestSigner(request, credentials).sign()
    }
    
  provide("aws4", module.exports);
}(global));

// pakmanager:bl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var DuplexStream = require('readable-stream/duplex')
      , util         = require('util')
    
    
    function BufferList (callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback)
    
      this._bufs  = []
      this.length = 0
    
      if (typeof callback == 'function') {
        this._callback = callback
    
        var piper = function piper (err) {
          if (this._callback) {
            this._callback(err)
            this._callback = null
          }
        }.bind(this)
    
        this.on('pipe', function onPipe (src) {
          src.on('error', piper)
        })
        this.on('unpipe', function onUnpipe (src) {
          src.removeListener('error', piper)
        })
      } else {
        this.append(callback)
      }
    
      DuplexStream.call(this)
    }
    
    
    util.inherits(BufferList, DuplexStream)
    
    
    BufferList.prototype._offset = function _offset (offset) {
      var tot = 0, i = 0, _t
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length
        if (offset < _t)
          return [ i, offset - tot ]
        tot = _t
      }
    }
    
    
    BufferList.prototype.append = function append (buf) {
      var i = 0
        , newBuf
    
      if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i])
      } else if (buf instanceof BufferList) {
        // unwrap argument into individual BufferLists
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i])
      } else if (buf != null) {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf == 'number')
          buf = buf.toString()
    
        newBuf = Buffer.isBuffer(buf) ? buf : new Buffer(buf)
        this._bufs.push(newBuf)
        this.length += newBuf.length
      }
    
      return this
    }
    
    
    BufferList.prototype._write = function _write (buf, encoding, callback) {
      this.append(buf)
    
      if (typeof callback == 'function')
        callback()
    }
    
    
    BufferList.prototype._read = function _read (size) {
      if (!this.length)
        return this.push(null)
    
      size = Math.min(size, this.length)
      this.push(this.slice(0, size))
      this.consume(size)
    }
    
    
    BufferList.prototype.end = function end (chunk) {
      DuplexStream.prototype.end.call(this, chunk)
    
      if (this._callback) {
        this._callback(null, this.slice())
        this._callback = null
      }
    }
    
    
    BufferList.prototype.get = function get (index) {
      return this.slice(index, index + 1)[0]
    }
    
    
    BufferList.prototype.slice = function slice (start, end) {
      return this.copy(null, 0, start, end)
    }
    
    
    BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != 'number' || srcStart < 0)
        srcStart = 0
      if (typeof srcEnd != 'number' || srcEnd > this.length)
        srcEnd = this.length
      if (srcStart >= this.length)
        return dst || new Buffer(0)
      if (srcEnd <= 0)
        return dst || new Buffer(0)
    
      var copy   = !!dst
        , off    = this._offset(srcStart)
        , len    = srcEnd - srcStart
        , bytes  = len
        , bufoff = (copy && dstStart) || 0
        , start  = off[1]
        , l
        , i
    
      // copy/slice everything
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy) // slice, just return a full concat
          return Buffer.concat(this._bufs)
    
        // copy, need to copy individual buffers
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff)
          bufoff += this._bufs[i].length
        }
    
        return dst
      }
    
      // easy, cheap case where it's a subset of one of the buffers
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy
          ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
          : this._bufs[off[0]].slice(start, start + bytes)
      }
    
      if (!copy) // a slice, we need something to copy in to
        dst = new Buffer(len)
    
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start
    
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start)
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes)
          break
        }
    
        bufoff += l
        bytes -= l
    
        if (start)
          start = 0
      }
    
      return dst
    }
    
    BufferList.prototype.toString = function toString (encoding, start, end) {
      return this.slice(start, end).toString(encoding)
    }
    
    BufferList.prototype.consume = function consume (bytes) {
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length
          this.length -= this._bufs[0].length
          this._bufs.shift()
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes)
          this.length -= bytes
          break
        }
      }
      return this
    }
    
    
    BufferList.prototype.duplicate = function duplicate () {
      var i = 0
        , copy = new BufferList()
    
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i])
    
      return copy
    }
    
    
    BufferList.prototype.destroy = function destroy () {
      this._bufs.length = 0
      this.length = 0
      this.push(null)
    }
    
    
    ;(function () {
      var methods = {
          'readDoubleBE' : 8
        , 'readDoubleLE' : 8
        , 'readFloatBE'  : 4
        , 'readFloatLE'  : 4
        , 'readInt32BE'  : 4
        , 'readInt32LE'  : 4
        , 'readUInt32BE' : 4
        , 'readUInt32LE' : 4
        , 'readInt16BE'  : 2
        , 'readInt16LE'  : 2
        , 'readUInt16BE' : 2
        , 'readUInt16LE' : 2
        , 'readInt8'     : 1
        , 'readUInt8'    : 1
      }
    
      for (var m in methods) {
        (function (m) {
          BufferList.prototype[m] = function (offset) {
            return this.slice(offset, offset + methods[m])[m](0)
          }
        }(m))
      }
    }())
    
    
    module.exports = BufferList
    
  provide("bl", module.exports);
}(global));

// pakmanager:caseless
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  function Caseless (dict) {
      this.dict = dict || {}
    }
    Caseless.prototype.set = function (name, value, clobber) {
      if (typeof name === 'object') {
        for (var i in name) {
          this.set(i, name[i], value)
        }
      } else {
        if (typeof clobber === 'undefined') clobber = true
        var has = this.has(name)
    
        if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
        else this.dict[has || name] = value
        return has
      }
    }
    Caseless.prototype.has = function (name) {
      var keys = Object.keys(this.dict)
        , name = name.toLowerCase()
        ;
      for (var i=0;i<keys.length;i++) {
        if (keys[i].toLowerCase() === name) return keys[i]
      }
      return false
    }
    Caseless.prototype.get = function (name) {
      name = name.toLowerCase()
      var result, _key
      var headers = this.dict
      Object.keys(headers).forEach(function (key) {
        _key = key.toLowerCase()
        if (name === _key) result = headers[key]
      })
      return result
    }
    Caseless.prototype.swap = function (name) {
      var has = this.has(name)
      if (!has) throw new Error('There is no header than matches "'+name+'"')
      this.dict[name] = this.dict[has]
      delete this.dict[has]
    }
    Caseless.prototype.del = function (name) {
      var has = this.has(name)
      return delete this.dict[has || name]
    }
    
    module.exports = function (dict) {return new Caseless(dict)}
    module.exports.httpify = function (resp, headers) {
      var c = new Caseless(headers)
      resp.setHeader = function (key, value, clobber) {
        if (typeof value === 'undefined') return
        return c.set(key, value, clobber)
      }
      resp.hasHeader = function (key) {
        return c.has(key)
      }
      resp.getHeader = function (key) {
        return c.get(key)
      }
      resp.removeHeader = function (key) {
        return c.del(key)
      }
      resp.headers = c.dict
      return c
    }
    
  provide("caseless", module.exports);
}(global));

// pakmanager:extend
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    
    var isArray = function isArray(arr) {
    	if (typeof Array.isArray === 'function') {
    		return Array.isArray(arr);
    	}
    
    	return toStr.call(arr) === '[object Array]';
    };
    
    var isPlainObject = function isPlainObject(obj) {
    	if (!obj || toStr.call(obj) !== '[object Object]') {
    		return false;
    	}
    
    	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    	// Not own constructor property must be Object
    	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    		return false;
    	}
    
    	// Own properties are enumerated firstly, so to speed up,
    	// if last one is own, then all properties are own.
    	var key;
    	for (key in obj) {/**/}
    
    	return typeof key === 'undefined' || hasOwn.call(obj, key);
    };
    
    module.exports = function extend() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[0],
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if (typeof target === 'boolean') {
    		deep = target;
    		target = arguments[1] || {};
    		// skip the boolean and the target
    		i = 2;
    	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
    		target = {};
    	}
    
    	for (; i < length; ++i) {
    		options = arguments[i];
    		// Only deal with non-null/undefined values
    		if (options != null) {
    			// Extend the base object
    			for (name in options) {
    				src = target[name];
    				copy = options[name];
    
    				// Prevent never-ending loop
    				if (target !== copy) {
    					// Recurse if we're merging plain objects or arrays
    					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
    						if (copyIsArray) {
    							copyIsArray = false;
    							clone = src && isArray(src) ? src : [];
    						} else {
    							clone = src && isPlainObject(src) ? src : {};
    						}
    
    						// Never move original objects, clone them
    						target[name] = extend(deep, clone, copy);
    
    					// Don't bring in undefined values
    					} else if (typeof copy !== 'undefined') {
    						target[name] = copy;
    					}
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    
  provide("extend", module.exports);
}(global));

// pakmanager:forever-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = ForeverAgent
    ForeverAgent.SSL = ForeverAgentSSL
    
    var util = require('util')
      , Agent = require('http').Agent
      , net = require('net')
      , tls = require('tls')
      , AgentSSL = require('https').Agent
      
    function getConnectionName(host, port) {  
      var name = ''
      if (typeof host === 'string') {
        name = host + ':' + port
      } else {
        // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
        name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
      }
      return name
    }    
    
    function ForeverAgent(options) {
      var self = this
      self.options = options || {}
      self.requests = {}
      self.sockets = {}
      self.freeSockets = {}
      self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
      self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
      self.on('free', function(socket, host, port) {
        var name = getConnectionName(host, port)
    
        if (self.requests[name] && self.requests[name].length) {
          self.requests[name].shift().onSocket(socket)
        } else if (self.sockets[name].length < self.minSockets) {
          if (!self.freeSockets[name]) self.freeSockets[name] = []
          self.freeSockets[name].push(socket)
          
          // if an error happens while we don't use the socket anyway, meh, throw the socket away
          var onIdleError = function() {
            socket.destroy()
          }
          socket._onIdleError = onIdleError
          socket.on('error', onIdleError)
        } else {
          // If there are no pending requests just destroy the
          // socket and it will get removed from the pool. This
          // gets us out of timeout issues and allows us to
          // default to Connection:keep-alive.
          socket.destroy()
        }
      })
    
    }
    util.inherits(ForeverAgent, Agent)
    
    ForeverAgent.defaultMinSockets = 5
    
    
    ForeverAgent.prototype.createConnection = net.createConnection
    ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
    ForeverAgent.prototype.addRequest = function(req, host, port) {
      var name = getConnectionName(host, port)
      
      if (typeof host !== 'string') {
        var options = host
        port = options.port
        host = options.host
      }
    
      if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
        var idleSocket = this.freeSockets[name].pop()
        idleSocket.removeListener('error', idleSocket._onIdleError)
        delete idleSocket._onIdleError
        req._reusedSocket = true
        req.onSocket(idleSocket)
      } else {
        this.addRequestNoreuse(req, host, port)
      }
    }
    
    ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
      if (this.sockets[name]) {
        var index = this.sockets[name].indexOf(s)
        if (index !== -1) {
          this.sockets[name].splice(index, 1)
        }
      } else if (this.sockets[name] && this.sockets[name].length === 0) {
        // don't leak
        delete this.sockets[name]
        delete this.requests[name]
      }
      
      if (this.freeSockets[name]) {
        var index = this.freeSockets[name].indexOf(s)
        if (index !== -1) {
          this.freeSockets[name].splice(index, 1)
          if (this.freeSockets[name].length === 0) {
            delete this.freeSockets[name]
          }
        }
      }
    
      if (this.requests[name] && this.requests[name].length) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createSocket(name, host, port).emit('free')
      }
    }
    
    function ForeverAgentSSL (options) {
      ForeverAgent.call(this, options)
    }
    util.inherits(ForeverAgentSSL, ForeverAgent)
    
    ForeverAgentSSL.prototype.createConnection = createConnectionSSL
    ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest
    
    function createConnectionSSL (port, host, options) {
      if (typeof port === 'object') {
        options = port;
      } else if (typeof host === 'object') {
        options = host;
      } else if (typeof options === 'object') {
        options = options;
      } else {
        options = {};
      }
    
      if (typeof port === 'number') {
        options.port = port;
      }
    
      if (typeof host === 'string') {
        options.host = host;
      }
    
      return tls.connect(options);
    }
    
  provide("forever-agent", module.exports);
}(global));

// pakmanager:is-typedarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports      = isTypedArray
    isTypedArray.strict = isStrictTypedArray
    isTypedArray.loose  = isLooseTypedArray
    
    var toString = Object.prototype.toString
    var names = {
        '[object Int8Array]': true
      , '[object Int16Array]': true
      , '[object Int32Array]': true
      , '[object Uint8Array]': true
      , '[object Uint8ClampedArray]': true
      , '[object Uint16Array]': true
      , '[object Uint32Array]': true
      , '[object Float32Array]': true
      , '[object Float64Array]': true
    }
    
    function isTypedArray(arr) {
      return (
           isStrictTypedArray(arr)
        || isLooseTypedArray(arr)
      )
    }
    
    function isStrictTypedArray(arr) {
      return (
           arr instanceof Int8Array
        || arr instanceof Int16Array
        || arr instanceof Int32Array
        || arr instanceof Uint8Array
        || arr instanceof Uint8ClampedArray
        || arr instanceof Uint16Array
        || arr instanceof Uint32Array
        || arr instanceof Float32Array
        || arr instanceof Float64Array
      )
    }
    
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)]
    }
    
  provide("is-typedarray", module.exports);
}(global));

// pakmanager:isstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stream = require('stream')
    
    
    function isStream (obj) {
      return obj instanceof stream.Stream
    }
    
    
    function isReadable (obj) {
      return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
    }
    
    
    function isWritable (obj) {
      return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
    }
    
    
    function isDuplex (obj) {
      return isReadable(obj) && isWritable(obj)
    }
    
    
    module.exports            = isStream
    module.exports.isReadable = isReadable
    module.exports.isWritable = isWritable
    module.exports.isDuplex   = isDuplex
    
  provide("isstream", module.exports);
}(global));

// pakmanager:json-stringify-safe
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = module.exports = stringify
    exports.getSerialize = serializer
    
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
    }
    
    function serializer(replacer, cycleReplacer) {
      var stack = [], keys = []
    
      if (cycleReplacer == null) cycleReplacer = function(key, value) {
        if (stack[0] === value) return "[Circular ~]"
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
      }
    
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this)
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
        }
        else stack.push(value)
    
        return replacer == null ? value : replacer.call(this, key, value)
      }
    }
    
  provide("json-stringify-safe", module.exports);
}(global));

// pakmanager:node-uuid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     uuid.js
    //
    //     Copyright (c) 2010-2012 Robert Kieffer
    //     MIT License - http://opensource.org/licenses/mit-license.php
    
    /*global window, require, define */
    (function(_window) {
      'use strict';
    
      // Unique ID creation requires a high quality random # generator.  We feature
      // detect to determine the best RNG source, normalizing to a function that
      // returns 128-bits of randomness, since that's what's usually required
      var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;
    
      function setupBrowser() {
        // Allow for MSIE11 msCrypto
        var _crypto = _window.crypto || _window.msCrypto;
    
        if (!_rng && _crypto && _crypto.getRandomValues) {
          // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
          //
          // Moderately fast, high quality
          try {
            var _rnds8 = new Uint8Array(16);
            _whatwgRNG = _rng = function whatwgRNG() {
              _crypto.getRandomValues(_rnds8);
              return _rnds8;
            };
            _rng();
          } catch(e) {}
        }
    
        if (!_rng) {
          // Math.random()-based (RNG)
          //
          // If all else fails, use Math.random().  It's fast, but is of unspecified
          // quality.
          var  _rnds = new Array(16);
          _mathRNG = _rng = function() {
            for (var i = 0, r; i < 16; i++) {
              if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
              _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
            }
    
            return _rnds;
          };
          if ('undefined' !== typeof console && console.warn) {
            console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
          }
        }
      }
    
      function setupNode() {
        // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
        //
        // Moderately fast, high quality
        if ('function' === typeof require) {
          try {
            var _rb = require('crypto').randomBytes;
            _nodeRNG = _rng = _rb && function() {return _rb(16);};
            _rng();
          } catch(e) {}
        }
      }
    
      if (_window) {
        setupBrowser();
      } else {
        setupNode();
      }
    
      // Buffer class to use
      var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;
    
      // Maps for number <-> hex string conversion
      var _byteToHex = [];
      var _hexToByte = {};
      for (var i = 0; i < 256; i++) {
        _byteToHex[i] = (i + 0x100).toString(16).substr(1);
        _hexToByte[_byteToHex[i]] = i;
      }
    
      // **`parse()` - Parse a UUID into it's component bytes**
      function parse(s, buf, offset) {
        var i = (buf && offset) || 0, ii = 0;
    
        buf = buf || [];
        s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
          if (ii < 16) { // Don't overflow!
            buf[i + ii++] = _hexToByte[oct];
          }
        });
    
        // Zero out remaining bytes if string was short
        while (ii < 16) {
          buf[i + ii++] = 0;
        }
    
        return buf;
      }
    
      // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
      function unparse(buf, offset) {
        var i = offset || 0, bth = _byteToHex;
        return  bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] + '-' +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]] +
                bth[buf[i++]] + bth[buf[i++]];
      }
    
      // **`v1()` - Generate time-based UUID**
      //
      // Inspired by https://github.com/LiosK/UUID.js
      // and http://docs.python.org/library/uuid.html
    
      // random #'s we need to init node and clockseq
      var _seedBytes = _rng();
    
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      var _nodeId = [
        _seedBytes[0] | 0x01,
        _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
      ];
    
      // Per 4.2.2, randomize (14 bit) clockseq
      var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    
      // Previous uuid creation time
      var _lastMSecs = 0, _lastNSecs = 0;
    
      // See https://github.com/broofa/node-uuid for API details
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || [];
    
        options = options || {};
    
        var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;
    
        // UUID timestamps are 100 nano-second units since the Gregorian epoch,
        // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
        // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
        // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
        var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();
    
        // Per 4.2.1.2, use count of uuid's generated during the current clock
        // cycle to simulate higher resolution clock
        var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;
    
        // Time since last uuid creation (in msecs)
        var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
    
        // Per 4.2.1.2, Bump clockseq on clock regression
        if (dt < 0 && options.clockseq == null) {
          clockseq = clockseq + 1 & 0x3fff;
        }
    
        // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
        // time interval
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
          nsecs = 0;
        }
    
        // Per 4.2.1.2 Throw error if too many uuids are requested
        if (nsecs >= 10000) {
          throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
        }
    
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
    
        // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
        msecs += 12219292800000;
    
        // `time_low`
        var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = tl >>> 24 & 0xff;
        b[i++] = tl >>> 16 & 0xff;
        b[i++] = tl >>> 8 & 0xff;
        b[i++] = tl & 0xff;
    
        // `time_mid`
        var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
        b[i++] = tmh >>> 8 & 0xff;
        b[i++] = tmh & 0xff;
    
        // `time_high_and_version`
        b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
        b[i++] = tmh >>> 16 & 0xff;
    
        // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
        b[i++] = clockseq >>> 8 | 0x80;
    
        // `clock_seq_low`
        b[i++] = clockseq & 0xff;
    
        // `node`
        var node = options.node || _nodeId;
        for (var n = 0; n < 6; n++) {
          b[i + n] = node[n];
        }
    
        return buf ? buf : unparse(b);
      }
    
      // **`v4()` - Generate random UUID**
    
      // See https://github.com/broofa/node-uuid for API details
      function v4(options, buf, offset) {
        // Deprecated - 'format' argument, as supported in v1.2
        var i = buf && offset || 0;
    
        if (typeof(options) === 'string') {
          buf = (options === 'binary') ? new BufferClass(16) : null;
          options = null;
        }
        options = options || {};
    
        var rnds = options.random || (options.rng || _rng)();
    
        // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        rnds[6] = (rnds[6] & 0x0f) | 0x40;
        rnds[8] = (rnds[8] & 0x3f) | 0x80;
    
        // Copy bytes to buffer, if provided
        if (buf) {
          for (var ii = 0; ii < 16; ii++) {
            buf[i + ii] = rnds[ii];
          }
        }
    
        return buf || unparse(rnds);
      }
    
      // Export public API
      var uuid = v4;
      uuid.v1 = v1;
      uuid.v4 = v4;
      uuid.parse = parse;
      uuid.unparse = unparse;
      uuid.BufferClass = BufferClass;
      uuid._rng = _rng;
      uuid._mathRNG = _mathRNG;
      uuid._nodeRNG = _nodeRNG;
      uuid._whatwgRNG = _whatwgRNG;
    
      if (('undefined' !== typeof module) && module.exports) {
        // Publish as node.js module
        module.exports = uuid;
      } else if (typeof define === 'function' && define.amd) {
        // Publish as AMD module
        define(function() {return uuid;});
    
    
      } else {
        // Publish as global (in browsers)
        _previousRoot = _window.uuid;
    
        // **`noConflict()` - (browser only) to reset global 'uuid' var**
        uuid.noConflict = function() {
          _window.uuid = _previousRoot;
          return uuid;
        };
    
        _window.uuid = uuid;
      }
    })('undefined' !== typeof window ? window : null);
    
  provide("node-uuid", module.exports);
}(global));

// pakmanager:oauth-sign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
      , qs = require('querystring')
      ;
    
    function sha1 (key, body) {
      return crypto.createHmac('sha1', key).update(body).digest('base64')
    }
    
    function rsa (key, body) {
      return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
    }
    
    function rfc3986 (str) {
      return encodeURIComponent(str)
        .replace(/!/g,'%21')
        .replace(/\*/g,'%2A')
        .replace(/\(/g,'%28')
        .replace(/\)/g,'%29')
        .replace(/'/g,'%27')
        ;
    }
    
    // Maps object to bi-dimensional array
    // Converts { foo: 'A', bar: [ 'b', 'B' ]} to
    // [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
    function map (obj) {
      var key, val, arr = []
      for (key in obj) {
        val = obj[key]
        if (Array.isArray(val))
          for (var i = 0; i < val.length; i++)
            arr.push([key, val[i]])
        else if (typeof val === "object")
          for (var prop in val)
            arr.push([key + '[' + prop + ']', val[prop]]);
        else
          arr.push([key, val])
      }
      return arr
    }
    
    // Compare function for sort
    function compare (a, b) {
      return a > b ? 1 : a < b ? -1 : 0
    }
    
    function generateBase (httpMethod, base_uri, params) {
      // adapted from https://dev.twitter.com/docs/auth/oauth and 
      // https://dev.twitter.com/docs/auth/creating-signature
    
      // Parameter normalization
      // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
      var normalized = map(params)
      // 1.  First, the name and value of each parameter are encoded
      .map(function (p) {
        return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
      })
      // 2.  The parameters are sorted by name, using ascending byte value
      //     ordering.  If two or more parameters share the same name, they
      //     are sorted by their value.
      .sort(function (a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1])
      })
      // 3.  The name of each parameter is concatenated to its corresponding
      //     value using an "=" character (ASCII code 61) as a separator, even
      //     if the value is empty.
      .map(function (p) { return p.join('=') })
       // 4.  The sorted name/value pairs are concatenated together into a
       //     single string by using an "&" character (ASCII code 38) as
       //     separator.
      .join('&')
    
      var base = [
        rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
        rfc3986(base_uri),
        rfc3986(normalized)
      ].join('&')
    
      return base
    }
    
    function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return sha1(key, base)
    }
    
    function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
      var base = generateBase(httpMethod, base_uri, params)
      var key = private_key || ''
    
      return rsa(key, base)
    }
    
    function plaintext (consumer_secret, token_secret) {
      var key = [
        consumer_secret || '',
        token_secret || ''
      ].map(rfc3986).join('&')
    
      return key
    }
    
    function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
      var method
      var skipArgs = 1
    
      switch (signMethod) {
        case 'RSA-SHA1':
          method = rsasign
          break
        case 'HMAC-SHA1':
          method = hmacsign
          break
        case 'PLAINTEXT':
          method = plaintext
          skipArgs = 4
          break
        default:
         throw new Error("Signature method not supported: " + signMethod)
      }
    
      return method.apply(null, [].slice.call(arguments, skipArgs))
    }
    
    exports.hmacsign = hmacsign
    exports.rsasign = rsasign
    exports.plaintext = plaintext
    exports.sign = sign
    exports.rfc3986 = rfc3986
    exports.generateBase = generateBase
    
    
  provide("oauth-sign", module.exports);
}(global));

// pakmanager:stringstream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    var Stream = require('stream')
    var StringDecoder = require('string_decoder').StringDecoder
    
    module.exports = StringStream
    module.exports.AlignedStringDecoder = AlignedStringDecoder
    
    function StringStream(from, to) {
      if (!(this instanceof StringStream)) return new StringStream(from, to)
    
      Stream.call(this)
    
      if (from == null) from = 'utf8'
    
      this.readable = this.writable = true
      this.paused = false
      this.toEncoding = (to == null ? from : to)
      this.fromEncoding = (to == null ? '' : from)
      this.decoder = new AlignedStringDecoder(this.toEncoding)
    }
    util.inherits(StringStream, Stream)
    
    StringStream.prototype.write = function(data) {
      if (!this.writable) {
        var err = new Error('stream not writable')
        err.code = 'EPIPE'
        this.emit('error', err)
        return false
      }
      if (this.fromEncoding) {
        if (Buffer.isBuffer(data)) data = data.toString()
        data = new Buffer(data, this.fromEncoding)
      }
      var string = this.decoder.write(data)
      if (string.length) this.emit('data', string)
      return !this.paused
    }
    
    StringStream.prototype.flush = function() {
      if (this.decoder.flush) {
        var string = this.decoder.flush()
        if (string.length) this.emit('data', string)
      }
    }
    
    StringStream.prototype.end = function() {
      if (!this.writable && !this.readable) return
      this.flush()
      this.emit('end')
      this.writable = this.readable = false
      this.destroy()
    }
    
    StringStream.prototype.destroy = function() {
      this.decoder = null
      this.writable = this.readable = false
      this.emit('close')
    }
    
    StringStream.prototype.pause = function() {
      this.paused = true
    }
    
    StringStream.prototype.resume = function () {
      if (this.paused) this.emit('drain')
      this.paused = false
    }
    
    function AlignedStringDecoder(encoding) {
      StringDecoder.call(this, encoding)
    
      switch (this.encoding) {
        case 'base64':
          this.write = alignedWrite
          this.alignedBuffer = new Buffer(3)
          this.alignedBytes = 0
          break
      }
    }
    util.inherits(AlignedStringDecoder, StringDecoder)
    
    AlignedStringDecoder.prototype.flush = function() {
      if (!this.alignedBuffer || !this.alignedBytes) return ''
      var leftover = this.alignedBuffer.toString(this.encoding, 0, this.alignedBytes)
      this.alignedBytes = 0
      return leftover
    }
    
    function alignedWrite(buffer) {
      var rem = (this.alignedBytes + buffer.length) % this.alignedBuffer.length
      if (!rem && !this.alignedBytes) return buffer.toString(this.encoding)
    
      var returnBuffer = new Buffer(this.alignedBytes + buffer.length - rem)
    
      this.alignedBuffer.copy(returnBuffer, 0, 0, this.alignedBytes)
      buffer.copy(returnBuffer, this.alignedBytes, 0, buffer.length - rem)
    
      buffer.copy(this.alignedBuffer, 0, buffer.length - rem, buffer.length)
      this.alignedBytes = rem
    
      return returnBuffer.toString(this.encoding)
    }
    
  provide("stringstream", module.exports);
}(global));

// pakmanager:tunnel-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var net = require('net')
      , tls = require('tls')
      , http = require('http')
      , https = require('https')
      , events = require('events')
      , assert = require('assert')
      , util = require('util')
      ;
    
    exports.httpOverHttp = httpOverHttp
    exports.httpsOverHttp = httpsOverHttp
    exports.httpOverHttps = httpOverHttps
    exports.httpsOverHttps = httpsOverHttps
    
    
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      return agent
    }
    
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options)
      agent.request = http.request
      agent.createSocket = createSecureSocket
      agent.defaultPort = 443
      return agent
    }
    
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      return agent
    }
    
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options)
      agent.request = https.request
      agent.createSocket = createSecureSocket
      agent.defaultPort = 443
      return agent
    }
    
    
    function TunnelingAgent(options) {
      var self = this
      self.options = options || {}
      self.proxyOptions = self.options.proxy || {}
      self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
      self.requests = []
      self.sockets = []
    
      self.on('free', function onFree(socket, host, port) {
        for (var i = 0, len = self.requests.length; i < len; ++i) {
          var pending = self.requests[i]
          if (pending.host === host && pending.port === port) {
            // Detect the request to connect same origin server,
            // reuse the connection.
            self.requests.splice(i, 1)
            pending.request.onSocket(socket)
            return
          }
        }
        socket.destroy()
        self.removeSocket(socket)
      })
    }
    util.inherits(TunnelingAgent, events.EventEmitter)
    
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self = this
    
       // Legacy API: addRequest(req, host, port, path)
      if (typeof options === 'string') {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
    
      if (self.sockets.length >= this.maxSockets) {
        // We are over limit so we'll add it to the queue.
        self.requests.push({host: options.host, port: options.port, request: req})
        return
      }
    
      // If we are under maxSockets create a new one.
      self.createConnection({host: options.host, port: options.port, request: req})
    }
    
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self = this
    
      self.createSocket(pending, function(socket) {
        socket.on('free', onFree)
        socket.on('close', onCloseOrRemove)
        socket.on('agentRemove', onCloseOrRemove)
        pending.request.onSocket(socket)
    
        function onFree() {
          self.emit('free', socket, pending.host, pending.port)
        }
    
        function onCloseOrRemove(err) {
          self.removeSocket(socket)
          socket.removeListener('free', onFree)
          socket.removeListener('close', onCloseOrRemove)
          socket.removeListener('agentRemove', onCloseOrRemove)
        }
      })
    }
    
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self = this
      var placeholder = {}
      self.sockets.push(placeholder)
    
      var connectOptions = mergeOptions({}, self.proxyOptions, 
        { method: 'CONNECT'
        , path: options.host + ':' + options.port
        , agent: false
        }
      )
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {}
        connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
            new Buffer(connectOptions.proxyAuth).toString('base64')
      }
    
      debug('making CONNECT request')
      var connectReq = self.request(connectOptions)
      connectReq.useChunkedEncodingByDefault = false // for v0.6
      connectReq.once('response', onResponse) // for v0.6
      connectReq.once('upgrade', onUpgrade)   // for v0.6
      connectReq.once('connect', onConnect)   // for v0.7 or later
      connectReq.once('error', onError)
      connectReq.end()
    
      function onResponse(res) {
        // Very hacky. This is necessary to avoid http-parser leaks.
        res.upgrade = true
      }
    
      function onUpgrade(res, socket, head) {
        // Hacky.
        process.nextTick(function() {
          onConnect(res, socket, head)
        })
      }
    
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners()
        socket.removeAllListeners()
    
        if (res.statusCode === 200) {
          assert.equal(head.length, 0)
          debug('tunneling connection has established')
          self.sockets[self.sockets.indexOf(placeholder)] = socket
          cb(socket)
        } else {
          debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
          var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
          error.code = 'ECONNRESET'
          options.request.emit('error', error)
          self.removeSocket(placeholder)
        }
      }
    
      function onError(cause) {
        connectReq.removeAllListeners()
    
        debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
        var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
        error.code = 'ECONNRESET'
        options.request.emit('error', error)
        self.removeSocket(placeholder)
      }
    }
    
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket)
      if (pos === -1) return
      
      this.sockets.splice(pos, 1)
    
      var pending = this.requests.shift()
      if (pending) {
        // If we have pending requests and a socket gets closed a new one
        // needs to be created to take over in the pool for the one that closed.
        this.createConnection(pending)
      }
    }
    
    function createSecureSocket(options, cb) {
      var self = this
      TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
        // 0 is dummy port for v0.6
        var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
          { servername: options.host
          , socket: socket
          }
        ))
        self.sockets[self.sockets.indexOf(socket)] = secureSocket
        cb(secureSocket)
      })
    }
    
    
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i]
        if (typeof overrides === 'object') {
          var keys = Object.keys(overrides)
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j]
            if (overrides[k] !== undefined) {
              target[k] = overrides[k]
            }
          }
        }
      }
      return target
    }
    
    
    var debug
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments)
        if (typeof args[0] === 'string') {
          args[0] = 'TUNNEL: ' + args[0]
        } else {
          args.unshift('TUNNEL:')
        }
        console.error.apply(console, args)
      }
    } else {
      debug = function() {}
    }
    exports.debug = debug // for test
    
  provide("tunnel-agent", module.exports);
}(global));

// pakmanager:debug
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var tty = require('tty');
    var util = require('util');
    
    /**
     * This is the Node.js implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */
    
    exports = module.exports =   require('debug');
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    
    /**
     * Colors.
     */
    
    exports.colors = [6, 2, 3, 4, 5, 1];
    
    /**
     * The file descriptor to write the `debug()` calls to.
     * Set the `DEBUG_FD` env variable to override with another value. i.e.:
     *
     *   $ DEBUG_FD=3 node script.js 3>debug.log
     */
    
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    var stream = 1 === fd ? process.stdout :
                 2 === fd ? process.stderr :
                 createWritableStdioStream(fd);
    
    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */
    
    function useColors() {
      var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();
      if (0 === debugColors.length) {
        return tty.isatty(fd);
      } else {
        return '0' !== debugColors
            && 'no' !== debugColors
            && 'false' !== debugColors
            && 'disabled' !== debugColors;
      }
    }
    
    /**
     * Map %o to `util.inspect()`, since Node doesn't do that out of the box.
     */
    
    var inspect = (4 === util.inspect.length ?
      // node <= 0.8.x
      function (v, colors) {
        return util.inspect(v, void 0, void 0, colors);
      } :
      // node > 0.8.x
      function (v, colors) {
        return util.inspect(v, { colors: colors });
      }
    );
    
    exports.formatters.o = function(v) {
      return inspect(v, this.useColors)
        .replace(/\s*\n\s*/g, ' ');
    };
    
    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */
    
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      var name = this.namespace;
    
      if (useColors) {
        var c = this.color;
    
        args[0] = '  \u001b[3' + c + ';1m' + name + ' '
          + '\u001b[0m'
          + args[0] + '\u001b[3' + c + 'm'
          + ' +' + exports.humanize(this.diff) + '\u001b[0m';
      } else {
        args[0] = new Date().toUTCString()
          + ' ' + name + ' ' + args[0];
      }
      return args;
    }
    
    /**
     * Invokes `console.error()` with the specified arguments.
     */
    
    function log() {
      return stream.write(util.format.apply(this, arguments) + '\n');
    }
    
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    
    function save(namespaces) {
      if (null == namespaces) {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    
    function load() {
      return process.env.DEBUG;
    }
    
    /**
     * Copied from `node/src/node.js`.
     *
     * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
     * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
     */
    
    function createWritableStdioStream (fd) {
      var stream;
      var tty_wrap = process.binding('tty_wrap');
    
      // Note stream._type is used for test-module-load-list.js
    
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          stream = new tty.WriteStream(fd);
          stream._type = 'tty';
    
          // Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        case 'FILE':
          var fs = require('fs');
          stream = new fs.SyncWriteStream(fd, { autoClose: false });
          stream._type = 'fs';
          break;
    
        case 'PIPE':
        case 'TCP':
          var net = require('net');
          stream = new net.Socket({
            fd: fd,
            readable: false,
            writable: true
          });
    
          // FIXME Should probably have an option in net.Socket to create a
          // stream from an existing fd which is writable only. But for now
          // we'll just add this hack and set the `readable` member to false.
          // Test: ./node test/fixtures/echo.js < /etc/passwd
          stream.readable = false;
          stream.read = null;
          stream._type = 'pipe';
    
          // FIXME Hack to have stream not keep the event loop alive.
          // See https://github.com/joyent/node/issues/1726
          if (stream._handle && stream._handle.unref) {
            stream._handle.unref();
          }
          break;
    
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stream file type!');
      }
    
      // For supporting legacy API we put the FD here.
      stream.fd = fd;
    
      stream._isStdio = true;
    
      return stream;
    }
    
    /**
     * Enable namespaces listed in `process.env.DEBUG` initially.
     */
    
    exports.enable(load());
    
  provide("debug", module.exports);
}(global));

// pakmanager:fstream-ignore
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Essentially, this is a fstream.DirReader class, but with a
    // bit of special logic to read the specified sort of ignore files,
    // and a filter that prevents it from picking up anything excluded
    // by those files.
    
    var Minimatch = require("minimatch").Minimatch
    , fstream = require("fstream")
    , DirReader = fstream.DirReader
    , inherits = require("inherits")
    , path = require("path")
    , fs = require("fs")
    
    module.exports = IgnoreReader
    
    inherits(IgnoreReader, DirReader)
    
    function IgnoreReader (props) {
      if (!(this instanceof IgnoreReader)) {
        return new IgnoreReader(props)
      }
    
      // must be a Directory type
      if (typeof props === "string") {
        props = { path: path.resolve(props) }
      }
    
      props.type = "Directory"
      props.Directory = true
    
      if (!props.ignoreFiles) props.ignoreFiles = [".ignore"]
      this.ignoreFiles = props.ignoreFiles
    
      this.ignoreRules = null
    
      // ensure that .ignore files always show up at the top of the list
      // that way, they can be read before proceeding to handle other
      // entries in that same folder
      if (props.sort) {
        this._sort = props.sort === "alpha" ? alphasort : props.sort
        props.sort = null
      }
    
      this.on("entries", function () {
        // if there are any ignore files in the list, then
        // pause and add them.
        // then, filter the list based on our ignoreRules
    
        var hasIg = this.entries.some(this.isIgnoreFile, this)
    
        if (!hasIg) return this.filterEntries()
    
        this.addIgnoreFiles()
      })
    
      // we filter entries before we know what they are.
      // however, directories have to be re-tested against
      // rules with a "/" appended, because "a/b/" will only
      // match if "a/b" is a dir, and not otherwise.
      this.on("_entryStat", function (entry, props) {
        var t = entry.basename
        if (!this.applyIgnores(entry.basename,
                               entry.type === "Directory",
                               entry)) {
          entry.abort()
        }
      }.bind(this))
    
      DirReader.call(this, props)
    }
    
    
    IgnoreReader.prototype.addIgnoreFiles = function () {
      if (this._paused) {
        this.once("resume", this.addIgnoreFiles)
        return
      }
      if (this._ignoreFilesAdded) return
      this._ignoreFilesAdded = true
    
      var newIg = this.entries.filter(this.isIgnoreFile, this)
      , count = newIg.length
      , errState = null
    
      if (!count) return
    
      this.pause()
    
      var then = function (er) {
        if (errState) return
        if (er) return this.emit("error", errState = er)
        if (-- count === 0) {
          this.filterEntries()
          this.resume()
        } else {
          this.addIgnoreFile(newIg[newIg.length - count], then)
        }
      }.bind(this)
    
      this.addIgnoreFile(newIg[0], then)
    }
    
    
    IgnoreReader.prototype.isIgnoreFile = function (e) {
      return e !== "." &&
             e !== ".." &&
             -1 !== this.ignoreFiles.indexOf(e)
    }
    
    
    IgnoreReader.prototype.getChildProps = function (stat) {
      var props = DirReader.prototype.getChildProps.call(this, stat)
      props.ignoreFiles = this.ignoreFiles
    
      // Directories have to be read as IgnoreReaders
      // otherwise fstream.Reader will create a DirReader instead.
      if (stat.isDirectory()) {
        props.type = this.constructor
      }
      return props
    }
    
    
    IgnoreReader.prototype.addIgnoreFile = function (e, cb) {
      // read the file, and then call addIgnoreRules
      // if there's an error, then tell the cb about it.
    
      var ig = path.resolve(this.path, e)
      fs.readFile(ig, function (er, data) {
        if (er) return cb(er)
    
        this.emit("ignoreFile", e, data)
        var rules = this.readRules(data, e)
        this.addIgnoreRules(rules, e)
        cb()
      }.bind(this))
    }
    
    
    IgnoreReader.prototype.readRules = function (buf, e) {
      return buf.toString().split(/\r?\n/)
    }
    
    
    // Override this to do fancier things, like read the
    // "files" array from a package.json file or something.
    IgnoreReader.prototype.addIgnoreRules = function (set, e) {
      // filter out anything obvious
      set = set.filter(function (s) {
        s = s.trim()
        return s && !s.match(/^#/)
      })
    
      // no rules to add!
      if (!set.length) return
    
      // now get a minimatch object for each one of these.
      // Note that we need to allow dot files by default, and
      // not switch the meaning of their exclusion
      var mmopt = { matchBase: true, dot: true, flipNegate: true }
      , mm = set.map(function (s) {
        var m = new Minimatch(s, mmopt)
        m.ignoreFile = e
        return m
      })
    
      if (!this.ignoreRules) this.ignoreRules = []
      this.ignoreRules.push.apply(this.ignoreRules, mm)
    }
    
    
    IgnoreReader.prototype.filterEntries = function () {
      // this exclusion is at the point where we know the list of
      // entries in the dir, but don't know what they are.  since
      // some of them *might* be directories, we have to run the
      // match in dir-mode as well, so that we'll pick up partials
      // of files that will be included later.  Anything included
      // at this point will be checked again later once we know
      // what it is.
      this.entries = this.entries.filter(function (entry) {
        // at this point, we don't know if it's a dir or not.
        return this.applyIgnores(entry) || this.applyIgnores(entry, true)
      }, this)
    }
    
    
    IgnoreReader.prototype.applyIgnores = function (entry, partial, obj) {
      var included = true
    
      // this = /a/b/c
      // entry = d
      // parent /a/b sees c/d
      if (this.parent && this.parent.applyIgnores) {
        var pt = this.basename + "/" + entry
        included = this.parent.applyIgnores(pt, partial)
      }
    
      // Negated Rules
      // Since we're *ignoring* things here, negating means that a file
      // is re-included, if it would have been excluded by a previous
      // rule.  So, negated rules are only relevant if the file
      // has been excluded.
      //
      // Similarly, if a file has been excluded, then there's no point
      // trying it against rules that have already been applied
      //
      // We're using the "flipnegate" flag here, which tells minimatch
      // to set the "negate" for our information, but still report
      // whether the core pattern was a hit or a miss.
    
      if (!this.ignoreRules) {
        return included
      }
    
      this.ignoreRules.forEach(function (rule) {
        // negation means inclusion
        if (rule.negate && included ||
            !rule.negate && !included) {
          // unnecessary
          return
        }
    
        // first, match against /foo/bar
        var match = rule.match("/" + entry)
    
        if (!match) {
          // try with the leading / trimmed off the test
          // eg: foo/bar instead of /foo/bar
          match = rule.match(entry)
        }
    
        // if the entry is a directory, then it will match
        // with a trailing slash. eg: /foo/bar/ or foo/bar/
        if (!match && partial) {
          match = rule.match("/" + entry + "/") ||
                  rule.match(entry + "/")
        }
    
        // When including a file with a negated rule, it's
        // relevant if a directory partially matches, since
        // it may then match a file within it.
        // Eg, if you ignore /a, but !/a/b/c
        if (!match && rule.negate && partial) {
          match = rule.match("/" + entry, true) ||
                  rule.match(entry, true)
        }
    
        if (match) {
          included = rule.negate
        }
      }, this)
    
      return included
    }
    
    
    IgnoreReader.prototype.sort = function (a, b) {
      var aig = this.ignoreFiles.indexOf(a) !== -1
      , big = this.ignoreFiles.indexOf(b) !== -1
    
      if (aig && !big) return -1
      if (big && !aig) return 1
      return this._sort(a, b)
    }
    
    IgnoreReader.prototype._sort = function (a, b) {
      return 0
    }
    
    function alphasort (a, b) {
      return a === b ? 0
           : a.toLowerCase() > b.toLowerCase() ? 1
           : a.toLowerCase() < b.toLowerCase() ? -1
           : a > b ? 1
           : -1
    }
    
  provide("fstream-ignore", module.exports);
}(global));

// pakmanager:tar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // field paths that every tar file must have.
    // header is padded to 512 bytes.
    var f = 0
      , fields = {}
      , path = fields.path = f++
      , mode = fields.mode = f++
      , uid = fields.uid = f++
      , gid = fields.gid = f++
      , size = fields.size = f++
      , mtime = fields.mtime = f++
      , cksum = fields.cksum = f++
      , type = fields.type = f++
      , linkpath = fields.linkpath = f++
      , headerSize = 512
      , blockSize = 512
      , fieldSize = []
    
    fieldSize[path] = 100
    fieldSize[mode] = 8
    fieldSize[uid] = 8
    fieldSize[gid] = 8
    fieldSize[size] = 12
    fieldSize[mtime] = 12
    fieldSize[cksum] = 8
    fieldSize[type] = 1
    fieldSize[linkpath] = 100
    
    // "ustar\0" may introduce another bunch of headers.
    // these are optional, and will be nulled out if not present.
    
    var ustar = fields.ustar = f++
      , ustarver = fields.ustarver = f++
      , uname = fields.uname = f++
      , gname = fields.gname = f++
      , devmaj = fields.devmaj = f++
      , devmin = fields.devmin = f++
      , prefix = fields.prefix = f++
      , fill = fields.fill = f++
    
    // terminate fields.
    fields[f] = null
    
    fieldSize[ustar] = 6
    fieldSize[ustarver] = 2
    fieldSize[uname] = 32
    fieldSize[gname] = 32
    fieldSize[devmaj] = 8
    fieldSize[devmin] = 8
    fieldSize[prefix] = 155
    fieldSize[fill] = 12
    
    // nb: prefix field may in fact be 130 bytes of prefix,
    // a null char, 12 bytes for atime, 12 bytes for ctime.
    //
    // To recognize this format:
    // 1. prefix[130] === ' ' or '\0'
    // 2. atime and ctime are octal numeric values
    // 3. atime and ctime have ' ' in their last byte
    
    var fieldEnds = {}
      , fieldOffs = {}
      , fe = 0
    for (var i = 0; i < f; i ++) {
      fieldOffs[i] = fe
      fieldEnds[i] = (fe += fieldSize[i])
    }
    
    // build a translation table of field paths.
    Object.keys(fields).forEach(function (f) {
      if (fields[f] !== null) fields[fields[f]] = f
    })
    
    // different values of the 'type' field
    // paths match the values of Stats.isX() functions, where appropriate
    var types =
      { 0: "File"
      , "\0": "OldFile" // like 0
      , "": "OldFile"
      , 1: "Link"
      , 2: "SymbolicLink"
      , 3: "CharacterDevice"
      , 4: "BlockDevice"
      , 5: "Directory"
      , 6: "FIFO"
      , 7: "ContiguousFile" // like 0
      // posix headers
      , g: "GlobalExtendedHeader" // k=v for the rest of the archive
      , x: "ExtendedHeader" // k=v for the next file
      // vendor-specific stuff
      , A: "SolarisACL" // skip
      , D: "GNUDumpDir" // like 5, but with data, which should be skipped
      , I: "Inode" // metadata only, skip
      , K: "NextFileHasLongLinkpath" // data = link path of next file
      , L: "NextFileHasLongPath" // data = path of next file
      , M: "ContinuationFile" // skip
      , N: "OldGnuLongPath" // like L
      , S: "SparseFile" // skip
      , V: "TapeVolumeHeader" // skip
      , X: "OldExtendedHeader" // like x
      }
    
    Object.keys(types).forEach(function (t) {
      types[types[t]] = types[types[t]] || t
    })
    
    // values for the mode field
    var modes =
      { suid: 04000 // set uid on extraction
      , sgid: 02000 // set gid on extraction
      , svtx: 01000 // set restricted deletion flag on dirs on extraction
      , uread:  0400
      , uwrite: 0200
      , uexec:  0100
      , gread:  040
      , gwrite: 020
      , gexec:  010
      , oread:  4
      , owrite: 2
      , oexec:  1
      , all: 07777
      }
    
    var numeric =
      { mode: true
      , uid: true
      , gid: true
      , size: true
      , mtime: true
      , devmaj: true
      , devmin: true
      , cksum: true
      , atime: true
      , ctime: true
      , dev: true
      , ino: true
      , nlink: true
      }
    
    Object.keys(modes).forEach(function (t) {
      modes[modes[t]] = modes[modes[t]] || t
    })
    
    var knownExtended =
      { atime: true
      , charset: true
      , comment: true
      , ctime: true
      , gid: true
      , gname: true
      , linkpath: true
      , mtime: true
      , path: true
      , realtime: true
      , security: true
      , size: true
      , uid: true
      , uname: true }
    
    
    exports.fields = fields
    exports.fieldSize = fieldSize
    exports.fieldOffs = fieldOffs
    exports.fieldEnds = fieldEnds
    exports.types = types
    exports.modes = modes
    exports.numeric = numeric
    exports.headerSize = headerSize
    exports.blockSize = blockSize
    exports.knownExtended = knownExtended
    
    exports.Pack = require("./lib/pack.js")
    exports.Parse = require("./lib/parse.js")
    exports.Extract = require("./lib/extract.js")
    
  provide("tar", module.exports);
}(global));

// pakmanager:uid-number
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = uidNumber
    
    // This module calls into get-uid-gid.js, which sets the
    // uid and gid to the supplied argument, in order to find out their
    // numeric value.  This can't be done in the main node process,
    // because otherwise node would be running as that user from this
    // point on.
    
    var child_process = require("child_process")
      , path = require("path")
      , uidSupport = process.getuid && process.setuid
      , uidCache = {}
      , gidCache = {}
    
    function uidNumber (uid, gid, cb) {
      if (!uidSupport) return cb()
      if (typeof cb !== "function") cb = gid, gid = null
      if (typeof cb !== "function") cb = uid, uid = null
      if (gid == null) gid = process.getgid()
      if (uid == null) uid = process.getuid()
      if (!isNaN(gid)) gid = gidCache[gid] = +gid
      if (!isNaN(uid)) uid = uidCache[uid] = +uid
    
      if (uidCache.hasOwnProperty(uid)) uid = uidCache[uid]
      if (gidCache.hasOwnProperty(gid)) gid = gidCache[gid]
    
      if (typeof gid === "number" && typeof uid === "number") {
        return process.nextTick(cb.bind(null, null, uid, gid))
      }
    
      var getter = require.resolve("./get-uid-gid.js")
    
      child_process.execFile( process.execPath
                            , [getter, uid, gid]
                            , function (code, out, stderr) {
        if (code) {
          var er = new Error("could not get uid/gid\n" + stderr)
          er.code = code
          return cb(er)
        }
    
        try {
          out = JSON.parse(out+"")
        } catch (ex) {
          return cb(ex)
        }
    
        if (out.error) {
          var er = new Error(out.error)
          er.errno = out.errno
          return cb(er)
        }
    
        if (isNaN(out.uid) || isNaN(out.gid)) return cb(new Error(
          "Could not get uid/gid: "+JSON.stringify(out)))
    
        cb(null, uidCache[uid] = +out.uid, gidCache[gid] = +out.gid)
      })
    }
    
  provide("uid-number", module.exports);
}(global));

// pakmanager:ini
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports.parse = exports.decode = decode
    exports.stringify = exports.encode = encode
    
    exports.safe = safe
    exports.unsafe = unsafe
    
    var eol = process.platform === "win32" ? "\r\n" : "\n"
    
    function encode (obj, opt) {
      var children = []
        , out = ""
    
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        }
      } else {
        opt = opt || {}
        opt.whitespace = opt.whitespace === true
      }
    
      var separator = opt.whitespace ? " = " : "="
    
      Object.keys(obj).forEach(function (k, _, __) {
        var val = obj[k]
        if (val && Array.isArray(val)) {
            val.forEach(function(item) {
                out += safe(k + "[]") + separator + safe(item) + "\n"
            })
        }
        else if (val && typeof val === "object") {
          children.push(k)
        } else {
          out += safe(k) + separator + safe(val) + eol
        }
      })
    
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + eol + out
      }
    
      children.forEach(function (k, _, __) {
        var nk = dotSplit(k).join('\\.')
        var section = (opt.section ? opt.section + "." : "") + nk
        var child = encode(obj[k], {
          section: section,
          whitespace: opt.whitespace
        })
        if (out.length && child.length) {
          out += eol
        }
        out += child
      })
    
      return out
    }
    
    function dotSplit (str) {
      return str.replace(/\1/g, '\u0002LITERAL\\1LITERAL\u0002')
             .replace(/\\\./g, '\u0001')
             .split(/\./).map(function (part) {
               return part.replace(/\1/g, '\\.')
                      .replace(/\2LITERAL\\1LITERAL\2/g, '\u0001')
            })
    }
    
    function decode (str) {
      var out = {}
        , p = out
        , section = null
        , state = "START"
               // section     |key = value
        , re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i
        , lines = str.split(/[\r\n]+/g)
        , section = null
    
      lines.forEach(function (line, _, __) {
        if (!line || line.match(/^\s*[;#]/)) return
        var match = line.match(re)
        if (!match) return
        if (match[1] !== undefined) {
          section = unsafe(match[1])
          p = out[section] = out[section] || {}
          return
        }
        var key = unsafe(match[2])
          , value = match[3] ? unsafe((match[4] || "")) : true
        switch (value) {
          case 'true':
          case 'false':
          case 'null': value = JSON.parse(value)
        }
    
        // Convert keys with '[]' suffix to an array
        if (key.length > 2 && key.slice(-2) === "[]") {
            key = key.substring(0, key.length - 2)
            if (!p[key]) {
              p[key] = []
            }
            else if (!Array.isArray(p[key])) {
              p[key] = [p[key]]
            }
        }
    
        // safeguard against resetting a previously defined
        // array by accidentally forgetting the brackets
        if (Array.isArray(p[key])) {
          p[key].push(value)
        }
        else {
          p[key] = value
        }
      })
    
      // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
      // use a filter to return the keys that have to be deleted.
      Object.keys(out).filter(function (k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) return false
        // see if the parent section is also an object.
        // if so, add it to that, and mark this one for deletion
        var parts = dotSplit(k)
          , p = out
          , l = parts.pop()
          , nl = l.replace(/\\\./g, '.')
        parts.forEach(function (part, _, __) {
          if (!p[part] || typeof p[part] !== "object") p[part] = {}
          p = p[part]
        })
        if (p === out && nl === l) return false
        p[nl] = out[k]
        return true
      }).forEach(function (del, _, __) {
        delete out[del]
      })
    
      return out
    }
    
    function isQuoted (val) {
      return (val.charAt(0) === "\"" && val.slice(-1) === "\"")
             || (val.charAt(0) === "'" && val.slice(-1) === "'")
    }
    
    function safe (val) {
      return ( typeof val !== "string"
             || val.match(/[=\r\n]/)
             || val.match(/^\[/)
             || (val.length > 1
                 && isQuoted(val))
             || val !== val.trim() )
             ? JSON.stringify(val)
             : val.replace(/;/g, '\\;').replace(/#/g, "\\#")
    }
    
    function unsafe (val, doUnesc) {
      val = (val || "").trim()
      if (isQuoted(val)) {
        // remove the single quotes before calling JSON.parse
        if (val.charAt(0) === "'") {
          val = val.substr(1, val.length - 2);
        }
        try { val = JSON.parse(val) } catch (_) {}
      } else {
        // walk the val to find the first not-escaped ; character
        var esc = false
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i)
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c
            else
              unesc += "\\" + c
            esc = false
          } else if (";#".indexOf(c) !== -1) {
            break
          } else if (c === "\\") {
            esc = true
          } else {
            unesc += c
          }
        }
        if (esc)
          unesc += "\\"
        return unesc
      }
      return val
    }
    
  provide("ini", module.exports);
}(global));

// pakmanager:strip-json-comments
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var singleComment = 1;
    var multiComment = 2;
    
    function stripWithoutWhitespace() {
    	return '';
    }
    
    function stripWithWhitespace(str, start, end) {
    	return str.slice(start, end).replace(/\S/g, ' ');
    }
    
    module.exports = function (str, opts) {
    	opts = opts || {};
    
    	var currentChar;
    	var nextChar;
    	var insideString = false;
    	var insideComment = false;
    	var offset = 0;
    	var ret = '';
    	var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
    
    	for (var i = 0; i < str.length; i++) {
    		currentChar = str[i];
    		nextChar = str[i + 1];
    
    		if (!insideComment && currentChar === '"') {
    			var escaped = str[i - 1] === '\\' && str[i - 2] !== '\\';
    			if (!escaped) {
    				insideString = !insideString;
    			}
    		}
    
    		if (insideString) {
    			continue;
    		}
    
    		if (!insideComment && currentChar + nextChar === '//') {
    			ret += str.slice(offset, i);
    			offset = i;
    			insideComment = singleComment;
    			i++;
    		} else if (insideComment === singleComment && currentChar + nextChar === '\r\n') {
    			i++;
    			insideComment = false;
    			ret += strip(str, offset, i);
    			offset = i;
    			continue;
    		} else if (insideComment === singleComment && currentChar === '\n') {
    			insideComment = false;
    			ret += strip(str, offset, i);
    			offset = i;
    		} else if (!insideComment && currentChar + nextChar === '/*') {
    			ret += str.slice(offset, i);
    			offset = i;
    			insideComment = multiComment;
    			i++;
    			continue;
    		} else if (insideComment === multiComment && currentChar + nextChar === '*/') {
    			i++;
    			insideComment = false;
    			ret += strip(str, offset, i + 1);
    			offset = i + 1;
    			continue;
    		}
    	}
    
    	return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
    
  provide("strip-json-comments", module.exports);
}(global));

// pakmanager:ultron
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var has = Object.prototype.hasOwnProperty;
    
    /**
     * An auto incrementing id which we can use to create "unique" Ultron instances
     * so we can track the event emitters that are added through the Ultron
     * interface.
     *
     * @type {Number}
     * @private
     */
    var id = 0;
    
    /**
     * Ultron is high-intelligence robot. It gathers intelligence so it can start improving
     * upon his rudimentary design. It will learn from your EventEmitting patterns
     * and exterminate them.
     *
     * @constructor
     * @param {EventEmitter} ee EventEmitter instance we need to wrap.
     * @api public
     */
    function Ultron(ee) {
      if (!(this instanceof Ultron)) return new Ultron(ee);
    
      this.id = id++;
      this.ee = ee;
    }
    
    /**
     * Register a new EventListener for the given event.
     *
     * @param {String} event Name of the event.
     * @param {Functon} fn Callback function.
     * @param {Mixed} context The context of the function.
     * @returns {Ultron}
     * @api public
     */
    Ultron.prototype.on = function on(event, fn, context) {
      fn.__ultron = this.id;
      this.ee.on(event, fn, context);
    
      return this;
    };
    /**
     * Add an EventListener that's only called once.
     *
     * @param {String} event Name of the event.
     * @param {Function} fn Callback function.
     * @param {Mixed} context The context of the function.
     * @returns {Ultron}
     * @api public
     */
    Ultron.prototype.once = function once(event, fn, context) {
      fn.__ultron = this.id;
      this.ee.once(event, fn, context);
    
      return this;
    };
    
    /**
     * Remove the listeners we assigned for the given event.
     *
     * @returns {Ultron}
     * @api public
     */
    Ultron.prototype.remove = function remove() {
      var args = arguments
        , event;
    
      //
      // When no event names are provided we assume that we need to clear all the
      // events that were assigned through us.
      //
      if (args.length === 1 && 'string' === typeof args[0]) {
        args = args[0].split(/[, ]+/);
      } else if (!args.length) {
        args = [];
    
        for (event in this.ee._events) {
          if (has.call(this.ee._events, event)) args.push(event);
        }
      }
    
      for (var i = 0; i < args.length; i++) {
        var listeners = this.ee.listeners(args[i]);
    
        for (var j = 0; j < listeners.length; j++) {
          event = listeners[j];
    
          //
          // Once listeners have a `listener` property that stores the real listener
          // in the EventEmitter that ships with Node.js.
          //
          if (event.listener) {
            if (event.listener.__ultron !== this.id) continue;
            delete event.listener.__ultron;
          } else {
            if (event.__ultron !== this.id) continue;
            delete event.__ultron;
          }
    
          this.ee.removeListener(args[i], event);
        }
      }
    
      return this;
    };
    
    /**
     * Destroy the Ultron instance, remove all listeners and release all references.
     *
     * @returns {Boolean}
     * @api public
     */
    Ultron.prototype.destroy = function destroy() {
      if (!this.ee) return false;
    
      this.remove();
      this.ee = null;
    
      return true;
    };
    
    //
    // Expose the module.
    //
    module.exports = Ultron;
    
  provide("ultron", module.exports);
}(global));

// pakmanager:after
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = after
    
    function after(count, callback, err_cb) {
        var bail = false
        err_cb = err_cb || noop
        proxy.count = count
    
        return (count === 0) ? callback() : proxy
    
        function proxy(err, result) {
            if (proxy.count <= 0) {
                throw new Error('after called too many times')
            }
            --proxy.count
    
            // after first error, rest are passed to err_cb
            if (err) {
                bail = true
                callback(err)
                // future error callbacks will go to error handler
                callback = err_cb
            } else if (proxy.count === 0 && !bail) {
                callback(null, result)
            }
        }
    }
    
    function noop() {}
    
  provide("after", module.exports);
}(global));

// pakmanager:arraybuffer.slice
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */
    
    module.exports = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
    
      if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
    
      if (start < 0) { start += bytes; }
      if (end < 0) { end += bytes; }
      if (end > bytes) { end = bytes; }
    
      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }
    
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start, ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };
    
  provide("arraybuffer.slice", module.exports);
}(global));

// pakmanager:blob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Create a blob builder even when vendor prefixes exist
     */
    
    var BlobBuilder = global.BlobBuilder
      || global.WebKitBlobBuilder
      || global.MSBlobBuilder
      || global.MozBlobBuilder;
    
    /**
     * Check if Blob constructor is supported
     */
    
    var blobSupported = (function() {
      try {
        var a = new Blob(['hi']);
        return a.size === 2;
      } catch(e) {
        return false;
      }
    })();
    
    /**
     * Check if Blob constructor supports ArrayBufferViews
     * Fails in Safari 6, so we need to map to ArrayBuffers there.
     */
    
    var blobSupportsArrayBufferView = blobSupported && (function() {
      try {
        var b = new Blob([new Uint8Array([1,2])]);
        return b.size === 2;
      } catch(e) {
        return false;
      }
    })();
    
    /**
     * Check if BlobBuilder is supported
     */
    
    var blobBuilderSupported = BlobBuilder
      && BlobBuilder.prototype.append
      && BlobBuilder.prototype.getBlob;
    
    /**
     * Helper function that maps ArrayBufferViews to ArrayBuffers
     * Used by BlobBuilder constructor and old browsers that didn't
     * support it in the Blob constructor.
     */
    
    function mapArrayBufferViews(ary) {
      for (var i = 0; i < ary.length; i++) {
        var chunk = ary[i];
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;
    
          // if this is a subarray, make a copy so we only
          // include the subarray region from the underlying buffer
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }
    
          ary[i] = buf;
        }
      }
    }
    
    function BlobBuilderConstructor(ary, options) {
      options = options || {};
    
      var bb = new BlobBuilder();
      mapArrayBufferViews(ary);
    
      for (var i = 0; i < ary.length; i++) {
        bb.append(ary[i]);
      }
    
      return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
    };
    
    function BlobConstructor(ary, options) {
      mapArrayBufferViews(ary);
      return new Blob(ary, options || {});
    };
    
    module.exports = (function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return undefined;
      }
    })();
    
  provide("blob", module.exports);
}(global));

// pakmanager:has-binary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /*
     * Module requirements.
     */
    
    var isArray = require('isarray');
    
    /**
     * Module exports.
     */
    
    module.exports = hasBinary;
    
    /**
     * Checks for binary data.
     *
     * Right now only Buffer and ArrayBuffer are supported..
     *
     * @param {Object} anything
     * @api public
     */
    
    function hasBinary(data) {
    
      function _hasBinary(obj) {
        if (!obj) return false;
    
        if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
             (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
             (global.Blob && obj instanceof Blob) ||
             (global.File && obj instanceof File)
            ) {
          return true;
        }
    
        if (isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
              if (_hasBinary(obj[i])) {
                  return true;
              }
          }
        } else if (obj && 'object' == typeof obj) {
          // see: https://github.com/Automattic/has-binary/pull/4
          if (obj.toJSON && 'function' == typeof obj.toJSON) {
            obj = obj.toJSON();
          }
    
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
              return true;
            }
          }
        }
    
        return false;
      }
    
      return _hasBinary(data);
    }
    
  provide("has-binary", module.exports);
}(global));

// pakmanager:utf8
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*! https://mths.be/utf8js v2.0.0 by @mathias */
    ;(function(root) {
    
    	// Detect free variables `exports`
    	var freeExports = typeof exports == 'object' && exports;
    
    	// Detect free variable `module`
    	var freeModule = typeof module == 'object' && module &&
    		module.exports == freeExports && module;
    
    	// Detect free variable `global`, from Node.js or Browserified code,
    	// and use it as `root`
    	var freeGlobal = typeof global == 'object' && global;
    	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    		root = freeGlobal;
    	}
    
    	/*--------------------------------------------------------------------------*/
    
    	var stringFromCharCode = String.fromCharCode;
    
    	// Taken from https://mths.be/punycode
    	function ucs2decode(string) {
    		var output = [];
    		var counter = 0;
    		var length = string.length;
    		var value;
    		var extra;
    		while (counter < length) {
    			value = string.charCodeAt(counter++);
    			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    				// high surrogate, and there is a next character
    				extra = string.charCodeAt(counter++);
    				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    				} else {
    					// unmatched surrogate; only append this code unit, in case the next
    					// code unit is the high surrogate of a surrogate pair
    					output.push(value);
    					counter--;
    				}
    			} else {
    				output.push(value);
    			}
    		}
    		return output;
    	}
    
    	// Taken from https://mths.be/punycode
    	function ucs2encode(array) {
    		var length = array.length;
    		var index = -1;
    		var value;
    		var output = '';
    		while (++index < length) {
    			value = array[index];
    			if (value > 0xFFFF) {
    				value -= 0x10000;
    				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    				value = 0xDC00 | value & 0x3FF;
    			}
    			output += stringFromCharCode(value);
    		}
    		return output;
    	}
    
    	function checkScalarValue(codePoint) {
    		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    			throw Error(
    				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
    				' is not a scalar value'
    			);
    		}
    	}
    	/*--------------------------------------------------------------------------*/
    
    	function createByte(codePoint, shift) {
    		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
    	}
    
    	function encodeCodePoint(codePoint) {
    		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
    			return stringFromCharCode(codePoint);
    		}
    		var symbol = '';
    		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
    			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
    		}
    		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
    			checkScalarValue(codePoint);
    			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
    			symbol += createByte(codePoint, 6);
    		}
    		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
    			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
    			symbol += createByte(codePoint, 12);
    			symbol += createByte(codePoint, 6);
    		}
    		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
    		return symbol;
    	}
    
    	function utf8encode(string) {
    		var codePoints = ucs2decode(string);
    		var length = codePoints.length;
    		var index = -1;
    		var codePoint;
    		var byteString = '';
    		while (++index < length) {
    			codePoint = codePoints[index];
    			byteString += encodeCodePoint(codePoint);
    		}
    		return byteString;
    	}
    
    	/*--------------------------------------------------------------------------*/
    
    	function readContinuationByte() {
    		if (byteIndex >= byteCount) {
    			throw Error('Invalid byte index');
    		}
    
    		var continuationByte = byteArray[byteIndex] & 0xFF;
    		byteIndex++;
    
    		if ((continuationByte & 0xC0) == 0x80) {
    			return continuationByte & 0x3F;
    		}
    
    		// If we end up here, it’s not a continuation byte
    		throw Error('Invalid continuation byte');
    	}
    
    	function decodeSymbol() {
    		var byte1;
    		var byte2;
    		var byte3;
    		var byte4;
    		var codePoint;
    
    		if (byteIndex > byteCount) {
    			throw Error('Invalid byte index');
    		}
    
    		if (byteIndex == byteCount) {
    			return false;
    		}
    
    		// Read first byte
    		byte1 = byteArray[byteIndex] & 0xFF;
    		byteIndex++;
    
    		// 1-byte sequence (no continuation bytes)
    		if ((byte1 & 0x80) == 0) {
    			return byte1;
    		}
    
    		// 2-byte sequence
    		if ((byte1 & 0xE0) == 0xC0) {
    			var byte2 = readContinuationByte();
    			codePoint = ((byte1 & 0x1F) << 6) | byte2;
    			if (codePoint >= 0x80) {
    				return codePoint;
    			} else {
    				throw Error('Invalid continuation byte');
    			}
    		}
    
    		// 3-byte sequence (may include unpaired surrogates)
    		if ((byte1 & 0xF0) == 0xE0) {
    			byte2 = readContinuationByte();
    			byte3 = readContinuationByte();
    			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
    			if (codePoint >= 0x0800) {
    				checkScalarValue(codePoint);
    				return codePoint;
    			} else {
    				throw Error('Invalid continuation byte');
    			}
    		}
    
    		// 4-byte sequence
    		if ((byte1 & 0xF8) == 0xF0) {
    			byte2 = readContinuationByte();
    			byte3 = readContinuationByte();
    			byte4 = readContinuationByte();
    			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
    				(byte3 << 0x06) | byte4;
    			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
    				return codePoint;
    			}
    		}
    
    		throw Error('Invalid UTF-8 detected');
    	}
    
    	var byteArray;
    	var byteCount;
    	var byteIndex;
    	function utf8decode(byteString) {
    		byteArray = ucs2decode(byteString);
    		byteCount = byteArray.length;
    		byteIndex = 0;
    		var codePoints = [];
    		var tmp;
    		while ((tmp = decodeSymbol()) !== false) {
    			codePoints.push(tmp);
    		}
    		return ucs2encode(codePoints);
    	}
    
    	/*--------------------------------------------------------------------------*/
    
    	var utf8 = {
    		'version': '2.0.0',
    		'encode': utf8encode,
    		'decode': utf8decode
    	};
    
    	// Some AMD build optimizers, like r.js, check for specific condition patterns
    	// like the following:
    	if (
    		typeof define == 'function' &&
    		typeof define.amd == 'object' &&
    		define.amd
    	) {
    		define(function() {
    			return utf8;
    		});
    	}	else if (freeExports && !freeExports.nodeType) {
    		if (freeModule) { // in Node.js or RingoJS v0.8.0+
    			freeModule.exports = utf8;
    		} else { // in Narwhal or RingoJS v0.7.0-
    			var object = {};
    			var hasOwnProperty = object.hasOwnProperty;
    			for (var key in utf8) {
    				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
    			}
    		}
    	} else { // in Rhino or a web browser
    		root.utf8 = utf8;
    	}
    
    }(this));
    
  provide("utf8", module.exports);
}(global));

// pakmanager:better-assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var AssertionError = require('assert').AssertionError
      , callsite = require('callsite')
      , fs = require('fs')
    
    /**
     * Expose `assert`.
     */
    
    module.exports = process.env.NO_ASSERT
      ? function(){}
      : assert;
    
    /**
     * Assert the given `expr`.
     */
    
    function assert(expr) {
      if (expr) return;
    
      var stack = callsite();
      var call = stack[1];
      var file = call.getFileName();
      var lineno = call.getLineNumber();
      var src = fs.readFileSync(file, 'utf8');
      var line = src.split('\n')[lineno-1];
      var src = line.match(/assert\((.*)\)/)[1];
    
      var err = new AssertionError({
        message: src,
        stackStartFunction: stack[0].getFunction()
      });
    
      throw err;
    }
    
  provide("better-assert", module.exports);
}(global));

// pakmanager:lodash
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @license
     * lodash 4.6.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash -d -o ./foo/lodash.js`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    ;(function() {
    
      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined;
    
      /** Used as the semantic version number. */
      var VERSION = '4.6.1';
    
      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;
    
      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';
    
      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';
    
      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';
    
      /** Used to compose bitmasks for wrapper metadata. */
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256,
          FLIP_FLAG = 512;
    
      /** Used to compose bitmasks for comparison styles. */
      var UNORDERED_COMPARE_FLAG = 1,
          PARTIAL_COMPARE_FLAG = 2;
    
      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
    
      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
    
      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;
    
      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;
    
      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    
      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';
    
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
    
      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    
      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    
      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
    
      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    
      /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);
    
      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/;
    
      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;
    
      /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    
      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;
    
      /** Used to detect hexadecimal string values. */
      var reHasHexPrefix = /^0x/i;
    
      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;
    
      /** Used to detect host constructors (Safari > 5). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;
    
      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;
    
      /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    
      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;
    
      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    
      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
          rsComboSymbolsRange = '\\u20d0-\\u20f0',
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsQuoteRange = '\\u2018\\u2019\\u201c\\u201d',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;
    
      /** Used to compose unicode capture groups. */
      var rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';
    
      /** Used to compose unicode regexes. */
      var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
          rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    
      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');
    
      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reComplexSymbol = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    
      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');
    
      /** Used to match non-compound words composed of alphanumeric characters. */
      var reBasicWord = /[a-zA-Z0-9]+/g;
    
      /** Used to match complex or compound words. */
      var reComplexWord = RegExp([
        rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
        rsUpper + '?' + rsLowerMisc + '+',
        rsUpper + '+',
        rsDigits,
        rsEmoji
      ].join('|'), 'g');
    
      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    
      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_',
        'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];
    
      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;
    
      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dateTag] = typedArrayTags[errorTag] =
      typedArrayTags[funcTag] = typedArrayTags[mapTag] =
      typedArrayTags[numberTag] = typedArrayTags[objectTag] =
      typedArrayTags[regexpTag] = typedArrayTags[setTag] =
      typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
      cloneableTags[dateTag] = cloneableTags[float32Tag] =
      cloneableTags[float64Tag] = cloneableTags[int8Tag] =
      cloneableTags[int16Tag] = cloneableTags[int32Tag] =
      cloneableTags[mapTag] = cloneableTags[numberTag] =
      cloneableTags[objectTag] = cloneableTags[regexpTag] =
      cloneableTags[setTag] = cloneableTags[stringTag] =
      cloneableTags[symbolTag] = cloneableTags[uint8Tag] =
      cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =
      cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;
    
      /** Used to map latin-1 supplementary letters to basic latin letters. */
      var deburredLetters = {
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss'
      };
    
      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
    
      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
    
      /** Used to determine if values are of the language type `Object`. */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;
    
      /** Detect free variable `exports`. */
      var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
        ? exports
        : undefined;
    
      /** Detect free variable `module`. */
      var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
        ? module
        : undefined;
    
      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = (freeModule && freeModule.exports === freeExports)
        ? freeExports
        : undefined;
    
      /** Detect free variable `global` from Node.js. */
      var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
      /** Detect free variable `self`. */
      var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
      /** Detect free variable `window`. */
      var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
      /** Detect `this` as the global object. */
      var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
      /**
       * Used as a reference to the global object.
       *
       * The `this` value is used if it's the global object to avoid Greasemonkey's
       * restricted `window` object, otherwise the `window` object is used.
       */
      var root = freeGlobal ||
        ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
          freeSelf || thisGlobal || Function('return this')();
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Adds the key-value `pair` to `map`.
       *
       * @private
       * @param {Object} map The map to modify.
       * @param {Array} pair The key-value pair to add.
       * @returns {Object} Returns `map`.
       */
      function addMapEntry(map, pair) {
        // Don't return `Map#set` because it doesn't return the map instance in IE 11.
        map.set(pair[0], pair[1]);
        return map;
      }
    
      /**
       * Adds `value` to `set`.
       *
       * @private
       * @param {Object} set The set to modify.
       * @param {*} value The value to add.
       * @returns {Object} Returns `set`.
       */
      function addSetEntry(set, value) {
        set.add(value);
        return set;
      }
    
      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        var length = args.length;
        switch (length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
    
      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
    
      /**
       * Creates a new array concatenating `array` with `other`.
       *
       * @private
       * @param {Array} array The first array to concatenate.
       * @param {Array} other The second array to concatenate.
       * @returns {Array} Returns the new concatenated array.
       */
      function arrayConcat(array, other) {
        var index = -1,
            length = array.length,
            othIndex = -1,
            othLength = other.length,
            result = Array(length + othLength);
    
        while (++index < length) {
          result[index] = array[index];
        }
        while (++othIndex < othLength) {
          result[index++] = other[othIndex];
        }
        return result;
      }
    
      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
    
      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array.length;
    
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
    
      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
    
      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
    
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
    
      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        return !!array.length && baseIndexOf(array, value, 0) > -1;
      }
    
      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
    
      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array.length,
            result = Array(length);
    
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
    
      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;
    
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
    
      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array.length;
    
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
    
      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
    
      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
    
      /**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */
      function baseExtremum(array, iteratee, comparator) {
        var index = -1,
            length = array.length;
    
        while (++index < length) {
          var value = array[index],
              current = iteratee(value);
    
          if (current != null && (computed === undefined
                ? current === current
                : comparator(current, computed)
              )) {
            var computed = current,
                result = value;
          }
        }
        return result;
      }
    
      /**
       * The base implementation of methods like `_.find` and `_.findKey`, without
       * support for iteratee shorthands, which iterates over `collection` using
       * `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @param {boolean} [retKey] Specify returning the key of the found element instead of the element itself.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFind(collection, predicate, eachFunc, retKey) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = retKey ? key : value;
            return false;
          }
        });
        return result;
      }
    
      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
    
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
    
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;
    
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }
    
      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;
    
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
    
      /**
       * The base implementation of `_.sum` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;
    
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined) {
            result = result === undefined ? current : (result + current);
          }
        }
        return result;
      }
    
      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);
    
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
    
      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the new array of key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
    
      /**
       * The base implementation of `_.unary` without support for storing wrapper metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
    
      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
    
      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;
    
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
    
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }
    
      /**
       * Checks if `value` is a global object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {null|Object} Returns `value` if it's a global object, else `null`.
       */
      function checkGlobal(value) {
        return (value && value.Object === Object) ? value : null;
      }
    
      /**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
    
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
    
          if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
    
      /**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
    
        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index;
      }
    
      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;
    
        while (length--) {
          if (array[length] === placeholder) {
            result++;
          }
        }
        return result;
      }
    
      /**
       * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
    
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
    
      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
    
      /**
       * Gets the index at which the first occurrence of `NaN` is found in `array`.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched `NaN`, else `-1`.
       */
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
    
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * Checks if `value` is a host object in IE < 9.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
       */
      function isHostObject(value) {
        // Many host objects are `Object` objects that can coerce to strings
        // despite having improperly defined `toString` methods.
        var result = false;
        if (value != null && typeof value.toString != 'function') {
          try {
            result = !!(value + '');
          } catch (e) {}
        }
        return result;
      }
    
      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */
      function isIndex(value, length) {
        value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return value > -1 && value % 1 == 0 && value < length;
      }
    
      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];
    
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
    
      /**
       * Converts `map` to an array.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the converted array.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);
    
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
    
      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
    
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
    
      /**
       * Converts `set` to an array.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the converted array.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);
    
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
    
      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        if (!(string && reHasComplexSymbol.test(string))) {
          return string.length;
        }
        var result = reComplexSymbol.lastIndex = 0;
        while (reComplexSymbol.test(string)) {
          result++;
        }
        return result;
      }
    
      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return string.match(reComplexSymbol);
      }
    
      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Use `context` to mock `Date#getTime` use in `_.now`.
       * var mock = _.runInContext({
       *   'Date': function() {
       *     return { 'getTime': getTimeMock };
       *   }
       * });
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      function runInContext(context) {
        context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;
    
        /** Built-in constructor references. */
        var Date = context.Date,
            Error = context.Error,
            Math = context.Math,
            RegExp = context.RegExp,
            TypeError = context.TypeError;
    
        /** Used for built-in method references. */
        var arrayProto = context.Array.prototype,
            objectProto = context.Object.prototype;
    
        /** Used to resolve the decompiled source of functions. */
        var funcToString = context.Function.prototype.toString;
    
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
    
        /** Used to generate unique IDs. */
        var idCounter = 0;
    
        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);
    
        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objectToString = objectProto.toString;
    
        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;
    
        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );
    
        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined,
            Reflect = context.Reflect,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            clearTimeout = context.clearTimeout,
            enumerate = Reflect ? Reflect.enumerate : undefined,
            getPrototypeOf = Object.getPrototypeOf,
            getOwnPropertySymbols = Object.getOwnPropertySymbols,
            iteratorSymbol = typeof (iteratorSymbol = Symbol && Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            setTimeout = context.setTimeout,
            splice = arrayProto.splice;
    
        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = Object.keys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;
    
        /* Built-in method references that are verified to be native. */
        var Map = getNative(context, 'Map'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');
    
        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;
    
        /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
        var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
    
        /** Used to lookup unminified function names. */
        var realNames = {};
    
        /** Used to detect maps, sets, and weakmaps. */
        var mapCtorString = Map ? funcToString.call(Map) : '',
            setCtorString = Set ? funcToString.call(Set) : '',
            weakMapCtorString = WeakMap ? funcToString.call(WeakMap) : '';
    
        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chaining. Methods that operate on and return arrays, collections, and
         * functions can be chained together. Methods that retrieve a single value or
         * may return a primitive value will automatically end the chain sequence and
         * return the unwrapped value. Otherwise, the value must be unwrapped with
         * `_#value`.
         *
         * Explicit chaining, which must be unwrapped with `_#value` in all cases,
         * may be enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization to merge iteratee calls; this avoids the creation
         * of intermediate arrays and can greatly reduce the number of iteratee executions.
         * Sections of a chain sequence qualify for shortcut fusion if the section is
         * applied to an array of at least two hundred elements and any iteratees
         * accept only one argument. The heuristic for whether a section qualifies
         * for shortcut fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatten`, `flattenDeep`, `flattenDepth`, `flip`, `flow`, `flowRight`,
         * `fromPairs`, `functions`, `functionsIn`, `groupBy`, `initial`, `intersection`,
         * `intersectionBy`, `intersectionWith`, `invert`, `invertBy`, `invokeMap`,
         * `iteratee`, `keyBy`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`,
         * `matches`, `matchesProperty`, `memoize`, `merge`, `mergeWith`, `method`,
         * `methodOf`, `mixin`, `negate`, `nthArg`, `omit`, `omitBy`, `once`, `orderBy`,
         * `over`, `overArgs`, `overEvery`, `overSome`, `partial`, `partialRight`,
         * `partition`, `pick`, `pickBy`, `plant`, `property`, `propertyOf`, `pull`,
         * `pullAll`, `pullAllBy`, `pullAllWith`, `pullAt`, `push`, `range`,
         * `rangeRight`, `rearg`, `reject`, `remove`, `rest`, `reverse`, `sampleSize`,
         * `set`, `setWith`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`, `spread`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
         * `thru`, `toArray`, `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`,
         * `transform`, `unary`, `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`,
         * `uniqWith`, `unset`, `unshift`, `unzip`, `unzipWith`, `update`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`, `zipObject`,
         * `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `each`, `eachRight`,
         * `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`, `floor`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`, `includes`,
         * `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`, `isArrayBuffer`,
         * `isArrayLike`, `isArrayLikeObject`, `isBoolean`, `isBuffer`, `isDate`,
         * `isElement`, `isEmpty`, `isEqual`, `isEqualWith`, `isError`, `isFinite`,
         * `isFunction`, `isInteger`, `isLength`, `isMap`, `isMatch`, `isMatchWith`,
         * `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`, `isObject`, `isObjectLike`,
         * `isPlainObject`, `isRegExp`, `isSafeInteger`, `isSet`, `isString`,
         * `isUndefined`, `isTypedArray`, `isWeakMap`, `isWeakSet`, `join`, `kebabCase`,
         * `last`, `lastIndexOf`, `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`,
         * `maxBy`, `mean`, `min`, `minBy`, `noConflict`, `noop`, `now`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toInteger`, `toJSON`, `toLength`, `toLower`,
         * `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`, `trimEnd`,
         * `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`, `upperFirst`,
         * `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
    
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }
    
        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined;
        }
    
        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB). Change the following template settings to use
         * alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {
    
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,
    
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,
    
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,
    
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',
    
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {
    
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
    
        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }
    
        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
    
        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
    
          if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
              (arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];
    
          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
    
            var iterIndex = -1,
                value = array[index];
    
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
    
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an hash object.
         *
         * @private
         * @constructor
         * @returns {Object} Returns the new hash object.
         */
        function Hash() {}
    
        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(hash, key) {
          return hashHas(hash, key) && delete hash[key];
        }
    
        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @param {Object} hash The hash to query.
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(hash, key) {
          if (nativeCreate) {
            var result = hash[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }
          return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
        }
    
        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @param {Object} hash The hash to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(hash, key) {
          return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
        }
    
        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         */
        function hashSet(hash, key, value) {
          hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function MapCache(values) {
          var index = -1,
              length = values ? values.length : 0;
    
          this.clear();
          while (++index < length) {
            var entry = values[index];
            this.set(entry[0], entry[1]);
          }
        }
    
        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapClear() {
          this.__data__ = {
            'hash': new Hash,
            'map': Map ? new Map : [],
            'string': new Hash
          };
        }
    
        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapDelete(key) {
          var data = this.__data__;
          if (isKeyable(key)) {
            return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
          }
          return Map ? data.map['delete'](key) : assocDelete(data.map, key);
        }
    
        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapGet(key) {
          var data = this.__data__;
          if (isKeyable(key)) {
            return hashGet(typeof key == 'string' ? data.string : data.hash, key);
          }
          return Map ? data.map.get(key) : assocGet(data.map, key);
        }
    
        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapHas(key) {
          var data = this.__data__;
          if (isKeyable(key)) {
            return hashHas(typeof key == 'string' ? data.string : data.hash, key);
          }
          return Map ? data.map.has(key) : assocHas(data.map, key);
        }
    
        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache object.
         */
        function mapSet(key, value) {
          var data = this.__data__;
          if (isKeyable(key)) {
            hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
          } else if (Map) {
            data.map.set(key, value);
          } else {
            assocSet(data.map, key, value);
          }
          return this;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         *
         * Creates a set cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values ? values.length : 0;
    
          this.__data__ = new MapCache;
          while (++index < length) {
            this.push(values[index]);
          }
        }
    
        /**
         * Checks if `value` is in `cache`.
         *
         * @private
         * @param {Object} cache The set cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function cacheHas(cache, value) {
          var map = cache.__data__;
          if (isKeyable(value)) {
            var data = map.__data__,
                hash = typeof value == 'string' ? data.string : data.hash;
    
            return hash[value] === HASH_UNDEFINED;
          }
          return map.has(value);
        }
    
        /**
         * Adds `value` to the set cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
          var map = this.__data__;
          if (isKeyable(value)) {
            var data = map.__data__,
                hash = typeof value == 'string' ? data.string : data.hash;
    
            hash[value] = HASH_UNDEFINED;
          }
          else {
            map.set(value, HASH_UNDEFINED);
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function Stack(values) {
          var index = -1,
              length = values ? values.length : 0;
    
          this.clear();
          while (++index < length) {
            var entry = values[index];
            this.set(entry[0], entry[1]);
          }
        }
    
        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = { 'array': [], 'map': null };
        }
    
        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              array = data.array;
    
          return array ? assocDelete(array, key) : data.map['delete'](key);
        }
    
        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          var data = this.__data__,
              array = data.array;
    
          return array ? assocGet(array, key) : data.map.get(key);
        }
    
        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          var data = this.__data__,
              array = data.array;
    
          return array ? assocHas(array, key) : data.map.has(key);
        }
    
        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache object.
         */
        function stackSet(key, value) {
          var data = this.__data__,
              array = data.array;
    
          if (array) {
            if (array.length < (LARGE_ARRAY_SIZE - 1)) {
              assocSet(array, key, value);
            } else {
              data.array = null;
              data.map = new MapCache(array);
            }
          }
          var map = data.map;
          if (map) {
            map.set(key, value);
          }
          return this;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Removes `key` and its value from the associative array.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function assocDelete(array, key) {
          var index = assocIndexOf(array, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = array.length - 1;
          if (index == lastIndex) {
            array.pop();
          } else {
            splice.call(array, index, 1);
          }
          return true;
        }
    
        /**
         * Gets the associative array value for `key`.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function assocGet(array, key) {
          var index = assocIndexOf(array, key);
          return index < 0 ? undefined : array[index][1];
        }
    
        /**
         * Checks if an associative array value for `key` exists.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function assocHas(array, key) {
          return assocIndexOf(array, key) > -1;
        }
    
        /**
         * Gets the index at which the first occurrence of `key` is found in `array`
         * of key-value pairs.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
    
        /**
         * Sets the associative array `key` to `value`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         */
        function assocSet(array, key, value) {
          var index = assocIndexOf(array, key);
          if (index < 0) {
            array.push([key, value]);
          } else {
            array[index][1] = value;
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Used by `_.defaults` to customize its `_.assignIn` use.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function assignInDefaults(objValue, srcValue, key, object) {
          if (objValue === undefined ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }
    
        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined && !eq(object[key], value)) ||
              (typeof key == 'number' && value === undefined && !(key in object))) {
            object[key] = value;
          }
        }
    
        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined && !(key in object))) {
            object[key] = value;
          }
        }
    
        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }
    
        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
    
        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths of elements to pick.
         * @returns {Array} Returns the new array of picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              isNil = object == null,
              length = paths.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = isNil ? undefined : get(object, paths[index]);
          }
          return result;
        }
    
        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the array-like object.
         */
        function baseCastArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
    
        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the array-like object.
         */
        function baseCastFunction(value) {
          return typeof value == 'function' ? value : identity;
        }
    
        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast property path array.
         */
        function baseCastPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
    
        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
    
        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {boolean} [isFull] Specify a clone including symbols.
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;
    
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              if (isHostObject(value)) {
                return object ? value : {};
              }
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                result = baseAssign(result, value);
                return isFull ? copySymbols(value, result) : result;
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);
    
          // Recursively populate clone (susceptible to call stack limits).
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
          });
          return (isFull && !isArr) ? copySymbols(value, result) : result;
        }
    
        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new function.
         */
        function baseConforms(source) {
          var props = keys(source),
              length = props.length;
    
          return function(object) {
            if (object == null) {
              return !length;
            }
            var index = length;
            while (index--) {
              var key = props[index],
                  predicate = source[key],
                  value = object[key];
    
              if ((value === undefined && !(key in Object(object))) || !predicate(value)) {
                return false;
              }
            }
            return true;
          };
        }
    
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        function baseCreate(proto) {
          return isObject(proto) ? objectCreate(proto) : {};
        }
    
        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an array
         * of `func` arguments.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments to provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }
    
        /**
         * The base implementation of methods like `_.difference` without support for
         * excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;
    
          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
    
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);
    
        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);
    
        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
    
        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;
    
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, isStrict, result) {
          result || (result = []);
    
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && isArrayLikeObject(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();
    
        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);
    
        /**
         * The base implementation of `_.forIn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
          return object == null ? object : baseFor(object, iteratee, keysIn);
        }
    
        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the new array of filtered property names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
    
        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = isKey(path, object) ? [path + ''] : baseCastPath(path);
    
          var index = 0,
              length = path.length;
    
          while (object != null && index < length) {
            object = object[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
    
        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
          // that are composed entirely of index properties, return `false` for
          // `hasOwnProperty` checks of them.
          return hasOwnProperty.call(object, key) ||
            (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
        }
    
        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return key in Object(object);
        }
    
        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
    
        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];
    
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined;
          }
          array = arrays[0];
    
          var index = -1,
              seen = caches[0];
    
          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
    
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }
    
        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          if (!isKey(path, object)) {
            path = baseCastPath(path);
            object = parent(object, path);
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : apply(func, object, args);
        }
    
        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {boolean} [bitmask] The bitmask of comparison flags.
         *  The bitmask may be composed of the following flags:
         *     1 - Unordered comparison
         *     2 - Partial comparison
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, bitmask, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
    
        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
    
          if (!objIsArr) {
            objTag = getTag(object);
            objTag = objTag == argsTag ? objectTag : objTag;
          }
          if (!othIsArr) {
            othTag = getTag(other);
            othTag = othTag == argsTag ? objectTag : othTag;
          }
          var objIsObj = objTag == objectTag && !isHostObject(object),
              othIsObj = othTag == objectTag && !isHostObject(other),
              isSameTag = objTag == othTag;
    
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
              : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
          }
          if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    
            if (objIsWrapped || othIsWrapped) {
              stack || (stack = new Stack);
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, bitmask, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
    
        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
    
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
    
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack,
                  result = customizer ? customizer(objValue, srcValue, key, object, source, stack) : undefined;
    
              if (!(result === undefined
                    ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }
    
        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          var type = typeof value;
          if (type == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (type == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }
    
        /**
         * The base implementation of `_.keys` which doesn't skip the constructor
         * property of prototypes or treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          return nativeKeys(Object(object));
        }
    
        /**
         * The base implementation of `_.keysIn` which doesn't skip the constructor
         * property of prototypes or treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          object = object == null ? object : Object(object);
    
          var result = [];
          for (var key in object) {
            result.push(key);
          }
          return result;
        }
    
        // Fallback for IE < 9 with es6-shim.
        if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
          baseKeysIn = function(object) {
            return iteratorToArray(enumerate(object));
          };
        }
    
        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
    
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === value &&
                (value !== undefined || (key in Object(object)));
            };
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
    
        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined && objValue === srcValue)
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
          };
        }
    
        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          var props = (isArray(source) || isTypedArray(source))
            ? undefined
            : keysIn(source);
    
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObject(srcValue)) {
              stack || (stack = new Stack);
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(object[key], srcValue, (key + ''), object, source, stack)
                : undefined;
    
              if (newValue === undefined) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          });
        }
    
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = object[key],
              srcValue = source[key],
              stacked = stack.get(srcValue);
    
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined;
    
          var isCommon = newValue === undefined;
    
          if (isCommon) {
            newValue = srcValue;
            if (isArray(srcValue) || isTypedArray(srcValue)) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else {
                isCommon = false;
                newValue = baseClone(srcValue, !customizer);
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
                isCommon = false;
                newValue = baseClone(srcValue, !customizer);
              }
              else {
                newValue = objValue;
              }
            }
            else {
              isCommon = false;
            }
          }
          stack.set(srcValue, newValue);
    
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          }
          stack['delete'](srcValue);
          assignMergeValue(object, key, newValue);
        }
    
        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          var index = -1;
          iteratees = arrayMap(iteratees.length ? iteratees : Array(1), getIteratee());
    
          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });
    
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
    
        /**
         * The base implementation of `_.pick` without support for individual
         * property names.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, props) {
          object = Object(object);
          return arrayReduce(props, function(result, key) {
            if (key in object) {
              result[key] = object[key];
            }
            return result;
          }, {});
        }
    
        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key) {
            if (predicate(value, key)) {
              result[key] = value;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : object[key];
          };
        }
    
        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
    
        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;
    
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;
    
            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
    
        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;
    
          while (length--) {
            var index = indexes[length];
            if (lastIndex == length || index != previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              }
              else if (!isKey(index, array)) {
                var path = baseCastPath(index),
                    object = parent(array, path);
    
                if (object != null) {
                  delete object[last(path)];
                }
              }
              else {
                delete array[index];
              }
            }
          }
          return array;
        }
    
        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
    
        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments to numbers.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the new array of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
    
          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }
    
        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          path = isKey(path, object) ? [path + ''] : baseCastPath(path);
    
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
    
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              var newValue = value;
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                if (newValue === undefined) {
                  newValue = objValue == null
                    ? (isIndex(path[index + 1]) ? [] : {})
                    : objValue;
                }
              }
              assignValue(nested, key, newValue);
            }
            nested = nested[key];
          }
          return object;
        }
    
        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
    
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
    
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
    
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
         */
        function baseSome(collection, predicate) {
          var result;
    
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
    
        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
    
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
    
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
    
        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
    
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
    
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
    
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
    
        /**
         * The base implementation of `_.sortedUniq`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array) {
          return baseSortedUniqBy(array);
        }
    
        /**
         * The base implementation of `_.sortedUniqBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniqBy(array, iteratee) {
          var index = 0,
              length = array.length,
              value = array[0],
              computed = iteratee ? iteratee(value) : value,
              seen = computed,
              resIndex = 1,
              result = [value];
    
          while (++index < length) {
            value = array[index],
            computed = iteratee ? iteratee(value) : value;
    
            if (!eq(computed, seen)) {
              seen = computed;
              result[resIndex++] = value;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;
    
          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;
    
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = isKey(path, object) ? [path + ''] : baseCastPath(path);
          object = parent(object, path);
          var key = last(path);
          return (object != null && has(object, key)) ? delete object[key] : true;
        }
    
        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
    
        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
    
          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}
    
          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
    
        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }
    
        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var index = -1,
              length = arrays.length;
    
          while (++index < length) {
            var result = result
              ? arrayPush(
                  baseDifference(result, arrays[index], iteratee, comparator),
                  baseDifference(arrays[index], result, iteratee, comparator)
                )
              : arrays[index];
          }
          return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
        }
    
        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property names.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};
    
          while (++index < length) {
            assignFunc(result, props[index], index < valsLength ? values[index] : undefined);
          }
          return result;
        }
    
        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var result = new buffer.constructor(buffer.length);
          buffer.copy(result);
          return result;
        }
    
        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }
    
        /**
         * Creates a clone of `map`.
         *
         * @private
         * @param {Object} map The map to clone.
         * @returns {Object} Returns the cloned map.
         */
        function cloneMap(map) {
          return arrayReduce(mapToArray(map), addMapEntry, new map.constructor);
        }
    
        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
    
        /**
         * Creates a clone of `set`.
         *
         * @private
         * @param {Object} set The set to clone.
         * @returns {Object} Returns the cloned set.
         */
        function cloneSet(set) {
          return arrayReduce(setToArray(set), addSetEntry, new set.constructor);
        }
    
        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }
    
        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
    
        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;
    
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;
    
          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }
    
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;
    
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
    
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object) {
          return copyObjectWith(source, props, object);
        }
    
        /**
         * This function is like `copyObject` except that it accepts a function to
         * customize copied values.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObjectWith(source, props, object, customizer) {
          object || (object = {});
    
          var index = -1,
              length = props.length;
    
          while (++index < length) {
            var key = props[index];
    
            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : source[key];
    
            assignValue(object, key, newValue);
          }
          return object;
        }
    
        /**
         * Copies own symbol properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
    
        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};
    
            return func(collection, setter, getIteratee(iteratee), accumulator);
          };
        }
    
        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return rest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
    
            customizer = typeof customizer == 'function'
              ? (length--, customizer)
              : undefined;
    
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
    
        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);
    
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
    
        /**
         * Creates a base function for methods like `_.forIn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
    
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
    
        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBaseWrapper(func, bitmask, thisArg) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
    
        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
    
            var strSymbols = reHasComplexSymbol.test(string)
              ? stringToArray(string)
              : undefined;
    
            var chr = strSymbols ? strSymbols[0] : string.charAt(0),
                trailing = strSymbols ? strSymbols.slice(1).join('') : string.slice(1);
    
            return chr[methodName]() + trailing;
          };
        }
    
        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string)), callback, '');
          };
        }
    
        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors.
            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
    
            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }
    
        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurryWrapper(func, bitmask, arity) {
          var Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getPlaceholder(wrapper);
    
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);
    
            length -= holders.length;
            if (length < arity) {
              return createRecurryWrapper(
                func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
                args, holders, undefined, undefined, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return rest(function(funcs) {
            funcs = baseFlatten(funcs, 1);
    
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;
    
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
    
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
    
              if (data && isLaziable(data[0]) &&
                    data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
    
              if (wrapper && args.length == 1 &&
                  isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
    
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }
    
        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
              isFlip = bitmask & FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
    
          function wrapper() {
            var length = arguments.length,
                index = length,
                args = Array(length);
    
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getPlaceholder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurryWrapper(
                func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
    
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }
    
        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new invoker function.
         */
        function createOver(arrayFunc) {
          return rest(function(iteratees) {
            iteratees = arrayMap(baseFlatten(iteratees, 1), getIteratee());
            return rest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }
    
        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {string} string The string to create padding for.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(string, length, chars) {
          length = toInteger(length);
    
          var strLength = stringSize(string);
          if (!length || strLength >= length) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars === undefined ? ' ' : (chars + '');
    
          var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));
          return reHasComplexSymbol.test(chars)
            ? stringToArray(result).slice(0, padLength).join('')
            : result.slice(0, padLength);
        }
    
        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg` and the `partials` prepended to those provided to
         * the wrapper.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            // Ensure the sign of `-0` is preserved.
            start = toNumber(start);
            start = start === start ? start : 0;
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toNumber(end) || 0;
            }
            step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);
            return baseRange(start, end, step, fromRight);
          };
        }
    
        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & CURRY_FLAG,
              newArgPos = argPos ? copyArray(argPos) : undefined,
              newHolders = isCurry ? holders : undefined,
              newHoldersRight = isCurry ? undefined : holders,
              newPartials = isCurry ? partials : undefined,
              newPartialsRight = isCurry ? undefined : partials;
    
          bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
    
          if (!(bitmask & CURRY_BOUND_FLAG)) {
            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, newArgPos, ary, arity
          ];
    
          var result = wrapFunc.apply(undefined, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return result;
        }
    
        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = toInteger(precision);
            if (precision) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));
    
              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }
    
        /**
         * Creates a set of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {
          return new Set(values);
        };
    
        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask of wrapper flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
    
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
    
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func);
    
          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];
    
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] == null
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);
    
          if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
            bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == BIND_FLAG) {
            var result = createBaseWrapper(func, bitmask, thisArg);
          } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
            result = createCurryWrapper(func, bitmask, arity);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
            result = createPartialWrapper(func, bitmask, thisArg, partials);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} customizer The function to customize comparisons.
         * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
          var index = -1,
              isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
              arrLength = array.length,
              othLength = other.length;
    
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(array);
          if (stacked) {
            return stacked == other;
          }
          var result = true;
          stack.set(array, other);
    
          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];
    
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (isUnordered) {
              if (!arraySome(other, function(othValue) {
                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);
                  })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          return result;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} customizer The function to customize comparisons.
         * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
          switch (tag) {
            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
    
            case boolTag:
            case dateTag:
              // Coerce dates and booleans to numbers, dates to milliseconds and booleans
              // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
              return +object == +other;
    
            case errorTag:
              return object.name == other.name && object.message == other.message;
    
            case numberTag:
              // Treat `NaN` vs. `NaN` as equal.
              return (object != +object) ? other != +other : object == +other;
    
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings primitives and string
              // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
              return object == (other + '');
    
            case mapTag:
              var convert = mapToArray;
    
            case setTag:
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
              convert || (convert = setToArray);
    
              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              // Recursively compare objects (susceptible to call stack limits).
              return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask | UNORDERED_COMPARE_FLAG, stack.set(object, other));
    
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} customizer The function to customize comparisons.
         * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
              objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
    
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : baseHas(other, key))) {
              return false;
            }
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
    
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];
    
            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined
                  ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
    
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          return result;
        }
    
        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
    
        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;
    
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
    
        /**
         * Gets the appropriate "iteratee" function. If the `_.iteratee` method is
         * customized this function returns the custom method, otherwise it returns
         * `baseIteratee`. If arguments are provided the chosen function is invoked
         * with them and its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }
    
        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');
    
        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = toPairs(object),
              length = result.length;
    
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
    
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = object[key];
          return isNative(value) ? value : undefined;
        }
    
        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getPlaceholder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }
    
        /**
         * Creates an array of the own symbol properties of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = getOwnPropertySymbols || function() {
          return [];
        };
    
        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function getTag(value) {
          return objectToString.call(value);
        }
    
        // Fallback for IE 11 providing `toStringTag` values for maps, sets, and weakmaps.
        if ((Map && getTag(new Map) != mapTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = objectToString.call(value),
                Ctor = result == objectTag ? value.constructor : null,
                ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';
    
            if (ctorString) {
              switch (ctorString) {
                case mapCtorString: return mapTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }
    
        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
    
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
    
            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }
    
        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          if (object == null) {
            return false;
          }
          var result = hasFunc(object, path);
          if (!result && !isKey(path)) {
            path = baseCastPath(path);
            object = parent(object, path);
            if (object != null) {
              path = last(path);
              result = hasFunc(object, path);
            }
          }
          var length = object ? object.length : undefined;
          return result || (
            !!length && isLength(length) && isIndex(path, length) &&
            (isArray(object) || isString(object) || isArguments(object))
          );
        }
    
        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = array.constructor(length);
    
          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
    
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototypeOf(object))
            : {};
        }
    
        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
    
            case boolTag:
            case dateTag:
              return new Ctor(+object);
    
            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);
    
            case mapTag:
              return cloneMap(object);
    
            case numberTag:
            case stringTag:
              return new Ctor(object);
    
            case regexpTag:
              return cloneRegExp(object);
    
            case setTag:
              return cloneSet(object);
    
            case symbolTag:
              return cloneSymbol(object);
          }
        }
    
        /**
         * Creates an array of index keys for `object` values of arrays,
         * `arguments` objects, and strings, otherwise `null` is returned.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array|null} Returns index keys, else `null`.
         */
        function indexKeys(object) {
          var length = object ? object.length : undefined;
          if (isLength(length) &&
              (isArray(object) || isString(object) || isArguments(object))) {
            return baseTimes(length, String);
          }
          return null;
        }
    
        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
            return eq(object[index], value);
          }
          return false;
        }
    
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (typeof value == 'number') {
            return true;
          }
          return !isArray(value) &&
            (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
              (object != null && value in Object(object)));
        }
    
        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return type == 'number' || type == 'boolean' ||
            (type == 'string' && value != '__proto__') || value == null;
        }
    
        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];
    
          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
    
        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
          return value === proto;
        }
    
        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
    
        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * modify function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * combined case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);
    
          var isCombo =
            ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
            ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));
    
          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : copyArray(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : copyArray(source[4]);
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : copyArray(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : copyArray(source[6]);
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = copyArray(value);
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;
    
          return data;
        }
    
        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
         * @returns {*} Returns the value to assign.
         */
        function mergeDefaults(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            baseMerge(objValue, srcValue, undefined, mergeDefaults, stack.set(srcValue, objValue));
          }
          return objValue;
        }
    
        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length == 1 ? object : get(object, baseSlice(path, 0, -1));
        }
    
        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);
    
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
    
        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
    
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
    
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
    
        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        function stringToPath(string) {
          var result = [];
          toString(string).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
    
        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=0] The length of each chunk.
         * @returns {Array} Returns the new array containing chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size) {
          size = nativeMax(toInteger(size), 0);
    
          var length = array ? array.length : 0;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));
    
          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }
    
        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = 0,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
    
        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        var concat = rest(function(array, values) {
          if (!isArray(array)) {
            array = array == null ? [] : [Object(array)];
          }
          values = baseFlatten(values, 1);
          return arrayConcat(array, values);
        });
    
        /**
         * Creates an array of unique `array` values not included in the other
         * given arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. The order of result values is determined by the
         * order they occur in the first array.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.difference([3, 2, 1], [4, 2]);
         * // => [3, 1]
         */
        var difference = rest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, true))
            : [];
        });
    
        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. Result values are chosen from the first array.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);
         * // => [3.1, 1.3]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = rest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, true), getIteratee(iteratee))
            : [];
        });
    
        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. Result values
         * are chosen from the first array. The comparator is invoked with two arguments:
         * (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = rest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, true), undefined, comparator)
            : [];
        });
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }
    
        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
    
        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate) {
          return (array && array.length)
            ? baseFindIndex(array, getIteratee(predicate, 3))
            : -1;
        }
    
        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate) {
          return (array && array.length)
            ? baseFindIndex(array, getIteratee(predicate, 3), true)
            : -1;
        }
    
        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, 1) : [];
        }
    
        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, INFINITY) : [];
        }
    
        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
    
        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['fred', 30], ['barney', 40]]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs ? pairs.length : 0,
              result = {};
    
          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }
    
        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return array ? array[0] : undefined;
        }
    
        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the offset
         * from the end of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          fromIndex = toInteger(fromIndex);
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return baseIndexOf(array, value, fromIndex);
        }
    
        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          return dropRight(array, 1);
        }
    
        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. The order of result values is determined by the
         * order they occur in the first array.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [4, 2], [1, 2]);
         * // => [2]
         */
        var intersection = rest(function(arrays) {
          var mapped = arrayMap(arrays, baseCastArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });
    
        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. Result values are chosen from the first array.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = rest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, baseCastArrayLikeObject);
    
          if (iteratee === last(mapped)) {
            iteratee = undefined;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee))
            : [];
        });
    
        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. Result values are chosen
         * from the first array. The comparator is invoked with two arguments:
         * (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = rest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, baseCastArrayLikeObject);
    
          if (comparator === last(mapped)) {
            comparator = undefined;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined, comparator)
            : [];
        });
    
        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array ? nativeJoin.call(array, separator) : '';
        }
    
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
    
        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pull(array, 2, 3);
         * console.log(array);
         * // => [1, 1]
         */
        var pull = rest(pullAll);
    
        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pullAll(array, [2, 3]);
         * console.log(array);
         * // => [1, 1]
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }
    
        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee))
            : array;
        }
    
        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined, comparator)
            : array;
        }
    
        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove,
         *  specified individually or in arrays.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [5, 10, 15, 20];
         * var evens = _.pullAt(array, 1, 3);
         *
         * console.log(array);
         * // => [5, 15]
         *
         * console.log(evens);
         * // => [10, 20]
         */
        var pullAt = rest(function(array, indexes) {
          indexes = arrayMap(baseFlatten(indexes, 1), String);
    
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(compareAscending));
          return result;
        });
    
        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
    
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
    
        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @category Array
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array ? nativeReverse.call(array) : array;
        }
    
        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of [`Array#slice`](https://mdn.io/Array/slice)
         * to ensure dense arrays are returned.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
    
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 5], 4);
         * // => 0
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
    
        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };
         *
         * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee));
        }
    
        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([1, 1, 2, 2], 2);
         * // => 2
         */
        function sortedIndexOf(array, value) {
          var length = array ? array.length : 0;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5], 4);
         * // => 1
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
    
        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted into `array`.
         * @example
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee), true);
        }
    
        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([1, 1, 2, 2], 2);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array ? array.length : 0;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }
    
        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniqBy(array, getIteratee(iteratee))
            : [];
        }
    
        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          return drop(array, 1);
        }
    
        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
    
        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with three
         * arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false},
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }
    
        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2, 1], [4, 2], [1, 2]);
         * // => [2, 1, 4]
         */
        var union = rest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, true));
        });
    
        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by which
         * uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);
         * // => [2.1, 1.2, 4.3]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = rest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, true), getIteratee(iteratee));
        });
    
        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = rest(function(arrays) {
          var comparator = last(arrays);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, true), undefined, comparator);
        });
    
        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length)
            ? baseUniq(array)
            : [];
        }
    
        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length)
            ? baseUniq(array, getIteratee(iteratee))
            : [];
        }
    
        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The comparator is invoked with
         * two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          return (array && array.length)
            ? baseUniq(array, undefined, comparator)
            : [];
        }
    
        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         *
         * _.unzip(zipped);
         * // => [['fred', 'barney'], [30, 40], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
    
        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined, group);
          });
        }
    
        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to filter.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 3], 1, 2);
         * // => [3]
         */
        var without = rest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });
    
        /**
         * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * _.xor([2, 1], [4, 2]);
         * // => [1, 4]
         */
        var xor = rest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
    
        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by which
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);
         * // => [1.2, 4.3]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = rest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));
        });
    
        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The comparator is invoked with
         * two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = rest(function(arrays) {
          var comparator = last(arrays);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });
    
        /**
         * Creates an array of grouped elements, the first of which contains the first
         * elements of the given arrays, the second of which contains the second elements
         * of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         */
        var zip = rest(unzip);
    
        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property names and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} [props=[]] The property names.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }
    
        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} [props=[]] The property names.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }
    
        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = rest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined;
    
          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
          return unzipWith(arrays, iteratee);
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object that wraps `value` with explicit method chaining enabled.
         * The result of such method chaining must be unwrapped with `_#value`.
         *
         * @static
         * @memberOf _
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
    
        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
    
        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain.
         *
         * @static
         * @memberOf _
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }
    
        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths of elements to pick,
         *  specified individually or in arrays.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         *
         * _(['a', 'b', 'c']).at(0, 2).value();
         * // => ['a', 'c']
         */
        var wrapperAt = rest(function(paths) {
          paths = baseFlatten(paths, 1);
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };
    
          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined);
            }
            return array;
          });
        });
    
        /**
         * Enables explicit method chaining on the wrapper object.
         *
         * @name chain
         * @memberOf _
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }
    
        /**
         * Executes the chained sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
    
        /**
         * This method is the wrapper version of `_.flatMap`.
         *
         * @name flatMap
         * @memberOf _
         * @category Seq
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _([1, 2]).flatMap(duplicate).value();
         * // => [1, 1, 2, 2]
         */
        function wrapperFlatMap(iteratee) {
          return this.map(iteratee).flatten();
        }
    
        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined : this.__values__[this.__index__++];
    
          return { 'done': done, 'value': value };
        }
    
        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }
    
        /**
         * Creates a clone of the chained sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;
    
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
    
        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
    
        /**
         * Executes the chained sequence to extract the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the number of times the key was returned by `iteratee`.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
    
        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
    
        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three arguments:
         * (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
    
        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three arguments:
         * (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        function find(collection, predicate) {
          predicate = getIteratee(predicate, 3);
          if (isArray(collection)) {
            var index = baseFindIndex(collection, predicate);
            return index > -1 ? collection[index] : undefined;
          }
          return baseFind(collection, predicate, baseEach);
        }
    
        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        function findLast(collection, predicate) {
          predicate = getIteratee(predicate, 3);
          if (isArray(collection)) {
            var index = baseFindIndex(collection, predicate, true);
            return index > -1 ? collection[index] : undefined;
          }
          return baseFind(collection, predicate, baseEachRight);
        }
    
        /**
         * Creates an array of flattened values by running each element in `collection`
         * through `iteratee` and concating its result to the other mapped values.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }
    
        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior use `_.forIn` or `_.forOwn`
         * for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(value) {
         *   console.log(value);
         * });
         * // => logs `1` then `2`
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a' then 'b' (iteration order is not guaranteed)
         */
        function forEach(collection, iteratee) {
          return (typeof iteratee == 'function' && isArray(collection))
            ? arrayEach(collection, iteratee)
            : baseEach(collection, baseCastFunction(iteratee));
        }
    
        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => logs `2` then `1`
         */
        function forEachRight(collection, iteratee) {
          return (typeof iteratee == 'function' && isArray(collection))
            ? arrayEachRight(collection, iteratee)
            : baseEachRight(collection, baseCastFunction(iteratee));
        }
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of elements responsible for generating the key.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
    
        /**
         * Checks if `value` is in `collection`. If `collection` is a string it's checked
         * for a substring of `value`, otherwise [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.includes('pebbles', 'eb');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
    
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }
    
        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `methodName` is a function it's
         * invoked for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = rest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
    
        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `curry`, `curryRight`, `drop`, `dropRight`, `every`, `fill`,
         * `invert`, `parseInt`, `random`, `range`, `rangeRight`, `slice`, `some`,
         * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimEnd`, `trimStart`,
         * and `words`
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }
    
        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} [iteratees=[_.identity]] The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
    
        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });
    
        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;
    
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }
    
        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;
    
          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }
    
        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getIteratee(predicate, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
    
        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var array = isArrayLike(collection) ? collection : values(collection),
              length = array.length;
    
          return length > 0 ? array[baseRandom(0, length - 1)] : undefined;
        }
    
        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=0] The number of elements to sample.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n) {
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
    
          n = baseClamp(toInteger(n), 0, length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
    
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
    
        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          return sampleSize(collection, MAX_ARRAY_LENGTH);
        }
    
        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            var result = collection.length;
            return (result && isString(collection)) ? stringSize(collection) : result;
          }
          return keys(collection).length;
        }
    
        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }
    
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[]|Object|Object[]|string|string[])} [iteratees=[_.identity]]
         *  The iteratees to sort by, specified individually or in arrays.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, function(o) { return o.user; });
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
         *
         * _.sortBy(users, 'user', function(o) {
         *   return Math.floor(o.age / 10);
         * });
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        var sortBy = rest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees.length = 1;
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @type {Function}
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = Date.now;
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => logs 'done saving!' after the two async saves have completed
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
    
        /**
         * Creates a function that accepts up to `n` arguments, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Function} Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined : n;
          n = (func && n == null) ? func.length : n;
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
    
        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => allows adding up to 4 contacts to the list
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = rest(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getPlaceholder(bind));
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
    
        /**
         * Creates a function that invokes the method at `object[key]` and prepends
         * any additional `_.bindKey` arguments to those provided to the bound function.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist.
         * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = rest(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getPlaceholder(bindKey));
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
    
        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curry.placeholder;
          return result;
        }
    
        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined : arity;
          var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }
    
        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide an options object to indicate whether `func` should be invoked on
         * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent calls
         * to the debounced function return the result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it's invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              leading = false,
              maxWait = false,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
    
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;
          }
    
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
    
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
    
          function flush() {
            if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {
              result = func.apply(thisArg, args);
            }
            cancel();
            return result;
          }
    
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
    
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
    
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!lastCalled && !maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled);
    
              var isCalled = (remaining <= 0 || remaining > maxWait) &&
                (leading || maxTimeoutId);
    
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              }
              else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            }
            else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
    
        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => logs 'deferred' after one or more milliseconds
         */
        var defer = rest(function(func, args) {
          return baseDelay(func, 1, args);
        });
    
        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => logs 'later' after one second
         */
        var delay = rest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
    
        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrapper(func, FLIP_FLAG);
        }
    
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoizing function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
    
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
    
        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
    
        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // `initialize` invokes `createApplication` once
         */
        function once(func) {
          return before(2, func);
        }
    
        /**
         * Creates a function that invokes `func` with arguments transformed by
         * corresponding `transforms`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms] The functions to transform
         * arguments, specified individually or in arrays.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, square, doubled);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = rest(function(func, transforms) {
          transforms = arrayMap(baseFlatten(transforms, 1), getIteratee());
    
          var funcsLength = transforms.length;
          return rest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);
    
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
    
        /**
         * Creates a function that invokes `func` with `partial` arguments prepended
         * to those provided to the new function. This method is like `_.bind` except
         * it does **not** alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = rest(function(func, partials) {
          var holders = replaceHolders(partials, getPlaceholder(partial));
          return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);
        });
    
        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to those provided to the new function.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = rest(function(func, partials) {
          var holders = replaceHolders(partials, getPlaceholder(partialRight));
          return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });
    
        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified indexes where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes,
         *  specified individually or in arrays.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, 2, 0, 1);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = rest(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes, 1));
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
    
            while (++index < length) {
              array[index] = args[start + index];
            }
            switch (start) {
              case 0: return func.call(this, array);
              case 1: return func.call(this, args[0], array);
              case 2: return func.call(this, args[0], args[1], array);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = array;
            return apply(func, this, otherArgs);
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the created
         * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
         *
         * **Note:** This method is based on the [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
          return rest(function(args) {
            var array = args[start],
                otherArgs = args.slice(0, start);
    
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
    
        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide an options object to indicate whether
         * `func` should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the throttled function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=true] Specify invoking on the leading
         *  edge of the timeout.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }
    
        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }
    
        /**
         * Creates a function that provides `value` to the wrapper function as its
         * first argument. Any additional arguments provided to the function are
         * appended to those provided to the wrapper function. The wrapper is invoked
         * with the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return partial(wrapper, value);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
    
        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, false, true);
        }
    
        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          return baseClone(value, false, true, customizer);
        }
    
        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, true, true);
        }
    
        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          return baseClone(value, true, true, customizer);
        }
    
        /**
         * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }
    
        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        function gt(value, other) {
          return value > other;
        }
    
        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        function gte(value, other) {
          return value >= other;
        }
    
        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
          // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
          return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
            (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
        }
    
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @type {Function}
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
    
        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        function isArrayBuffer(value) {
          return isObjectLike(value) && objectToString.call(value) == arrayBufferTag;
        }
    
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(getLength(value)) && !isFunction(value);
        }
    
        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
    
        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && objectToString.call(value) == boolTag);
        }
    
        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = !Buffer ? constant(false) : function(value) {
          return value instanceof Buffer;
        };
    
        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        function isDate(value) {
          return isObjectLike(value) && objectToString.call(value) == dateTag;
        }
    
        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
    
        /**
         * Checks if `value` is an empty collection or object. A value is considered
         * empty if it's an `arguments` object, array, string, or jQuery-like collection
         * with a length of `0` or has no own enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (isArrayLike(value) &&
              (isArray(value) || isString(value) ||
                isFunction(value.splice) || isArguments(value))) {
            return !value.length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are **not** supported.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
    
        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined` comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
    
        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          return (objectToString.call(value) == errorTag) ||
            (typeof value.message == 'string' && typeof value.name == 'string');
        }
    
        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MAX_VALUE);
         * // => true
         *
         * _.isFinite(3.14);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
    
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 8 which returns 'object' for typed array and weak map constructors,
          // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
          var tag = isObject(value) ? objectToString.call(value) : '';
          return tag == funcTag || tag == genTag;
        }
    
        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }
    
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
    
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
    
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return !!value && typeof value == 'object';
        }
    
        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        function isMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
    
        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values. This method is
         * equivalent to a `_.matches` function when `source` is partially applied.
         *
         * **Note:** This method supports comparing the same values as `_.isEqual`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.isMatch(object, { 'age': 40 });
         * // => true
         *
         * _.isMatch(object, { 'age': 36 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
    
        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined` comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
    
        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
         * which returns `true` for `undefined` and other non-numeric values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }
    
        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(funcToString.call(value));
          }
          return isObjectLike(value) &&
            (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
        }
    
        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }
    
        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }
    
        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && objectToString.call(value) == numberTag);
        }
    
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) ||
              objectToString.call(value) != objectTag || isHostObject(value)) {
            return false;
          }
          var proto = getPrototypeOf(value);
          if (proto === null) {
            return true;
          }
          var Ctor = proto.constructor;
          return (typeof Ctor == 'function' &&
            Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
        }
    
        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        function isRegExp(value) {
          return isObject(value) && objectToString.call(value) == regexpTag;
        }
    
        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
    
        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        function isSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
    
        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
        }
    
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && objectToString.call(value) == symbolTag);
        }
    
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
    
        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }
    
        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
    
        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && objectToString.call(value) == weakSetTag;
        }
    
        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        function lt(value, other) {
          return value < other;
        }
    
        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        function lte(value, other) {
          return value <= other;
        }
    
        /**
         * Converts `value` to an array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (iteratorSymbol && value[iteratorSymbol]) {
            return iteratorToArray(value[iteratorSymbol]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
    
          return func(value);
        }
    
        /**
         * Converts `value` to an integer.
         *
         * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3');
         * // => 3
         */
        function toInteger(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          var remainder = value % 1;
          return value === value ? (remainder ? value - remainder : value) : 0;
        }
    
        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
    
        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3);
         * // => 3
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3');
         * // => 3
         */
        function toNumber(value) {
          if (isObject(value)) {
            var other = isFunction(value.valueOf) ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, '');
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }
    
        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
    
        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3');
         * // => 3
         */
        function toSafeInteger(value) {
          return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        }
    
        /**
         * Converts `value` to a string if it's not one. An empty string is returned
         * for `null` and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (value == null) {
            return '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Assigns own enumerable properties of source objects to the destination
         * object. Source objects are applied from left to right. Subsequent sources
         * overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.c = 3;
         * }
         *
         * function Bar() {
         *   this.e = 5;
         * }
         *
         * Foo.prototype.d = 4;
         * Bar.prototype.f = 6;
         *
         * _.assign({ 'a': 1 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3, 'e': 5 }
         */
        var assign = createAssigner(function(object, source) {
          if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
    
        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * function Bar() {
         *   this.d = 4;
         * }
         *
         * Foo.prototype.c = 3;
         * Bar.prototype.e = 5;
         *
         * _.assignIn({ 'a': 1 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }
         */
        var assignIn = createAssigner(function(object, source) {
          if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keysIn(source), object);
            return;
          }
          for (var key in source) {
            assignValue(object, key, source[key]);
          }
        });
    
        /**
         * This method is like `_.assignIn` except that it accepts `customizer` which
         * is invoked to produce the assigned values. If `customizer` returns `undefined`
         * assignment is handled by the method instead. The `customizer` is invoked
         * with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObjectWith(source, keysIn(source), object, customizer);
        });
    
        /**
         * This method is like `_.assign` except that it accepts `customizer` which
         * is invoked to produce the assigned values. If `customizer` returns `undefined`
         * assignment is handled by the method instead. The `customizer` is invoked
         * with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObjectWith(source, keys(source), object, customizer);
        });
    
        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths of elements to pick,
         *  specified individually or in arrays.
         * @returns {Array} Returns the new array of picked elements.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         *
         * _.at(['a', 'b', 'c'], 0, 2);
         * // => ['a', 'c']
         */
        var at = rest(function(object, paths) {
          return baseAt(object, baseFlatten(paths, 1));
        });
    
        /**
         * Creates an object that inherits from the `prototype` object. If a `properties`
         * object is given its own enumerable properties are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties ? baseAssign(result, properties) : result;
        }
    
        /**
         * Assigns own and inherited enumerable properties of source objects to the
         * destination object for all destination properties that resolve to `undefined`.
         * Source objects are applied from left to right. Once a property is set,
         * additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var defaults = rest(function(args) {
          args.push(undefined, assignInDefaults);
          return apply(assignInWith, undefined, args);
        });
    
        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
         * // => { 'user': { 'name': 'barney', 'age': 36 } }
         *
         */
        var defaultsDeep = rest(function(args) {
          args.push(undefined, mergeDefaults);
          return apply(mergeWith, undefined, args);
        });
    
        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);
        }
    
        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);
        }
    
        /**
         * Iterates over own and inherited enumerable properties of an object invoking
         * `iteratee` for each property. The iteratee is invoked with three arguments:
         * (value, key, object). Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a', 'b', then 'c' (iteration order is not guaranteed)
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, baseCastFunction(iteratee), keysIn);
        }
    
        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, baseCastFunction(iteratee), keysIn);
        }
    
        /**
         * Iterates over own enumerable properties of an object invoking `iteratee`
         * for each property. The iteratee is invoked with three arguments:
         * (value, key, object). Iteratee functions may exit iteration early by
         * explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a' then 'b' (iteration order is not guaranteed)
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, baseCastFunction(iteratee));
        }
    
        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, baseCastFunction(iteratee));
        }
    
        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the new array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
    
        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the new array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
    
        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined` the `defaultValue` is used in its place.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, path);
          return result === undefined ? defaultValue : result;
        }
    
        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return hasPath(object, path, baseHas);
        }
    
        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b.c');
         * // => true
         *
         * _.hasIn(object, ['a', 'b', 'c']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return hasPath(object, path, baseHasIn);
        }
    
        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite property
         * assignments of previous values.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          result[value] = key;
        }, constant(identity));
    
        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` through `iteratee`.
         * The corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);
    
        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = rest(baseInvoke);
    
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          var isProto = isPrototype(object);
          if (!(isProto || isArrayLike(object))) {
            return baseKeys(object);
          }
          var indexes = indexKeys(object),
              skipIndexes = !!indexes,
              result = indexes || [],
              length = result.length;
    
          for (var key in object) {
            if (baseHas(object, key) &&
                !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
                !(isProto && key == 'constructor')) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          var index = -1,
              isProto = isPrototype(object),
              props = baseKeysIn(object),
              propsLength = props.length,
              indexes = indexKeys(object),
              skipIndexes = !!indexes,
              result = indexes || [],
              length = result.length;
    
          while (++index < propsLength) {
            var key = props[index];
            if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * property of `object` through `iteratee`. The iteratee is invoked with
         * three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);
    
          baseForOwn(object, function(value, key, object) {
            result[iteratee(value, key, object)] = value;
          });
          return result;
        }
    
        /**
         * Creates an object with the same keys as `object` and values generated by
         * running each own enumerable property of `object` through `iteratee`. The
         * iteratee is invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);
    
          baseForOwn(object, function(value, key, object) {
            result[key] = iteratee(value, key, object);
          });
          return result;
        }
    
        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable properties of source objects into the destination
         * object. Source properties that resolve to `undefined` are skipped if a
         * destination value exists. Array and plain object properties are merged
         * recursively.Other objects and value types are overridden by assignment.
         * Source objects are applied from left to right. Subsequent sources
         * overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
    
        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined` merging is handled by the
         * method instead. The `customizer` is invoked with seven arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
    
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [props] The property names to omit, specified
         *  individually or in arrays.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = rest(function(object, props) {
          if (object == null) {
            return {};
          }
          props = arrayMap(baseFlatten(props, 1), String);
          return basePick(object, baseDifference(keysIn(object), props));
        });
    
        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable properties of `object` that `predicate`
         * doesn't return truthy for. The predicate is invoked with two arguments:
         * (value, key).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          predicate = getIteratee(predicate);
          return basePickBy(object, function(value, key) {
            return !predicate(value, key);
          });
        }
    
        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [props] The property names to pick, specified
         *  individually or in arrays.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = rest(function(object, props) {
          return object == null ? {} : basePick(object, baseFlatten(props, 1));
        });
    
        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          return object == null ? {} : basePickBy(object, getIteratee(predicate));
        }
    
        /**
         * This method is like `_.get` except that if the resolved value is a function
         * it's invoked with the `this` binding of its parent object and its result
         * is returned.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          if (!isKey(path, object)) {
            path = baseCastPath(path);
            var result = get(object, path);
            object = parent(object, path);
          } else {
            result = object == null ? undefined : object[path];
          }
          if (result === undefined) {
            result = defaultValue;
          }
          return isFunction(result) ? result.call(object) : result;
        }
    
        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, 'x[0].y.z', 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
    
        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
    
        /**
         * Creates an array of own enumerable key-value pairs for `object` which
         * can be consumed by `_.fromPairs`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        function toPairs(object) {
          return baseToPairs(object, keys(object));
        }
    
        /**
         * Creates an array of own and inherited enumerable key-value pairs for
         * `object` which can be consumed by `_.fromPairs`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)
         */
        function toPairsIn(object) {
          return baseToPairs(object, keysIn(object));
        }
    
        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own enumerable
         * properties through `iteratee`, with each invocation potentially mutating
         * the `accumulator` object. The iteratee is invoked with four arguments:
         * (accumulator, value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getIteratee(iteratee, 4);
    
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototypeOf(object)) : {};
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
    
        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
    
        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, baseCastFunction(updater));
        }
    
        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseUpdate(object, path, baseCastFunction(updater), customizer);
        }
    
        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object ? baseValues(object, keys(object)) : [];
        }
    
        /**
         * Creates an array of the own and inherited enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined) {
            upper = lower;
            lower = undefined;
          }
          if (upper !== undefined) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
    
        /**
         * Checks if `n` is between `start` and up to but not including, `end`. If
         * `end` is not specified it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toNumber(start) || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toNumber(end) || 0;
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
    
        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are floats,
         * a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined;
          }
          if (floating === undefined) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined;
            }
          }
          if (lower === undefined && upper === undefined) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toNumber(lower) || 0;
            if (upper === undefined) {
              upper = lower;
              lower = 0;
            } else {
              upper = toNumber(upper) || 0;
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar');
         * // => 'fooBar'
         *
         * _.camelCase('__foo_bar__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });
    
        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
    
        /**
         * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
    
        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search from.
         * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = typeof target == 'string' ? target : (target + '');
    
          var length = string.length;
          position = position === undefined
            ? length
            : baseClamp(toInteger(position), 0, length);
    
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
    
        /**
         * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
         * their corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value.
         * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * Backticks are escaped because in IE < 9, they can break out of
         * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
         * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
         * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
         * for more details.
         *
         * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
         * to reduce XSS vectors.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }
    
        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }
    
        /**
         * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__foo_bar__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
    
        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });
    
        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');
    
        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');
    
        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
    
          var strLength = stringSize(string);
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
    
          return createPadding('', leftLength, chars) + string + createPadding('', rightLength, chars);
        }
    
        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          return string + createPadding(string, length, chars);
        }
    
        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          return createPadding(string, length, chars) + string;
        }
    
        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
         * in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#x15.1.2.2)
         * of `parseInt`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          // Chrome fails to trim leading <BOM> whitespace characters.
          // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = toString(string).replace(reTrim, '');
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
    
        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=0] The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n) {
          string = toString(string);
          n = toInteger(n);
    
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
    
          return result;
        }
    
        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);
    
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
    
        /**
         * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--foo-bar');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
    
        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the new array of string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          return toString(string).split(separator, limit);
        }
    
        /**
         * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__foo_bar__');
         * // => 'Foo Bar'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + capitalize(word);
        });
    
        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = baseClamp(toInteger(position), 0, string.length);
          return string.lastIndexOf(target, position) == position;
        }
    
        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options] The options object.
         * @param {RegExp} [options.escape] The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
         * @param {Object} [options.imports] An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
         * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
         * @param {string} [options.variable] The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES delimiter as an alternative to the default "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;
    
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, assignInDefaults);
    
          var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
    
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
    
          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');
    
          // Use a sourceURL for easier debugging.
          var sourceURL = '//# sourceURL=' +
            ('sourceURL' in options
              ? options.sourceURL
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';
    
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
    
            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    
            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
    
            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });
    
          source += "';\n";
    
          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');
    
          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';
    
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined, importsValues);
          });
    
          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
    
        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar');
         * // => '--foo-bar'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }
    
        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar');
         * // => '--FOO-BAR'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
    
        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (!string) {
            return string;
          }
          if (guard || chars === undefined) {
            return string.replace(reTrim, '');
          }
          chars = (chars + '');
          if (!chars) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars);
    
          return strSymbols
            .slice(charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1)
            .join('');
        }
    
        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (!string) {
            return string;
          }
          if (guard || chars === undefined) {
            return string.replace(reTrimEnd, '');
          }
          chars = (chars + '');
          if (!chars) {
            return string;
          }
          var strSymbols = stringToArray(string);
          return strSymbols
            .slice(0, charsEndIndex(strSymbols, stringToArray(chars)) + 1)
            .join('');
        }
    
        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (!string) {
            return string;
          }
          if (guard || chars === undefined) {
            return string.replace(reTrimStart, '');
          }
          chars = (chars + '');
          if (!chars) {
            return string;
          }
          var strSymbols = stringToArray(string);
          return strSymbols
            .slice(charsStartIndex(strSymbols, stringToArray(chars)))
            .join('');
        }
    
        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options=({})] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
    
          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? toString(options.omission) : omission;
          }
          string = toString(string);
    
          var strLength = string.length;
          if (reHasComplexSymbol.test(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? strSymbols.slice(0, end).join('')
            : string.slice(0, end);
    
          if (separator === undefined) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;
    
              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
    
        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
         * corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional HTML
         * entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }
    
        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });
    
        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined : pattern;
    
          if (pattern === undefined) {
            pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;
          }
          return string.match(pattern) || [];
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Function} func The function to attempt.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = rest(function(func, args) {
          try {
            return apply(func, undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });
    
        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind,
         *  specified individually or in arrays.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'onClick': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, 'onClick');
         * jQuery(element).on('click', view.onClick);
         * // => logs 'clicked docs' when clicked
         */
        var bindAll = rest(function(object, methodNames) {
          arrayEach(baseFlatten(methodNames, 1), function(key) {
            object[key] = bind(object[key], object);
          });
          return object;
        });
    
        /**
         * Creates a function that iterates over `pairs` invoking the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.constant(true),                _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs ? pairs.length : 0,
              toIteratee = getIteratee();
    
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
    
          return rest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
    
        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, true));
        }
    
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var getter = _.constant(object);
         *
         * getter() === object;
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }
    
        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow(_.add, square);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();
    
        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight(square, _.add);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);
    
        /**
         * This method returns the first argument given to it.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
          return value;
        }
    
        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name the created callback returns the
         * property value for a given element. If `func` is an object the created
         * callback returns `true` for elements that contain the equivalent object
         * properties, otherwise it returns `false`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(callback, func) {
         *   var p = /^(\S+)\s*([<>])\s*(\S+)$/.exec(func);
         *   return !p ? callback(func) : function(object) {
         *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);
         *   };
         * });
         *
         * _.filter(users, 'age > 36');
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, true));
        }
    
        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`. The created function is equivalent to
         * `_.isMatch` with a `source` partially applied.
         *
         * **Note:** This method supports comparing the same values as `_.isEqual`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, _.matches({ 'age': 40, 'active': false }));
         * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
    
        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** This method supports comparing the same values as `_.isEqual`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * _.find(users, _.matchesProperty('user', 'fred'));
         * // => { 'user': 'fred' }
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
    
        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': _.constant(2) } } },
         *   { 'a': { 'b': { 'c': _.constant(1) } } }
         * ];
         *
         * _.map(objects, _.method('a.b.c'));
         * // => [2, 1]
         *
         * _.invokeMap(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        var method = rest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
    
        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = rest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
    
        /**
         * Adds all own enumerable function properties of a source object to the
         * destination object. If `object` is a function then methods are added to
         * its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.chain=true] Specify whether the functions added
         *  are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);
    
          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = (isObject(options) && 'chain' in options) ? options.chain : true,
              isFunc = isFunction(object);
    
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);
    
                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
    
          return object;
        }
    
        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
    
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Util
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
          // No operation performed.
        }
    
        /**
         * Creates a function that returns its nth argument.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.nthArg(1);
         *
         * func('a', 'b', 'c');
         * // => 'b'
         */
        function nthArg(n) {
          n = toInteger(n);
          return function() {
            return arguments[n];
          };
        }
    
        /**
         * Creates a function that invokes `iteratees` with the arguments provided
         * to the created function and returns their results.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} iteratees The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over(Math.max, Math.min);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);
    
        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments provided to the created function.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} predicates The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery(Boolean, isFinite);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);
    
        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments provided to the created function.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} predicates The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome(Boolean, isFinite);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         */
        var overSome = createOver(arraySome);
    
        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
    
        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined : baseGet(object, path);
          };
        }
    
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the new array of numbers.
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();
    
        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the new array of numbers.
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);
    
        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(true));
         * // => [true, true, true, true]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);
    
          iteratee = baseCastFunction(iteratee);
          n -= MAX_ARRAY_LENGTH;
    
          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }
    
        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         *
         * var path = ['a', 'b', 'c'],
         *     newPath = _.toPath(path);
         *
         * console.log(newPath);
         * // => ['a', 'b', 'c']
         *
         * console.log(path === newPath);
         * // => false
         */
        function toPath(value) {
          return isArray(value) ? arrayMap(value, String) : stringToPath(value);
        }
    
        /**
         * Generates a unique ID. If `prefix` is given the ID is appended to it.
         *
         * @static
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        function add(augend, addend) {
          var result;
          if (augend === undefined && addend === undefined) {
            return 0;
          }
          if (augend !== undefined) {
            result = augend;
          }
          if (addend !== undefined) {
            result = result === undefined ? addend : (result + addend);
          }
          return result;
        }
    
        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');
    
        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');
    
        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey
         * `undefined` is returned.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, gt)
            : undefined;
        }
    
        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee), gt)
            : undefined;
        }
    
        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return sum(array) / (array ? array.length : 0);
        }
    
        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey
         * `undefined` is returned.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, lt)
            : undefined;
        }
    
        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee), lt)
            : undefined;
        }
    
        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');
    
        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        function subtract(minuend, subtrahend) {
          var result;
          if (minuend === undefined && subtrahend === undefined) {
            return 0;
          }
          if (minuend !== undefined) {
            result = minuend;
          }
          if (subtrahend !== undefined) {
            result = result === undefined ? subtrahend : (result - subtrahend);
          }
          return result;
        }
    
        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }
    
        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee))
            : 0;
        }
    
        /*------------------------------------------------------------------------*/
    
        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
    
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
    
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
    
        // Avoid inheriting from `Object.prototype` when possible.
        Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
    
        // Add functions to the `MapCache`.
        MapCache.prototype.clear = mapClear;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
    
        // Add functions to the `SetCache`.
        SetCache.prototype.push = cachePush;
    
        // Add functions to the `Stack` cache.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
    
        // Assign cache to `_.memoize`.
        memoize.Cache = MapCache;
    
        // Add functions that return wrapped values when chaining.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
    
        // Add aliases.
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
    
        // Add functions to `lodash.prototype`.
        mixin(lodash, lodash);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions that return unwrapped values when chaining.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
    
        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
    
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;
    
        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
    
        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
    
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };
    
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
    
        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
    
          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
    
        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
    
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
    
        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
    
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
    
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
    
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
    
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
    
        LazyWrapper.prototype.invokeMap = rest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
    
        LazyWrapper.prototype.reject = function(predicate) {
          predicate = getIteratee(predicate, 3);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
    
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
    
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
    
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
    
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
    
        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);
    
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
    
            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };
    
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;
    
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });
    
        // Add `Array` and `String` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);
    
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
    
        // Map minified function names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = (lodashFunc.name + ''),
                names = realNames[key] || (realNames[key] = []);
    
            names.push({ 'name': methodName, 'func': lodashFunc });
          }
        });
    
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined
        }];
    
        // Add functions to the lazy wrapper.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
    
        // Add chaining functions to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.flatMap = wrapperFlatMap;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
    
        if (iteratorSymbol) {
          lodash.prototype[iteratorSymbol] = wrapperToIterator;
        }
        return lodash;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // Export lodash.
      var _ = runInContext();
    
      // Expose lodash on the free variable `window` or `self` when available. This
      // prevents errors in cases where lodash is loaded by a script tag in the presence
      // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.
      (freeWindow || freeSelf || {})._ = _;
    
      // Some AMD build optimizers like r.js check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        define(function() {
          return _;
        });
      }
      // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
      else if (freeExports && freeModule) {
        // Export for Node.js.
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        }
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(this));
    
  provide("lodash", module.exports);
}(global));

// pakmanager:platform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Platform.js v1.3.1 <http://mths.be/platform>
     * Copyright 2014-2016 Benjamin Tan <https://d10.github.io/>
     * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
     * Available under MIT license <http://mths.be/mit>
     */
    ;(function() {
      'use strict';
    
      /** Used to determine if values are of the language type `Object` */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used as a reference to the global object */
      var root = (objectTypes[typeof window] && window) || this;
    
      /** Backup possible global object */
      var oldRoot = root;
    
      /** Detect free variable `exports` */
      var freeExports = objectTypes[typeof exports] && exports;
    
      /** Detect free variable `module` */
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    
      /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
    
      /**
       * Used as the maximum length of an array-like object.
       * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
       * for more details.
       */
      var maxSafeInteger = Math.pow(2, 53) - 1;
    
      /** Opera regexp */
      var reOpera = /\bOpera/;
    
      /** Possible global object */
      var thisBinding = this;
    
      /** Used for native method references */
      var objectProto = Object.prototype;
    
      /** Used to check for own properties of an object */
      var hasOwnProperty = objectProto.hasOwnProperty;
    
      /** Used to resolve the internal `[[Class]]` of values */
      var toString = objectProto.toString;
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Capitalizes a string value.
       *
       * @private
       * @param {string} string The string to capitalize.
       * @returns {string} The capitalized string.
       */
      function capitalize(string) {
        string = String(string);
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
    
      /**
       * A utility function to clean up the OS name.
       *
       * @private
       * @param {string} os The OS name to clean up.
       * @param {string} [pattern] A `RegExp` pattern matching the OS name.
       * @param {string} [label] A label for the OS.
       */
      function cleanupOS(os, pattern, label) {
        // platform tokens defined at
        // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
        // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
        var data = {
          '6.4':  '10',
          '6.3':  '8.1',
          '6.2':  '8',
          '6.1':  'Server 2008 R2 / 7',
          '6.0':  'Server 2008 / Vista',
          '5.2':  'Server 2003 / XP 64-bit',
          '5.1':  'XP',
          '5.01': '2000 SP1',
          '5.0':  '2000',
          '4.0':  'NT',
          '4.90': 'ME'
        };
        // detect Windows version from platform tokens
        if (pattern && label && /^Win/i.test(os) &&
            (data = data[0/*Opera 9.25 fix*/, /[\d.]+$/.exec(os)])) {
          os = 'Windows ' + data;
        }
        // correct character case and cleanup
        os = String(os);
    
        if (pattern && label) {
          os = os.replace(RegExp(pattern, 'i'), label);
        }
    
        os = format(
          os.replace(/ ce$/i, ' CE')
            .replace(/\bhpw/i, 'web')
            .replace(/\bMacintosh\b/, 'Mac OS')
            .replace(/_PowerPC\b/i, ' OS')
            .replace(/\b(OS X) [^ \d]+/i, '$1')
            .replace(/\bMac (OS X)\b/, '$1')
            .replace(/\/(\d)/, ' $1')
            .replace(/_/g, '.')
            .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
            .replace(/\bx86\.64\b/gi, 'x86_64')
            .replace(/\b(Windows Phone) OS\b/, '$1')
            .split(' on ')[0]
        );
    
        return os;
      }
    
      /**
       * An iteration utility for arrays and objects.
       *
       * @private
       * @param {Array|Object} object The object to iterate over.
       * @param {Function} callback The function called per iteration.
       */
      function each(object, callback) {
        var index = -1,
            length = object ? object.length : 0;
    
        if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
          while (++index < length) {
            callback(object[index], index, object);
          }
        } else {
          forOwn(object, callback);
        }
      }
    
      /**
       * Trim and conditionally capitalize string values.
       *
       * @private
       * @param {string} string The string to format.
       * @returns {string} The formatted string.
       */
      function format(string) {
        string = trim(string);
        return /^(?:webOS|i(?:OS|P))/.test(string)
          ? string
          : capitalize(string);
      }
    
      /**
       * Iterates over an object's own properties, executing the `callback` for each.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} callback The function executed per own property.
       */
      function forOwn(object, callback) {
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            callback(object[key], key, object);
          }
        }
      }
    
      /**
       * Gets the internal `[[Class]]` of a value.
       *
       * @private
       * @param {*} value The value.
       * @returns {string} The `[[Class]]`.
       */
      function getClassOf(value) {
        return value == null
          ? capitalize(value)
          : toString.call(value).slice(8, -1);
      }
    
      /**
       * Host objects can return type values that are different from their actual
       * data type. The objects we are concerned with usually return non-primitive
       * types of "object", "function", or "unknown".
       *
       * @private
       * @param {*} object The owner of the property.
       * @param {string} property The property to check.
       * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
       */
      function isHostType(object, property) {
        var type = object != null ? typeof object[property] : 'number';
        return !/^(?:boolean|number|string|undefined)$/.test(type) &&
          (type == 'object' ? !!object[property] : true);
      }
    
      /**
       * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
       *
       * @private
       * @param {string} string The string to qualify.
       * @returns {string} The qualified string.
       */
      function qualify(string) {
        return String(string).replace(/([ -])(?!$)/g, '$1?');
      }
    
      /**
       * A bare-bones `Array#reduce` like utility function.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} callback The function called per iteration.
       * @returns {*} The accumulated result.
       */
      function reduce(array, callback) {
        var accumulator = null;
        each(array, function(value, index) {
          accumulator = callback(accumulator, value, index, array);
        });
        return accumulator;
      }
    
      /**
       * Removes leading and trailing whitespace from a string.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} The trimmed string.
       */
      function trim(string) {
        return String(string).replace(/^ +| +$/g, '');
      }
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Creates a new platform object.
       *
       * @memberOf platform
       * @param {Object|string} [ua=navigator.userAgent] The user agent string or
       *  context object.
       * @returns {Object} A platform object.
       */
      function parse(ua) {
    
        /** The environment context object */
        var context = root;
    
        /** Used to flag when a custom context is provided */
        var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';
    
        // juggle arguments
        if (isCustomContext) {
          context = ua;
          ua = null;
        }
    
        /** Browser navigator object */
        var nav = context.navigator || {};
    
        /** Browser user agent string */
        var userAgent = nav.userAgent || '';
    
        ua || (ua = userAgent);
    
        /** Used to flag when `thisBinding` is the [ModuleScope] */
        var isModuleScope = isCustomContext || thisBinding == oldRoot;
    
        /** Used to detect if browser is like Chrome */
        var likeChrome = isCustomContext
          ? !!nav.likeChrome
          : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
    
        /** Internal `[[Class]]` value shortcuts */
        var objectClass = 'Object',
            airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
            enviroClass = isCustomContext ? objectClass : 'Environment',
            javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
            phantomClass = isCustomContext ? objectClass : 'RuntimeObject';
    
        /** Detect Java environment */
        var java = /\bJava/.test(javaClass) && context.java;
    
        /** Detect Rhino */
        var rhino = java && getClassOf(context.environment) == enviroClass;
    
        /** A character to represent alpha */
        var alpha = java ? 'a' : '\u03b1';
    
        /** A character to represent beta */
        var beta = java ? 'b' : '\u03b2';
    
        /** Browser document object */
        var doc = context.document || {};
    
        /**
         * Detect Opera browser (Presto-based)
         * http://www.howtocreate.co.uk/operaStuff/operaObject.html
         * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
         */
        var opera = context.operamini || context.opera;
    
        /** Opera `[[Class]]` */
        var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
          ? operaClass
          : (opera = null);
    
        /*------------------------------------------------------------------------*/
    
        /** Temporary variable used over the script's lifetime */
        var data;
    
        /** The CPU architecture */
        var arch = ua;
    
        /** Platform description array */
        var description = [];
    
        /** Platform alpha/beta indicator */
        var prerelease = null;
    
        /** A flag to indicate that environment features should be used to resolve the platform */
        var useFeatures = ua == userAgent;
    
        /** The browser/environment version */
        var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();
    
        /** A flag to indicate if the OS ends with "/ Version" */
        var isSpecialCasedOS;
    
        /* Detectable layout engines (order is important) */
        var layout = getLayout([
          'Trident',
          { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
          'iCab',
          'Presto',
          'NetFront',
          'Tasman',
          'KHTML',
          'Gecko'
        ]);
    
        /* Detectable browser names (order is important) */
        var name = getName([
          'Adobe AIR',
          'Arora',
          'Avant Browser',
          'Breach',
          'Camino',
          'Epiphany',
          'Fennec',
          'Flock',
          'Galeon',
          'GreenBrowser',
          'iCab',
          'Iceweasel',
          { 'label': 'SRWare Iron', 'pattern': 'Iron' },
          'K-Meleon',
          'Konqueror',
          'Lunascape',
          'Maxthon',
          'Midori',
          'Nook Browser',
          'PhantomJS',
          'Raven',
          'Rekonq',
          'RockMelt',
          'SeaMonkey',
          { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
          'Sleipnir',
          'SlimBrowser',
          'Sunrise',
          'Swiftfox',
          'WebPositive',
          'Opera Mini',
          { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
          'Opera',
          { 'label': 'Opera', 'pattern': 'OPR' },
          'Chrome',
          { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
          { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
          { 'label': 'IE', 'pattern': 'IEMobile' },
          { 'label': 'IE', 'pattern': 'MSIE' },
          'Safari'
        ]);
    
        /* Detectable products (order is important) */
        var product = getProduct([
          { 'label': 'BlackBerry', 'pattern': 'BB10' },
          'BlackBerry',
          { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
          { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
          { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
          { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
          'Google TV',
          'Lumia',
          'iPad',
          'iPod',
          'iPhone',
          'Kindle',
          { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
          'Nook',
          'PlayBook',
          'PlayStation 4',
          'PlayStation 3',
          'PlayStation Vita',
          'TouchPad',
          'Transformer',
          { 'label': 'Wii U', 'pattern': 'WiiU' },
          'Wii',
          'Xbox One',
          { 'label': 'Xbox 360', 'pattern': 'Xbox' },
          'Xoom'
        ]);
    
        /* Detectable manufacturers */
        var manufacturer = getManufacturer({
          'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
          'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
          'Asus': { 'Transformer': 1 },
          'Barnes & Noble': { 'Nook': 1 },
          'BlackBerry': { 'PlayBook': 1 },
          'Google': { 'Google TV': 1 },
          'HP': { 'TouchPad': 1 },
          'HTC': {},
          'LG': {},
          'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
          'Motorola': { 'Xoom': 1 },
          'Nintendo': { 'Wii U': 1,  'Wii': 1 },
          'Nokia': { 'Lumia': 1 },
          'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
          'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
        });
    
        /* Detectable OSes (order is important) */
        var os = getOS([
          'Windows Phone ',
          'Android',
          'CentOS',
          'Debian',
          'Fedora',
          'FreeBSD',
          'Gentoo',
          'Haiku',
          'Kubuntu',
          'Linux Mint',
          'Red Hat',
          'SuSE',
          'Ubuntu',
          'Xubuntu',
          'Cygwin',
          'Symbian OS',
          'hpwOS',
          'webOS ',
          'webOS',
          'Tablet OS',
          'Linux',
          'Mac OS X',
          'Macintosh',
          'Mac',
          'Windows 98;',
          'Windows '
        ]);
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Picks the layout engine from an array of guesses.
         *
         * @private
         * @param {Array} guesses An array of guesses.
         * @returns {null|string} The detected layout engine.
         */
        function getLayout(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp('\\b' + (
              guess.pattern || qualify(guess)
            ) + '\\b', 'i').exec(ua) && (guess.label || guess);
          });
        }
    
        /**
         * Picks the manufacturer from an array of guesses.
         *
         * @private
         * @param {Array} guesses An object of guesses.
         * @returns {null|string} The detected manufacturer.
         */
        function getManufacturer(guesses) {
          return reduce(guesses, function(result, value, key) {
            // lookup the manufacturer by product or scan the UA for the manufacturer
            return result || (
              value[product] ||
              value[0/*Opera 9.25 fix*/, /^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
              RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
            ) && key;
          });
        }
    
        /**
         * Picks the browser name from an array of guesses.
         *
         * @private
         * @param {Array} guesses An array of guesses.
         * @returns {null|string} The detected browser name.
         */
        function getName(guesses) {
          return reduce(guesses, function(result, guess) {
            return result || RegExp('\\b' + (
              guess.pattern || qualify(guess)
            ) + '\\b', 'i').exec(ua) && (guess.label || guess);
          });
        }
    
        /**
         * Picks the OS name from an array of guesses.
         *
         * @private
         * @param {Array} guesses An array of guesses.
         * @returns {null|string} The detected OS name.
         */
        function getOS(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result =
                  RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
                )) {
              result = cleanupOS(result, pattern, guess.label || guess);
            }
            return result;
          });
        }
    
        /**
         * Picks the product name from an array of guesses.
         *
         * @private
         * @param {Array} guesses An array of guesses.
         * @returns {null|string} The detected product name.
         */
        function getProduct(guesses) {
          return reduce(guesses, function(result, guess) {
            var pattern = guess.pattern || qualify(guess);
            if (!result && (result =
                  RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
                  RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
                )) {
              // split by forward slash and append product version if needed
              if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
                result[0] += ' ' + result[1];
              }
              // correct character case and cleanup
              guess = guess.label || guess;
              result = format(result[0]
                .replace(RegExp(pattern, 'i'), guess)
                .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
                .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
            }
            return result;
          });
        }
    
        /**
         * Resolves the version using an array of UA patterns.
         *
         * @private
         * @param {Array} patterns An array of UA patterns.
         * @returns {null|string} The detected version.
         */
        function getVersion(patterns) {
          return reduce(patterns, function(result, pattern) {
            return result || (RegExp(pattern +
              '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
          });
        }
    
        /**
         * Returns `platform.description` when the platform object is coerced to a string.
         *
         * @name toString
         * @memberOf platform
         * @returns {string} Returns `platform.description` if available, else an empty string.
         */
        function toStringPlatform() {
          return this.description || '';
        }
    
        /*------------------------------------------------------------------------*/
    
        // convert layout to an array so we can add extra details
        layout && (layout = [layout]);
    
        // detect product names that contain their manufacturer's name
        if (manufacturer && !product) {
          product = getProduct([manufacturer]);
        }
        // clean up Google TV
        if ((data = /\bGoogle TV\b/.exec(product))) {
          product = data[0];
        }
        // detect simulators
        if (/\bSimulator\b/i.test(ua)) {
          product = (product ? product + ' ' : '') + 'Simulator';
        }
        // detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS
        if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
          description.push('running in Turbo/Uncompressed mode');
        }
        // detect iOS
        if (/^iP/.test(product)) {
          name || (name = 'Safari');
          os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
            ? ' ' + data[1].replace(/_/g, '.')
            : '');
        }
        // detect Kubuntu
        else if (name == 'Konqueror' && !/buntu/i.test(os)) {
          os = 'Kubuntu';
        }
        // detect Android browsers
        else if (manufacturer && manufacturer != 'Google' &&
            ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) {
          name = 'Android Browser';
          os = /\bAndroid\b/.test(os) ? os : 'Android';
        }
        // detect false positives for Firefox/Safari
        else if (!name || (data = !/\bMinefield\b|\(Android;/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
          // escape the `/` for Firefox 1
          if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
            // clear name of false positives
            name = null;
          }
          // reassign a generic name
          if ((data = product || manufacturer || os) &&
              (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
            name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
          }
        }
        // detect Firefox OS
        if ((data = /\((Mobile|Tablet).*?Firefox\b/i.exec(ua)) && data[1]) {
          os = 'Firefox OS';
          if (!product) {
            product = data[1];
          }
        }
        // detect non-Opera versions (order is important)
        if (!version) {
          version = getVersion([
            '(?:Cloud9|CriOS|CrMo|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
            'Version',
            qualify(name),
            '(?:Firefox|Minefield|NetFront)'
          ]);
        }
        // detect stubborn layout engines
        if (layout == 'iCab' && parseFloat(version) > 3) {
          layout = ['WebKit'];
        } else if (
            layout != 'Trident' &&
            (data =
              /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
              /\b(?:Midori|Nook|Safari)\b/i.test(ua) && 'WebKit' ||
              !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident')
            )
        ) {
          layout = [data];
        }
        // detect NetFront on PlayStation
        else if (/\bPlayStation\b(?! Vita\b)/i.test(name) && layout == 'WebKit') {
          layout = ['NetFront'];
        }
        // detect Windows Phone 7 desktop mode
        if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
          name += ' Mobile';
          os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
          description.unshift('desktop mode');
        }
        // detect Windows Phone 8+ desktop mode
        else if (/\bWPDesktop\b/i.test(ua)) {
          name = 'IE Mobile';
          os = 'Windows Phone 8+';
          description.unshift('desktop mode');
          version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
        }
        // detect IE 11 and above
        else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
          if (!/\bWPDesktop\b/i.test(ua)) {
            if (name) {
              description.push('identifying as ' + name + (version ? ' ' + version : ''));
            }
            name = 'IE';
          }
          version = data[1];
        }
        // detect Microsoft Edge
        else if ((name == 'Chrome' || name != 'IE') && (data = /\bEdge\/([\d.]+)/.exec(ua))) {
          name = 'Microsoft Edge';
          version = data[1];
          layout = ['Trident'];
        }
        // leverage environment features
        if (useFeatures) {
          // detect server-side environments
          // Rhino has a global function while others have a global object
          if (isHostType(context, 'global')) {
            if (java) {
              data = java.lang.System;
              arch = data.getProperty('os.arch');
              os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
            }
            if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
              os || (os = data[0].os || null);
              try {
                data[1] = context.require('ringo/engine').version;
                version = data[1].join('.');
                name = 'RingoJS';
              } catch(e) {
                if (data[0].global.system == context.system) {
                  name = 'Narwhal';
                }
              }
            }
            else if (typeof context.process == 'object' && (data = context.process)) {
              name = 'Node.js';
              arch = data.arch;
              os = data.platform;
              version = /[\d.]+/.exec(data.version)[0];
            }
            else if (rhino) {
              name = 'Rhino';
            }
          }
          // detect Adobe AIR
          else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
            name = 'Adobe AIR';
            os = data.flash.system.Capabilities.os;
          }
          // detect PhantomJS
          else if (getClassOf((data = context.phantom)) == phantomClass) {
            name = 'PhantomJS';
            version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
          }
          // detect IE compatibility modes
          else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
            // we're in compatibility mode when the Trident version + 4 doesn't
            // equal the document mode
            version = [version, doc.documentMode];
            if ((data = +data[1] + 4) != version[1]) {
              description.push('IE ' + version[1] + ' mode');
              layout && (layout[1] = '');
              version[1] = data;
            }
            version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
          }
          os = os && format(os);
        }
        // detect prerelease phases
        if (version && (data =
              /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
              /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
              /\bMinefield\b/i.test(ua) && 'a'
            )) {
          prerelease = /b/i.test(data) ? 'beta' : 'alpha';
          version = version.replace(RegExp(data + '\\+?$'), '') +
            (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
        }
        // detect Firefox Mobile
        if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
          name = 'Firefox Mobile';
        }
        // obscure Maxthon's unreliable version
        else if (name == 'Maxthon' && version) {
          version = version.replace(/\.[\d.]+/, '.x');
        }
        // detect Silk desktop/accelerated modes
        else if (name == 'Silk') {
          if (!/\bMobi/i.test(ua)) {
            os = 'Android';
            description.unshift('desktop mode');
          }
          if (/Accelerated *= *true/i.test(ua)) {
            description.unshift('accelerated');
          }
        }
        // detect Xbox 360 and Xbox One
        else if (/\bXbox\b/i.test(product)) {
          os = null;
          if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
            description.unshift('mobile mode');
          }
        }
        // add mobile postfix
        else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
            (os == 'Windows CE' || /Mobi/i.test(ua))) {
          name += ' Mobile';
        }
        // detect IE platform preview
        else if (name == 'IE' && useFeatures && context.external === null) {
          description.unshift('platform preview');
        }
        // detect BlackBerry OS version
        // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
        else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
              (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
              version
            )) {
          data = [data, /BB10/.test(ua)];
          os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
          version = null;
        }
        // detect Opera identifying/masking itself as another browser
        // http://www.opera.com/support/kb/view/843/
        else if (this != forOwn && (
              product != 'Wii' && (
                (useFeatures && opera) ||
                (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
                (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
                (name == 'IE' && (
                  (os && !/^Win/.test(os) && version > 5.5) ||
                  /\bWindows XP\b/.test(os) && version > 8 ||
                  version == 8 && !/\bTrident\b/.test(ua)
                ))
              )
            ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
    
          // when "indentifying", the UA contains both Opera and the other browser's name
          data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
          if (reOpera.test(name)) {
            if (/\bIE\b/.test(data) && os == 'Mac OS') {
              os = null;
            }
            data = 'identify' + data;
          }
          // when "masking", the UA contains only the other browser's name
          else {
            data = 'mask' + data;
            if (operaClass) {
              name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
            } else {
              name = 'Opera';
            }
            if (/\bIE\b/.test(data)) {
              os = null;
            }
            if (!useFeatures) {
              version = null;
            }
          }
          layout = ['Presto'];
          description.push(data);
        }
        // detect WebKit Nightly and approximate Chrome/Safari versions
        if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
          // correct build for numeric comparison
          // (e.g. "532.5" becomes "532.05")
          data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
          // nightly builds are postfixed with a `+`
          if (name == 'Safari' && data[1].slice(-1) == '+') {
            name = 'WebKit Nightly';
            prerelease = 'alpha';
            version = data[1].slice(0, -1);
          }
          // clear incorrect browser versions
          else if (version == data[1] ||
              version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
            version = null;
          }
          // use the full Chrome version when available
          data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
          // detect Blink layout engine
          if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && name != 'IE' && name != 'Microsoft Edge') {
            layout = ['Blink'];
          }
          // detect JavaScriptCore
          // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
          if (!useFeatures || (!likeChrome && !data[1])) {
            layout && (layout[1] = 'like Safari');
            data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
          } else {
            layout && (layout[1] = 'like Chrome');
            data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
          }
          // add the postfix of ".x" or "+" for approximate versions
          layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
          // obscure version for some Safari 1-2 releases
          if (name == 'Safari' && (!version || parseInt(version) > 45)) {
            version = data;
          }
        }
        // detect Opera desktop modes
        if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
          name += ' ';
          description.unshift('desktop mode');
          if (data == 'zvav') {
            name += 'Mini';
            version = null;
          } else {
            name += 'Mobile';
          }
          os = os.replace(RegExp(' *' + data + '$'), '');
        }
        // detect Chrome desktop mode
        else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
          description.unshift('desktop mode');
          name = 'Chrome Mobile';
          version = null;
    
          if (/\bOS X\b/.test(os)) {
            manufacturer = 'Apple';
            os = 'iOS 4.3+';
          } else {
            os = null;
          }
        }
        // strip incorrect OS versions
        if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
            ua.indexOf('/' + data + '-') > -1) {
          os = trim(os.replace(data, ''));
        }
        // add layout engine
        if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
            /Browser|Lunascape|Maxthon/.test(name) ||
            /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
          // don't add layout details to description if they are falsey
          (data = layout[layout.length - 1]) && description.push(data);
        }
        // combine contextual information
        if (description.length) {
          description = ['(' + description.join('; ') + ')'];
        }
        // append manufacturer
        if (manufacturer && product && product.indexOf(manufacturer) < 0) {
          description.push('on ' + manufacturer);
        }
        // append product
        if (product) {
          description.push((/^on /.test(description[description.length -1]) ? '' : 'on ') + product);
        }
        // parse OS into an object
        if (os) {
          data = / ([\d.+]+)$/.exec(os);
          isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
          os = {
            'architecture': 32,
            'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
            'version': data ? data[1] : null,
            'toString': function() {
              var version = this.version;
              return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
            }
          };
        }
        // add browser/OS architecture
        if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
          if (os) {
            os.architecture = 64;
            os.family = os.family.replace(RegExp(' *' + data), '');
          }
          if (
              name && (/\bWOW64\b/i.test(ua) ||
              (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
          ) {
            description.unshift('32-bit');
          }
        }
    
        ua || (ua = null);
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The platform object.
         *
         * @name platform
         * @type Object
         */
        var platform = {};
    
        /**
         * The platform description.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.description = ua;
    
        /**
         * The name of the browser's layout engine.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.layout = layout && layout[0];
    
        /**
         * The name of the product's manufacturer.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.manufacturer = manufacturer;
    
        /**
         * The name of the browser/environment.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.name = name;
    
        /**
         * The alpha/beta release indicator.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.prerelease = prerelease;
    
        /**
         * The name of the product hosting the browser.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.product = product;
    
        /**
         * The browser's user agent string.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.ua = ua;
    
        /**
         * The browser/environment version.
         *
         * @memberOf platform
         * @type string|null
         */
        platform.version = name && version;
    
        /**
         * The name of the operating system.
         *
         * @memberOf platform
         * @type Object
         */
        platform.os = os || {
    
          /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */
          'architecture': null,
    
          /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
           * "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */
          'family': null,
    
          /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */
          'version': null,
    
          /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */
          'toString': function() { return 'null'; }
        };
    
        platform.parse = parse;
        platform.toString = toStringPlatform;
    
        if (platform.version) {
          description.unshift(version);
        }
        if (platform.name) {
          description.unshift(name);
        }
        if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
          description.push(product ? '(' + os + ')' : 'on ' + os);
        }
        if (description.length) {
          platform.description = description.join(' ');
        }
        return platform;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // export platform
      // some AMD build optimizers, like r.js, check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // define as an anonymous module so, through path mapping, it can be aliased
        define(function() {
          return parse();
        });
      }
      // check for `exports` after `define` in case a build optimizer adds an `exports` object
      else if (freeExports && freeModule) {
        // in Narwhal, Node.js, Rhino -require, or RingoJS
        forOwn(parse(), function(value, key) {
          freeExports[key] = value;
        });
      }
      // in a browser or Rhino
      else {
        root.platform = parse();
      }
    }.call(this));
    
  provide("platform", module.exports);
}(global));

// pakmanager:unc-path-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = function uncPathRegex() {
      return /^[\\\/]{2,}[^\\\/]+[\\\/]+[^\\\/]+/;
    };
    
  provide("unc-path-regex", module.exports);
}(global));

// pakmanager:normalize-path
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * normalize-path <https://github.com/jonschlinkert/normalize-path>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License
     */
    
    module.exports = function normalizePath(str, stripTrailing) {
      if (typeof str !== 'string') {
        throw new TypeError('expected a string');
      }
      str = str.replace(/[\\\/]+/g, '/');
      if (stripTrailing !== false) {
        str = str.replace(/\/$/, '');
      }
      return str;
    };
    
  provide("normalize-path", module.exports);
}(global));

// pakmanager:node-int64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  //     Int64.js
    //
    //     Copyright (c) 2012 Robert Kieffer
    //     MIT License - http://opensource.org/licenses/mit-license.php
    
    /**
     * Support for handling 64-bit int numbers in Javascript (node.js)
     *
     * JS Numbers are IEEE-754 binary double-precision floats, which limits the
     * range of values that can be represented with integer precision to:
     *
     * 2^^53 <= N <= 2^53
     *
     * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These
     * objects operate directly on the buffer which means that if they are created
     * using an existing buffer then setting the value will modify the Buffer, and
     * vice-versa.
     *
     * Internal Representation
     *
     * The internal buffer format is Big Endian.  I.e. the most-significant byte is
     * at buffer[0], the least-significant at buffer[7].  For the purposes of
     * converting to/from JS native numbers, the value is assumed to be a signed
     * integer stored in 2's complement form.
     *
     * For details about IEEE-754 see:
     * http://en.wikipedia.org/wiki/Double_precision_floating-point_format
     */
    
    // Useful masks and values for bit twiddling
    var MASK31 =  0x7fffffff, VAL31 = 0x80000000;
    var MASK32 =  0xffffffff, VAL32 = 0x100000000;
    
    // Map for converting hex octets to strings
    var _HEX = [];
    for (var i = 0; i < 256; i++) {
      _HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);
    }
    
    //
    // Int64
    //
    
    /**
     * Constructor accepts any of the following argument types:
     *
     * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset
     * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset
     * new Int64(string)             - Hex string (throws if n is outside int64 range)
     * new Int64(number)             - Number (throws if n is outside int64 range)
     * new Int64(hi, lo)             - Raw bits as two 32-bit values
     */
    var Int64 = module.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {
        // Under Browserify, Buffers can extend Uint8Arrays rather than an
        // instance of Buffer. We could assume the passed in Uint8Array is actually
        // a buffer but that won't handle the case where a raw Uint8Array is passed
        // in. We construct a new Buffer just in case.
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    
    
    // Max integer value that JS can accurately represent
    Int64.MAX_INT = Math.pow(2, 53);
    
    // Min integer value that JS can accurately represent
    Int64.MIN_INT = -Math.pow(2, 53);
    
    Int64.prototype = {
    
      constructor: Int64,
    
      /**
       * Do in-place 2's compliment.  See
       * http://en.wikipedia.org/wiki/Two's_complement
       */
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i = o + 7; i >= o; i--) {
          var v = (b[i] ^ 0xff) + carry;
          b[i] = v & 0xff;
          carry = v >> 8;
        }
      },
    
      /**
       * Set the value. Takes any of the following arguments:
       *
       * setValue(string) - A hexidecimal string
       * setValue(number) - Number (throws if n is outside int64 range)
       * setValue(hi, lo) - Raw bits as two 32-bit values
       */
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof(hi) == 'number') {
            // Simplify bitfield retrieval by using abs() value.  We restore sign
            // later
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');
            hi = hi | 0;
          } else if (typeof(hi) == 'string') {
            hi = (hi + '').replace(/^0x/, '');
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + ' must be a Number or String');
          }
        }
    
        // Technically we should throw if hi or lo is outside int32 range here, but
        // it's not worth the effort. Anything past the 32'nd bit is ignored.
    
        // Copy bytes to buffer
        var b = this.buffer, o = this.offset;
        for (var i = 7; i >= 0; i--) {
          b[o+i] = lo & 0xff;
          lo = i == 4 ? hi : lo >>> 8;
        }
    
        // Restore sign of passed argument
        if (negate) this._2scomp();
      },
    
      /**
       * Convert to a native JS number.
       *
       * WARNING: Do not expect this value to be accurate to integer precision for
       * large (positive or negative) numbers!
       *
       * @param allowImprecise If true, no check is performed to verify the
       * returned value is accurate to integer precision.  If false, imprecise
       * numbers (very large positive or negative numbers) will be forced to +/-
       * Infinity.
       */
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
    
        // Running sum of octets, doing a 2's complement
        var negate = b[o] & 0x80, x = 0, carry = 1;
        for (var i = 7, m = 1; i >= 0; i--, m *= 256) {
          var v = b[o+i];
    
          // 2's complement for negative numbers
          if (negate) {
            v = (v ^ 0xff) + carry;
            carry = v >> 8;
            v = v & 0xff;
          }
    
          x += v * m;
        }
    
        // Return Infinity if we've lost integer precision
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
    
        return negate ? -x : x;
      },
    
      /**
       * Convert to a JS Number. Returns +/-Infinity for values that can't be
       * represented to integer precision.
       */
      valueOf: function() {
        return this.toNumber(false);
      },
    
      /**
       * Return string value
       *
       * @param radix Just like Number#toString()'s radix
       */
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
    
      /**
       * Return a string showing the buffer octets, with MSB on the left.
       *
       * @param sep separator string. default is '' (empty string)
       */
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i = 0; i < 8; i++) {
          out[i] = _HEX[b[o+i]];
        }
        return out.join(sep || '');
      },
    
      /**
       * Returns the int64's 8 bytes in a buffer.
       *
       * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
       *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
       */
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0) return this.buffer;
    
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
    
      /**
       * Copy 8 bytes of int64 into target buffer at target offset.
       *
       * @param {Buffer} targetBuffer       Buffer to copy into.
       * @param {number} [targetOffset=0]   Offset into target buffer.
       */
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
    
      /**
       * Returns a number indicating whether this comes before or after or is the
       * same as the other in sort order.
       *
       * @param {Int64} other  Other Int64 to compare.
       */
      compare: function(other) {
    
        // If sign bits differ ...
        if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
    
        // otherwise, compare bytes lexicographically
        for (var i = 0; i < 8; i++) {
          if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {
            return this.buffer[this.offset+i] - other.buffer[other.offset+i];
          }
        }
        return 0;
      },
    
      /**
       * Returns a boolean indicating if this integer is equal to other.
       *
       * @param {Int64} other  Other Int64 to compare.
       */
      equals: function(other) {
        return this.compare(other) === 0;
      },
    
      /**
       * Pretty output in console.log
       */
      inspect: function() {
        return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';
      }
    };
    
  provide("node-int64", module.exports);
}(global));

// pakmanager:number-is-nan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = Number.isNaN || function (x) {
    	return x !== x;
    };
    
  provide("number-is-nan", module.exports);
}(global));

// pakmanager:pinkie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var PENDING = 'pending';
    var SETTLED = 'settled';
    var FULFILLED = 'fulfilled';
    var REJECTED = 'rejected';
    var NOOP = function () {};
    var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
    
    var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
    var asyncQueue = [];
    var asyncTimer;
    
    function asyncFlush() {
    	// run promise callbacks
    	for (var i = 0; i < asyncQueue.length; i++) {
    		asyncQueue[i][0](asyncQueue[i][1]);
    	}
    
    	// reset async asyncQueue
    	asyncQueue = [];
    	asyncTimer = false;
    }
    
    function asyncCall(callback, arg) {
    	asyncQueue.push([callback, arg]);
    
    	if (!asyncTimer) {
    		asyncTimer = true;
    		asyncSetTimer(asyncFlush, 0);
    	}
    }
    
    function invokeResolver(resolver, promise) {
    	function resolvePromise(value) {
    		resolve(promise, value);
    	}
    
    	function rejectPromise(reason) {
    		reject(promise, reason);
    	}
    
    	try {
    		resolver(resolvePromise, rejectPromise);
    	} catch (e) {
    		rejectPromise(e);
    	}
    }
    
    function invokeCallback(subscriber) {
    	var owner = subscriber.owner;
    	var settled = owner._state;
    	var value = owner._data;
    	var callback = subscriber[settled];
    	var promise = subscriber.then;
    
    	if (typeof callback === 'function') {
    		settled = FULFILLED;
    		try {
    			value = callback(value);
    		} catch (e) {
    			reject(promise, e);
    		}
    	}
    
    	if (!handleThenable(promise, value)) {
    		if (settled === FULFILLED) {
    			resolve(promise, value);
    		}
    
    		if (settled === REJECTED) {
    			reject(promise, value);
    		}
    	}
    }
    
    function handleThenable(promise, value) {
    	var resolved;
    
    	try {
    		if (promise === value) {
    			throw new TypeError('A promises callback cannot return that same promise.');
    		}
    
    		if (value && (typeof value === 'function' || typeof value === 'object')) {
    			// then should be retrieved only once
    			var then = value.then;
    
    			if (typeof then === 'function') {
    				then.call(value, function (val) {
    					if (!resolved) {
    						resolved = true;
    
    						if (value === val) {
    							fulfill(promise, val);
    						} else {
    							resolve(promise, val);
    						}
    					}
    				}, function (reason) {
    					if (!resolved) {
    						resolved = true;
    
    						reject(promise, reason);
    					}
    				});
    
    				return true;
    			}
    		}
    	} catch (e) {
    		if (!resolved) {
    			reject(promise, e);
    		}
    
    		return true;
    	}
    
    	return false;
    }
    
    function resolve(promise, value) {
    	if (promise === value || !handleThenable(promise, value)) {
    		fulfill(promise, value);
    	}
    }
    
    function fulfill(promise, value) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = value;
    
    		asyncCall(publishFulfillment, promise);
    	}
    }
    
    function reject(promise, reason) {
    	if (promise._state === PENDING) {
    		promise._state = SETTLED;
    		promise._data = reason;
    
    		asyncCall(publishRejection, promise);
    	}
    }
    
    function publish(promise) {
    	promise._then = promise._then.forEach(invokeCallback);
    }
    
    function publishFulfillment(promise) {
    	promise._state = FULFILLED;
    	publish(promise);
    }
    
    function publishRejection(promise) {
    	promise._state = REJECTED;
    	publish(promise);
    	if (!promise._handled && isNode) {
    		global.process.emit('unhandledRejection', promise._data, promise);
    	}
    }
    
    function notifyRejectionHandled(promise) {
    	global.process.emit('rejectionHandled', promise);
    }
    
    /**
     * @class
     */
    function Promise(resolver) {
    	if (typeof resolver !== 'function') {
    		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
    	}
    
    	if (this instanceof Promise === false) {
    		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
    	}
    
    	this._then = [];
    
    	invokeResolver(resolver, this);
    }
    
    Promise.prototype = {
    	constructor: Promise,
    
    	_state: PENDING,
    	_then: null,
    	_data: undefined,
    	_handled: false,
    
    	then: function (onFulfillment, onRejection) {
    		var subscriber = {
    			owner: this,
    			then: new this.constructor(NOOP),
    			fulfilled: onFulfillment,
    			rejected: onRejection
    		};
    
    		if ((onRejection || onFulfillment) && !this._handled) {
    			this._handled = true;
    			if (this._state === REJECTED && isNode) {
    				asyncCall(notifyRejectionHandled, this);
    			}
    		}
    
    		if (this._state === FULFILLED || this._state === REJECTED) {
    			// already resolved, call callback async
    			asyncCall(invokeCallback, subscriber);
    		} else {
    			// subscribe
    			this._then.push(subscriber);
    		}
    
    		return subscriber.then;
    	},
    
    	catch: function (onRejection) {
    		return this.then(null, onRejection);
    	}
    };
    
    Promise.all = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.all().');
    	}
    
    	return new Promise(function (resolve, reject) {
    		var results = [];
    		var remaining = 0;
    
    		function resolver(index) {
    			remaining++;
    			return function (value) {
    				results[index] = value;
    				if (!--remaining) {
    					resolve(results);
    				}
    			};
    		}
    
    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];
    
    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolver(i), reject);
    			} else {
    				results[i] = promise;
    			}
    		}
    
    		if (!remaining) {
    			resolve(results);
    		}
    	});
    };
    
    Promise.race = function (promises) {
    	if (!Array.isArray(promises)) {
    		throw new TypeError('You must pass an array to Promise.race().');
    	}
    
    	return new Promise(function (resolve, reject) {
    		for (var i = 0, promise; i < promises.length; i++) {
    			promise = promises[i];
    
    			if (promise && typeof promise.then === 'function') {
    				promise.then(resolve, reject);
    			} else {
    				resolve(promise);
    			}
    		}
    	});
    };
    
    Promise.resolve = function (value) {
    	if (value && typeof value === 'object' && value.constructor === Promise) {
    		return value;
    	}
    
    	return new Promise(function (resolve) {
    		resolve(value);
    	});
    };
    
    Promise.reject = function (reason) {
    	return new Promise(function (resolve, reject) {
    		reject(reason);
    	});
    };
    
    module.exports = Promise;
    
  provide("pinkie", module.exports);
}(global));

// pakmanager:error-ex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var util = require('util');
    var isArrayish = require('is-arrayish');
    
    var errorEx = function errorEx(name, properties) {
    	if (!name || name.constructor !== String) {
    		properties = name || {};
    		name = Error.name;
    	}
    
    	var errorExError = function ErrorEXError(message) {
    		if (!this) {
    			return new ErrorEXError(message);
    		}
    
    		message = message instanceof Error
    			? message.message
    			: (message || this.message);
    
    		Error.call(this, message);
    		Error.captureStackTrace(this, errorExError);
    		this.name = name;
    
    		delete this.message;
    
    		Object.defineProperty(this, 'message', {
    			configurable: true,
    			enumerable: false,
    			get: function () {
    				var newMessage = message.split(/\r?\n/g);
    
    				for (var key in properties) {
    					if (properties.hasOwnProperty(key) && 'message' in properties[key]) {
    						newMessage = properties[key].message(this[key], newMessage) ||
    							newMessage;
    						if (!isArrayish(newMessage)) {
    							newMessage = [newMessage];
    						}
    					}
    				}
    
    				return newMessage.join('\n');
    			},
    			set: function (v) {
    				message = v;
    			}
    		});
    
    		var stackDescriptor = Object.getOwnPropertyDescriptor(this, 'stack');
    		var stackGetter = stackDescriptor.get;
    
    		stackDescriptor.get = function () {
    			var stack = stackGetter.call(this).split(/\r?\n+/g);
    
    			var lineCount = 1;
    			for (var key in properties) {
    				if (!properties.hasOwnProperty(key)) {
    					continue;
    				}
    
    				var modifier = properties[key];
    
    				if ('line' in modifier) {
    					var line = modifier.line(this[key]);
    					if (line) {
    						stack.splice(lineCount, 0, '    ' + line);
    					}
    				}
    
    				if ('stack' in modifier) {
    					modifier.stack(this[key], stack);
    				}
    			}
    
    			return stack.join('\n');
    		};
    
    		Object.defineProperty(this, 'stack', stackDescriptor);
    	};
    
    	util.inherits(errorExError, Error);
    
    	return errorExError;
    };
    
    errorEx.append = function (str, def) {
    	return {
    		message: function (v, message) {
    			v = v || def;
    
    			if (v) {
    				message[0] += ' ' + str.replace('%s', v.toString());
    			}
    
    			return message;
    		}
    	};
    };
    
    errorEx.line = function (str, def) {
    	return {
    		line: function (v) {
    			v = v || def;
    
    			if (v) {
    				return str.replace('%s', v.toString());
    			}
    
    			return null;
    		}
    	};
    };
    
    module.exports = errorEx;
    
  provide("error-ex", module.exports);
}(global));

// pakmanager:is-utf8
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    exports = module.exports = function(bytes)
    {
        var i = 0;
        while(i < bytes.length)
        {
            if(     (// ASCII
                        bytes[i] == 0x09 ||
                        bytes[i] == 0x0A ||
                        bytes[i] == 0x0D ||
                        (0x20 <= bytes[i] && bytes[i] <= 0x7E)
                    )
              ) {
                  i += 1;
                  continue;
              }
    
            if(     (// non-overlong 2-byte
                        (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
                        (0x80 <= bytes[i+1] && bytes[i+1] <= 0xBF)
                    )
              ) {
                  i += 2;
                  continue;
              }
    
            if(     (// excluding overlongs
                        bytes[i] == 0xE0 &&
                        (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                        (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
                    ) ||
                    (// straight 3-byte
                     ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
                      bytes[i] == 0xEE ||
                      bytes[i] == 0xEF) &&
                     (0x80 <= bytes[i + 1] && bytes[i+1] <= 0xBF) &&
                     (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
                    ) ||
                    (// excluding surrogates
                     bytes[i] == 0xED &&
                     (0x80 <= bytes[i+1] && bytes[i+1] <= 0x9F) &&
                     (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
                    )
              ) {
                  i += 3;
                  continue;
              }
    
            if(     (// planes 1-3
                        bytes[i] == 0xF0 &&
                        (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                        (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                        (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                    ) ||
                    (// planes 4-15
                     (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
                     (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                     (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                     (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                    ) ||
                    (// plane 16
                     bytes[i] == 0xF4 &&
                     (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
                     (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                     (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                    )
              ) {
                  i += 4;
                  continue;
              }
    
            return false;
        }
    
        return true;
    }
    
  provide("is-utf8", module.exports);
}(global));

// pakmanager:builtin-modules
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var blacklist = [
    	'freelist',
    	'sys'
    ];
    
    module.exports = Object.keys(process.binding('natives')).filter(function (el) {
    	return !/^_|^internal|\//.test(el) && blacklist.indexOf(el) === -1;
    }).sort();
    
  provide("builtin-modules", module.exports);
}(global));

// pakmanager:spdx-correct
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var licenseIDs = require('spdx-license-ids');
    
    function valid(string) {
      return licenseIDs.indexOf(string) > -1;
    }
    
    // Common transpositions of license identifier acronyms
    var transpositions = [
      ['APGL', 'AGPL'],
      ['Gpl', 'GPL'],
      ['GLP', 'GPL'],
      ['APL', 'Apache'],
      ['ISD', 'ISC'],
      ['GLP', 'GPL'],
      ['IST', 'ISC'],
      ['Claude', 'Clause'],
      [' or later', '+'],
      [' International', ''],
      ['GNU', 'GPL'],
      ['GUN', 'GPL'],
      ['+', ''],
      ['GNU GPL', 'GPL'],
      ['GNU/GPL', 'GPL'],
      ['GNU GLP', 'GPL'],
      ['GNU General Public License', 'GPL'],
      ['Gnu public license', 'GPL'],
      ['GNU Public License', 'GPL'],
      ['GNU GENERAL PUBLIC LICENSE', 'GPL'],
      ['MTI', 'MIT'],
      ['Mozilla Public License', 'MPL'],
      ['WTH', 'WTF'],
      ['-License', '']
    ];
    
    var TRANSPOSED = 0;
    var CORRECT = 1;
    
    // Simple corrections to nearly valid identifiers.
    var transforms = [
      // e.g. 'mit'
      function(argument) {
        return argument.toUpperCase();
      },
      // e.g. 'MIT '
      function(argument) {
        return argument.trim();
      },
      // e.g. 'M.I.T.'
      function(argument) {
        return argument.replace(/\./g, '');
      },
      // e.g. 'Apache- 2.0'
      function(argument) {
        return argument.replace(/\s+/g, '');
      },
      // e.g. 'CC BY 4.0''
      function(argument) {
        return argument.replace(/\s+/g, '-');
      },
      // e.g. 'LGPLv2.1'
      function(argument) {
        return argument.replace('v', '-');
      },
      // e.g. 'Apache 2.0'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, '-$1');
      },
      // e.g. 'GPL 2'
      function(argument) {
        return argument.replace(/,?\s*(\d)/, '-$1.0');
      },
      // e.g. 'Apache Version 2.0'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, '-$2');
      },
      // e.g. 'Apache Version 2'
      function(argument) {
        return argument.replace(/,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/, '-$2.0');
      },
      // e.g. 'ZLIB'
      function(argument) {
        return argument[0].toUpperCase() + argument.slice(1);
      },
      // e.g. 'MPL/2.0'
      function(argument) {
        return argument.replace('/', '-');
      },
      // e.g. 'Apache 2'
      function(argument) {
        return argument
          .replace(/\s*V\s*(\d)/, '-$1')
          .replace(/(\d)$/, '$1.0');
      },
      // e.g. 'GPL-2.0-'
      function(argument) {
        return argument.slice(0, argument.length - 1);
      },
      // e.g. 'GPL2'
      function(argument) {
        return argument.replace(/(\d)$/, '-$1.0');
      },
      // e.g. 'BSD 3'
      function(argument) {
        return argument.replace(/(-| )?(\d)$/, '-$2-Clause');
      },
      // e.g. 'BSD clause 3'
      function(argument) {
        return argument.replace(/(-| )clause(-| )(\d)/, '-$3-Clause');
      },
      // e.g. 'BY-NC-4.0'
      function(argument) {
        return 'CC-' + argument;
      },
      // e.g. 'BY-NC'
      function(argument) {
        return 'CC-' + argument + '-4.0';
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return argument
          .replace('Attribution', 'BY')
          .replace('NonCommercial', 'NC')
          .replace('NoDerivatives', 'ND')
          .replace(/ (\d)/, '-$1')
          .replace(/ ?International/, '');
      },
      // e.g. 'Attribution-NonCommercial'
      function(argument) {
        return 'CC-' +
          argument
          .replace('Attribution', 'BY')
          .replace('NonCommercial', 'NC')
          .replace('NoDerivatives', 'ND')
          .replace(/ (\d)/, '-$1')
          .replace(/ ?International/, '') +
          '-4.0';
      }
    ];
    
    // If all else fails, guess that strings containing certain substrings
    // meant to identify certain licenses.
    var lastResorts = [
      ['UNLI', 'Unlicense'],
      ['WTF', 'WTFPL'],
      ['2 CLAUSE', 'BSD-2-Clause'],
      ['2-CLAUSE', 'BSD-2-Clause'],
      ['3 CLAUSE', 'BSD-3-Clause'],
      ['3-CLAUSE', 'BSD-3-Clause'],
      ['AFFERO', 'AGPL-3.0'],
      ['AGPL', 'AGPL-3.0'],
      ['APACHE', 'Apache-2.0'],
      ['ARTISTIC', 'Artistic-2.0'],
      ['Affero', 'AGPL-3.0'],
      ['BEER', 'Beerware'],
      ['BOOST', 'BSL-1.0'],
      ['BSD', 'BSD-2-Clause'],
      ['ECLIPSE', 'EPL-1.0'],
      ['FUCK', 'WTFPL'],
      ['GNU', 'GPL-3.0'],
      ['LGPL', 'LGPL-3.0'],
      ['GPL', 'GPL-3.0'],
      ['MIT', 'MIT'],
      ['MPL', 'MPL-2.0'],
      ['X11', 'X11'],
      ['ZLIB', 'Zlib']
    ];
    
    var SUBSTRING = 0;
    var IDENTIFIER = 1;
    
    var validTransformation = function(identifier) {
      for (var i = 0; i < transforms.length; i++) {
        var transformed = transforms[i](identifier);
        if (transformed !== identifier && valid(transformed)) {
          return transformed;
        }
      }
      return null;
    };
    
    var validLastResort = function(identifier) {
      var upperCased = identifier.toUpperCase();
      for (var i = 0; i < lastResorts.length; i++) {
        var lastResort = lastResorts[i];
        if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
          return lastResort[IDENTIFIER];
        }
      }
      return null;
    };
    
    var anyCorrection = function(identifier, check) {
      for (var i = 0; i < transpositions.length; i++) {
        var transposition = transpositions[i];
        var transposed = transposition[TRANSPOSED];
        if (identifier.indexOf(transposed) > -1) {
          var corrected = identifier.replace(
            transposed,
            transposition[CORRECT]
          );
          var checked = check(corrected);
          if (checked !== null) {
            return checked;
          }
        }
      }
      return null;
    };
    
    module.exports = function(identifier) {
      identifier = identifier.replace(/\+$/, '');
      if (valid(identifier)) {
        return identifier;
      }
      var transformed = validTransformation(identifier);
      if (transformed !== null) {
        return transformed;
      }
      transformed = anyCorrection(identifier, function(argument) {
        if (valid(argument)) {
          return argument;
        }
        return validTransformation(argument);
      });
      if (transformed !== null) {
        return transformed;
      }
      transformed = validLastResort(identifier);
      if (transformed !== null) {
        return transformed;
      }
      transformed = anyCorrection(identifier, validLastResort);
      if (transformed !== null) {
        return transformed;
      }
      return null;
    };
    
  provide("spdx-correct", module.exports);
}(global));

// pakmanager:spdx-expression-parse/parser.generated.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var spdxparse=function(){var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,5],$V1=[1,6],$V2=[1,7],$V3=[1,4],$V4=[1,9],$V5=[1,10],$V6=[5,14,15,17],$V7=[5,12,14,15,17];var parser={trace:function trace(){},yy:{},symbols_:{error:2,start:3,expression:4,EOS:5,simpleExpression:6,LICENSE:7,PLUS:8,LICENSEREF:9,DOCUMENTREF:10,COLON:11,WITH:12,EXCEPTION:13,AND:14,OR:15,OPEN:16,CLOSE:17,$accept:0,$end:1},terminals_:{2:"error",5:"EOS",7:"LICENSE",8:"PLUS",9:"LICENSEREF",10:"DOCUMENTREF",11:"COLON",12:"WITH",13:"EXCEPTION",14:"AND",15:"OR",16:"OPEN",17:"CLOSE"},productions_:[0,[3,2],[6,1],[6,2],[6,1],[6,3],[4,1],[4,3],[4,3],[4,3],[4,3]],performAction:function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$){var $0=$$.length-1;switch(yystate){case 1:return this.$=$$[$0-1];break;case 2:case 4:case 5:this.$={license:yytext};break;case 3:this.$={license:$$[$0-1],plus:true};break;case 6:this.$=$$[$0];break;case 7:this.$={exception:$$[$0]};this.$.license=$$[$0-2].license;if($$[$0-2].hasOwnProperty("plus")){this.$.plus=$$[$0-2].plus}break;case 8:this.$={conjunction:"and",left:$$[$0-2],right:$$[$0]};break;case 9:this.$={conjunction:"or",left:$$[$0-2],right:$$[$0]};break;case 10:this.$=$$[$0-1];break}},table:[{3:1,4:2,6:3,7:$V0,9:$V1,10:$V2,16:$V3},{1:[3]},{5:[1,8],14:$V4,15:$V5},o($V6,[2,6],{12:[1,11]}),{4:12,6:3,7:$V0,9:$V1,10:$V2,16:$V3},o($V7,[2,2],{8:[1,13]}),o($V7,[2,4]),{11:[1,14]},{1:[2,1]},{4:15,6:3,7:$V0,9:$V1,10:$V2,16:$V3},{4:16,6:3,7:$V0,9:$V1,10:$V2,16:$V3},{13:[1,17]},{14:$V4,15:$V5,17:[1,18]},o($V7,[2,3]),{9:[1,19]},o($V6,[2,8]),o([5,15,17],[2,9],{14:$V4}),o($V6,[2,7]),o($V6,[2,10]),o($V7,[2,5])],defaultActions:{8:[2,1]},parseError:function parseError(str,hash){if(hash.recoverable){this.trace(str)}else{throw new Error(str)}},parse:function parse(input){var self=this,stack=[0],tstack=[],vstack=[null],lstack=[],table=this.table,yytext="",yylineno=0,yyleng=0,recovering=0,TERROR=2,EOF=1;var args=lstack.slice.call(arguments,1);var lexer=Object.create(this.lexer);var sharedState={yy:{}};for(var k in this.yy){if(Object.prototype.hasOwnProperty.call(this.yy,k)){sharedState.yy[k]=this.yy[k]}}lexer.setInput(input,sharedState.yy);sharedState.yy.lexer=lexer;sharedState.yy.parser=this;if(typeof lexer.yylloc=="undefined"){lexer.yylloc={}}var yyloc=lexer.yylloc;lstack.push(yyloc);var ranges=lexer.options&&lexer.options.ranges;if(typeof sharedState.yy.parseError==="function"){this.parseError=sharedState.yy.parseError}else{this.parseError=Object.getPrototypeOf(this).parseError}function popStack(n){stack.length=stack.length-2*n;vstack.length=vstack.length-n;lstack.length=lstack.length-n}_token_stack:function lex(){var token;token=lexer.lex()||EOF;if(typeof token!=="number"){token=self.symbols_[token]||token}return token}var symbol,preErrorSymbol,state,action,a,r,yyval={},p,len,newState,expected;while(true){state=stack[stack.length-1];if(this.defaultActions[state]){action=this.defaultActions[state]}else{if(symbol===null||typeof symbol=="undefined"){symbol=lex()}action=table[state]&&table[state][symbol]}if(typeof action==="undefined"||!action.length||!action[0]){var errStr="";expected=[];for(p in table[state]){if(this.terminals_[p]&&p>TERROR){expected.push("'"+this.terminals_[p]+"'")}}if(lexer.showPosition){errStr="Parse error on line "+(yylineno+1)+":\n"+lexer.showPosition()+"\nExpecting "+expected.join(", ")+", got '"+(this.terminals_[symbol]||symbol)+"'"}else{errStr="Parse error on line "+(yylineno+1)+": Unexpected "+(symbol==EOF?"end of input":"'"+(this.terminals_[symbol]||symbol)+"'")}this.parseError(errStr,{text:lexer.match,token:this.terminals_[symbol]||symbol,line:lexer.yylineno,loc:yyloc,expected:expected})}if(action[0]instanceof Array&&action.length>1){throw new Error("Parse Error: multiple actions possible at state: "+state+", token: "+symbol)}switch(action[0]){case 1:stack.push(symbol);vstack.push(lexer.yytext);lstack.push(lexer.yylloc);stack.push(action[1]);symbol=null;if(!preErrorSymbol){yyleng=lexer.yyleng;yytext=lexer.yytext;yylineno=lexer.yylineno;yyloc=lexer.yylloc;if(recovering>0){recovering--}}else{symbol=preErrorSymbol;preErrorSymbol=null}break;case 2:len=this.productions_[action[1]][1];yyval.$=vstack[vstack.length-len];yyval._$={first_line:lstack[lstack.length-(len||1)].first_line,last_line:lstack[lstack.length-1].last_line,first_column:lstack[lstack.length-(len||1)].first_column,last_column:lstack[lstack.length-1].last_column};if(ranges){yyval._$.range=[lstack[lstack.length-(len||1)].range[0],lstack[lstack.length-1].range[1]]}r=this.performAction.apply(yyval,[yytext,yyleng,yylineno,sharedState.yy,action[1],vstack,lstack].concat(args));if(typeof r!=="undefined"){return r}if(len){stack=stack.slice(0,-1*len*2);vstack=vstack.slice(0,-1*len);lstack=lstack.slice(0,-1*len)}stack.push(this.productions_[action[1]][0]);vstack.push(yyval.$);lstack.push(yyval._$);newState=table[stack[stack.length-2]][stack[stack.length-1]];stack.push(newState);break;case 3:return true}}return true}};var lexer=function(){var lexer={EOF:1,parseError:function parseError(str,hash){if(this.yy.parser){this.yy.parser.parseError(str,hash)}else{throw new Error(str)}},setInput:function(input,yy){this.yy=yy||this.yy||{};this._input=input;this._more=this._backtrack=this.done=false;this.yylineno=this.yyleng=0;this.yytext=this.matched=this.match="";this.conditionStack=["INITIAL"];this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};if(this.options.ranges){this.yylloc.range=[0,0]}this.offset=0;return this},input:function(){var ch=this._input[0];this.yytext+=ch;this.yyleng++;this.offset++;this.match+=ch;this.matched+=ch;var lines=ch.match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno++;this.yylloc.last_line++}else{this.yylloc.last_column++}if(this.options.ranges){this.yylloc.range[1]++}this._input=this._input.slice(1);return ch},unput:function(ch){var len=ch.length;var lines=ch.split(/(?:\r\n?|\n)/g);this._input=ch+this._input;this.yytext=this.yytext.substr(0,this.yytext.length-len);this.offset-=len;var oldLines=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1);this.matched=this.matched.substr(0,this.matched.length-1);if(lines.length-1){this.yylineno-=lines.length-1}var r=this.yylloc.range;this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:lines?(lines.length===oldLines.length?this.yylloc.first_column:0)+oldLines[oldLines.length-lines.length].length-lines[0].length:this.yylloc.first_column-len};if(this.options.ranges){this.yylloc.range=[r[0],r[0]+this.yyleng-len]}this.yyleng=this.yytext.length;return this},more:function(){this._more=true;return this},reject:function(){if(this.options.backtrack_lexer){this._backtrack=true}else{return this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})}return this},less:function(n){this.unput(this.match.slice(n))},pastInput:function(){var past=this.matched.substr(0,this.matched.length-this.match.length);return(past.length>20?"...":"")+past.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var next=this.match;if(next.length<20){next+=this._input.substr(0,20-next.length)}return(next.substr(0,20)+(next.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var pre=this.pastInput();var c=new Array(pre.length+1).join("-");return pre+this.upcomingInput()+"\n"+c+"^"},test_match:function(match,indexed_rule){var token,lines,backup;if(this.options.backtrack_lexer){backup={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done};if(this.options.ranges){backup.yylloc.range=this.yylloc.range.slice(0)}}lines=match[0].match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno+=lines.length}this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:lines?lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+match[0].length};this.yytext+=match[0];this.match+=match[0];this.matches=match;this.yyleng=this.yytext.length;if(this.options.ranges){this.yylloc.range=[this.offset,this.offset+=this.yyleng]}this._more=false;this._backtrack=false;this._input=this._input.slice(match[0].length);this.matched+=match[0];token=this.performAction.call(this,this.yy,this,indexed_rule,this.conditionStack[this.conditionStack.length-1]);if(this.done&&this._input){this.done=false}if(token){return token}else if(this._backtrack){for(var k in backup){this[k]=backup[k]}return false}return false},next:function(){if(this.done){return this.EOF}if(!this._input){this.done=true}var token,match,tempMatch,index;if(!this._more){this.yytext="";this.match=""}var rules=this._currentRules();for(var i=0;i<rules.length;i++){tempMatch=this._input.match(this.rules[rules[i]]);if(tempMatch&&(!match||tempMatch[0].length>match[0].length)){match=tempMatch;index=i;if(this.options.backtrack_lexer){token=this.test_match(tempMatch,rules[i]);if(token!==false){return token}else if(this._backtrack){match=false;continue}else{return false}}else if(!this.options.flex){break}}}if(match){token=this.test_match(match,rules[index]);if(token!==false){return token}return false}if(this._input===""){return this.EOF}else{return this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})}},lex:function lex(){var r=this.next();if(r){return r}else{return this.lex()}},begin:function begin(condition){this.conditionStack.push(condition)},popState:function popState(){var n=this.conditionStack.length-1;if(n>0){return this.conditionStack.pop()}else{return this.conditionStack[0]}},_currentRules:function _currentRules(){if(this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules}else{return this.conditions["INITIAL"].rules}},topState:function topState(n){n=this.conditionStack.length-1-Math.abs(n||0);if(n>=0){return this.conditionStack[n]}else{return"INITIAL"}},pushState:function pushState(condition){this.begin(condition)},stateStackSize:function stateStackSize(){return this.conditionStack.length},options:{},performAction:function anonymous(yy,yy_,$avoiding_name_collisions,YY_START){var YYSTATE=YY_START;switch($avoiding_name_collisions){case 0:return 5;break;case 1:break;case 2:return 8;break;case 3:return 16;break;case 4:return 17;break;case 5:return 11;break;case 6:return 10;break;case 7:return 9;break;case 8:return 14;break;case 9:return 15;break;case 10:return 12;break;case 11:return 7;break;case 12:return 7;break;case 13:return 7;break;case 14:return 13;break;case 15:return 13;break;case 16:return 13;break;case 17:return 13;break;case 18:return 13;break;case 19:return 13;break;case 20:return 13;break;case 21:return 13;break;case 22:return 7;break;case 23:return 7;break;case 24:return 13;break;case 25:return 13;break;case 26:return 13;break;case 27:return 7;break;case 28:return 13;break;case 29:return 13;break;case 30:return 13;break;case 31:return 7;break;case 32:return 7;break;case 33:return 13;break;case 34:return 13;break;case 35:return 13;break;case 36:return 7;break;case 37:return 13;break;case 38:return 7;break;case 39:return 7;break;case 40:return 7;break;case 41:return 7;break;case 42:return 7;break;case 43:return 7;break;case 44:return 7;break;case 45:return 7;break;case 46:return 7;break;case 47:return 7;break;case 48:return 7;break;case 49:return 7;break;case 50:return 7;break;case 51:return 13;break;case 52:return 7;break;case 53:return 7;break;case 54:return 7;break;case 55:return 13;break;case 56:return 7;break;case 57:return 7;break;case 58:return 7;break;case 59:return 13;break;case 60:return 7;break;case 61:return 13;break;case 62:return 7;break;case 63:return 7;break;case 64:return 7;break;case 65:return 7;break;case 66:return 7;break;case 67:return 7;break;case 68:return 7;break;case 69:return 7;break;case 70:return 7;break;case 71:return 7;break;case 72:return 7;break;case 73:return 7;break;case 74:return 7;break;case 75:return 7;break;case 76:return 7;break;case 77:return 7;break;case 78:return 7;break;case 79:return 7;break;case 80:return 7;break;case 81:return 7;break;case 82:return 7;break;case 83:return 7;break;case 84:return 7;break;case 85:return 7;break;case 86:return 7;break;case 87:return 7;break;case 88:return 7;break;case 89:return 7;break;case 90:return 7;break;case 91:return 7;break;case 92:return 7;break;case 93:return 7;break;case 94:return 7;break;case 95:return 7;break;case 96:return 7;break;case 97:return 7;break;case 98:return 7;break;case 99:return 7;break;case 100:return 7;break;case 101:return 7;break;case 102:return 7;break;case 103:return 7;break;case 104:return 7;break;case 105:return 7;break;case 106:return 7;break;case 107:return 7;break;case 108:return 7;break;case 109:return 7;break;case 110:return 7;break;case 111:return 7;break;case 112:return 7;break;case 113:return 7;break;case 114:return 7;break;case 115:return 7;break;case 116:return 7;break;case 117:return 7;break;case 118:return 7;break;case 119:return 7;break;case 120:return 7;break;case 121:return 7;break;case 122:return 7;break;case 123:return 7;break;case 124:return 7;break;case 125:return 7;break;case 126:return 7;break;case 127:return 7;break;case 128:return 7;break;case 129:return 7;break;case 130:return 7;break;case 131:return 7;break;case 132:return 7;break;case 133:return 7;break;case 134:return 7;break;case 135:return 7;break;case 136:return 7;break;case 137:return 7;break;case 138:return 7;break;case 139:return 7;break;case 140:return 7;break;case 141:return 7;break;case 142:return 7;break;case 143:return 7;break;case 144:return 7;break;case 145:return 7;break;case 146:return 7;break;case 147:return 7;break;case 148:return 7;break;case 149:return 7;break;case 150:return 7;break;case 151:return 7;break;case 152:return 7;break;case 153:return 7;break;case 154:return 7;break;case 155:return 7;break;case 156:return 7;break;case 157:return 7;break;case 158:return 7;break;case 159:return 7;break;case 160:return 7;break;case 161:return 7;break;case 162:return 7;break;case 163:return 7;break;case 164:return 7;break;case 165:return 7;break;case 166:return 7;break;case 167:return 7;break;case 168:return 7;break;case 169:return 7;break;case 170:return 7;break;case 171:return 7;break;case 172:return 7;break;case 173:return 7;break;case 174:return 7;break;case 175:return 7;break;case 176:return 7;break;case 177:return 7;break;case 178:return 7;break;case 179:return 7;break;case 180:return 7;break;case 181:return 7;break;case 182:return 7;break;case 183:return 7;break;case 184:return 7;break;case 185:return 7;break;case 186:return 7;break;case 187:return 7;break;case 188:return 7;break;case 189:return 7;break;case 190:return 7;break;case 191:return 7;break;case 192:return 7;break;case 193:return 7;break;case 194:return 7;break;case 195:return 7;break;case 196:return 7;break;case 197:return 7;break;case 198:return 7;break;case 199:return 7;break;case 200:return 7;break;case 201:return 7;break;case 202:return 7;break;case 203:return 7;break;case 204:return 7;break;case 205:return 7;break;case 206:return 7;break;case 207:return 7;break;case 208:return 7;break;case 209:return 7;break;case 210:return 7;break;case 211:return 7;break;case 212:return 7;break;case 213:return 7;break;case 214:return 7;break;case 215:return 7;break;case 216:return 7;break;case 217:return 7;break;case 218:return 7;break;case 219:return 7;break;case 220:return 7;break;case 221:return 7;break;case 222:return 7;break;case 223:return 7;break;case 224:return 7;break;case 225:return 7;break;case 226:return 7;break;case 227:return 7;break;case 228:return 7;break;case 229:return 7;break;case 230:return 7;break;case 231:return 7;break;case 232:return 7;break;case 233:return 7;break;case 234:return 7;break;case 235:return 7;break;case 236:return 7;break;case 237:return 7;break;case 238:return 7;break;case 239:return 7;break;case 240:return 7;break;case 241:return 7;break;case 242:return 7;break;case 243:return 7;break;case 244:return 7;break;case 245:return 7;break;case 246:return 7;break;case 247:return 7;break;case 248:return 7;break;case 249:return 7;break;case 250:return 7;break;case 251:return 7;break;case 252:return 7;break;case 253:return 7;break;case 254:return 7;break;case 255:return 7;break;case 256:return 7;break;case 257:return 7;break;case 258:return 7;break;case 259:return 7;break;case 260:return 7;break;case 261:return 7;break;case 262:return 7;break;case 263:return 7;break;case 264:return 7;break;case 265:return 7;break;case 266:return 7;break;case 267:return 7;break;case 268:return 7;break;case 269:return 7;break;case 270:return 7;break;case 271:return 7;break;case 272:return 7;break;case 273:return 7;break;case 274:return 7;break;case 275:return 7;break;case 276:return 7;break;case 277:return 7;break;case 278:return 7;break;case 279:return 7;break;case 280:return 7;break;case 281:return 7;break;case 282:return 7;break;case 283:return 7;break;case 284:return 7;break;case 285:return 7;break;case 286:return 7;break;case 287:return 7;break;case 288:return 7;break;case 289:return 7;break;case 290:return 7;break;case 291:return 7;break;case 292:return 7;break;case 293:return 7;break;case 294:return 7;break;case 295:return 7;break;case 296:return 7;break;case 297:return 7;break;case 298:return 7;break;case 299:return 7;break;case 300:return 7;break;case 301:return 7;break;case 302:return 7;break;case 303:return 7;break;case 304:return 7;break;case 305:return 7;break;case 306:return 7;break;case 307:return 7;break;case 308:return 7;break;case 309:return 7;break;case 310:return 7;break;case 311:return 7;break;case 312:return 7;break;case 313:return 7;break;case 314:return 7;break;case 315:return 7;break;case 316:return 7;break;case 317:return 7;break;case 318:return 7;break;case 319:return 7;break;case 320:return 7;break;case 321:return 7;break;case 322:return 7;break;case 323:return 7;break;case 324:return 7;break;case 325:return 7;break;case 326:return 7;break;case 327:return 7;break;case 328:return 7;break;case 329:return 7;break;case 330:return 7;break;case 331:return 7;break;case 332:return 7;break;case 333:return 7;break;case 334:return 7;break;case 335:return 7;break;case 336:return 7;break;case 337:return 7;break;case 338:return 7;break}},rules:[/^(?:$)/,/^(?:\s+)/,/^(?:\+)/,/^(?:\()/,/^(?:\))/,/^(?::)/,/^(?:DocumentRef-([0-9A-Za-z-+.]+))/,/^(?:LicenseRef-([0-9A-Za-z-+.]+))/,/^(?:AND)/,/^(?:OR)/,/^(?:WITH)/,/^(?:MPL-2\.0-no-copyleft-exception)/,/^(?:CNRI-Python-GPL-Compatible)/,/^(?:BSD-3-Clause-Attribution)/,/^(?:WxWindows-exception-3\.1)/,/^(?:Classpath-exception-2\.0)/,/^(?:gnu-javamail-exception)/,/^(?:freertos-exception-2\.0)/,/^(?:i2p-gpl-java-exception)/,/^(?:Autoconf-exception-2\.0)/,/^(?:Nokia-Qt-exception-1\.1)/,/^(?:Autoconf-exception-3\.0)/,/^(?:zlib-acknowledgement)/,/^(?:BSD-2-Clause-FreeBSD)/,/^(?:u-boot-exception-2\.0)/,/^(?:Bison-exception-2\.2)/,/^(?:CLISP-exception-2\.0)/,/^(?:BSD-2-Clause-NetBSD)/,/^(?:FLTK-exception-2\.0)/,/^(?:eCos-exception-2\.0)/,/^(?:Font-exception-2\.0)/,/^(?:BSD-3-Clause-Clear)/,/^(?:BSD-3-Clause-LBNL)/,/^(?:GCC-exception-3\.1)/,/^(?:Qwt-exception-1\.0)/,/^(?:GCC-exception-2\.0)/,/^(?:Artistic-1\.0-Perl)/,/^(?:Libtool-exception)/,/^(?:Artistic-1\.0-cl8)/,/^(?:CC-BY-NC-SA-4\.0)/,/^(?:CC-BY-NC-SA-1\.0)/,/^(?:CC-BY-NC-ND-4\.0)/,/^(?:CC-BY-NC-SA-3\.0)/,/^(?:CC-BY-NC-ND-3\.0)/,/^(?:CC-BY-NC-SA-2\.5)/,/^(?:CC-BY-NC-ND-2\.0)/,/^(?:CC-BY-NC-ND-1\.0)/,/^(?:CC-BY-NC-SA-2\.0)/,/^(?:MIT-advertising)/,/^(?:BSD-4-Clause-UC)/,/^(?:CC-BY-NC-ND-2\.5)/,/^(?:FLTK-exception)/,/^(?:SugarCRM-1\.1\.3)/,/^(?:CrystalStacker)/,/^(?:BSD-Protection)/,/^(?:LZMA-exception)/,/^(?:BitTorrent-1\.1)/,/^(?:BitTorrent-1\.0)/,/^(?:Frameworx-1\.0)/,/^(?:mif-exception)/,/^(?:Interbase-1\.0)/,/^(?:389-exception)/,/^(?:HaskellReport)/,/^(?:CC-BY-NC-3\.0)/,/^(?:CC-BY-ND-4\.0)/,/^(?:CC-BY-NC-1\.0)/,/^(?:CC-BY-NC-2\.0)/,/^(?:CC-BY-NC-2\.5)/,/^(?:CC-BY-SA-4\.0)/,/^(?:CC-BY-NC-4\.0)/,/^(?:W3C-19980720)/,/^(?:BSD-4-Clause)/,/^(?:Artistic-1\.0)/,/^(?:BSD-3-Clause)/,/^(?:CC-BY-ND-1\.0)/,/^(?:BSD-2-Clause)/,/^(?:CC-BY-ND-2\.0)/,/^(?:CC-BY-ND-2\.5)/,/^(?:CC-BY-ND-3\.0)/,/^(?:Artistic-2\.0)/,/^(?:CC-BY-SA-1\.0)/,/^(?:CC-BY-SA-2\.0)/,/^(?:CC-BY-SA-2\.5)/,/^(?:CC-BY-SA-3\.0)/,/^(?:XFree86-1\.1)/,/^(?:OLDAP-2\.0\.1)/,/^(?:bzip2-1\.0\.6)/,/^(?:OLDAP-2\.2\.1)/,/^(?:ImageMagick)/,/^(?:Unicode-TOU)/,/^(?:Adobe-Glyph)/,/^(?:CUA-OPL-1\.0)/,/^(?:CNRI-Jython)/,/^(?:CNRI-Python)/,/^(?:bzip2-1\.0\.5)/,/^(?:OLDAP-2\.2\.2)/,/^(?:PostgreSQL)/,/^(?:Apache-1\.1)/,/^(?:CECILL-1\.0)/,/^(?:Apache-2\.0)/,/^(?:Zimbra-1\.4)/,/^(?:CECILL-1\.1)/,/^(?:Zimbra-1\.3)/,/^(?:Adobe-2006)/,/^(?:JasPer-2\.0)/,/^(?:CECILL-2\.0)/,/^(?:TORQUE-1\.1)/,/^(?:CECILL-2\.1)/,/^(?:Watcom-1\.0)/,/^(?:Intel-ACPI)/,/^(?:ClArtistic)/,/^(?:Spencer-99)/,/^(?:Condor-1\.1)/,/^(?:Spencer-94)/,/^(?:gSOAP-1\.3b)/,/^(?:EUDatagrid)/,/^(?:Spencer-86)/,/^(?:Python-2\.0)/,/^(?:RHeCos-1\.1)/,/^(?:CATOSL-1\.1)/,/^(?:Apache-1\.0)/,/^(?:FreeImage)/,/^(?:SGI-B-1\.1)/,/^(?:SGI-B-1\.0)/,/^(?:SimPL-2\.0)/,/^(?:Sleepycat)/,/^(?:Crossword)/,/^(?:ErlPL-1\.1)/,/^(?:CPOL-1\.02)/,/^(?:OLDAP-2\.8)/,/^(?:OLDAP-2\.7)/,/^(?:OLDAP-2\.6)/,/^(?:CC-BY-1\.0)/,/^(?:OLDAP-2\.5)/,/^(?:OLDAP-2\.4)/,/^(?:OLDAP-2\.3)/,/^(?:SISSL-1\.2)/,/^(?:Unlicense)/,/^(?:SGI-B-2\.0)/,/^(?:OLDAP-2\.2)/,/^(?:OLDAP-2\.1)/,/^(?:CC-BY-2\.5)/,/^(?:D-FSL-1\.0)/,/^(?:LPPL-1\.3a)/,/^(?:LPPL-1\.3c)/,/^(?:OLDAP-2\.0)/,/^(?:CC-BY-3\.0)/,/^(?:Leptonica)/,/^(?:OLDAP-1\.4)/,/^(?:OLDAP-1\.3)/,/^(?:OLDAP-1\.2)/,/^(?:OLDAP-1\.1)/,/^(?:MakeIndex)/,/^(?:CC-BY-4\.0)/,/^(?:NPOSL-3\.0)/,/^(?:CC-BY-2\.0)/,/^(?:PHP-3\.01)/,/^(?:ANTLR-PD)/,/^(?:APSL-1\.0)/,/^(?:MIT-enna)/,/^(?:IBM-pibs)/,/^(?:APSL-1\.1)/,/^(?:APSL-1\.2)/,/^(?:Beerware)/,/^(?:EUPL-1\.0)/,/^(?:EUPL-1\.1)/,/^(?:diffmark)/,/^(?:CDDL-1\.0)/,/^(?:Zend-2\.0)/,/^(?:CDDL-1\.1)/,/^(?:CPAL-1\.0)/,/^(?:APSL-2\.0)/,/^(?:LPPL-1\.0)/,/^(?:AGPL-1\.0)/,/^(?:Giftware)/,/^(?:Abstyles)/,/^(?:LPPL-1\.1)/,/^(?:LPPL-1\.2)/,/^(?:Sendmail)/,/^(?:CECILL-B)/,/^(?:AGPL-3\.0)/,/^(?:GFDL-1\.1)/,/^(?:GFDL-1\.2)/,/^(?:GFDL-1\.3)/,/^(?:RPSL-1\.0)/,/^(?:LPL-1\.02)/,/^(?:CECILL-C)/,/^(?:Afmparse)/,/^(?:LGPL-2\.1)/,/^(?:PDDL-1\.0)/,/^(?:ODbL-1\.0)/,/^(?:OCLC-2\.0)/,/^(?:LGPL-3\.0)/,/^(?:Newsletr)/,/^(?:Motosoto)/,/^(?:NBPL-1\.0)/,/^(?:NASA-1\.3)/,/^(?:LGPL-2\.0)/,/^(?:FSFULLR)/,/^(?:MPL-2\.0)/,/^(?:Multics)/,/^(?:AFL-1\.1)/,/^(?:MPL-1\.1)/,/^(?:AFL-1\.2)/,/^(?:MPL-1\.0)/,/^(?:AFL-2\.0)/,/^(?:AFL-2\.1)/,/^(?:AFL-3\.0)/,/^(?:NPL-1\.0)/,/^(?:NPL-1\.1)/,/^(?:APL-1\.0)/,/^(?:Aladdin)/,/^(?:AMDPLPA)/,/^(?:BSL-1\.0)/,/^(?:Borceux)/,/^(?:Caldera)/,/^(?:MIT-CMU)/,/^(?:CPL-1\.0)/,/^(?:ZPL-2\.1)/,/^(?:ZPL-2\.0)/,/^(?:ZPL-1\.1)/,/^(?:CC0-1\.0)/,/^(?:YPL-1\.1)/,/^(?:LPL-1\.0)/,/^(?:libtiff)/,/^(?:YPL-1\.0)/,/^(?:Dotseqn)/,/^(?:Latex2e)/,/^(?:VSL-1\.0)/,/^(?:VOSTROM)/,/^(?:UPL-1\.0)/,/^(?:dvipdfm)/,/^(?:EPL-1\.0)/,/^(?:ECL-1\.0)/,/^(?:ECL-2\.0)/,/^(?:SPL-1\.0)/,/^(?:IPL-1\.0)/,/^(?:EFL-1\.0)/,/^(?:EFL-2\.0)/,/^(?:OPL-1\.0)/,/^(?:OSL-1\.0)/,/^(?:OSL-1\.1)/,/^(?:OSL-2\.0)/,/^(?:OSL-2\.1)/,/^(?:OSL-3\.0)/,/^(?:OpenSSL)/,/^(?:PHP-3\.0)/,/^(?:gnuplot)/,/^(?:Entessa)/,/^(?:GPL-3\.0)/,/^(?:Eurosym)/,/^(?:psutils)/,/^(?:GPL-2\.0)/,/^(?:QPL-1\.0)/,/^(?:MIT-feh)/,/^(?:OFL-1\.1)/,/^(?:GPL-1\.0)/,/^(?:RPL-1\.1)/,/^(?:RPL-1\.5)/,/^(?:OFL-1\.0)/,/^(?:Saxpath)/,/^(?:Bahyph)/,/^(?:RSA-MD)/,/^(?:Naumen)/,/^(?:NetCDF)/,/^(?:mpich2)/,/^(?:Glulxe)/,/^(?:APAFML)/,/^(?:psfrag)/,/^(?:Plexus)/,/^(?:SAX-PD)/,/^(?:MITNFA)/,/^(?:eGenix)/,/^(?:iMatix)/,/^(?:Imlib2)/,/^(?:Libpng)/,/^(?:xinetd)/,/^(?:LGPLLR)/,/^(?:Wsuipa)/,/^(?:SMLNJ)/,/^(?:RSCPL)/,/^(?:SISSL)/,/^(?:Rdisc)/,/^(?:Noweb)/,/^(?:Qhull)/,/^(?:Nunit)/,/^(?:GL2PS)/,/^(?:TMate)/,/^(?:MirOS)/,/^(?:MS-RL)/,/^(?:Intel)/,/^(?:MS-PL)/,/^(?:OGTSL)/,/^(?:WTFPL)/,/^(?:Nokia)/,/^(?:XSkat)/,/^(?:Glide)/,/^(?:FSFUL)/,/^(?:AMPAS)/,/^(?:Xerox)/,/^(?:0BSD)/,/^(?:Ruby)/,/^(?:JSON)/,/^(?:MTLL)/,/^(?:Cube)/,/^(?:Zlib)/,/^(?:NCSA)/,/^(?:TOSL)/,/^(?:Xnet)/,/^(?:DSDP)/,/^(?:HPND)/,/^(?:Barr)/,/^(?:SNIA)/,/^(?:ADSL)/,/^(?:NLPL)/,/^(?:Fair)/,/^(?:NOSL)/,/^(?:NGPL)/,/^(?:SCEA)/,/^(?:Zed)/,/^(?:DOC)/,/^(?:ICU)/,/^(?:Vim)/,/^(?:xpp)/,/^(?:OML)/,/^(?:AAL)/,/^(?:AML)/,/^(?:W3C)/,/^(?:ISC)/,/^(?:IPA)/,/^(?:X11)/,/^(?:MIT)/,/^(?:FTL)/,/^(?:IJG)/,/^(?:TCL)/,/^(?:SWL)/,/^(?:NTP)/,/^(?:Mup)/,/^(?:NRL)/],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338],inclusive:true}}};return lexer}();parser.lexer=lexer;function Parser(){this.yy={}}Parser.prototype=parser;parser.Parser=Parser;return new Parser}();if(typeof require!=="undefined"&&typeof exports!=="undefined"){exports.parser=spdxparse;exports.Parser=spdxparse.Parser;exports.parse=function(){return spdxparse.parse.apply(spdxparse,arguments)};exports.main=function commonjsMain(args){if(!args[1]){console.log("Usage: "+args[0]+" FILE");process.exit(1)}var source=require("fs").readFileSync(require("path").normalize(args[1]),"utf8");return exports.parser.parse(source)};if(typeof module!=="undefined"&&require.main===module){exports.main(process.argv.slice(1))}}
    
  provide("spdx-expression-parse/parser.generated.js", module.exports);
}(global));

// pakmanager:spdx-expression-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parser =  require('spdx-expression-parse/parser.generated.js').parser
    
    module.exports = function(argument) {
      return parser.parse(argument) }
    
  provide("spdx-expression-parse", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
    exports.SourceNode = require('./lib/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:lodash._mapcache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    
    /** Used to detect host constructors (Safari > 5). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    
    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;
    
    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );
    
    /** Built-in value references. */
    var splice = arrayProto.splice;
    
    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map'),
        nativeCreate = getNative(Object, 'create');
    
    /**
     * Creates an hash object.
     *
     * @private
     * @constructor
     * @returns {Object} Returns the new hash object.
     */
    function Hash() {}
    
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(hash, key) {
      return hashHas(hash, key) && delete hash[key];
    }
    
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(hash, key) {
      if (nativeCreate) {
        var result = hash[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
    }
    
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(hash, key) {
      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
    }
    
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function hashSet(hash, key, value) {
      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    }
    
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function MapCache(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapClear() {
      this.__data__ = {
        'hash': new Hash,
        'map': Map ? new Map : [],
        'string': new Hash
      };
    }
    
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapDelete(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
    }
    
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapGet(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.get(key) : assocGet(data.map, key);
    }
    
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.has(key) : assocHas(data.map, key);
    }
    
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache object.
     */
    function mapSet(key, value) {
      var data = this.__data__;
      if (isKeyable(key)) {
        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
      } else if (Map) {
        data.map.set(key, value);
      } else {
        assocSet(data.map, key, value);
      }
      return this;
    }
    
    /**
     * Removes `key` and its value from the associative array.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function assocDelete(array, key) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = array.length - 1;
      if (index == lastIndex) {
        array.pop();
      } else {
        splice.call(array, index, 1);
      }
      return true;
    }
    
    /**
     * Gets the associative array value for `key`.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function assocGet(array, key) {
      var index = assocIndexOf(array, key);
      return index < 0 ? undefined : array[index][1];
    }
    
    /**
     * Checks if an associative array value for `key` exists.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function assocHas(array, key) {
      return assocIndexOf(array, key) > -1;
    }
    
    /**
     * Gets the index at which the first occurrence of `key` is found in `array`
     * of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    
    /**
     * Sets the associative array `key` to `value`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function assocSet(array, key, value) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        array.push([key, value]);
      } else {
        array[index][1] = value;
      }
    }
    
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }
    
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return type == 'number' || type == 'boolean' ||
        (type == 'string' && value != '__proto__') || value == null;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(funcToString.call(value));
      }
      return isObjectLike(value) &&
        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
    }
    
    // Avoid inheriting from `Object.prototype` when possible.
    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
    
    // Add functions to the `MapCache`.
    MapCache.prototype.clear = mapClear;
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;
    
    module.exports = MapCache;
    
  provide("lodash._mapcache", module.exports);
}(global));

// pakmanager:randombytes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('crypto').randomBytes
    
  provide("randombytes", module.exports);
}(global));

// pakmanager:brorand
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var r;
    
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
    
      return r.generate(len);
    };
    
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    
    if (typeof window === 'object') {
      if (window.crypto && window.crypto.getRandomValues) {
        // Modern browsers
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          window.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (window.msCrypto && window.msCrypto.getRandomValues) {
        // IE
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          window.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else {
        // Old junk
        Rand.prototype._rand = function() {
          throw new Error('Not implemented yet');
        };
      }
    } else {
      // Node.js or Web worker
      try {
        var crypto = require('cry' + 'pto');
    
        Rand.prototype._rand = function _rand(n) {
          return crypto.randomBytes(n);
        };
      } catch (e) {
        // Emulate crypto API using randy
        Rand.prototype._rand = function _rand(n) {
          var res = new Uint8Array(n);
          for (var i = 0; i < res.length; i++)
            res[i] = this.rand.getByte();
          return res;
        };
      }
    }
    
  provide("brorand", module.exports);
}(global));

// pakmanager:browserify-aes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
    
    exports.createCipher = exports.Cipher = crypto.createCipher
    exports.createCipheriv = exports.Cipheriv = crypto.createCipheriv
    exports.createDecipher = exports.Decipher = crypto.createDecipher
    exports.createDecipheriv = exports.Decipheriv = crypto.createDecipheriv
    exports.listCiphers = exports.getCiphers = crypto.getCiphers
    
  provide("browserify-aes", module.exports);
}(global));

// pakmanager:pbkdf2/browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var createHmac = require('create-hmac')
    var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
    
    exports.pbkdf2 = pbkdf2
    function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === 'function') {
        callback = digest
        digest = undefined
      }
    
      if (typeof callback !== 'function') {
        throw new Error('No callback provided to pbkdf2')
      }
    
      var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
      setTimeout(function () {
        callback(undefined, result)
      })
    }
    
    exports.pbkdf2Sync = pbkdf2Sync
    function pbkdf2Sync (password, salt, iterations, keylen, digest) {
      if (typeof iterations !== 'number') {
        throw new TypeError('Iterations not a number')
      }
    
      if (iterations < 0) {
        throw new TypeError('Bad iterations')
      }
    
      if (typeof keylen !== 'number') {
        throw new TypeError('Key length not a number')
      }
    
      if (keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError('Bad key length')
      }
    
      digest = digest || 'sha1'
    
      if (!Buffer.isBuffer(password)) password = new Buffer(password, 'binary')
      if (!Buffer.isBuffer(salt)) salt = new Buffer(salt, 'binary')
    
      var hLen
      var l = 1
      var DK = new Buffer(keylen)
      var block1 = new Buffer(salt.length + 4)
      salt.copy(block1, 0, 0, salt.length)
    
      var r
      var T
    
      for (var i = 1; i <= l; i++) {
        block1.writeUInt32BE(i, salt.length)
        var U = createHmac(digest, password).update(block1).digest()
    
        if (!hLen) {
          hLen = U.length
          T = new Buffer(hLen)
          l = Math.ceil(keylen / hLen)
          r = keylen - (l - 1) * hLen
        }
    
        U.copy(T, 0, 0, hLen)
    
        for (var j = 1; j < iterations; j++) {
          U = createHmac(digest, password).update(U).digest()
    
          for (var k = 0; k < hLen; k++) {
            T[k] ^= U[k]
          }
        }
    
        var destPos = (i - 1) * hLen
        var len = (i === l ? r : hLen)
        T.copy(DK, destPos, 0, len)
      }
    
      return DK
    }
    
  provide("pbkdf2/browser", module.exports);
}(global));

// pakmanager:pbkdf2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var compat =  require('pbkdf2/browser')
    var crypto = require('crypto')
    var fork = require('child_process').fork
    var path = require('path')
    
    var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
    
    function asyncPBKDF2 (password, salt, iterations, keylen, digest, callback) {
      if (typeof iterations !== 'number') {
        throw new TypeError('Iterations not a number')
      }
    
      if (iterations < 0) {
        throw new TypeError('Bad iterations')
      }
    
      if (typeof keylen !== 'number') {
        throw new TypeError('Key length not a number')
      }
    
      if (keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError('Bad key length')
      }
    
      if (typeof password === 'string') {
        password = new Buffer(password, 'binary')
      }
    
      if (typeof salt === 'string') {
        salt = new Buffer(salt, 'binary')
      }
    
      var child = fork(path.resolve(__dirname, 'async-shim.js'))
    
      child.on('message', function (result) {
        if (result.type === 'success') {
          callback(null, new Buffer(result.data, 'hex'))
        } else if (result.type === 'fail') {
          callback(new TypeError(result.data))
        }
      })
    
      child.send({
        password: password.toString('hex'),
        salt: salt.toString('hex'),
        iterations: iterations,
        keylen: keylen,
        digest: digest
      })
    }
    
    exports.pbkdf2Sync = function pbkdf2Sync (password, salt, iterations, keylen, digest) {
      digest = digest || 'sha1'
    
      if (isNode10()) {
        if (digest === 'sha1') {
          return crypto.pbkdf2Sync(password, salt, iterations, keylen)
        } else {
          return compat.pbkdf2Sync(password, salt, iterations, keylen, digest)
        }
      } else {
        return crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)
      }
    }
    
    exports.pbkdf2 = function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
      if (typeof digest === 'function') {
        callback = digest
        digest = 'sha1'
      }
    
      if (isNode10()) {
        if (digest === 'sha1') {
          return crypto.pbkdf2(password, salt, iterations, keylen, callback)
        } else {
          return asyncPBKDF2(password, salt, iterations, keylen, digest, callback)
        }
      } else {
        return crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)
      }
    }
    
    var sha1 = '0c60c80f961f0e71f3a9b524af6012062fe037a6e0f0eb94fe8fc46bdc637164'
    var isNode10Result
    
    function isNode10 () {
      if (typeof isNode10Result === 'undefined') {
        isNode10Result = crypto.pbkdf2Sync('password', 'salt', 1, 32, 'sha256').toString('hex') === sha1
      }
    
      return isNode10Result
    }
    
  provide("pbkdf2", module.exports);
}(global));

// pakmanager:jsonify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.parse = require('./lib/parse');
    exports.stringify = require('./lib/stringify');
    
  provide("jsonify", module.exports);
}(global));

// pakmanager:arr-diff
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * arr-diff <https://github.com/jonschlinkert/arr-diff>
     *
     * Copyright (c) 2014 Jon Schlinkert, contributors.
     * Licensed under the MIT License
     */
    
    'use strict';
    
    var flatten = require('arr-flatten');
    var slice = [].slice;
    
    /**
     * Return the difference between the first array and
     * additional arrays.
     *
     * ```js
     * var diff = require('{%= name %}');
     *
     * var a = ['a', 'b', 'c', 'd'];
     * var b = ['b', 'c'];
     *
     * console.log(diff(a, b))
     * //=> ['a', 'd']
     * ```
     *
     * @param  {Array} `a`
     * @param  {Array} `b`
     * @return {Array}
     * @api public
     */
    
    function diff(arr, arrays) {
      var argsLen = arguments.length;
      var len = arr.length, i = -1;
      var res = [], arrays;
    
      if (argsLen === 1) {
        return arr;
      }
    
      if (argsLen > 2) {
        arrays = flatten(slice.call(arguments, 1));
      }
    
      while (++i < len) {
        if (!~arrays.indexOf(arr[i])) {
          res.push(arr[i]);
        }
      }
      return res;
    }
    
    /**
     * Expose `diff`
     */
    
    module.exports = diff;
    
  provide("arr-diff", module.exports);
}(global));

// pakmanager:array-unique
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * array-unique <https://github.com/jonschlinkert/array-unique>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function unique(arr) {
      if (!Array.isArray(arr)) {
        throw new TypeError('array-unique expects an array.');
      }
    
      var len = arr.length;
      var i = -1;
    
      while (i++ < len) {
        var j = i + 1;
    
        for (; j < arr.length; ++j) {
          if (arr[i] === arr[j]) {
            arr.splice(j--, 1);
          }
        }
      }
      return arr;
    };
    
  provide("array-unique", module.exports);
}(global));

// pakmanager:braces
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * braces <https://github.com/jonschlinkert/braces>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * Module dependencies
     */
    
    var expand = require('expand-range');
    var repeat = require('repeat-element');
    var tokens = require('preserve');
    
    /**
     * Expose `braces`
     */
    
    module.exports = function (str, options) {
      if (typeof str !== 'string') {
        throw new Error('braces expects a string');
      }
      return braces(str, options);
    };
    
    /**
     * Expand `{foo,bar}` or `{1..5}` braces in the
     * given `string`.
     *
     * @param  {String} `str`
     * @param  {Array} `arr`
     * @param  {Object} `options`
     * @return {Array}
     */
    
    function braces(str, arr, options) {
      if (str === '') {
        return [];
      }
    
      if (!Array.isArray(arr)) {
        options = arr;
        arr = [];
      }
    
      var opts = options || {};
      arr = arr || [];
    
      if (typeof opts.nodupes === 'undefined') {
        opts.nodupes = true;
      }
    
      var fn = opts.fn;
      var es6;
    
      if (typeof opts === 'function') {
        fn = opts;
        opts = {};
      }
    
      if (!(patternRe instanceof RegExp)) {
        patternRe = patternRegex();
      }
    
      var matches = str.match(patternRe) || [];
      var m = matches[0];
    
      switch(m) {
        case '\\,':
          return escapeCommas(str, arr, opts);
        case '\\.':
          return escapeDots(str, arr, opts);
        case '\/.':
          return escapePaths(str, arr, opts);
        case ' ':
          return splitWhitespace(str);
        case '{,}':
          return exponential(str, opts, braces);
        case '{}':
          return emptyBraces(str, arr, opts);
        case '\\{':
        case '\\}':
          return escapeBraces(str, arr, opts);
        case '${':
          if (!/\{[^{]+\{/.test(str)) {
            return arr.concat(str);
          } else {
            es6 = true;
            str = tokens.before(str, es6Regex());
          }
      }
    
      if (!(braceRe instanceof RegExp)) {
        braceRe = braceRegex();
      }
    
      var match = braceRe.exec(str);
      if (match == null) {
        return [str];
      }
    
      var outter = match[1];
      var inner = match[2];
      if (inner === '') { return [str]; }
    
      var segs, segsLength;
    
      if (inner.indexOf('..') !== -1) {
        segs = expand(inner, opts, fn) || inner.split(',');
        segsLength = segs.length;
    
      } else if (inner[0] === '"' || inner[0] === '\'') {
        return arr.concat(str.split(/['"]/).join(''));
    
      } else {
        segs = inner.split(',');
        if (opts.makeRe) {
          return braces(str.replace(outter, wrap(segs, '|')), opts);
        }
    
        segsLength = segs.length;
        if (segsLength === 1 && opts.bash) {
          segs[0] = wrap(segs[0], '\\');
        }
      }
    
      var len = segs.length;
      var i = 0, val;
    
      while (len--) {
        var path = segs[i++];
    
        if (/(\.[^.\/])/.test(path)) {
          if (segsLength > 1) {
            return segs;
          } else {
            return [str];
          }
        }
    
        val = splice(str, outter, path);
    
        if (/\{[^{}]+?\}/.test(val)) {
          arr = braces(val, arr, opts);
        } else if (val !== '') {
          if (opts.nodupes && arr.indexOf(val) !== -1) { continue; }
          arr.push(es6 ? tokens.after(val) : val);
        }
      }
    
      if (opts.strict) { return filter(arr, filterEmpty); }
      return arr;
    }
    
    /**
     * Expand exponential ranges
     *
     *   `a{,}{,}` => ['a', 'a', 'a', 'a']
     */
    
    function exponential(str, options, fn) {
      if (typeof options === 'function') {
        fn = options;
        options = null;
      }
    
      var opts = options || {};
      var esc = '__ESC_EXP__';
      var exp = 0;
      var res;
    
      var parts = str.split('{,}');
      if (opts.nodupes) {
        return fn(parts.join(''), opts);
      }
    
      exp = parts.length - 1;
      res = fn(parts.join(esc), opts);
      var len = res.length;
      var arr = [];
      var i = 0;
    
      while (len--) {
        var ele = res[i++];
        var idx = ele.indexOf(esc);
    
        if (idx === -1) {
          arr.push(ele);
    
        } else {
          ele = ele.split('__ESC_EXP__').join('');
          if (!!ele && opts.nodupes !== false) {
            arr.push(ele);
    
          } else {
            var num = Math.pow(2, exp);
            arr.push.apply(arr, repeat(ele, num));
          }
        }
      }
      return arr;
    }
    
    /**
     * Wrap a value with parens, brackets or braces,
     * based on the given character/separator.
     *
     * @param  {String|Array} `val`
     * @param  {String} `ch`
     * @return {String}
     */
    
    function wrap(val, ch) {
      if (ch === '|') {
        return '(' + val.join(ch) + ')';
      }
      if (ch === ',') {
        return '{' + val.join(ch) + '}';
      }
      if (ch === '-') {
        return '[' + val.join(ch) + ']';
      }
      if (ch === '\\') {
        return '\\{' + val + '\\}';
      }
    }
    
    /**
     * Handle empty braces: `{}`
     */
    
    function emptyBraces(str, arr, opts) {
      return braces(str.split('{}').join('\\{\\}'), arr, opts);
    }
    
    /**
     * Filter out empty-ish values
     */
    
    function filterEmpty(ele) {
      return !!ele && ele !== '\\';
    }
    
    /**
     * Handle patterns with whitespace
     */
    
    function splitWhitespace(str) {
      var segs = str.split(' ');
      var len = segs.length;
      var res = [];
      var i = 0;
    
      while (len--) {
        res.push.apply(res, braces(segs[i++]));
      }
      return res;
    }
    
    /**
     * Handle escaped braces: `\\{foo,bar}`
     */
    
    function escapeBraces(str, arr, opts) {
      if (!/\{[^{]+\{/.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\{').join('__LT_BRACE__');
        str = str.split('\\}').join('__RT_BRACE__');
        return map(braces(str, arr, opts), function (ele) {
          ele = ele.split('__LT_BRACE__').join('{');
          return ele.split('__RT_BRACE__').join('}');
        });
      }
    }
    
    /**
     * Handle escaped dots: `{1\\.2}`
     */
    
    function escapeDots(str, arr, opts) {
      if (!/[^\\]\..+\\\./.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\.').join('__ESC_DOT__');
        return map(braces(str, arr, opts), function (ele) {
          return ele.split('__ESC_DOT__').join('.');
        });
      }
    }
    
    /**
     * Handle escaped dots: `{1\\.2}`
     */
    
    function escapePaths(str, arr, opts) {
      str = str.split('\/.').join('__ESC_PATH__');
      return map(braces(str, arr, opts), function (ele) {
        return ele.split('__ESC_PATH__').join('\/.');
      });
    }
    
    /**
     * Handle escaped commas: `{a\\,b}`
     */
    
    function escapeCommas(str, arr, opts) {
      if (!/\w,/.test(str)) {
        return arr.concat(str.split('\\').join(''));
      } else {
        str = str.split('\\,').join('__ESC_COMMA__');
        return map(braces(str, arr, opts), function (ele) {
          return ele.split('__ESC_COMMA__').join(',');
        });
      }
    }
    
    /**
     * Regex for common patterns
     */
    
    function patternRegex() {
      return /\$\{|[ \t]|{}|{,}|\\,(?=.*[{}])|\/\.(?=.*[{}])|\\\.(?={)|\\{|\\}/;
    }
    
    /**
     * Braces regex.
     */
    
    function braceRegex() {
      return /.*(\\?\{([^}]+)\})/;
    }
    
    /**
     * es6 delimiter regex.
     */
    
    function es6Regex() {
      return /\$\{([^}]+)\}/;
    }
    
    var braceRe;
    var patternRe;
    
    /**
     * Faster alternative to `String.replace()` when the
     * index of the token to be replaces can't be supplied
     */
    
    function splice(str, token, replacement) {
      var i = str.indexOf(token);
      return str.substr(0, i) + replacement
        + str.substr(i + token.length);
    }
    
    /**
     * Fast array map
     */
    
    function map(arr, fn) {
      if (arr == null) {
        return [];
      }
    
      var len = arr.length;
      var res = new Array(len);
      var i = -1;
    
      while (++i < len) {
        res[i] = fn(arr[i], i, arr);
      }
    
      return res;
    }
    
    /**
     * Fast array filter
     */
    
    function filter(arr, cb) {
      if (arr == null) return [];
      if (typeof cb !== 'function') {
        throw new TypeError('braces: filter expects a callback function.');
      }
    
      var len = arr.length;
      var res = arr.slice();
      var i = 0;
    
      while (len--) {
        if (!cb(arr[len], i++)) {
          res.splice(len, 1);
        }
      }
      return res;
    }
    
  provide("braces", module.exports);
}(global));

// pakmanager:expand-brackets
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * expand-brackets <https://github.com/jonschlinkert/expand-brackets>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    /**
     * POSIX character classes
     */
    
    var POSIX = {
      alnum: 'a-zA-Z0-9',
      alpha: 'a-zA-Z',
      blank: ' \\t',
      cntrl: '\\x00-\\x1F\\x7F',
      digit: '0-9',
      graph: '\\x21-\\x7E',
      lower: 'a-z',
      print: '\\x20-\\x7E',
      punct: '!"#$%&\'()\\*+,-./:;<=>?@[\\]^_`{|}~',
      space: ' \\t\\r\\n\\v\\f',
      upper: 'A-Z',
      word:  'A-Za-z0-9_',
      xdigit: 'A-Fa-f0-9',
    };
    
    /**
     * Expose `brackets`
     */
    
    module.exports = brackets;
    
    function brackets(str) {
      var negated = false;
      if (str.indexOf('[^') !== -1) {
        negated = true;
        str = str.split('[^').join('[');
      }
      if (str.indexOf('[!') !== -1) {
        negated = true;
        str = str.split('[!').join('[');
      }
    
      var a = str.split('[');
      var b = str.split(']');
      var imbalanced = a.length !== b.length;
    
      var parts = str.split(/(?::\]\[:|\[?\[:|:\]\]?)/);
      var len = parts.length, i = 0;
      var end = '', beg = '';
      var res = [];
    
      // start at the end (innermost) first
      while (len--) {
        var inner = parts[i++];
        if (inner === '^[!' || inner === '[!') {
          inner = '';
          negated = true;
        }
    
        var prefix = negated ? '^' : '';
        var ch = POSIX[inner];
    
        if (ch) {
          res.push('[' + prefix + ch + ']');
        } else if (inner) {
          if (/^\[?\w-\w\]?$/.test(inner)) {
            if (i === parts.length) {
              res.push('[' + prefix + inner);
            } else if (i === 1) {
              res.push(prefix + inner + ']');
            } else {
              res.push(prefix + inner);
            }
          } else {
            if (i === 1) {
              beg += inner;
            } else if (i === parts.length) {
              end += inner;
            } else {
              res.push('[' + prefix + inner + ']');
            }
          }
        }
      }
    
      var result = res.join('|');
      var rlen = res.length || 1;
      if (rlen > 1) {
        result = '(?:' + result + ')';
        rlen = 1;
      }
      if (beg) {
        rlen++;
        if (beg.charAt(0) === '[') {
          if (imbalanced) {
            beg = '\\[' + beg.slice(1);
          } else {
            beg += ']';
          }
        }
        result = beg + result;
      }
      if (end) {
        rlen++;
        if (end.slice(-1) === ']') {
          if (imbalanced) {
            end = end.slice(0, end.length - 1) + '\\]';
          } else {
            end = '[' + end;
          }
        }
        result += end;
      }
    
      if (rlen > 1) {
        result = result.split('][').join(']|[');
        if (result.indexOf('|') !== -1 && !/\(\?/.test(result)) {
          result = '(?:' + result + ')';
        }
      }
    
      result = result.replace(/\[+=|=\]+/g, '\\b');
      return result;
    }
    
    brackets.makeRe = function (pattern) {
      try {
        return new RegExp(brackets(pattern));
      } catch (err) {}
    };
    
    brackets.isMatch = function (str, pattern) {
      try {
        return brackets.makeRe(pattern).test(str);
      } catch (err) {
        return false;
      }
    };
    
    brackets.match = function (arr, pattern) {
      var len = arr.length, i = 0;
      var res = arr.slice();
    
      var re = brackets.makeRe(pattern);
      while (i < len) {
        var ele = arr[i++];
        if (!re.test(ele)) {
          continue;
        }
        res.splice(i, 1);
      }
      return res;
    };
    
  provide("expand-brackets", module.exports);
}(global));

// pakmanager:extglob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * extglob <https://github.com/jonschlinkert/extglob>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    /**
     * Module dependencies
     */
    
    var isExtglob = require('is-extglob');
    var re, cache = {};
    
    /**
     * Expose `extglob`
     */
    
    module.exports = extglob;
    
    /**
     * Convert the given extglob `string` to a regex-compatible
     * string.
     *
     * ```js
     * var extglob =  require('extglob');
     * extglob('!(a?(b))');
     * //=> '(?!a(?:b)?)[^/]*?'
     * ```
     *
     * @param {String} `str` The string to convert.
     * @param {Object} `options`
     *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.
     *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.
     * @return {String}
     * @api public
     */
    
    
    function extglob(str, opts) {
      opts = opts || {};
      var o = {}, i = 0;
    
      // fix common character reversals
      // '*!(.js)' => '*.!(js)'
      str = str.replace(/!\(([^\w*()])/g, '$1!(');
    
      // support file extension negation
      str = str.replace(/([*\/])\.!\([*]\)/g, function (m, ch) {
        if (ch === '/') {
          return escape('\\/[^.]+');
        }
        return escape('[^.]+');
      });
    
      // create a unique key for caching by
      // combining the string and options
      var key = str
        + String(!!opts.regex)
        + String(!!opts.contains)
        + String(!!opts.escape);
    
      if (cache.hasOwnProperty(key)) {
        return cache[key];
      }
    
      if (!(re instanceof RegExp)) {
        re = regex();
      }
    
      opts.negate = false;
      var m;
    
      while (m = re.exec(str)) {
        var prefix = m[1];
        var inner = m[3];
        if (prefix === '!') {
          opts.negate = true;
        }
    
        var id = '__EXTGLOB_' + (i++) + '__';
        // use the prefix of the _last_ (outtermost) pattern
        o[id] = wrap(inner, prefix, opts.escape);
        str = str.split(m[0]).join(id);
      }
    
      var keys = Object.keys(o);
      var len = keys.length;
    
      // we have to loop again to allow us to convert
      // patterns in reverse order (starting with the
      // innermost/last pattern first)
      while (len--) {
        var prop = keys[len];
        str = str.split(prop).join(o[prop]);
      }
    
      var result = opts.regex
        ? toRegex(str, opts.contains, opts.negate)
        : str;
    
      result = result.split('.').join('\\.');
    
      // cache the result and return it
      return (cache[key] = result);
    }
    
    /**
     * Convert `string` to a regex string.
     *
     * @param  {String} `str`
     * @param  {String} `prefix` Character that determines how to wrap the string.
     * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.
     * @return {String}
     */
    
    function wrap(inner, prefix, esc) {
      if (esc) inner = escape(inner);
    
      switch (prefix) {
        case '!':
          return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');
        case '@':
          return '(?:' + inner + ')';
        case '+':
          return '(?:' + inner + ')+';
        case '*':
          return '(?:' + inner + ')' + (esc ? '%%' : '*')
        case '?':
          return '(?:' + inner + '|)';
        default:
          return inner;
      }
    }
    
    function escape(str) {
      str = str.split('*').join('[^/]%%%~');
      str = str.split('.').join('\\.');
      return str;
    }
    
    /**
     * extglob regex.
     */
    
    function regex() {
      return /(\\?[@?!+*$]\\?)(\(([^()]*?)\))/;
    }
    
    /**
     * Negation regex
     */
    
    function negate(str) {
      return '(?!^' + str + ').*$';
    }
    
    /**
     * Create the regex to do the matching. If
     * the leading character in the `pattern` is `!`
     * a negation regex is returned.
     *
     * @param {String} `pattern`
     * @param {Boolean} `contains` Allow loose matching.
     * @param {Boolean} `isNegated` True if the pattern is a negation pattern.
     */
    
    function toRegex(pattern, contains, isNegated) {
      var prefix = contains ? '^' : '';
      var after = contains ? '$' : '';
      pattern = ('(?:' + pattern + ')' + after);
      if (isNegated) {
        pattern = prefix + negate(pattern);
      }
      return new RegExp(prefix + pattern);
    }
    
  provide("extglob", module.exports);
}(global));

// pakmanager:filename-regex
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * filename-regex <https://github.com/regexps/filename-regex>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    module.exports = function filenameRegex() {
      return /([^\\\/]+)$/;
    };
    
  provide("filename-regex", module.exports);
}(global));

// pakmanager:object.omit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * object.omit <https://github.com/jonschlinkert/object.omit>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isObject = require('is-extendable');
    var forOwn = require('for-own');
    
    module.exports = function omit(obj, keys) {
      if (!isObject(obj)) return {};
    
      var keys = [].concat.apply([], [].slice.call(arguments, 1));
      var last = keys[keys.length - 1];
      var res = {}, fn;
    
      if (typeof last === 'function') {
        fn = keys.pop();
      }
    
      var isFunction = typeof fn === 'function';
      if (!keys.length && !isFunction) {
        return obj;
      }
    
      forOwn(obj, function (value, key) {
        if (keys.indexOf(key) === -1) {
    
          if (!isFunction) {
            res[key] = value;
          } else if (fn(value, key, obj)) {
            res[key] = value;
          }
        }
      });
      return res;
    };
    
  provide("object.omit", module.exports);
}(global));

// pakmanager:parse-glob
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * parse-glob <https://github.com/jonschlinkert/parse-glob>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var isGlob = require('is-glob');
    var findBase = require('glob-base');
    var extglob = require('is-extglob');
    var dotfile = require('is-dotfile');
    
    /**
     * Expose `cache`
     */
    
    var cache = module.exports.cache = {};
    
    /**
     * Parse a glob pattern into tokens.
     *
     * When no paths or '**' are in the glob, we use a
     * different strategy for parsing the filename, since
     * file names can contain braces and other difficult
     * patterns. such as:
     *
     *  - `*.{a,b}`
     *  - `(**|*.js)`
     */
    
    module.exports = function parseGlob(glob) {
      if (cache.hasOwnProperty(glob)) {
        return cache[glob];
      }
    
      var tok = {};
      tok.orig = glob;
      tok.is = {};
    
      // unescape dots and slashes in braces/brackets
      glob = escape(glob);
    
      var parsed = findBase(glob);
      tok.is.glob = parsed.isGlob;
    
      tok.glob = parsed.glob;
      tok.base = parsed.base;
      var segs = /([^\/]*)$/.exec(glob);
    
      tok.path = {};
      tok.path.dirname = '';
      tok.path.basename = segs[1] || '';
      tok.path.dirname = glob.split(tok.path.basename).join('') || '';
      var basename = (tok.path.basename || '').split('.') || '';
      tok.path.filename = basename[0] || '';
      tok.path.extname = basename.slice(1).join('.') || '';
      tok.path.ext = '';
    
      if (isGlob(tok.path.dirname) && !tok.path.basename) {
        if (!/\/$/.test(tok.glob)) {
          tok.path.basename = tok.glob;
        }
        tok.path.dirname = tok.base;
      }
    
      if (glob.indexOf('/') === -1 && !tok.is.globstar) {
        tok.path.dirname = '';
        tok.path.basename = tok.orig;
      }
    
      var dot = tok.path.basename.indexOf('.');
      if (dot !== -1) {
        tok.path.filename = tok.path.basename.slice(0, dot);
        tok.path.extname = tok.path.basename.slice(dot);
      }
    
      if (tok.path.extname.charAt(0) === '.') {
        var exts = tok.path.extname.split('.');
        tok.path.ext = exts[exts.length - 1];
      }
    
      // unescape dots and slashes in braces/brackets
      tok.glob = unescape(tok.glob);
      tok.path.dirname = unescape(tok.path.dirname);
      tok.path.basename = unescape(tok.path.basename);
      tok.path.filename = unescape(tok.path.filename);
      tok.path.extname = unescape(tok.path.extname);
    
      // Booleans
      var is = (glob && tok.is.glob);
      tok.is.negated  = glob && glob.charAt(0) === '!';
      tok.is.extglob  = glob && extglob(glob);
      tok.is.braces   = has(is, glob, '{');
      tok.is.brackets = has(is, glob, '[:');
      tok.is.globstar = has(is, glob, '**');
      tok.is.dotfile  = dotfile(tok.path.basename) || dotfile(tok.path.filename);
      tok.is.dotdir   = dotdir(tok.path.dirname);
      return (cache[glob] = tok);
    }
    
    /**
     * Returns true if the glob matches dot-directories.
     *
     * @param  {Object} `tok` The tokens object
     * @param  {Object} `path` The path object
     * @return {Object}
     */
    
    function dotdir(base) {
      if (base.indexOf('/.') !== -1) {
        return true;
      }
      if (base.charAt(0) === '.' && base.charAt(1) !== '/') {
        return true;
      }
      return false;
    }
    
    /**
     * Returns true if the pattern has the given `ch`aracter(s)
     *
     * @param  {Object} `glob` The glob pattern.
     * @param  {Object} `ch` The character to test for
     * @return {Object}
     */
    
    function has(is, glob, ch) {
      return is && glob.indexOf(ch) !== -1;
    }
    
    /**
     * Escape/unescape utils
     */
    
    function escape(str) {
      var re = /\{([^{}]*?)}|\(([^()]*?)\)|\[([^\[\]]*?)\]/g;
      return str.replace(re, function (outter, braces, parens, brackets) {
        var inner = braces || parens || brackets;
        if (!inner) { return outter; }
        return outter.split(inner).join(esc(inner));
      });
    }
    
    function esc(str) {
      str = str.split('/').join('__SLASH__');
      str = str.split('.').join('__DOT__');
      return str;
    }
    
    function unescape(str) {
      str = str.split('__SLASH__').join('/');
      str = str.split('__DOT__').join('.');
      return str;
    }
    
  provide("parse-glob", module.exports);
}(global));

// pakmanager:regex-cache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * regex-cache <https://github.com/jonschlinkert/regex-cache>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    var isPrimitive = require('is-primitive');
    var equal = require('is-equal-shallow');
    
    /**
     * Expose `regexCache`
     */
    
    module.exports = regexCache;
    
    /**
     * Memoize the results of a call to the new RegExp constructor.
     *
     * @param  {Function} fn [description]
     * @param  {String} str [description]
     * @param  {Options} options [description]
     * @param  {Boolean} nocompare [description]
     * @return {RegExp}
     */
    
    function regexCache(fn, str, opts) {
      var key = '_default_', regex, cached;
    
      if (!str && !opts) {
        if (typeof fn !== 'function') {
          return fn;
        }
        return basic[key] || (basic[key] = fn());
      }
    
      var isString = typeof str === 'string';
      if (isString) {
        if (!opts) {
          return basic[str] || (basic[str] = fn(str));
        }
        key = str;
      } else {
        opts = str;
      }
    
      cached = cache[key];
      if (cached && equal(cached.opts, opts)) {
        return cached.regex;
      }
    
      memo(key, opts, (regex = fn(str, opts)));
      return regex;
    }
    
    function memo(key, opts, regex) {
      cache[key] = {regex: regex, opts: opts};
    }
    
    /**
     * Expose `cache`
     */
    
    var cache = module.exports.cache = {};
    var basic = module.exports.basic = {};
    
  provide("regex-cache", module.exports);
}(global));

// pakmanager:npmlog
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var Progress = require('are-we-there-yet')
    var Gauge = require('gauge')
    var EE = require('events').EventEmitter
    var log = exports = module.exports = new EE
    var util = require('util')
    
    var ansi = require('ansi')
    log.cursor = ansi(process.stderr)
    log.stream = process.stderr
    
    // by default, let ansi decide based on tty-ness.
    var colorEnabled = undefined
    log.enableColor = function () {
      colorEnabled = true
      this.cursor.enabled = true
    }
    log.disableColor = function () {
      colorEnabled = false
      this.cursor.enabled = false
    }
    
    // default level
    log.level = 'info'
    
    log.gauge = new Gauge(log.cursor)
    log.tracker = new Progress.TrackerGroup()
    
    // no progress bars unless asked
    log.progressEnabled = false
    
    var gaugeTheme = undefined
    
    log.enableUnicode = function () {
      gaugeTheme = Gauge.unicode
      log.gauge.setTheme(gaugeTheme)
    }
    
    log.disableUnicode = function () {
      gaugeTheme = Gauge.ascii
      log.gauge.setTheme(gaugeTheme)
    }
    
    var gaugeTemplate = undefined
    log.setGaugeTemplate = function (template) {
      gaugeTemplate = template
      log.gauge.setTemplate(gaugeTemplate)
    }
    
    log.enableProgress = function () {
      if (this.progressEnabled) return
      this.progressEnabled = true
      if (this._pause) return
      this.tracker.on('change', this.showProgress)
      this.gauge.enable()
      this.showProgress()
    }
    
    log.disableProgress = function () {
      if (!this.progressEnabled) return
      this.clearProgress()
      this.progressEnabled = false
      this.tracker.removeListener('change', this.showProgress)
      this.gauge.disable()
    }
    
    var trackerConstructors = ['newGroup', 'newItem', 'newStream']
    
    var mixinLog = function (tracker) {
      // mixin the public methods from log into the tracker
      // (except: conflicts and one's we handle specially)
      Object.keys(log).forEach(function (P) {
        if (P[0] === '_') return
        if (trackerConstructors.filter(function (C) { return C === P }).length) return
        if (tracker[P]) return
        if (typeof log[P] !== 'function') return
        var func = log[P]
        tracker[P] = function () {
          return func.apply(log, arguments)
        }
      })
      // if the new tracker is a group, make sure any subtrackers get
      // mixed in too
      if (tracker instanceof Progress.TrackerGroup) {
        trackerConstructors.forEach(function (C) {
          var func = tracker[C]
          tracker[C] = function () { return mixinLog(func.apply(tracker, arguments)) }
        })
      }
      return tracker
    }
    
    // Add tracker constructors to the top level log object
    trackerConstructors.forEach(function (C) {
      log[C] = function () { return mixinLog(this.tracker[C].apply(this.tracker, arguments)) }
    })
    
    log.clearProgress = function () {
      if (!this.progressEnabled) return
      this.gauge.hide()
    }
    
    log.showProgress = function (name, completed) {
      if (!this.progressEnabled) return
      if (completed == null) completed = this.tracker.completed()
      this.gauge.show(name, completed)
    }.bind(log) // bind for use in tracker's on-change listener
    
    // temporarily stop emitting, but don't drop
    log.pause = function () {
      this._paused = true
    }
    
    log.resume = function () {
      if (!this._paused) return
      this._paused = false
    
      var b = this._buffer
      this._buffer = []
      b.forEach(function (m) {
        this.emitLog(m)
      }, this)
      if (this.progressEnabled) this.enableProgress()
    }
    
    log._buffer = []
    
    var id = 0
    log.record = []
    log.maxRecordSize = 10000
    log.log = function (lvl, prefix, message) {
      var l = this.levels[lvl]
      if (l === undefined) {
        return this.emit('error', new Error(util.format(
          'Undefined log level: %j', lvl)))
      }
    
      var a = new Array(arguments.length - 2)
      var stack = null
      for (var i = 2; i < arguments.length; i ++) {
        var arg = a[i-2] = arguments[i]
    
        // resolve stack traces to a plain string.
        if (typeof arg === 'object' && arg &&
            (arg instanceof Error) && arg.stack) {
          arg.stack = stack = arg.stack + ''
        }
      }
      if (stack) a.unshift(stack + '\n')
      message = util.format.apply(util, a)
    
      var m = { id: id++,
                level: lvl,
                prefix: String(prefix || ''),
                message: message,
                messageRaw: a }
    
      this.emit('log', m)
      this.emit('log.' + lvl, m)
      if (m.prefix) this.emit(m.prefix, m)
    
      this.record.push(m)
      var mrs = this.maxRecordSize
      var n = this.record.length - mrs
      if (n > mrs / 10) {
        var newSize = Math.floor(mrs * 0.9)
        this.record = this.record.slice(-1 * newSize)
      }
    
      this.emitLog(m)
    }.bind(log)
    
    log.emitLog = function (m) {
      if (this._paused) {
        this._buffer.push(m)
        return
      }
      if (this.progressEnabled) this.gauge.pulse(m.prefix)
      var l = this.levels[m.level]
      if (l === undefined) return
      if (l < this.levels[this.level]) return
      if (l > 0 && !isFinite(l)) return
    
      var style = log.style[m.level]
      var disp = log.disp[m.level] || m.level
      this.clearProgress()
      m.message.split(/\r?\n/).forEach(function (line) {
        if (this.heading) {
          this.write(this.heading, this.headingStyle)
          this.write(' ')
        }
        this.write(disp, log.style[m.level])
        var p = m.prefix || ''
        if (p) this.write(' ')
        this.write(p, this.prefixStyle)
        this.write(' ' + line + '\n')
      }, this)
      this.showProgress()
    }
    
    log.write = function (msg, style) {
      if (!this.cursor) return
      if (this.stream !== this.cursor.stream) {
        this.cursor = ansi(this.stream, { enabled: colorEnabled })
        var options = {}
        if (gaugeTheme != null) options.theme = gaugeTheme
        if (gaugeTemplate != null) options.template = gaugeTemplate
        this.gauge = new Gauge(options, this.cursor)
      }
    
      style = style || {}
      if (style.fg) this.cursor.fg[style.fg]()
      if (style.bg) this.cursor.bg[style.bg]()
      if (style.bold) this.cursor.bold()
      if (style.underline) this.cursor.underline()
      if (style.inverse) this.cursor.inverse()
      if (style.beep) this.cursor.beep()
      this.cursor.write(msg).reset()
    }
    
    log.addLevel = function (lvl, n, style, disp) {
      if (!disp) disp = lvl
      this.levels[lvl] = n
      this.style[lvl] = style
      if (!this[lvl]) this[lvl] = function () {
        var a = new Array(arguments.length + 1)
        a[0] = lvl
        for (var i = 0; i < arguments.length; i ++) {
          a[i + 1] = arguments[i]
        }
        return this.log.apply(this, a)
      }.bind(this)
      this.disp[lvl] = disp
    }
    
    log.prefixStyle = { fg: 'magenta' }
    log.headingStyle = { fg: 'white', bg: 'black' }
    
    log.style = {}
    log.levels = {}
    log.disp = {}
    log.addLevel('silly', -Infinity, { inverse: true }, 'sill')
    log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb')
    log.addLevel('info', 2000, { fg: 'green' })
    log.addLevel('http', 3000, { fg: 'green', bg: 'black' })
    log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN')
    log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!')
    log.addLevel('silent', Infinity)
    
    // allow 'error' prefix
    log.on('error', function(){})
    
  provide("npmlog", module.exports);
}(global));

// pakmanager:request
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2010-2012 Mikeal Rogers
    //
    //    Licensed under the Apache License, Version 2.0 (the "License");
    //    you may not use this file except in compliance with the License.
    //    You may obtain a copy of the License at
    //
    //        http://www.apache.org/licenses/LICENSE-2.0
    //
    //    Unless required by applicable law or agreed to in writing, software
    //    distributed under the License is distributed on an "AS IS" BASIS,
    //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    //    See the License for the specific language governing permissions and
    //    limitations under the License.
    
    'use strict'
    
    var extend                = require('extend')
      , cookies               = require('./lib/cookies')
      , helpers               = require('./lib/helpers')
    
    var isFunction            = helpers.isFunction
      , paramsHaveRequestBody = helpers.paramsHaveRequestBody
    
    
    // organize params for patch, post, put, head, del
    function initParams(uri, options, callback) {
      if (typeof options === 'function') {
        callback = options
      }
    
      var params = {}
      if (typeof options === 'object') {
        extend(params, options, {uri: uri})
      } else if (typeof uri === 'string') {
        extend(params, {uri: uri})
      } else {
        extend(params, uri)
      }
    
      params.callback = callback
      return params
    }
    
    function request (uri, options, callback) {
      if (typeof uri === 'undefined') {
        throw new Error('undefined is not a valid uri or options object.')
      }
    
      var params = initParams(uri, options, callback)
    
      if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
        throw new Error('HTTP HEAD requests MUST NOT include a request body.')
      }
    
      return new request.Request(params)
    }
    
    function verbFunc (verb) {
      var method = verb === 'del' ? 'DELETE' : verb.toUpperCase()
      return function (uri, options, callback) {
        var params = initParams(uri, options, callback)
        params.method = method
        return request(params, params.callback)
      }
    }
    
    // define like this to please codeintel/intellisense IDEs
    request.get = verbFunc('get')
    request.head = verbFunc('head')
    request.post = verbFunc('post')
    request.put = verbFunc('put')
    request.patch = verbFunc('patch')
    request.del = verbFunc('del')
    
    request.jar = function (store) {
      return cookies.jar(store)
    }
    
    request.cookie = function (str) {
      return cookies.parse(str)
    }
    
    function wrapRequestMethod (method, options, requester, verb) {
    
      return function (uri, opts, callback) {
        var params = initParams(uri, opts, callback)
    
        var target = {}
        extend(true, target, options, params)
    
        target.pool = params.pool || options.pool
    
        if (verb) {
          target.method = (verb === 'del' ? 'DELETE' : verb.toUpperCase())
        }
    
        if (isFunction(requester)) {
          method = requester
        }
    
        return method(target, target.callback)
      }
    }
    
    request.defaults = function (options, requester) {
      var self = this
    
      options = options || {}
    
      if (typeof options === 'function') {
        requester = options
        options = {}
      }
    
      var defaults      = wrapRequestMethod(self, options, requester)
    
      var verbs = ['get', 'head', 'post', 'put', 'patch', 'del']
      verbs.forEach(function(verb) {
        defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
      })
    
      defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
      defaults.jar      = self.jar
      defaults.defaults = self.defaults
      return defaults
    }
    
    request.forever = function (agentOptions, optionsArg) {
      var options = {}
      if (optionsArg) {
        extend(options, optionsArg)
      }
      if (agentOptions) {
        options.agentOptions = agentOptions
      }
    
      options.forever = true
      return request.defaults(options)
    }
    
    // Exports
    
    module.exports = request
    request.Request =   require('request')
    request.initParams = initParams
    
    // Backwards compatibility for request.debug
    Object.defineProperty(request, 'debug', {
      enumerable : true,
      get : function() {
        return request.Request.debug
      },
      set : function(debug) {
        request.Request.debug = debug
      }
    })
    
  provide("request", module.exports);
}(global));

// pakmanager:semver
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports = module.exports = SemVer;
    
    // The debug function is excluded entirely from the minified version.
    /* nomin */ var debug;
    /* nomin */ if (typeof process === 'object' &&
        /* nomin */ process.env &&
        /* nomin */ process.env.NODE_DEBUG &&
        /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
      /* nomin */ debug = function() {
        /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
        /* nomin */ args.unshift('SEMVER');
        /* nomin */ console.log.apply(console, args);
        /* nomin */ };
    /* nomin */ else
      /* nomin */ debug = function() {};
    
    // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.
    exports.SEMVER_SPEC_VERSION = '2.0.0';
    
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    
    // The actual regexps go on exports.re
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    
    // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.
    
    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.
    
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    
    
    // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.
    
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    
    
    // ## Main Version
    // Three dot-separated numeric identifiers.
    
    var MAINVERSION = R++;
    src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                       '(' + src[NUMERICIDENTIFIER] + ')';
    
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                            '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
    
    // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.
    
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                                '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                     '|' + src[NONNUMERICIDENTIFIER] + ')';
    
    
    // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.
    
    var PRERELEASE = R++;
    src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                      '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
    
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                           '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
    
    // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.
    
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    
    // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.
    
    var BUILD = R++;
    src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
                 '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
    
    
    // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.
    
    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.
    
    var FULL = R++;
    var FULLPLAIN = 'v?' + src[MAINVERSION] +
                    src[PRERELEASE] + '?' +
                    src[BUILD] + '?';
    
    src[FULL] = '^' + FULLPLAIN + '$';
    
    // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.
    var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                     src[PRERELEASELOOSE] + '?' +
                     src[BUILD] + '?';
    
    var LOOSE = R++;
    src[LOOSE] = '^' + LOOSEPLAIN + '$';
    
    var GTLT = R++;
    src[GTLT] = '((?:<|>)?=?)';
    
    // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
    
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                       '(?:' + src[PRERELEASE] + ')?' +
                       src[BUILD] + '?' +
                       ')?)?';
    
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                            '(?:' + src[PRERELEASELOOSE] + ')?' +
                            src[BUILD] + '?' +
                            ')?)?';
    
    var XRANGE = R++;
    src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
    
    // Tilde ranges.
    // Meaning is "reasonably at or greater than"
    var LONETILDE = R++;
    src[LONETILDE] = '(?:~>?)';
    
    var TILDETRIM = R++;
    src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
    re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    
    var TILDE = R++;
    src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
    var TILDELOOSE = R++;
    src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
    
    // Caret ranges.
    // Meaning is "at least and backwards compatible with"
    var LONECARET = R++;
    src[LONECARET] = '(?:\\^)';
    
    var CARETTRIM = R++;
    src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
    re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    
    var CARET = R++;
    src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
    var CARETLOOSE = R++;
    src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
    
    // A simple gt/lt/eq thing, or just "" to indicate "any version"
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
    var COMPARATOR = R++;
    src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
    
    
    // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                          '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
    
    // this one has to use the /g flag
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    
    
    // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                       '\\s+-\\s+' +
                       '(' + src[XRANGEPLAIN] + ')' +
                       '\\s*$';
    
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s+-\\s+' +
                            '(' + src[XRANGEPLAINLOOSE] + ')' +
                            '\\s*$';
    
    // Star ranges basically just allow anything at all.
    var STAR = R++;
    src[STAR] = '(<|>)?=?\\s*\\*';
    
    // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.
    for (var i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i])
        re[i] = new RegExp(src[i]);
    }
    
    exports.parse = parse;
    function parse(version, loose) {
      if (version instanceof SemVer)
        return version;
    
      if (typeof version !== 'string')
        return null;
    
      if (version.length > MAX_LENGTH)
        return null;
    
      var r = loose ? re[LOOSE] : re[FULL];
      if (!r.test(version))
        return null;
    
      try {
        return new SemVer(version, loose);
      } catch (er) {
        return null;
      }
    }
    
    exports.valid = valid;
    function valid(version, loose) {
      var v = parse(version, loose);
      return v ? v.version : null;
    }
    
    
    exports.clean = clean;
    function clean(version, loose) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
      return s ? s.version : null;
    }
    
    exports.SemVer = SemVer;
    
    function SemVer(version, loose) {
      if (version instanceof SemVer) {
        if (version.loose === loose)
          return version;
        else
          version = version.version;
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }
    
      if (version.length > MAX_LENGTH)
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
    
      if (!(this instanceof SemVer))
        return new SemVer(version, loose);
    
      debug('SemVer', version, loose);
      this.loose = loose;
      var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);
    
      if (!m)
        throw new TypeError('Invalid Version: ' + version);
    
      this.raw = version;
    
      // these are actually numbers
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
    
      if (this.major > MAX_SAFE_INTEGER || this.major < 0)
        throw new TypeError('Invalid major version')
    
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
        throw new TypeError('Invalid minor version')
    
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
        throw new TypeError('Invalid patch version')
    
      // numberify any prerelease numeric ids
      if (!m[4])
        this.prerelease = [];
      else
        this.prerelease = m[4].split('.').map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id
            if (num >= 0 && num < MAX_SAFE_INTEGER)
              return num
          }
          return id;
        });
    
      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }
    
    SemVer.prototype.format = function() {
      this.version = this.major + '.' + this.minor + '.' + this.patch;
      if (this.prerelease.length)
        this.version += '-' + this.prerelease.join('.');
      return this.version;
    };
    
    SemVer.prototype.toString = function() {
      return this.version;
    };
    
    SemVer.prototype.compare = function(other) {
      debug('SemVer.compare', this.version, this.loose, other);
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return this.compareMain(other) || this.comparePre(other);
    };
    
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      return compareIdentifiers(this.major, other.major) ||
             compareIdentifiers(this.minor, other.minor) ||
             compareIdentifiers(this.patch, other.patch);
    };
    
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer))
        other = new SemVer(other, this.loose);
    
      // NOT having a prerelease is > having one
      if (this.prerelease.length && !other.prerelease.length)
        return -1;
      else if (!this.prerelease.length && other.prerelease.length)
        return 1;
      else if (!this.prerelease.length && !other.prerelease.length)
        return 0;
    
      var i = 0;
      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);
        if (a === undefined && b === undefined)
          return 0;
        else if (b === undefined)
          return 1;
        else if (a === undefined)
          return -1;
        else if (a === b)
          continue;
        else
          return compareIdentifiers(a, b);
      } while (++i);
    };
    
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;
        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;
        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case 'prerelease':
          if (this.prerelease.length === 0)
            this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
    
        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
            this.major++;
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0)
            this.minor++;
          this.patch = 0;
          this.prerelease = [];
          break;
        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0)
            this.patch++;
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case 'pre':
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            var i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) // didn't increment anything
              this.prerelease.push(0);
          }
          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1]))
                this.prerelease = [identifier, 0];
            } else
              this.prerelease = [identifier, 0];
          }
          break;
    
        default:
          throw new Error('invalid increment argument: ' + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof(loose) === 'string') {
        identifier = loose;
        loose = undefined;
      }
    
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        if (v1.prerelease.length || v2.prerelease.length) {
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return 'pre'+key;
              }
            }
          }
          return 'prerelease';
        }
        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return key;
            }
          }
        }
      }
    }
    
    exports.compareIdentifiers = compareIdentifiers;
    
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
    
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
    
      return (anum && !bnum) ? -1 :
             (bnum && !anum) ? 1 :
             a < b ? -1 :
             a > b ? 1 :
             0;
    }
    
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(b);
    }
    
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      var ret;
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a === b;
          break;
        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          ret = a !== b;
          break;
        case '': case '=': case '==': ret = eq(a, b, loose); break;
        case '!=': ret = neq(a, b, loose); break;
        case '>': ret = gt(a, b, loose); break;
        case '>=': ret = gte(a, b, loose); break;
        case '<': ret = lt(a, b, loose); break;
        case '<=': ret = lte(a, b, loose); break;
        default: throw new TypeError('Invalid operator: ' + op);
      }
      return ret;
    }
    
    exports.Comparator = Comparator;
    function Comparator(comp, loose) {
      if (comp instanceof Comparator) {
        if (comp.loose === loose)
          return comp;
        else
          comp = comp.value;
      }
    
      if (!(this instanceof Comparator))
        return new Comparator(comp, loose);
    
      debug('comparator', comp, loose);
      this.loose = loose;
      this.parse(comp);
    
      if (this.semver === ANY)
        this.value = '';
      else
        this.value = this.operator + this.semver.version;
    
      debug('comp', this);
    }
    
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
    
      if (!m)
        throw new TypeError('Invalid comparator: ' + comp);
    
      this.operator = m[1];
      if (this.operator === '=')
        this.operator = '';
    
      // if it literally is just '>' or '' then allow anything.
      if (!m[2])
        this.semver = ANY;
      else
        this.semver = new SemVer(m[2], this.loose);
    };
    
    Comparator.prototype.toString = function() {
      return this.value;
    };
    
    Comparator.prototype.test = function(version) {
      debug('Comparator.test', version, this.loose);
    
      if (this.semver === ANY)
        return true;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      return cmp(version, this.operator, this.semver, this.loose);
    };
    
    
    exports.Range = Range;
    function Range(range, loose) {
      if ((range instanceof Range) && range.loose === loose)
        return range;
    
      if (!(this instanceof Range))
        return new Range(range, loose);
    
      this.loose = loose;
    
      // First, split based on boolean or ||
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range) {
        return this.parseRange(range.trim());
      }, this).filter(function(c) {
        // throw out any that are not relevant for whatever reason
        return c.length;
      });
    
      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }
    
      this.format();
    }
    
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };
    
    Range.prototype.toString = function() {
      return this.range;
    };
    
    Range.prototype.parseRange = function(range) {
      var loose = this.loose;
      range = range.trim();
      debug('range', range, loose);
      // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[COMPARATORTRIM]);
    
      // `~ 1.2.3` => `~1.2.3`
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
    
      // `^ 1.2.3` => `^1.2.3`
      range = range.replace(re[CARETTRIM], caretTrimReplace);
    
      // normalize spaces
      range = range.split(/\s+/).join(' ');
    
      // At this point, the range is completely trimmed and
      // ready to be split into comparators.
    
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(' ').map(function(comp) {
        return parseComparator(comp, loose);
      }).join(' ').split(/\s+/);
      if (this.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, loose);
      });
    
      return set;
    };
    
    // Mostly just for testing and legacy API reasons
    exports.toComparators = toComparators;
    function toComparators(range, loose) {
      return new Range(range, loose).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }
    
    // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.
    function parseComparator(comp, loose) {
      debug('comp', comp);
      comp = replaceCarets(comp, loose);
      debug('caret', comp);
      comp = replaceTildes(comp, loose);
      debug('tildes', comp);
      comp = replaceXRanges(comp, loose);
      debug('xrange', comp);
      comp = replaceStars(comp, loose);
      debug('stars', comp);
      return comp;
    }
    
    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }
    
    // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
    function replaceTildes(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceTilde(comp, loose);
      }).join(' ');
    }
    
    function replaceTilde(comp, loose) {
      var r = loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p))
          // ~1.2 == >=1.2.0- <1.3.0-
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        else if (pr) {
          debug('replaceTilde pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        } else
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
    
        debug('tilde return', ret);
        return ret;
      });
    }
    
    // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0
    function replaceCarets(comp, loose) {
      return comp.trim().split(/\s+/).map(function(comp) {
        return replaceCaret(comp, loose);
      }).join(' ');
    }
    
    function replaceCaret(comp, loose) {
      debug('caret', comp, loose);
      var r = loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;
    
        if (isX(M))
          ret = '';
        else if (isX(m))
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        else if (isX(p)) {
          if (M === '0')
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          else
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        } else if (pr) {
          debug('replaceCaret pr', pr);
          if (pr.charAt(0) !== '-')
            pr = '-' + pr;
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p + pr +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p + pr +
                  ' <' + (+M + 1) + '.0.0';
        } else {
          debug('no pr');
          if (M === '0') {
            if (m === '0')
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + m + '.' + (+p + 1);
            else
              ret = '>=' + M + '.' + m + '.' + p +
                    ' <' + M + '.' + (+m + 1) + '.0';
          } else
            ret = '>=' + M + '.' + m + '.' + p +
                  ' <' + (+M + 1) + '.0.0';
        }
    
        debug('caret return', ret);
        return ret;
      });
    }
    
    function replaceXRanges(comp, loose) {
      debug('replaceXRanges', comp, loose);
      return comp.split(/\s+/).map(function(comp) {
        return replaceXRange(comp, loose);
      }).join(' ');
    }
    
    function replaceXRange(comp, loose) {
      comp = comp.trim();
      var r = loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
    
        if (gtlt === '=' && anyX)
          gtlt = '';
    
        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // replace X with 0
          if (xm)
            m = 0;
          if (xp)
            p = 0;
    
          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else if (xp) {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<'
            if (xm)
              M = +M + 1
            else
              m = +m + 1
          }
    
          ret = gtlt + M + '.' + m + '.' + p;
        } else if (xm) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        }
    
        debug('xRange return', ret);
    
        return ret;
      });
    }
    
    // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.
    function replaceStars(comp, loose) {
      debug('replaceStars', comp, loose);
      // Looseness is ignored here.  star is always as loose as it gets!
      return comp.trim().replace(re[STAR], '');
    }
    
    // This function is passed to string.replace(re[HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0
    function hyphenReplace($0,
                           from, fM, fm, fp, fpr, fb,
                           to, tM, tm, tp, tpr, tb) {
    
      if (isX(fM))
        from = '';
      else if (isX(fm))
        from = '>=' + fM + '.0.0';
      else if (isX(fp))
        from = '>=' + fM + '.' + fm + '.0';
      else
        from = '>=' + from;
    
      if (isX(tM))
        to = '';
      else if (isX(tm))
        to = '<' + (+tM + 1) + '.0.0';
      else if (isX(tp))
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      else if (tpr)
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      else
        to = '<=' + to;
    
      return (from + ' ' + to).trim();
    }
    
    
    // if ANY of the sets match ALL of its comparators, then pass
    Range.prototype.test = function(version) {
      if (!version)
        return false;
    
      if (typeof version === 'string')
        version = new SemVer(version, this.loose);
    
      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version))
          return true;
      }
      return false;
    };
    
    function testSet(set, version) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version))
          return false;
      }
    
      if (version.prerelease.length) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (var i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === ANY)
            continue;
    
          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;
            if (allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch)
              return true;
          }
        }
    
        // Version has a -pre, but it's not one of the ones we like.
        return false;
      }
    
      return true;
    }
    
    exports.satisfies = satisfies;
    function satisfies(version, range, loose) {
      try {
        range = new Range(range, loose);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, loose) {
      return versions.filter(function(version) {
        return satisfies(version, range, loose);
      }).sort(function(a, b) {
        return rcompare(a, b, loose);
      })[0] || null;
    }
    
    exports.validRange = validRange;
    function validRange(range, loose) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, loose).range || '*';
      } catch (er) {
        return null;
      }
    }
    
    // Determine if version is less than all the versions possible in the range
    exports.ltr = ltr;
    function ltr(version, range, loose) {
      return outside(version, range, '<', loose);
    }
    
    // Determine if version is greater than all the versions possible in the range.
    exports.gtr = gtr;
    function gtr(version, range, loose) {
      return outside(version, range, '>', loose);
    }
    
    exports.outside = outside;
    function outside(version, range, hilo, loose) {
      version = new SemVer(version, loose);
      range = new Range(range, loose);
    
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;
        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
    
      // If it satisifes the range it is not outside
      if (satisfies(version, range, loose)) {
        return false;
      }
    
      // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.
    
      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
    
        var high = null;
        var low = null;
    
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0')
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, loose)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, loose)) {
            low = comparator;
          }
        });
    
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
    
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    
  provide("semver", module.exports);
}(global));

// pakmanager:tar-pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict"
    
    var debug = require('debug')('tar-pack')
    var uidNumber = require('uid-number')
    var rm = require('rimraf')
    var tar = require('tar')
    var once = require('once')
    var fstream = require('fstream')
    var packer = require('fstream-ignore')
    
    var PassThrough = require('stream').PassThrough || require('readable-stream').PassThrough
    var zlib = require('zlib')
    var path = require('path')
    
    var win32 = process.platform === 'win32'
    var myUid = process.getuid && process.getuid()
    var myGid = process.getgid && process.getgid()
    
    if (process.env.SUDO_UID && myUid === 0) {
      if (!isNaN(process.env.SUDO_UID)) myUid = +process.env.SUDO_UID
      if (!isNaN(process.env.SUDO_GID)) myGid = +process.env.SUDO_GID
    }
    
    exports.pack = pack
    exports.unpack = unpack
    
    function pack(folder, options) {
      options = options || {}
      if (typeof folder === 'string') {
    
        var filter = options.filter || function (entry) { return true; }
    
        folder = packer({
          path: folder,
          type: 'Directory',
          isDirectory: true,
          ignoreFiles: options.ignoreFiles || ['.gitignore'],
          filter: function (entry) { // {path, basename, dirname, type} (type is "Directory" or "File")
            var basename = entry.basename
            // some files are *never* allowed under any circumstances
            // these files should always be either temporary files or
            // version control related files
            if (basename === '.git' || basename === '.lock-wscript' || basename.match(/^\.wafpickle-[0-9]+$/) ||
                basename === 'CVS' || basename === '.svn' || basename === '.hg' || basename.match(/^\..*\.swp$/) ||
                basename === '.DS_Store' ||  basename.match(/^\._/)) {
              return false
            }
            //custom excludes
            return filter(entry)
          }
        })
      }
      // By default, npm includes some proprietary attributes in the
      // package tarball.  This is sane, and allowed by the spec.
      // However, npm *itself* excludes these from its own package,
      // so that it can be more easily bootstrapped using old and
      // non-compliant tar implementations.
      var tarPack = tar.Pack({ noProprietary: options.noProprietary || false })
      var gzip = zlib.Gzip()
    
      folder
        .on('error', function (er) {
          if (er) debug('Error reading folder')
          return gzip.emit('error', er)
        })
      tarPack
        .on('error', function (er) {
          if (er) debug('tar creation error')
          gzip.emit('error', er)
        })
      return folder.pipe(tarPack).pipe(gzip)
    }
    
    function unpack(unpackTarget, options, cb) {
      if (typeof options === 'function' && cb === undefined) cb = options, options = undefined
    
      var tarball = new PassThrough()
      if (typeof cb === 'function') {
        cb = once(cb)
        tarball.on('error', cb)
        tarball.on('close', function () {
          cb()
        })
      }
    
      var parent = path.dirname(unpackTarget)
      var base = path.basename(unpackTarget)
    
      options = options || {}
      var gid = options.gid || null
      var uid = options.uid || null
      var dMode = options.dmode || 0x0777 //npm.modes.exec
      var fMode = options.fmode || 0x0666 //npm.modes.file
      var defaultName = options.defaultName || (options.defaultName === false ? false : 'index.js')
    
      // figure out who we're supposed to be, if we're not pretending
      // to be a specific user.
      if (options.unsafe && !win32) {
        uid = myUid
        gid = myGid
      }
    
      var pending = 2
      uidNumber(uid, gid, function (er, uid, gid) {
        if (er) {
          tarball.emit('error', er)
          return tarball.end()
        }
        if (0 === --pending) next()
      })
      rm(unpackTarget, function (er) {
        if (er) {
          tarball.emit('error', er)
          return tarball.end()
        }
        if (0 === --pending) next()
      })
      function next() {
        // gzip {tarball} --decompress --stdout \
        //   | tar -mvxpf - --strip-components=1 -C {unpackTarget}
        gunzTarPerm(tarball, unpackTarget, dMode, fMode, uid, gid, defaultName)
      }
      return tarball
    }
    
    
    function gunzTarPerm(tarball, target, dMode, fMode, uid, gid, defaultName) {
      debug('modes %j', [dMode.toString(8), fMode.toString(8)])
    
      function fixEntry(entry) {
        debug('fixEntry %j', entry.path)
        // never create things that are user-unreadable,
        // or dirs that are user-un-listable. Only leads to headaches.
        var originalMode = entry.mode = entry.mode || entry.props.mode
        entry.mode = entry.mode | (entry.type === 'Directory' ? dMode : fMode)
        entry.props.mode = entry.mode
        if (originalMode !== entry.mode) {
          debug('modified mode %j', [entry.path, originalMode, entry.mode])
        }
    
        // if there's a specific owner uid/gid that we want, then set that
        if (!win32 &&  typeof uid === 'number' && typeof gid === 'number') {
          entry.props.uid = entry.uid = uid
          entry.props.gid = entry.gid = gid
        }
      }
    
      var extractOpts = { type: 'Directory', path: target, strip: 1 }
    
      if (!win32 && typeof uid === 'number' && typeof gid === 'number') {
        extractOpts.uid = uid
        extractOpts.gid = gid
      }
    
      extractOpts.filter = function () {
        // symbolic links are not allowed in packages.
        if (this.type.match(/^.*Link$/)) {
          debug('excluding symbolic link: ' + this.path.substr(target.length + 1) + ' -> ' + this.linkpath)
          return false
        }
        return true
      }
    
    
      type(tarball, function (err, type) {
        if (err) return tarball.emit('error', err)
        var strm = tarball
        if (type === 'gzip') {
          strm = strm.pipe(zlib.Unzip())
          strm.on('error', function (er) {
              if (er) debug('unzip error')
              tarball.emit('error', er)
            })
          type = 'tar'
        }
        if (type === 'tar') {
          strm
            .pipe(tar.Extract(extractOpts))
            .on('entry', fixEntry)
            .on('error', function (er) {
              if (er) debug('untar error')
              tarball.emit('error', er)
            })
            .on('close', function () {
              tarball.emit('close')
            })
          return
        }
        if (type === 'naked-file' && defaultName) {
          var jsOpts = { path: path.resolve(target, defaultName) }
    
          if (!win32 && typeof uid === 'number' && typeof gid === 'number') {
            jsOpts.uid = uid
            jsOpts.gid = gid
          }
    
          strm
            .pipe(fstream.Writer(jsOpts))
            .on('error', function (er) {
              if (er) debug('copy error')
              tarball.emit('error', er)
            })
            .on('close', function () {
              tarball.emit('close')
            })
          return
        }
    
        return cb(new Error('Unrecognised package type'));
      })
    }
    
    function type(stream, callback) {
      stream.on('error', handle)
      stream.on('data', parse)
      function handle(err) {
        stream.removeListener('data', parse)
        stream.removeListener('error', handle)
      }
      function parse(chunk) {
        // detect what it is.
        // Then, depending on that, we'll figure out whether it's
        // a single-file module, gzipped tarball, or naked tarball.
    
        // gzipped files all start with 1f8b08
        if (chunk[0] === 0x1F && chunk[1] === 0x8B && chunk[2] === 0x08) {
          callback(null, 'gzip')
        } else if (chunk.toString().match(/^package\/\u0000/)) {
          // note, this will only pick up on tarballs with a root directory called package
          callback(null, 'tar')
        } else {
          callback(null, 'naked-file')
        }
    
        // now un-hook, and re-emit the chunk
        stream.removeListener('data', parse)
        stream.removeListener('error', handle)
        stream.unshift(chunk)
      }
    }
    
  provide("tar-pack", module.exports);
}(global));

// pakmanager:rc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  #! /usr/bin/env node
    var cc   = require('./lib/utils')
    var join = require('path').join
    var deepExtend = require('deep-extend')
    var etc = '/etc'
    var win = process.platform === "win32"
    var home = win
               ? process.env.USERPROFILE
               : process.env.HOME
    
    module.exports = function (name, defaults, argv, parse) {
      if('string' !== typeof name)
        throw new Error('rc(name): name *must* be string')
      if(!argv)
        argv = require('minimist')(process.argv.slice(2))
      defaults = (
          'string' === typeof defaults
        ? cc.json(defaults) : defaults
        ) || {}
    
      parse = parse || cc.parse
    
      var env = cc.env(name + '_')
    
      var configs = [defaults]
      var configFiles = []
      function addConfigFile (file) {
        if (configFiles.indexOf(file) >= 0) return
        var fileConfig = cc.file(file)
        if (fileConfig) {
          configs.push(parse(fileConfig))
          configFiles.push(file)
        }
      }
    
      // which files do we look at?
      if (!win)
       [join(etc, name, 'config'),
        join(etc, name + 'rc')].forEach(addConfigFile)
      if (home)
       [join(home, '.config', name, 'config'),
        join(home, '.config', name),
        join(home, '.' + name, 'config'),
        join(home, '.' + name + 'rc')].forEach(addConfigFile)
      addConfigFile(cc.find('.'+name+'rc'))
      if (env.config) addConfigFile(env.config)
      if (argv.config) addConfigFile(argv.config)
    
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? {configs: configFiles, config: configFiles[configFiles.length - 1]} : undefined,
      ]))
    }
    
    if(!module.parent) {
      console.log(
        JSON.stringify(module.exports(process.argv[2]), false, 2)
      )
    }
    
  provide("rc", module.exports);
}(global));

// pakmanager:ee-first
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * ee-first
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = first
    
    /**
     * Get the first event in a set of event emitters and event pairs.
     *
     * @param {array} stuff
     * @param {function} done
     * @public
     */
    
    function first(stuff, done) {
      if (!Array.isArray(stuff))
        throw new TypeError('arg must be an array of [ee, events...] arrays')
    
      var cleanups = []
    
      for (var i = 0; i < stuff.length; i++) {
        var arr = stuff[i]
    
        if (!Array.isArray(arr) || arr.length < 2)
          throw new TypeError('each array member must be [ee, events...]')
    
        var ee = arr[0]
    
        for (var j = 1; j < arr.length; j++) {
          var event = arr[j]
          var fn = listener(event, callback)
    
          // listen to the event
          ee.on(event, fn)
          // push this listener to the list of cleanups
          cleanups.push({
            ee: ee,
            event: event,
            fn: fn,
          })
        }
      }
    
      function callback() {
        cleanup()
        done.apply(null, arguments)
      }
    
      function cleanup() {
        var x
        for (var i = 0; i < cleanups.length; i++) {
          x = cleanups[i]
          x.ee.removeListener(x.event, x.fn)
        }
      }
    
      function thunk(fn) {
        done = fn
      }
    
      thunk.cancel = cleanup
    
      return thunk
    }
    
    /**
     * Create the event listener.
     * @private
     */
    
    function listener(event, done) {
      return function onevent(arg1) {
        var args = new Array(arguments.length)
        var ee = this
        var err = event === 'error'
          ? arg1
          : null
    
        // copy args to prevent arguments escaping scope
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
    
        done(err, ee, event, args)
      }
    }
    
  provide("ee-first", module.exports);
}(global));

// pakmanager:negotiator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * negotiator
     * Copyright(c) 2012 Federico Romero
     * Copyright(c) 2012-2014 Isaac Z. Schlueter
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Cached loaded submodules.
     * @private
     */
    
    var modules = Object.create(null);
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = Negotiator;
    module.exports.Negotiator = Negotiator;
    
    /**
     * Create a Negotiator instance from a request.
     * @param {object} request
     * @public
     */
    
    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }
    
      this.request = request;
    }
    
    Negotiator.prototype.charset = function charset(available) {
      var set = this.charsets(available);
      return set && set[0];
    };
    
    Negotiator.prototype.charsets = function charsets(available) {
      var preferredCharsets = loadModule('charset').preferredCharsets;
      return preferredCharsets(this.request.headers['accept-charset'], available);
    };
    
    Negotiator.prototype.encoding = function encoding(available) {
      var set = this.encodings(available);
      return set && set[0];
    };
    
    Negotiator.prototype.encodings = function encodings(available) {
      var preferredEncodings = loadModule('encoding').preferredEncodings;
      return preferredEncodings(this.request.headers['accept-encoding'], available);
    };
    
    Negotiator.prototype.language = function language(available) {
      var set = this.languages(available);
      return set && set[0];
    };
    
    Negotiator.prototype.languages = function languages(available) {
      var preferredLanguages = loadModule('language').preferredLanguages;
      return preferredLanguages(this.request.headers['accept-language'], available);
    };
    
    Negotiator.prototype.mediaType = function mediaType(available) {
      var set = this.mediaTypes(available);
      return set && set[0];
    };
    
    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
      return preferredMediaTypes(this.request.headers.accept, available);
    };
    
    // Backwards compatibility
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;
    
    /**
     * Load the given module.
     * @private
     */
    
    function loadModule(moduleName) {
      var module = modules[moduleName];
    
      if (module !== undefined) {
        return module;
      }
    
      // This uses a switch for static require analysis
      switch (moduleName) {
        case 'charset':
          module = require('./lib/charset');
          break;
        case 'encoding':
          module = require('./lib/encoding');
          break;
        case 'language':
          module = require('./lib/language');
          break;
        case 'mediaType':
          module = require('./lib/mediaType');
          break;
        default:
          throw new Error('Cannot find module \'' + moduleName + '\'');
      }
    
      // Store to prevent invoking require()
      modules[moduleName] = module;
    
      return module;
    }
    
  provide("negotiator", module.exports);
}(global));

// pakmanager:has-cors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */
    
    try {
      module.exports = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      // if XMLHttp support is disabled in IE then it will throw
      // when trying to create
      module.exports = false;
    }
    
  provide("has-cors", module.exports);
}(global));

// pakmanager:ws
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /*!
     * ws: a node.js websocket client
     * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>
     * MIT Licensed
     */
    
    var WS = module.exports = require('./lib/WebSocket');
    
    WS.Server = require('./lib/WebSocketServer');
    WS.Sender = require('./lib/Sender');
    WS.Receiver = require('./lib/Receiver');
    
    /**
     * Create a new WebSocket server.
     *
     * @param {Object} options Server options
     * @param {Function} fn Optional connection listener.
     * @returns {WS.Server}
     * @api public
     */
    WS.createServer = function createServer(options, fn) {
      var server = new WS.Server(options);
    
      if (typeof fn === 'function') {
        server.on('connection', fn);
      }
    
      return server;
    };
    
    /**
     * Create a new WebSocket connection.
     *
     * @param {String} address The URL/address we need to connect to.
     * @param {Function} fn Open listener.
     * @returns {WS}
     * @api public
     */
    WS.connect = WS.createConnection = function connect(address, fn) {
      var client = new WS(address);
    
      if (typeof fn === 'function') {
        client.on('open', fn);
      }
    
      return client;
    };
    
  provide("ws", module.exports);
}(global));

// pakmanager:component-emitter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Emitter`.
     */
    
    module.exports = Emitter;
    
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */
    
    function Emitter(obj) {
      if (obj) return mixin(obj);
    };
    
    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */
    
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    
    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
        .push(fn);
      return this;
    };
    
    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.once = function(event, fn){
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
    
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    
    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */
    
    Emitter.prototype.off =
    Emitter.prototype.removeListener =
    Emitter.prototype.removeAllListeners =
    Emitter.prototype.removeEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
    
      // all
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
    
      // specific event
      var callbacks = this._callbacks['$' + event];
      if (!callbacks) return this;
    
      // remove all handlers
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }
    
      // remove specific handler
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    
    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */
    
    Emitter.prototype.emit = function(event){
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1)
        , callbacks = this._callbacks['$' + event];
    
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
    
      return this;
    };
    
    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */
    
    Emitter.prototype.listeners = function(event){
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    
    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */
    
    Emitter.prototype.hasListeners = function(event){
      return !! this.listeners(event).length;
    };
    
  provide("component-emitter", module.exports);
}(global));

// pakmanager:indexof
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var indexOf = [].indexOf;
    
    module.exports = function(arr, obj){
      if (indexOf) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj) return i;
      }
      return -1;
    };
  provide("indexof", module.exports);
}(global));

// pakmanager:engine.io-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = require('./lib/');
    
  provide("engine.io-parser", module.exports);
}(global));

// pakmanager:parseuri
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */
    
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    
    var parts = [
        'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
    ];
    
    module.exports = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');
    
        if (b != -1 && e != -1) {
            str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }
    
        var m = re.exec(str || ''),
            uri = {},
            i = 14;
    
        while (i--) {
            uri[parts[i]] = m[i] || '';
        }
    
        if (b != -1 && e != -1) {
            uri.source = src;
            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
            uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
            uri.ipv6uri = true;
        }
    
        return uri;
    };
    
  provide("parseuri", module.exports);
}(global));

// pakmanager:parsejson
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * JSON parse.
     *
     * @see Based on jQuery#parseJSON (MIT) and JSON2
     * @api private
     */
    
    var rvalidchars = /^[\],:{}\s]*$/;
    var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
    var rtrimLeft = /^\s+/;
    var rtrimRight = /\s+$/;
    
    module.exports = function parsejson(data) {
      if ('string' != typeof data || !data) {
        return null;
      }
    
      data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
    
      // Attempt to parse using the native JSON parser first
      if (global.JSON && JSON.parse) {
        return JSON.parse(data);
      }
    
      if (rvalidchars.test(data.replace(rvalidescape, '@')
          .replace(rvalidtokens, ']')
          .replace(rvalidbraces, ''))) {
        return (new Function('return ' + data))();
      }
    };
  provide("parsejson", module.exports);
}(global));

// pakmanager:parseqs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */
    
    exports.encode = function (obj) {
      var str = '';
    
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length) str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }
    
      return str;
    };
    
    /**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */
    
    exports.decode = function(qs){
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
    
  provide("parseqs", module.exports);
}(global));

// pakmanager:component-inherit
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = function(a, b){
      var fn = function(){};
      fn.prototype = b.prototype;
      a.prototype = new fn;
      a.prototype.constructor = a;
    };
  provide("component-inherit", module.exports);
}(global));

// pakmanager:yeast
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
      , length = 64
      , map = {}
      , seed = 0
      , i = 0
      , prev;
    
    /**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
    function encode(num) {
      var encoded = '';
    
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
    
      return encoded;
    }
    
    /**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
    function decode(str) {
      var decoded = 0;
    
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
    
      return decoded;
    }
    
    /**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
    function yeast() {
      var now = encode(+new Date());
    
      if (now !== prev) return seed = 0, prev = now;
      return now +'.'+ encode(seed++);
    }
    
    //
    // Map each character to its index.
    //
    for (; i < length; i++) map[alphabet[i]] = i;
    
    //
    // Expose the `yeast`, `encode` and `decode` functions.
    //
    yeast.encode = encode;
    yeast.decode = decode;
    module.exports = yeast;
    
  provide("yeast", module.exports);
}(global));

// pakmanager:benchmark
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Benchmark.js v2.1.0 <https://benchmarkjs.com/>
     * Copyright 2010-2016 Mathias Bynens <https://mths.be/>
     * Based on JSLitmus.js, copyright Robert Kieffer <http://broofa.com/>
     * Modified by John-David Dalton <http://allyoucanleet.com/>
     * Available under MIT license <https://mths.be/mit>
     */
    ;(function() {
      'use strict';
    
      /** Used as a safe reference for `undefined` in pre ES5 environments. */
      var undefined;
    
      /** Used to determine if values are of the language type Object. */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used as a reference to the global object. */
      var root = (objectTypes[typeof window] && window) || this;
    
      /** Detect free variable `define`. */
      var freeDefine = typeof define == 'function' && typeof define.amd == 'object' && define.amd && define;
    
      /** Detect free variable `exports`. */
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    
      /** Detect free variable `module`. */
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    
      /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }
    
      /** Detect free variable `require`. */
      var freeRequire = typeof require == 'function' && require;
    
      /** Used to assign each benchmark an incremented id. */
      var counter = 0;
    
      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    
      /** Used to detect primitive types. */
      var rePrimitive = /^(?:boolean|number|string|undefined)$/;
    
      /** Used to make every compiled test unique. */
      var uidCounter = 0;
    
      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Date', 'Function', 'Math', 'Object', 'RegExp', 'String', '_',
        'clearTimeout', 'chrome', 'chromium', 'document', 'navigator', 'phantom',
        'platform', 'process', 'runtime', 'setTimeout'
      ];
    
      /** Used to avoid hz of Infinity. */
      var divisors = {
        '1': 4096,
        '2': 512,
        '3': 64,
        '4': 8,
        '5': 0
      };
    
      /**
       * T-Distribution two-tailed critical values for 95% confidence.
       * For more info see http://www.itl.nist.gov/div898/handbook/eda/section3/eda3672.htm.
       */
      var tTable = {
        '1':  12.706, '2':  4.303, '3':  3.182, '4':  2.776, '5':  2.571, '6':  2.447,
        '7':  2.365,  '8':  2.306, '9':  2.262, '10': 2.228, '11': 2.201, '12': 2.179,
        '13': 2.16,   '14': 2.145, '15': 2.131, '16': 2.12,  '17': 2.11,  '18': 2.101,
        '19': 2.093,  '20': 2.086, '21': 2.08,  '22': 2.074, '23': 2.069, '24': 2.064,
        '25': 2.06,   '26': 2.056, '27': 2.052, '28': 2.048, '29': 2.045, '30': 2.042,
        'infinity': 1.96
      };
    
      /**
       * Critical Mann-Whitney U-values for 95% confidence.
       * For more info see http://www.saburchill.com/IBbiology/stats/003.html.
       */
      var uTable = {
        '5':  [0, 1, 2],
        '6':  [1, 2, 3, 5],
        '7':  [1, 3, 5, 6, 8],
        '8':  [2, 4, 6, 8, 10, 13],
        '9':  [2, 4, 7, 10, 12, 15, 17],
        '10': [3, 5, 8, 11, 14, 17, 20, 23],
        '11': [3, 6, 9, 13, 16, 19, 23, 26, 30],
        '12': [4, 7, 11, 14, 18, 22, 26, 29, 33, 37],
        '13': [4, 8, 12, 16, 20, 24, 28, 33, 37, 41, 45],
        '14': [5, 9, 13, 17, 22, 26, 31, 36, 40, 45, 50, 55],
        '15': [5, 10, 14, 19, 24, 29, 34, 39, 44, 49, 54, 59, 64],
        '16': [6, 11, 15, 21, 26, 31, 37, 42, 47, 53, 59, 64, 70, 75],
        '17': [6, 11, 17, 22, 28, 34, 39, 45, 51, 57, 63, 67, 75, 81, 87],
        '18': [7, 12, 18, 24, 30, 36, 42, 48, 55, 61, 67, 74, 80, 86, 93, 99],
        '19': [7, 13, 19, 25, 32, 38, 45, 52, 58, 65, 72, 78, 85, 92, 99, 106, 113],
        '20': [8, 14, 20, 27, 34, 41, 48, 55, 62, 69, 76, 83, 90, 98, 105, 112, 119, 127],
        '21': [8, 15, 22, 29, 36, 43, 50, 58, 65, 73, 80, 88, 96, 103, 111, 119, 126, 134, 142],
        '22': [9, 16, 23, 30, 38, 45, 53, 61, 69, 77, 85, 93, 101, 109, 117, 125, 133, 141, 150, 158],
        '23': [9, 17, 24, 32, 40, 48, 56, 64, 73, 81, 89, 98, 106, 115, 123, 132, 140, 149, 157, 166, 175],
        '24': [10, 17, 25, 33, 42, 50, 59, 67, 76, 85, 94, 102, 111, 120, 129, 138, 147, 156, 165, 174, 183, 192],
        '25': [10, 18, 27, 35, 44, 53, 62, 71, 80, 89, 98, 107, 117, 126, 135, 145, 154, 163, 173, 182, 192, 201, 211],
        '26': [11, 19, 28, 37, 46, 55, 64, 74, 83, 93, 102, 112, 122, 132, 141, 151, 161, 171, 181, 191, 200, 210, 220, 230],
        '27': [11, 20, 29, 38, 48, 57, 67, 77, 87, 97, 107, 118, 125, 138, 147, 158, 168, 178, 188, 199, 209, 219, 230, 240, 250],
        '28': [12, 21, 30, 40, 50, 60, 70, 80, 90, 101, 111, 122, 132, 143, 154, 164, 175, 186, 196, 207, 218, 228, 239, 250, 261, 272],
        '29': [13, 22, 32, 42, 52, 62, 73, 83, 94, 105, 116, 127, 138, 149, 160, 171, 182, 193, 204, 215, 226, 238, 249, 260, 271, 282, 294],
        '30': [13, 23, 33, 43, 54, 65, 76, 87, 98, 109, 120, 131, 143, 154, 166, 177, 189, 200, 212, 223, 235, 247, 258, 270, 282, 293, 305, 317]
      };
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Create a new `Benchmark` function using the given `context` object.
       *
       * @static
       * @memberOf Benchmark
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `Benchmark` function.
       */
      function runInContext(context) {
        // Exit early if unable to acquire lodash.
        var _ = context && context._ || req('lodash') || root._;
        if (!_) {
          Benchmark.runInContext = runInContext;
          return Benchmark;
        }
        // Avoid issues with some ES3 environments that attempt to use values, named
        // after built-in constructors like `Object`, for the creation of literals.
        // ES5 clears this up by stating that literals must use built-in constructors.
        // See http://es5.github.io/#x11.1.5.
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    
        /** Native constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String;
    
        /** Used for `Array` and `Object` method references. */
        var arrayRef = [],
            objectProto = Object.prototype;
    
        /** Native method shortcuts. */
        var abs = Math.abs,
            clearTimeout = context.clearTimeout,
            floor = Math.floor,
            log = Math.log,
            max = Math.max,
            min = Math.min,
            pow = Math.pow,
            push = arrayRef.push,
            setTimeout = context.setTimeout,
            shift = arrayRef.shift,
            slice = arrayRef.slice,
            sqrt = Math.sqrt,
            toString = objectProto.toString,
            unshift = arrayRef.unshift;
    
        /** Detect DOM document object. */
        var doc = isHostType(context, 'document') && context.document;
    
        /** Used to access Wade Simmons' Node.js `microtime` module. */
        var microtimeObject = req('microtime');
    
        /** Used to access Node.js's high resolution timer. */
        var processObject = isHostType(context, 'process') && context.process;
    
        /** Used to prevent a `removeChild` memory leak in IE < 9. */
        var trash = doc && doc.createElement('div');
    
        /** Used to integrity check compiled tests. */
        var uid = 'uid' + _.now();
    
        /** Used to avoid infinite recursion when methods call each other. */
        var calledBy = {};
    
        /**
         * An object used to flag environments/features.
         *
         * @static
         * @memberOf Benchmark
         * @type Object
         */
        var support = {};
    
        (function() {
    
          /**
           * Detect if running in a browser environment.
           *
           * @memberOf Benchmark.support
           * @type boolean
           */
          support.browser = doc && isHostType(context, 'navigator') && !isHostType(context, 'phantom');
    
          /**
           * Detect if the Timers API exists.
           *
           * @memberOf Benchmark.support
           * @type boolean
           */
          support.timeout = isHostType(context, 'setTimeout') && isHostType(context, 'clearTimeout');
    
          /**
           * Detect if function decompilation is support.
           *
           * @name decompilation
           * @memberOf Benchmark.support
           * @type boolean
           */
          try {
            // Safari 2.x removes commas in object literals from `Function#toString` results.
            // See http://webk.it/11609 for more details.
            // Firefox 3.6 and Opera 9.25 strip grouping parentheses from `Function#toString` results.
            // See http://bugzil.la/559438 for more details.
            support.decompilation = Function(
              ('return (' + (function(x) { return { 'x': '' + (1 + x) + '', 'y': 0 }; }) + ')')
              // Avoid issues with code added by Istanbul.
              .replace(/__cov__[^;]+;/g, '')
            )()(0).x === '1';
          } catch(e) {
            support.decompilation = false;
          }
        }());
    
        /**
         * Timer object used by `clock()` and `Deferred#resolve`.
         *
         * @private
         * @type Object
         */
        var timer = {
    
          /**
           * The timer namespace object or constructor.
           *
           * @private
           * @memberOf timer
           * @type {Function|Object}
           */
          'ns': Date,
    
          /**
           * Starts the deferred timer.
           *
           * @private
           * @memberOf timer
           * @param {Object} deferred The deferred instance.
           */
          'start': null, // Lazy defined in `clock()`.
    
          /**
           * Stops the deferred timer.
           *
           * @private
           * @memberOf timer
           * @param {Object} deferred The deferred instance.
           */
          'stop': null // Lazy defined in `clock()`.
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The Benchmark constructor.
         *
         * Note: The Benchmark constructor exposes a handful of lodash methods to
         * make working with arrays, collections, and objects easier. The lodash
         * methods are:
         * [`each/forEach`](https://lodash.com/docs#forEach), [`forOwn`](https://lodash.com/docs#forOwn),
         * [`has`](https://lodash.com/docs#has), [`indexOf`](https://lodash.com/docs#indexOf),
         * [`map`](https://lodash.com/docs#map), and [`reduce`](https://lodash.com/docs#reduce)
         *
         * @constructor
         * @param {string} name A name to identify the benchmark.
         * @param {Function|string} fn The test to benchmark.
         * @param {Object} [options={}] Options object.
         * @example
         *
         * // basic usage (the `new` operator is optional)
         * var bench = new Benchmark(fn);
         *
         * // or using a name first
         * var bench = new Benchmark('foo', fn);
         *
         * // or with options
         * var bench = new Benchmark('foo', fn, {
         *
         *   // displayed by `Benchmark#toString` if `name` is not available
         *   'id': 'xyz',
         *
         *   // called when the benchmark starts running
         *   'onStart': onStart,
         *
         *   // called after each run cycle
         *   'onCycle': onCycle,
         *
         *   // called when aborted
         *   'onAbort': onAbort,
         *
         *   // called when a test errors
         *   'onError': onError,
         *
         *   // called when reset
         *   'onReset': onReset,
         *
         *   // called when the benchmark completes running
         *   'onComplete': onComplete,
         *
         *   // compiled/called before the test loop
         *   'setup': setup,
         *
         *   // compiled/called after the test loop
         *   'teardown': teardown
         * });
         *
         * // or name and options
         * var bench = new Benchmark('foo', {
         *
         *   // a flag to indicate the benchmark is deferred
         *   'defer': true,
         *
         *   // benchmark test function
         *   'fn': function(deferred) {
         *     // call `Deferred#resolve` when the deferred test is finished
         *     deferred.resolve();
         *   }
         * });
         *
         * // or options only
         * var bench = new Benchmark({
         *
         *   // benchmark name
         *   'name': 'foo',
         *
         *   // benchmark test as a string
         *   'fn': '[1,2,3,4].sort()'
         * });
         *
         * // a test's `this` binding is set to the benchmark instance
         * var bench = new Benchmark('foo', function() {
         *   'My name is '.concat(this.name); // "My name is foo"
         * });
         */
        function Benchmark(name, fn, options) {
          var bench = this;
    
          // Allow instance creation without the `new` operator.
          if (!(bench instanceof Benchmark)) {
            return new Benchmark(name, fn, options);
          }
          // Juggle arguments.
          if (_.isPlainObject(name)) {
            // 1 argument (options).
            options = name;
          }
          else if (_.isFunction(name)) {
            // 2 arguments (fn, options).
            options = fn;
            fn = name;
          }
          else if (_.isPlainObject(fn)) {
            // 2 arguments (name, options).
            options = fn;
            fn = null;
            bench.name = name;
          }
          else {
            // 3 arguments (name, fn [, options]).
            bench.name = name;
          }
          setOptions(bench, options);
    
          bench.id || (bench.id = ++counter);
          bench.fn == null && (bench.fn = fn);
    
          bench.stats = cloneDeep(bench.stats);
          bench.times = cloneDeep(bench.times);
        }
    
        /**
         * The Deferred constructor.
         *
         * @constructor
         * @memberOf Benchmark
         * @param {Object} clone The cloned benchmark instance.
         */
        function Deferred(clone) {
          var deferred = this;
          if (!(deferred instanceof Deferred)) {
            return new Deferred(clone);
          }
          deferred.benchmark = clone;
          clock(deferred);
        }
    
        /**
         * The Event constructor.
         *
         * @constructor
         * @memberOf Benchmark
         * @param {Object|string} type The event type.
         */
        function Event(type) {
          var event = this;
          if (type instanceof Event) {
            return type;
          }
          return (event instanceof Event)
            ? _.assign(event, { 'timeStamp': _.now() }, typeof type == 'string' ? { 'type': type } : type)
            : new Event(type);
        }
    
        /**
         * The Suite constructor.
         *
         * Note: Each Suite instance has a handful of wrapped lodash methods to
         * make working with Suites easier. The wrapped lodash methods are:
         * [`each/forEach`](https://lodash.com/docs#forEach), [`indexOf`](https://lodash.com/docs#indexOf),
         * [`map`](https://lodash.com/docs#map), and [`reduce`](https://lodash.com/docs#reduce)
         *
         * @constructor
         * @memberOf Benchmark
         * @param {string} name A name to identify the suite.
         * @param {Object} [options={}] Options object.
         * @example
         *
         * // basic usage (the `new` operator is optional)
         * var suite = new Benchmark.Suite;
         *
         * // or using a name first
         * var suite = new Benchmark.Suite('foo');
         *
         * // or with options
         * var suite = new Benchmark.Suite('foo', {
         *
         *   // called when the suite starts running
         *   'onStart': onStart,
         *
         *   // called between running benchmarks
         *   'onCycle': onCycle,
         *
         *   // called when aborted
         *   'onAbort': onAbort,
         *
         *   // called when a test errors
         *   'onError': onError,
         *
         *   // called when reset
         *   'onReset': onReset,
         *
         *   // called when the suite completes running
         *   'onComplete': onComplete
         * });
         */
        function Suite(name, options) {
          var suite = this;
    
          // Allow instance creation without the `new` operator.
          if (!(suite instanceof Suite)) {
            return new Suite(name, options);
          }
          // Juggle arguments.
          if (_.isPlainObject(name)) {
            // 1 argument (options).
            options = name;
          } else {
            // 2 arguments (name [, options]).
            suite.name = name;
          }
          setOptions(suite, options);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * A specialized version of `_.cloneDeep` which only clones arrays and plain
         * objects assigning all other values by reference.
         *
         * @private
         * @param {*} value The value to clone.
         * @returns {*} The cloned value.
         */
        var cloneDeep = _.partial(_.cloneDeepWith, _, function(value) {
          // Only clone primitives, arrays, and plain objects.
          return (_.isObject(value) && !_.isArray(value) && !_.isPlainObject(value))
            ? value
            : undefined;
        });
    
        /**
         * Creates a function from the given arguments string and body.
         *
         * @private
         * @param {string} args The comma separated function arguments.
         * @param {string} body The function body.
         * @returns {Function} The new function.
         */
        function createFunction() {
          // Lazy define.
          createFunction = function(args, body) {
            var result,
                anchor = freeDefine ? freeDefine.amd : Benchmark,
                prop = uid + 'createFunction';
    
            runScript((freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '=function(' + args + '){' + body + '}');
            result = anchor[prop];
            delete anchor[prop];
            return result;
          };
          // Fix JaegerMonkey bug.
          // For more information see http://bugzil.la/639720.
          createFunction = support.browser && (createFunction('', 'return"' + uid + '"') || _.noop)() == uid ? createFunction : Function;
          return createFunction.apply(null, arguments);
        }
    
        /**
         * Delay the execution of a function based on the benchmark's `delay` property.
         *
         * @private
         * @param {Object} bench The benchmark instance.
         * @param {Object} fn The function to execute.
         */
        function delay(bench, fn) {
          bench._timerId = _.delay(fn, bench.delay * 1e3);
        }
    
        /**
         * Destroys the given element.
         *
         * @private
         * @param {Element} element The element to destroy.
         */
        function destroyElement(element) {
          trash.appendChild(element);
          trash.innerHTML = '';
        }
    
        /**
         * Gets the name of the first argument from a function's source.
         *
         * @private
         * @param {Function} fn The function.
         * @returns {string} The argument name.
         */
        function getFirstArgument(fn) {
          return (!_.has(fn, 'toString') &&
            (/^[\s(]*function[^(]*\(([^\s,)]+)/.exec(fn) || 0)[1]) || '';
        }
    
        /**
         * Computes the arithmetic mean of a sample.
         *
         * @private
         * @param {Array} sample The sample.
         * @returns {number} The mean.
         */
        function getMean(sample) {
          return (_.reduce(sample, function(sum, x) {
            return sum + x;
          }) / sample.length) || 0;
        }
    
        /**
         * Gets the source code of a function.
         *
         * @private
         * @param {Function} fn The function.
         * @returns {string} The function's source code.
         */
        function getSource(fn) {
          var result = '';
          if (isStringable(fn)) {
            result = String(fn);
          } else if (support.decompilation) {
            // Escape the `{` for Firefox 1.
            result = _.result(/^[^{]+\{([\s\S]*)\}\s*$/.exec(fn), 1);
          }
          // Trim string.
          result = (result || '').replace(/^\s+|\s+$/g, '');
    
          // Detect strings containing only the "use strict" directive.
          return /^(?:\/\*+[\w\W]*?\*\/|\/\/.*?[\n\r\u2028\u2029]|\s)*(["'])use strict\1;?$/.test(result)
            ? ''
            : result;
        }
    
        /**
         * Checks if an object is of the specified class.
         *
         * @private
         * @param {*} value The value to check.
         * @param {string} name The name of the class.
         * @returns {boolean} Returns `true` if the value is of the specified class, else `false`.
         */
        function isClassOf(value, name) {
          return value != null && toString.call(value) == '[object ' + name + ']';
        }
    
        /**
         * Host objects can return type values that are different from their actual
         * data type. The objects we are concerned with usually return non-primitive
         * types of "object", "function", or "unknown".
         *
         * @private
         * @param {*} object The owner of the property.
         * @param {string} property The property to check.
         * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
         */
        function isHostType(object, property) {
          if (object == null) {
            return false;
          }
          var type = typeof object[property];
          return !rePrimitive.test(type) && (type != 'object' || !!object[property]);
        }
    
        /**
         * Checks if a value can be safely coerced to a string.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the value can be coerced, else `false`.
         */
        function isStringable(value) {
          return _.isString(value) || (_.has(value, 'toString') && _.isFunction(value.toString));
        }
    
        /**
         * A wrapper around `require` to suppress `module missing` errors.
         *
         * @private
         * @param {string} id The module id.
         * @returns {*} The exported module or `null`.
         */
        function req(id) {
          try {
            var result = freeExports && freeRequire(id);
          } catch(e) {}
          return result || null;
        }
    
        /**
         * Runs a snippet of JavaScript via script injection.
         *
         * @private
         * @param {string} code The code to run.
         */
        function runScript(code) {
          var anchor = freeDefine ? define.amd : Benchmark,
              script = doc.createElement('script'),
              sibling = doc.getElementsByTagName('script')[0],
              parent = sibling.parentNode,
              prop = uid + 'runScript',
              prefix = '(' + (freeDefine ? 'define.amd.' : 'Benchmark.') + prop + '||function(){})();';
    
          // Firefox 2.0.0.2 cannot use script injection as intended because it executes
          // asynchronously, but that's OK because script injection is only used to avoid
          // the previously commented JaegerMonkey bug.
          try {
            // Remove the inserted script *before* running the code to avoid differences
            // in the expected script element count/order of the document.
            script.appendChild(doc.createTextNode(prefix + code));
            anchor[prop] = function() { destroyElement(script); };
          } catch(e) {
            parent = parent.cloneNode(false);
            sibling = null;
            script.text = code;
          }
          parent.insertBefore(script, sibling);
          delete anchor[prop];
        }
    
        /**
         * A helper function for setting options/event handlers.
         *
         * @private
         * @param {Object} object The benchmark or suite instance.
         * @param {Object} [options={}] Options object.
         */
        function setOptions(object, options) {
          options = object.options = _.assign({}, cloneDeep(object.constructor.options), cloneDeep(options));
    
          _.forOwn(options, function(value, key) {
            if (value != null) {
              // Add event listeners.
              if (/^on[A-Z]/.test(key)) {
                _.each(key.split(' '), function(key) {
                  object.on(key.slice(2).toLowerCase(), value);
                });
              } else if (!_.has(object, key)) {
                object[key] = cloneDeep(value);
              }
            }
          });
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Handles cycling/completing the deferred benchmark.
         *
         * @memberOf Benchmark.Deferred
         */
        function resolve() {
          var deferred = this,
              clone = deferred.benchmark,
              bench = clone._original;
    
          if (bench.aborted) {
            // cycle() -> clone cycle/complete event -> compute()'s invoked bench.run() cycle/complete.
            deferred.teardown();
            clone.running = false;
            cycle(deferred);
          }
          else if (++deferred.cycles < clone.count) {
            clone.compiled.call(deferred, context, timer);
          }
          else {
            timer.stop(deferred);
            deferred.teardown();
            delay(clone, function() { cycle(deferred); });
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * A generic `Array#filter` like method.
         *
         * @static
         * @memberOf Benchmark
         * @param {Array} array The array to iterate over.
         * @param {Function|string} callback The function/alias called per iteration.
         * @returns {Array} A new array of values that passed callback filter.
         * @example
         *
         * // get odd numbers
         * Benchmark.filter([1, 2, 3, 4, 5], function(n) {
         *   return n % 2;
         * }); // -> [1, 3, 5];
         *
         * // get fastest benchmarks
         * Benchmark.filter(benches, 'fastest');
         *
         * // get slowest benchmarks
         * Benchmark.filter(benches, 'slowest');
         *
         * // get benchmarks that completed without erroring
         * Benchmark.filter(benches, 'successful');
         */
        function filter(array, callback) {
          if (callback === 'successful') {
            // Callback to exclude those that are errored, unrun, or have hz of Infinity.
            callback = function(bench) {
              return bench.cycles && _.isFinite(bench.hz) && !bench.error;
            };
          }
          else if (callback === 'fastest' || callback === 'slowest') {
            // Get successful, sort by period + margin of error, and filter fastest/slowest.
            var result = filter(array, 'successful').sort(function(a, b) {
              a = a.stats; b = b.stats;
              return (a.mean + a.moe > b.mean + b.moe ? 1 : -1) * (callback === 'fastest' ? 1 : -1);
            });
    
            return _.filter(result, function(bench) {
              return result[0].compare(bench) == 0;
            });
          }
          return _.filter(array, callback);
        }
    
        /**
         * Converts a number to a more readable comma-separated string representation.
         *
         * @static
         * @memberOf Benchmark
         * @param {number} number The number to convert.
         * @returns {string} The more readable string representation.
         */
        function formatNumber(number) {
          number = String(number).split('.');
          return number[0].replace(/(?=(?:\d{3})+$)(?!\b)/g, ',') +
            (number[1] ? '.' + number[1] : '');
        }
    
        /**
         * Invokes a method on all items in an array.
         *
         * @static
         * @memberOf Benchmark
         * @param {Array} benches Array of benchmarks to iterate over.
         * @param {Object|string} name The name of the method to invoke OR options object.
         * @param {...*} [args] Arguments to invoke the method with.
         * @returns {Array} A new array of values returned from each method invoked.
         * @example
         *
         * // invoke `reset` on all benchmarks
         * Benchmark.invoke(benches, 'reset');
         *
         * // invoke `emit` with arguments
         * Benchmark.invoke(benches, 'emit', 'complete', listener);
         *
         * // invoke `run(true)`, treat benchmarks as a queue, and register invoke callbacks
         * Benchmark.invoke(benches, {
         *
         *   // invoke the `run` method
         *   'name': 'run',
         *
         *   // pass a single argument
         *   'args': true,
         *
         *   // treat as queue, removing benchmarks from front of `benches` until empty
         *   'queued': true,
         *
         *   // called before any benchmarks have been invoked.
         *   'onStart': onStart,
         *
         *   // called between invoking benchmarks
         *   'onCycle': onCycle,
         *
         *   // called after all benchmarks have been invoked.
         *   'onComplete': onComplete
         * });
         */
        function invoke(benches, name) {
          var args,
              bench,
              queued,
              index = -1,
              eventProps = { 'currentTarget': benches },
              options = { 'onStart': _.noop, 'onCycle': _.noop, 'onComplete': _.noop },
              result = _.toArray(benches);
    
          /**
           * Invokes the method of the current object and if synchronous, fetches the next.
           */
          function execute() {
            var listeners,
                async = isAsync(bench);
    
            if (async) {
              // Use `getNext` as the first listener.
              bench.on('complete', getNext);
              listeners = bench.events.complete;
              listeners.splice(0, 0, listeners.pop());
            }
            // Execute method.
            result[index] = _.isFunction(bench && bench[name]) ? bench[name].apply(bench, args) : undefined;
            // If synchronous return `true` until finished.
            return !async && getNext();
          }
    
          /**
           * Fetches the next bench or executes `onComplete` callback.
           */
          function getNext(event) {
            var cycleEvent,
                last = bench,
                async = isAsync(last);
    
            if (async) {
              last.off('complete', getNext);
              last.emit('complete');
            }
            // Emit "cycle" event.
            eventProps.type = 'cycle';
            eventProps.target = last;
            cycleEvent = Event(eventProps);
            options.onCycle.call(benches, cycleEvent);
    
            // Choose next benchmark if not exiting early.
            if (!cycleEvent.aborted && raiseIndex() !== false) {
              bench = queued ? benches[0] : result[index];
              if (isAsync(bench)) {
                delay(bench, execute);
              }
              else if (async) {
                // Resume execution if previously asynchronous but now synchronous.
                while (execute()) {}
              }
              else {
                // Continue synchronous execution.
                return true;
              }
            } else {
              // Emit "complete" event.
              eventProps.type = 'complete';
              options.onComplete.call(benches, Event(eventProps));
            }
            // When used as a listener `event.aborted = true` will cancel the rest of
            // the "complete" listeners because they were already called above and when
            // used as part of `getNext` the `return false` will exit the execution while-loop.
            if (event) {
              event.aborted = true;
            } else {
              return false;
            }
          }
    
          /**
           * Checks if invoking `Benchmark#run` with asynchronous cycles.
           */
          function isAsync(object) {
            // Avoid using `instanceof` here because of IE memory leak issues with host objects.
            var async = args[0] && args[0].async;
            return name == 'run' && (object instanceof Benchmark) &&
              ((async == null ? object.options.async : async) && support.timeout || object.defer);
          }
    
          /**
           * Raises `index` to the next defined index or returns `false`.
           */
          function raiseIndex() {
            index++;
    
            // If queued remove the previous bench.
            if (queued && index > 0) {
              shift.call(benches);
            }
            // If we reached the last index then return `false`.
            return (queued ? benches.length : index < result.length)
              ? index
              : (index = false);
          }
          // Juggle arguments.
          if (_.isString(name)) {
            // 2 arguments (array, name).
            args = slice.call(arguments, 2);
          } else {
            // 2 arguments (array, options).
            options = _.assign(options, name);
            name = options.name;
            args = _.isArray(args = 'args' in options ? options.args : []) ? args : [args];
            queued = options.queued;
          }
          // Start iterating over the array.
          if (raiseIndex() !== false) {
            // Emit "start" event.
            bench = result[index];
            eventProps.type = 'start';
            eventProps.target = bench;
            options.onStart.call(benches, Event(eventProps));
    
            // End early if the suite was aborted in an "onStart" listener.
            if (name == 'run' && (benches instanceof Suite) && benches.aborted) {
              // Emit "cycle" event.
              eventProps.type = 'cycle';
              options.onCycle.call(benches, Event(eventProps));
              // Emit "complete" event.
              eventProps.type = 'complete';
              options.onComplete.call(benches, Event(eventProps));
            }
            // Start method execution.
            else {
              if (isAsync(bench)) {
                delay(bench, execute);
              } else {
                while (execute()) {}
              }
            }
          }
          return result;
        }
    
        /**
         * Creates a string of joined array values or object key-value pairs.
         *
         * @static
         * @memberOf Benchmark
         * @param {Array|Object} object The object to operate on.
         * @param {string} [separator1=','] The separator used between key-value pairs.
         * @param {string} [separator2=': '] The separator used between keys and values.
         * @returns {string} The joined result.
         */
        function join(object, separator1, separator2) {
          var result = [],
              length = (object = Object(object)).length,
              arrayLike = length === length >>> 0;
    
          separator2 || (separator2 = ': ');
          _.each(object, function(value, key) {
            result.push(arrayLike ? value : key + separator2 + value);
          });
          return result.join(separator1 || ',');
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Aborts all benchmarks in the suite.
         *
         * @name abort
         * @memberOf Benchmark.Suite
         * @returns {Object} The suite instance.
         */
        function abortSuite() {
          var event,
              suite = this,
              resetting = calledBy.resetSuite;
    
          if (suite.running) {
            event = Event('abort');
            suite.emit(event);
            if (!event.cancelled || resetting) {
              // Avoid infinite recursion.
              calledBy.abortSuite = true;
              suite.reset();
              delete calledBy.abortSuite;
    
              if (!resetting) {
                suite.aborted = true;
                invoke(suite, 'abort');
              }
            }
          }
          return suite;
        }
    
        /**
         * Adds a test to the benchmark suite.
         *
         * @memberOf Benchmark.Suite
         * @param {string} name A name to identify the benchmark.
         * @param {Function|string} fn The test to benchmark.
         * @param {Object} [options={}] Options object.
         * @returns {Object} The benchmark instance.
         * @example
         *
         * // basic usage
         * suite.add(fn);
         *
         * // or using a name first
         * suite.add('foo', fn);
         *
         * // or with options
         * suite.add('foo', fn, {
         *   'onCycle': onCycle,
         *   'onComplete': onComplete
         * });
         *
         * // or name and options
         * suite.add('foo', {
         *   'fn': fn,
         *   'onCycle': onCycle,
         *   'onComplete': onComplete
         * });
         *
         * // or options only
         * suite.add({
         *   'name': 'foo',
         *   'fn': fn,
         *   'onCycle': onCycle,
         *   'onComplete': onComplete
         * });
         */
        function add(name, fn, options) {
          var suite = this,
              bench = new Benchmark(name, fn, options),
              event = Event({ 'type': 'add', 'target': bench });
    
          if (suite.emit(event), !event.cancelled) {
            suite.push(bench);
          }
          return suite;
        }
    
        /**
         * Creates a new suite with cloned benchmarks.
         *
         * @name clone
         * @memberOf Benchmark.Suite
         * @param {Object} options Options object to overwrite cloned options.
         * @returns {Object} The new suite instance.
         */
        function cloneSuite(options) {
          var suite = this,
              result = new suite.constructor(_.assign({}, suite.options, options));
    
          // Copy own properties.
          _.forOwn(suite, function(value, key) {
            if (!_.has(result, key)) {
              result[key] = value && _.isFunction(value.clone)
                ? value.clone()
                : cloneDeep(value);
            }
          });
          return result;
        }
    
        /**
         * An `Array#filter` like method.
         *
         * @name filter
         * @memberOf Benchmark.Suite
         * @param {Function|string} callback The function/alias called per iteration.
         * @returns {Object} A new suite of benchmarks that passed callback filter.
         */
        function filterSuite(callback) {
          var suite = this,
              result = new suite.constructor(suite.options);
    
          result.push.apply(result, filter(suite, callback));
          return result;
        }
    
        /**
         * Resets all benchmarks in the suite.
         *
         * @name reset
         * @memberOf Benchmark.Suite
         * @returns {Object} The suite instance.
         */
        function resetSuite() {
          var event,
              suite = this,
              aborting = calledBy.abortSuite;
    
          if (suite.running && !aborting) {
            // No worries, `resetSuite()` is called within `abortSuite()`.
            calledBy.resetSuite = true;
            suite.abort();
            delete calledBy.resetSuite;
          }
          // Reset if the state has changed.
          else if ((suite.aborted || suite.running) &&
              (suite.emit(event = Event('reset')), !event.cancelled)) {
            suite.aborted = suite.running = false;
            if (!aborting) {
              invoke(suite, 'reset');
            }
          }
          return suite;
        }
    
        /**
         * Runs the suite.
         *
         * @name run
         * @memberOf Benchmark.Suite
         * @param {Object} [options={}] Options object.
         * @returns {Object} The suite instance.
         * @example
         *
         * // basic usage
         * suite.run();
         *
         * // or with options
         * suite.run({ 'async': true, 'queued': true });
         */
        function runSuite(options) {
          var suite = this;
    
          suite.reset();
          suite.running = true;
          options || (options = {});
    
          invoke(suite, {
            'name': 'run',
            'args': options,
            'queued': options.queued,
            'onStart': function(event) {
              suite.emit(event);
            },
            'onCycle': function(event) {
              var bench = event.target;
              if (bench.error) {
                suite.emit({ 'type': 'error', 'target': bench });
              }
              suite.emit(event);
              event.aborted = suite.aborted;
            },
            'onComplete': function(event) {
              suite.running = false;
              suite.emit(event);
            }
          });
          return suite;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Executes all registered listeners of the specified event type.
         *
         * @memberOf Benchmark, Benchmark.Suite
         * @param {Object|string} type The event type or object.
         * @param {...*} [args] Arguments to invoke the listener with.
         * @returns {*} Returns the return value of the last listener executed.
         */
        function emit(type) {
          var listeners,
              object = this,
              event = Event(type),
              events = object.events,
              args = (arguments[0] = event, arguments);
    
          event.currentTarget || (event.currentTarget = object);
          event.target || (event.target = object);
          delete event.result;
    
          if (events && (listeners = _.has(events, event.type) && events[event.type])) {
            _.each(listeners.slice(), function(listener) {
              if ((event.result = listener.apply(object, args)) === false) {
                event.cancelled = true;
              }
              return !event.aborted;
            });
          }
          return event.result;
        }
    
        /**
         * Returns an array of event listeners for a given type that can be manipulated
         * to add or remove listeners.
         *
         * @memberOf Benchmark, Benchmark.Suite
         * @param {string} type The event type.
         * @returns {Array} The listeners array.
         */
        function listeners(type) {
          var object = this,
              events = object.events || (object.events = {});
    
          return _.has(events, type) ? events[type] : (events[type] = []);
        }
    
        /**
         * Unregisters a listener for the specified event type(s),
         * or unregisters all listeners for the specified event type(s),
         * or unregisters all listeners for all event types.
         *
         * @memberOf Benchmark, Benchmark.Suite
         * @param {string} [type] The event type.
         * @param {Function} [listener] The function to unregister.
         * @returns {Object} The benchmark instance.
         * @example
         *
         * // unregister a listener for an event type
         * bench.off('cycle', listener);
         *
         * // unregister a listener for multiple event types
         * bench.off('start cycle', listener);
         *
         * // unregister all listeners for an event type
         * bench.off('cycle');
         *
         * // unregister all listeners for multiple event types
         * bench.off('start cycle complete');
         *
         * // unregister all listeners for all event types
         * bench.off();
         */
        function off(type, listener) {
          var object = this,
              events = object.events;
    
          if (!events) {
            return object;
          }
          _.each(type ? type.split(' ') : events, function(listeners, type) {
            var index;
            if (typeof listeners == 'string') {
              type = listeners;
              listeners = _.has(events, type) && events[type];
            }
            if (listeners) {
              if (listener) {
                index = _.indexOf(listeners, listener);
                if (index > -1) {
                  listeners.splice(index, 1);
                }
              } else {
                listeners.length = 0;
              }
            }
          });
          return object;
        }
    
        /**
         * Registers a listener for the specified event type(s).
         *
         * @memberOf Benchmark, Benchmark.Suite
         * @param {string} type The event type.
         * @param {Function} listener The function to register.
         * @returns {Object} The benchmark instance.
         * @example
         *
         * // register a listener for an event type
         * bench.on('cycle', listener);
         *
         * // register a listener for multiple event types
         * bench.on('start cycle', listener);
         */
        function on(type, listener) {
          var object = this,
              events = object.events || (object.events = {});
    
          _.each(type.split(' '), function(type) {
            (_.has(events, type)
              ? events[type]
              : (events[type] = [])
            ).push(listener);
          });
          return object;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Aborts the benchmark without recording times.
         *
         * @memberOf Benchmark
         * @returns {Object} The benchmark instance.
         */
        function abort() {
          var event,
              bench = this,
              resetting = calledBy.reset;
    
          if (bench.running) {
            event = Event('abort');
            bench.emit(event);
            if (!event.cancelled || resetting) {
              // Avoid infinite recursion.
              calledBy.abort = true;
              bench.reset();
              delete calledBy.abort;
    
              if (support.timeout) {
                clearTimeout(bench._timerId);
                delete bench._timerId;
              }
              if (!resetting) {
                bench.aborted = true;
                bench.running = false;
              }
            }
          }
          return bench;
        }
    
        /**
         * Creates a new benchmark using the same test and options.
         *
         * @memberOf Benchmark
         * @param {Object} options Options object to overwrite cloned options.
         * @returns {Object} The new benchmark instance.
         * @example
         *
         * var bizarro = bench.clone({
         *   'name': 'doppelganger'
         * });
         */
        function clone(options) {
          var bench = this,
              result = new bench.constructor(_.assign({}, bench, options));
    
          // Correct the `options` object.
          result.options = _.assign({}, cloneDeep(bench.options), cloneDeep(options));
    
          // Copy own custom properties.
          _.forOwn(bench, function(value, key) {
            if (!_.has(result, key)) {
              result[key] = cloneDeep(value);
            }
          });
    
          return result;
        }
    
        /**
         * Determines if a benchmark is faster than another.
         *
         * @memberOf Benchmark
         * @param {Object} other The benchmark to compare.
         * @returns {number} Returns `-1` if slower, `1` if faster, and `0` if indeterminate.
         */
        function compare(other) {
          var bench = this;
    
          // Exit early if comparing the same benchmark.
          if (bench == other) {
            return 0;
          }
          var critical,
              zStat,
              sample1 = bench.stats.sample,
              sample2 = other.stats.sample,
              size1 = sample1.length,
              size2 = sample2.length,
              maxSize = max(size1, size2),
              minSize = min(size1, size2),
              u1 = getU(sample1, sample2),
              u2 = getU(sample2, sample1),
              u = min(u1, u2);
    
          function getScore(xA, sampleB) {
            return _.reduce(sampleB, function(total, xB) {
              return total + (xB > xA ? 0 : xB < xA ? 1 : 0.5);
            }, 0);
          }
    
          function getU(sampleA, sampleB) {
            return _.reduce(sampleA, function(total, xA) {
              return total + getScore(xA, sampleB);
            }, 0);
          }
    
          function getZ(u) {
            return (u - ((size1 * size2) / 2)) / sqrt((size1 * size2 * (size1 + size2 + 1)) / 12);
          }
          // Reject the null hypothesis the two samples come from the
          // same population (i.e. have the same median) if...
          if (size1 + size2 > 30) {
            // ...the z-stat is greater than 1.96 or less than -1.96
            // http://www.statisticslectures.com/topics/mannwhitneyu/
            zStat = getZ(u);
            return abs(zStat) > 1.96 ? (u == u1 ? 1 : -1) : 0;
          }
          // ...the U value is less than or equal the critical U value.
          critical = maxSize < 5 || minSize < 3 ? 0 : uTable[maxSize][minSize - 3];
          return u <= critical ? (u == u1 ? 1 : -1) : 0;
        }
    
        /**
         * Reset properties and abort if running.
         *
         * @memberOf Benchmark
         * @returns {Object} The benchmark instance.
         */
        function reset() {
          var bench = this;
          if (bench.running && !calledBy.abort) {
            // No worries, `reset()` is called within `abort()`.
            calledBy.reset = true;
            bench.abort();
            delete calledBy.reset;
            return bench;
          }
          var event,
              index = 0,
              changes = [],
              queue = [];
    
          // A non-recursive solution to check if properties have changed.
          // For more information see http://www.jslab.dk/articles/non.recursive.preorder.traversal.part4.
          var data = {
            'destination': bench,
            'source': _.assign({}, cloneDeep(bench.constructor.prototype), cloneDeep(bench.options))
          };
    
          do {
            _.forOwn(data.source, function(value, key) {
              var changed,
                  destination = data.destination,
                  currValue = destination[key];
    
              // Skip pseudo private properties like `_timerId` which could be a
              // Java object in environments like RingoJS.
              if (key.charAt(0) == '_') {
                return;
              }
              if (value && typeof value == 'object') {
                if (_.isArray(value)) {
                  // Check if an array value has changed to a non-array value.
                  if (!_.isArray(currValue)) {
                    changed = currValue = [];
                  }
                  // Check if an array has changed its length.
                  if (currValue.length != value.length) {
                    changed = currValue = currValue.slice(0, value.length);
                    currValue.length = value.length;
                  }
                }
                // Check if an object has changed to a non-object value.
                else if (!currValue || typeof currValue != 'object') {
                  changed = currValue = {};
                }
                // Register a changed object.
                if (changed) {
                  changes.push({ 'destination': destination, 'key': key, 'value': currValue });
                }
                queue.push({ 'destination': currValue, 'source': value });
              }
              // Register a changed primitive.
              else if (value !== currValue && !(value == null || _.isFunction(value))) {
                changes.push({ 'destination': destination, 'key': key, 'value': value });
              }
            });
          }
          while ((data = queue[index++]));
    
          // If changed emit the `reset` event and if it isn't cancelled reset the benchmark.
          if (changes.length && (bench.emit(event = Event('reset')), !event.cancelled)) {
            _.each(changes, function(data) {
              data.destination[data.key] = data.value;
            });
          }
          return bench;
        }
    
        /**
         * Displays relevant benchmark information when coerced to a string.
         *
         * @name toString
         * @memberOf Benchmark
         * @returns {string} A string representation of the benchmark instance.
         */
        function toStringBench() {
          var bench = this,
              error = bench.error,
              hz = bench.hz,
              id = bench.id,
              stats = bench.stats,
              size = stats.sample.length,
              pm = '\xb1',
              result = bench.name || (_.isNaN(id) ? id : '<Test #' + id + '>');
    
          if (error) {
            result += ': ' + join(error);
          } else {
            result += ' x ' + formatNumber(hz.toFixed(hz < 100 ? 2 : 0)) + ' ops/sec ' + pm +
              stats.rme.toFixed(2) + '% (' + size + ' run' + (size == 1 ? '' : 's') + ' sampled)';
          }
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Clocks the time taken to execute a test per cycle (secs).
         *
         * @private
         * @param {Object} bench The benchmark instance.
         * @returns {number} The time taken.
         */
        function clock() {
          var options = Benchmark.options,
              templateData = {},
              timers = [{ 'ns': timer.ns, 'res': max(0.0015, getRes('ms')), 'unit': 'ms' }];
    
          // Lazy define for hi-res timers.
          clock = function(clone) {
            var deferred;
    
            if (clone instanceof Deferred) {
              deferred = clone;
              clone = deferred.benchmark;
            }
            var bench = clone._original,
                stringable = isStringable(bench.fn),
                count = bench.count = clone.count,
                decompilable = stringable || (support.decompilation && (clone.setup !== _.noop || clone.teardown !== _.noop)),
                id = bench.id,
                name = bench.name || (typeof id == 'number' ? '<Test #' + id + '>' : id),
                result = 0;
    
            // Init `minTime` if needed.
            clone.minTime = bench.minTime || (bench.minTime = bench.options.minTime = options.minTime);
    
            // Compile in setup/teardown functions and the test loop.
            // Create a new compiled test, instead of using the cached `bench.compiled`,
            // to avoid potential engine optimizations enabled over the life of the test.
            var funcBody = deferred
              ? 'var d#=this,${fnArg}=d#,m#=d#.benchmark._original,f#=m#.fn,su#=m#.setup,td#=m#.teardown;' +
                // When `deferred.cycles` is `0` then...
                'if(!d#.cycles){' +
                // set `deferred.fn`,
                'd#.fn=function(){var ${fnArg}=d#;if(typeof f#=="function"){try{${fn}\n}catch(e#){f#(d#)}}else{${fn}\n}};' +
                // set `deferred.teardown`,
                'd#.teardown=function(){d#.cycles=0;if(typeof td#=="function"){try{${teardown}\n}catch(e#){td#()}}else{${teardown}\n}};' +
                // execute the benchmark's `setup`,
                'if(typeof su#=="function"){try{${setup}\n}catch(e#){su#()}}else{${setup}\n};' +
                // start timer,
                't#.start(d#);' +
                // and then execute `deferred.fn` and return a dummy object.
                '}d#.fn();return{uid:"${uid}"}'
    
              : 'var r#,s#,m#=this,f#=m#.fn,i#=m#.count,n#=t#.ns;${setup}\n${begin};' +
                'while(i#--){${fn}\n}${end};${teardown}\nreturn{elapsed:r#,uid:"${uid}"}';
    
            var compiled = bench.compiled = clone.compiled = createCompiled(bench, decompilable, deferred, funcBody),
                isEmpty = !(templateData.fn || stringable);
    
            try {
              if (isEmpty) {
                // Firefox may remove dead code from `Function#toString` results.
                // For more information see http://bugzil.la/536085.
                throw new Error('The test "' + name + '" is empty. This may be the result of dead code removal.');
              }
              else if (!deferred) {
                // Pretest to determine if compiled code exits early, usually by a
                // rogue `return` statement, by checking for a return object with the uid.
                bench.count = 1;
                compiled = decompilable && (compiled.call(bench, context, timer) || {}).uid == templateData.uid && compiled;
                bench.count = count;
              }
            } catch(e) {
              compiled = null;
              clone.error = e || new Error(String(e));
              bench.count = count;
            }
            // Fallback when a test exits early or errors during pretest.
            if (!compiled && !deferred && !isEmpty) {
              funcBody = (
                stringable || (decompilable && !clone.error)
                  ? 'function f#(){${fn}\n}var r#,s#,m#=this,i#=m#.count'
                  : 'var r#,s#,m#=this,f#=m#.fn,i#=m#.count'
                ) +
                ',n#=t#.ns;${setup}\n${begin};m#.f#=f#;while(i#--){m#.f#()}${end};' +
                'delete m#.f#;${teardown}\nreturn{elapsed:r#}';
    
              compiled = createCompiled(bench, decompilable, deferred, funcBody);
    
              try {
                // Pretest one more time to check for errors.
                bench.count = 1;
                compiled.call(bench, context, timer);
                bench.count = count;
                delete clone.error;
              }
              catch(e) {
                bench.count = count;
                if (!clone.error) {
                  clone.error = e || new Error(String(e));
                }
              }
            }
            // If no errors run the full test loop.
            if (!clone.error) {
              compiled = bench.compiled = clone.compiled = createCompiled(bench, decompilable, deferred, funcBody);
              result = compiled.call(deferred || bench, context, timer).elapsed;
            }
            return result;
          };
    
          /*----------------------------------------------------------------------*/
    
          /**
           * Creates a compiled function from the given function `body`.
           */
          function createCompiled(bench, decompilable, deferred, body) {
            var fn = bench.fn,
                fnArg = deferred ? getFirstArgument(fn) || 'deferred' : '';
    
            templateData.uid = uid + uidCounter++;
    
            _.assign(templateData, {
              'setup': decompilable ? getSource(bench.setup) : interpolate('m#.setup()'),
              'fn': decompilable ? getSource(fn) : interpolate('m#.fn(' + fnArg + ')'),
              'fnArg': fnArg,
              'teardown': decompilable ? getSource(bench.teardown) : interpolate('m#.teardown()')
            });
    
            // Use API of chosen timer.
            if (timer.unit == 'ns') {
              _.assign(templateData, {
                'begin': interpolate('s#=n#()'),
                'end': interpolate('r#=n#(s#);r#=r#[0]+(r#[1]/1e9)')
              });
            }
            else if (timer.unit == 'us') {
              if (timer.ns.stop) {
                _.assign(templateData, {
                  'begin': interpolate('s#=n#.start()'),
                  'end': interpolate('r#=n#.microseconds()/1e6')
                });
              } else {
                _.assign(templateData, {
                  'begin': interpolate('s#=n#()'),
                  'end': interpolate('r#=(n#()-s#)/1e6')
                });
              }
            }
            else if (timer.ns.now) {
              _.assign(templateData, {
                'begin': interpolate('s#=n#.now()'),
                'end': interpolate('r#=(n#.now()-s#)/1e3')
              });
            }
            else {
              _.assign(templateData, {
                'begin': interpolate('s#=new n#().getTime()'),
                'end': interpolate('r#=(new n#().getTime()-s#)/1e3')
              });
            }
            // Define `timer` methods.
            timer.start = createFunction(
              interpolate('o#'),
              interpolate('var n#=this.ns,${begin};o#.elapsed=0;o#.timeStamp=s#')
            );
    
            timer.stop = createFunction(
              interpolate('o#'),
              interpolate('var n#=this.ns,s#=o#.timeStamp,${end};o#.elapsed=r#')
            );
    
            // Create compiled test.
            return createFunction(
              interpolate('window,t#'),
              'var global = window, clearTimeout = global.clearTimeout, setTimeout = global.setTimeout;\n' +
              interpolate(body)
            );
          }
    
          /**
           * Gets the current timer's minimum resolution (secs).
           */
          function getRes(unit) {
            var measured,
                begin,
                count = 30,
                divisor = 1e3,
                ns = timer.ns,
                sample = [];
    
            // Get average smallest measurable time.
            while (count--) {
              if (unit == 'us') {
                divisor = 1e6;
                if (ns.stop) {
                  ns.start();
                  while (!(measured = ns.microseconds())) {}
                } else {
                  begin = ns();
                  while (!(measured = ns() - begin)) {}
                }
              }
              else if (unit == 'ns') {
                divisor = 1e9;
                begin = (begin = ns())[0] + (begin[1] / divisor);
                while (!(measured = ((measured = ns())[0] + (measured[1] / divisor)) - begin)) {}
                divisor = 1;
              }
              else if (ns.now) {
                begin = ns.now();
                while (!(measured = ns.now() - begin)) {}
              }
              else {
                begin = new ns().getTime();
                while (!(measured = new ns().getTime() - begin)) {}
              }
              // Check for broken timers.
              if (measured > 0) {
                sample.push(measured);
              } else {
                sample.push(Infinity);
                break;
              }
            }
            // Convert to seconds.
            return getMean(sample) / divisor;
          }
    
          /**
           * Interpolates a given template string.
           */
          function interpolate(string) {
            // Replaces all occurrences of `#` with a unique number and template tokens with content.
            return _.template(string.replace(/\#/g, /\d+/.exec(templateData.uid)))(templateData);
          }
    
          /*----------------------------------------------------------------------*/
    
          // Detect Chrome's microsecond timer:
          // enable benchmarking via the --enable-benchmarking command
          // line switch in at least Chrome 7 to use chrome.Interval
          try {
            if ((timer.ns = new (context.chrome || context.chromium).Interval)) {
              timers.push({ 'ns': timer.ns, 'res': getRes('us'), 'unit': 'us' });
            }
          } catch(e) {}
    
          // Detect Node.js's nanosecond resolution timer available in Node.js >= 0.8.
          if (processObject && typeof (timer.ns = processObject.hrtime) == 'function') {
            timers.push({ 'ns': timer.ns, 'res': getRes('ns'), 'unit': 'ns' });
          }
          // Detect Wade Simmons' Node.js `microtime` module.
          if (microtimeObject && typeof (timer.ns = microtimeObject.now) == 'function') {
            timers.push({ 'ns': timer.ns,  'res': getRes('us'), 'unit': 'us' });
          }
          // Pick timer with highest resolution.
          timer = _.minBy(timers, 'res');
    
          // Error if there are no working timers.
          if (timer.res == Infinity) {
            throw new Error('Benchmark.js was unable to find a working timer.');
          }
          // Resolve time span required to achieve a percent uncertainty of at most 1%.
          // For more information see http://spiff.rit.edu/classes/phys273/uncert/uncert.html.
          options.minTime || (options.minTime = max(timer.res / 2 / 0.01, 0.05));
          return clock.apply(null, arguments);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Computes stats on benchmark results.
         *
         * @private
         * @param {Object} bench The benchmark instance.
         * @param {Object} options The options object.
         */
        function compute(bench, options) {
          options || (options = {});
    
          var async = options.async,
              elapsed = 0,
              initCount = bench.initCount,
              minSamples = bench.minSamples,
              queue = [],
              sample = bench.stats.sample;
    
          /**
           * Adds a clone to the queue.
           */
          function enqueue() {
            queue.push(bench.clone({
              '_original': bench,
              'events': {
                'abort': [update],
                'cycle': [update],
                'error': [update],
                'start': [update]
              }
            }));
          }
    
          /**
           * Updates the clone/original benchmarks to keep their data in sync.
           */
          function update(event) {
            var clone = this,
                type = event.type;
    
            if (bench.running) {
              if (type == 'start') {
                // Note: `clone.minTime` prop is inited in `clock()`.
                clone.count = bench.initCount;
              }
              else {
                if (type == 'error') {
                  bench.error = clone.error;
                }
                if (type == 'abort') {
                  bench.abort();
                  bench.emit('cycle');
                } else {
                  event.currentTarget = event.target = bench;
                  bench.emit(event);
                }
              }
            } else if (bench.aborted) {
              // Clear abort listeners to avoid triggering bench's abort/cycle again.
              clone.events.abort.length = 0;
              clone.abort();
            }
          }
    
          /**
           * Determines if more clones should be queued or if cycling should stop.
           */
          function evaluate(event) {
            var critical,
                df,
                mean,
                moe,
                rme,
                sd,
                sem,
                variance,
                clone = event.target,
                done = bench.aborted,
                now = _.now(),
                size = sample.push(clone.times.period),
                maxedOut = size >= minSamples && (elapsed += now - clone.times.timeStamp) / 1e3 > bench.maxTime,
                times = bench.times,
                varOf = function(sum, x) { return sum + pow(x - mean, 2); };
    
            // Exit early for aborted or unclockable tests.
            if (done || clone.hz == Infinity) {
              maxedOut = !(size = sample.length = queue.length = 0);
            }
    
            if (!done) {
              // Compute the sample mean (estimate of the population mean).
              mean = getMean(sample);
              // Compute the sample variance (estimate of the population variance).
              variance = _.reduce(sample, varOf, 0) / (size - 1) || 0;
              // Compute the sample standard deviation (estimate of the population standard deviation).
              sd = sqrt(variance);
              // Compute the standard error of the mean (a.k.a. the standard deviation of the sampling distribution of the sample mean).
              sem = sd / sqrt(size);
              // Compute the degrees of freedom.
              df = size - 1;
              // Compute the critical value.
              critical = tTable[Math.round(df) || 1] || tTable.infinity;
              // Compute the margin of error.
              moe = sem * critical;
              // Compute the relative margin of error.
              rme = (moe / mean) * 100 || 0;
    
              _.assign(bench.stats, {
                'deviation': sd,
                'mean': mean,
                'moe': moe,
                'rme': rme,
                'sem': sem,
                'variance': variance
              });
    
              // Abort the cycle loop when the minimum sample size has been collected
              // and the elapsed time exceeds the maximum time allowed per benchmark.
              // We don't count cycle delays toward the max time because delays may be
              // increased by browsers that clamp timeouts for inactive tabs. For more
              // information see https://developer.mozilla.org/en/window.setTimeout#Inactive_tabs.
              if (maxedOut) {
                // Reset the `initCount` in case the benchmark is rerun.
                bench.initCount = initCount;
                bench.running = false;
                done = true;
                times.elapsed = (now - times.timeStamp) / 1e3;
              }
              if (bench.hz != Infinity) {
                bench.hz = 1 / mean;
                times.cycle = mean * bench.count;
                times.period = mean;
              }
            }
            // If time permits, increase sample size to reduce the margin of error.
            if (queue.length < 2 && !maxedOut) {
              enqueue();
            }
            // Abort the `invoke` cycle when done.
            event.aborted = done;
          }
    
          // Init queue and begin.
          enqueue();
          invoke(queue, {
            'name': 'run',
            'args': { 'async': async },
            'queued': true,
            'onCycle': evaluate,
            'onComplete': function() { bench.emit('complete'); }
          });
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Cycles a benchmark until a run `count` can be established.
         *
         * @private
         * @param {Object} clone The cloned benchmark instance.
         * @param {Object} options The options object.
         */
        function cycle(clone, options) {
          options || (options = {});
    
          var deferred;
          if (clone instanceof Deferred) {
            deferred = clone;
            clone = clone.benchmark;
          }
          var clocked,
              cycles,
              divisor,
              event,
              minTime,
              period,
              async = options.async,
              bench = clone._original,
              count = clone.count,
              times = clone.times;
    
          // Continue, if not aborted between cycles.
          if (clone.running) {
            // `minTime` is set to `Benchmark.options.minTime` in `clock()`.
            cycles = ++clone.cycles;
            clocked = deferred ? deferred.elapsed : clock(clone);
            minTime = clone.minTime;
    
            if (cycles > bench.cycles) {
              bench.cycles = cycles;
            }
            if (clone.error) {
              event = Event('error');
              event.message = clone.error;
              clone.emit(event);
              if (!event.cancelled) {
                clone.abort();
              }
            }
          }
          // Continue, if not errored.
          if (clone.running) {
            // Compute the time taken to complete last test cycle.
            bench.times.cycle = times.cycle = clocked;
            // Compute the seconds per operation.
            period = bench.times.period = times.period = clocked / count;
            // Compute the ops per second.
            bench.hz = clone.hz = 1 / period;
            // Avoid working our way up to this next time.
            bench.initCount = clone.initCount = count;
            // Do we need to do another cycle?
            clone.running = clocked < minTime;
    
            if (clone.running) {
              // Tests may clock at `0` when `initCount` is a small number,
              // to avoid that we set its count to something a bit higher.
              if (!clocked && (divisor = divisors[clone.cycles]) != null) {
                count = floor(4e6 / divisor);
              }
              // Calculate how many more iterations it will take to achieve the `minTime`.
              if (count <= clone.count) {
                count += Math.ceil((minTime - clocked) / period);
              }
              clone.running = count != Infinity;
            }
          }
          // Should we exit early?
          event = Event('cycle');
          clone.emit(event);
          if (event.aborted) {
            clone.abort();
          }
          // Figure out what to do next.
          if (clone.running) {
            // Start a new cycle.
            clone.count = count;
            if (deferred) {
              clone.compiled.call(deferred, context, timer);
            } else if (async) {
              delay(clone, function() { cycle(clone, options); });
            } else {
              cycle(clone);
            }
          }
          else {
            // Fix TraceMonkey bug associated with clock fallbacks.
            // For more information see http://bugzil.la/509069.
            if (support.browser) {
              runScript(uid + '=1;delete ' + uid);
            }
            // We're done.
            clone.emit('complete');
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Runs the benchmark.
         *
         * @memberOf Benchmark
         * @param {Object} [options={}] Options object.
         * @returns {Object} The benchmark instance.
         * @example
         *
         * // basic usage
         * bench.run();
         *
         * // or with options
         * bench.run({ 'async': true });
         */
        function run(options) {
          var bench = this,
              event = Event('start');
    
          // Set `running` to `false` so `reset()` won't call `abort()`.
          bench.running = false;
          bench.reset();
          bench.running = true;
    
          bench.count = bench.initCount;
          bench.times.timeStamp = _.now();
          bench.emit(event);
    
          if (!event.cancelled) {
            options = { 'async': ((options = options && options.async) == null ? bench.async : options) && support.timeout };
    
            // For clones created within `compute()`.
            if (bench._original) {
              if (bench.defer) {
                Deferred(bench);
              } else {
                cycle(bench, options);
              }
            }
            // For original benchmarks.
            else {
              compute(bench, options);
            }
          }
          return bench;
        }
    
        /*------------------------------------------------------------------------*/
    
        // Firefox 1 erroneously defines variable and argument names of functions on
        // the function itself as non-configurable properties with `undefined` values.
        // The bugginess continues as the `Benchmark` constructor has an argument
        // named `options` and Firefox 1 will not assign a value to `Benchmark.options`,
        // making it non-writable in the process, unless it is the first property
        // assigned by for-in loop of `_.assign()`.
        _.assign(Benchmark, {
    
          /**
           * The default options copied by benchmark instances.
           *
           * @static
           * @memberOf Benchmark
           * @type Object
           */
          'options': {
    
            /**
             * A flag to indicate that benchmark cycles will execute asynchronously
             * by default.
             *
             * @memberOf Benchmark.options
             * @type boolean
             */
            'async': false,
    
            /**
             * A flag to indicate that the benchmark clock is deferred.
             *
             * @memberOf Benchmark.options
             * @type boolean
             */
            'defer': false,
    
            /**
             * The delay between test cycles (secs).
             * @memberOf Benchmark.options
             * @type number
             */
            'delay': 0.005,
    
            /**
             * Displayed by `Benchmark#toString` when a `name` is not available
             * (auto-generated if absent).
             *
             * @memberOf Benchmark.options
             * @type string
             */
            'id': undefined,
    
            /**
             * The default number of times to execute a test on a benchmark's first cycle.
             *
             * @memberOf Benchmark.options
             * @type number
             */
            'initCount': 1,
    
            /**
             * The maximum time a benchmark is allowed to run before finishing (secs).
             *
             * Note: Cycle delays aren't counted toward the maximum time.
             *
             * @memberOf Benchmark.options
             * @type number
             */
            'maxTime': 5,
    
            /**
             * The minimum sample size required to perform statistical analysis.
             *
             * @memberOf Benchmark.options
             * @type number
             */
            'minSamples': 5,
    
            /**
             * The time needed to reduce the percent uncertainty of measurement to 1% (secs).
             *
             * @memberOf Benchmark.options
             * @type number
             */
            'minTime': 0,
    
            /**
             * The name of the benchmark.
             *
             * @memberOf Benchmark.options
             * @type string
             */
            'name': undefined,
    
            /**
             * An event listener called when the benchmark is aborted.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onAbort': undefined,
    
            /**
             * An event listener called when the benchmark completes running.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onComplete': undefined,
    
            /**
             * An event listener called after each run cycle.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onCycle': undefined,
    
            /**
             * An event listener called when a test errors.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onError': undefined,
    
            /**
             * An event listener called when the benchmark is reset.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onReset': undefined,
    
            /**
             * An event listener called when the benchmark starts running.
             *
             * @memberOf Benchmark.options
             * @type Function
             */
            'onStart': undefined
          },
    
          /**
           * Platform object with properties describing things like browser name,
           * version, and operating system. See [`platform.js`](https://mths.be/platform).
           *
           * @static
           * @memberOf Benchmark
           * @type Object
           */
          'platform': context.platform || req('platform') || ({
            'description': context.navigator && context.navigator.userAgent || null,
            'layout': null,
            'product': null,
            'name': null,
            'manufacturer': null,
            'os': null,
            'prerelease': null,
            'version': null,
            'toString': function() {
              return this.description || '';
            }
          }),
    
          /**
           * The semantic version number.
           *
           * @static
           * @memberOf Benchmark
           * @type string
           */
          'version': '2.1.0'
        });
    
        _.assign(Benchmark, {
          'filter': filter,
          'formatNumber': formatNumber,
          'invoke': invoke,
          'join': join,
          'runInContext': runInContext,
          'support': support
        });
    
        // Add lodash methods to Benchmark.
        _.each(['each', 'forEach', 'forOwn', 'has', 'indexOf', 'map', 'reduce'], function(methodName) {
          Benchmark[methodName] = _[methodName];
        });
    
        /*------------------------------------------------------------------------*/
    
        _.assign(Benchmark.prototype, {
    
          /**
           * The number of times a test was executed.
           *
           * @memberOf Benchmark
           * @type number
           */
          'count': 0,
    
          /**
           * The number of cycles performed while benchmarking.
           *
           * @memberOf Benchmark
           * @type number
           */
          'cycles': 0,
    
          /**
           * The number of executions per second.
           *
           * @memberOf Benchmark
           * @type number
           */
          'hz': 0,
    
          /**
           * The compiled test function.
           *
           * @memberOf Benchmark
           * @type {Function|string}
           */
          'compiled': undefined,
    
          /**
           * The error object if the test failed.
           *
           * @memberOf Benchmark
           * @type Object
           */
          'error': undefined,
    
          /**
           * The test to benchmark.
           *
           * @memberOf Benchmark
           * @type {Function|string}
           */
          'fn': undefined,
    
          /**
           * A flag to indicate if the benchmark is aborted.
           *
           * @memberOf Benchmark
           * @type boolean
           */
          'aborted': false,
    
          /**
           * A flag to indicate if the benchmark is running.
           *
           * @memberOf Benchmark
           * @type boolean
           */
          'running': false,
    
          /**
           * Compiled into the test and executed immediately **before** the test loop.
           *
           * @memberOf Benchmark
           * @type {Function|string}
           * @example
           *
           * // basic usage
           * var bench = Benchmark({
           *   'setup': function() {
           *     var c = this.count,
           *         element = document.getElementById('container');
           *     while (c--) {
           *       element.appendChild(document.createElement('div'));
           *     }
           *   },
           *   'fn': function() {
           *     element.removeChild(element.lastChild);
           *   }
           * });
           *
           * // compiles to something like:
           * var c = this.count,
           *     element = document.getElementById('container');
           * while (c--) {
           *   element.appendChild(document.createElement('div'));
           * }
           * var start = new Date;
           * while (count--) {
           *   element.removeChild(element.lastChild);
           * }
           * var end = new Date - start;
           *
           * // or using strings
           * var bench = Benchmark({
           *   'setup': '\
           *     var a = 0;\n\
           *     (function() {\n\
           *       (function() {\n\
           *         (function() {',
           *   'fn': 'a += 1;',
           *   'teardown': '\
           *          }())\n\
           *        }())\n\
           *      }())'
           * });
           *
           * // compiles to something like:
           * var a = 0;
           * (function() {
           *   (function() {
           *     (function() {
           *       var start = new Date;
           *       while (count--) {
           *         a += 1;
           *       }
           *       var end = new Date - start;
           *     }())
           *   }())
           * }())
           */
          'setup': _.noop,
    
          /**
           * Compiled into the test and executed immediately **after** the test loop.
           *
           * @memberOf Benchmark
           * @type {Function|string}
           */
          'teardown': _.noop,
    
          /**
           * An object of stats including mean, margin or error, and standard deviation.
           *
           * @memberOf Benchmark
           * @type Object
           */
          'stats': {
    
            /**
             * The margin of error.
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'moe': 0,
    
            /**
             * The relative margin of error (expressed as a percentage of the mean).
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'rme': 0,
    
            /**
             * The standard error of the mean.
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'sem': 0,
    
            /**
             * The sample standard deviation.
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'deviation': 0,
    
            /**
             * The sample arithmetic mean (secs).
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'mean': 0,
    
            /**
             * The array of sampled periods.
             *
             * @memberOf Benchmark#stats
             * @type Array
             */
            'sample': [],
    
            /**
             * The sample variance.
             *
             * @memberOf Benchmark#stats
             * @type number
             */
            'variance': 0
          },
    
          /**
           * An object of timing data including cycle, elapsed, period, start, and stop.
           *
           * @memberOf Benchmark
           * @type Object
           */
          'times': {
    
            /**
             * The time taken to complete the last cycle (secs).
             *
             * @memberOf Benchmark#times
             * @type number
             */
            'cycle': 0,
    
            /**
             * The time taken to complete the benchmark (secs).
             *
             * @memberOf Benchmark#times
             * @type number
             */
            'elapsed': 0,
    
            /**
             * The time taken to execute the test once (secs).
             *
             * @memberOf Benchmark#times
             * @type number
             */
            'period': 0,
    
            /**
             * A timestamp of when the benchmark started (ms).
             *
             * @memberOf Benchmark#times
             * @type number
             */
            'timeStamp': 0
          }
        });
    
        _.assign(Benchmark.prototype, {
          'abort': abort,
          'clone': clone,
          'compare': compare,
          'emit': emit,
          'listeners': listeners,
          'off': off,
          'on': on,
          'reset': reset,
          'run': run,
          'toString': toStringBench
        });
    
        /*------------------------------------------------------------------------*/
    
        _.assign(Deferred.prototype, {
    
          /**
           * The deferred benchmark instance.
           *
           * @memberOf Benchmark.Deferred
           * @type Object
           */
          'benchmark': null,
    
          /**
           * The number of deferred cycles performed while benchmarking.
           *
           * @memberOf Benchmark.Deferred
           * @type number
           */
          'cycles': 0,
    
          /**
           * The time taken to complete the deferred benchmark (secs).
           *
           * @memberOf Benchmark.Deferred
           * @type number
           */
          'elapsed': 0,
    
          /**
           * A timestamp of when the deferred benchmark started (ms).
           *
           * @memberOf Benchmark.Deferred
           * @type number
           */
          'timeStamp': 0
        });
    
        _.assign(Deferred.prototype, {
          'resolve': resolve
        });
    
        /*------------------------------------------------------------------------*/
    
        _.assign(Event.prototype, {
    
          /**
           * A flag to indicate if the emitters listener iteration is aborted.
           *
           * @memberOf Benchmark.Event
           * @type boolean
           */
          'aborted': false,
    
          /**
           * A flag to indicate if the default action is cancelled.
           *
           * @memberOf Benchmark.Event
           * @type boolean
           */
          'cancelled': false,
    
          /**
           * The object whose listeners are currently being processed.
           *
           * @memberOf Benchmark.Event
           * @type Object
           */
          'currentTarget': undefined,
    
          /**
           * The return value of the last executed listener.
           *
           * @memberOf Benchmark.Event
           * @type Mixed
           */
          'result': undefined,
    
          /**
           * The object to which the event was originally emitted.
           *
           * @memberOf Benchmark.Event
           * @type Object
           */
          'target': undefined,
    
          /**
           * A timestamp of when the event was created (ms).
           *
           * @memberOf Benchmark.Event
           * @type number
           */
          'timeStamp': 0,
    
          /**
           * The event type.
           *
           * @memberOf Benchmark.Event
           * @type string
           */
          'type': ''
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The default options copied by suite instances.
         *
         * @static
         * @memberOf Benchmark.Suite
         * @type Object
         */
        Suite.options = {
    
          /**
           * The name of the suite.
           *
           * @memberOf Benchmark.Suite.options
           * @type string
           */
          'name': undefined
        };
    
        /*------------------------------------------------------------------------*/
    
        _.assign(Suite.prototype, {
    
          /**
           * The number of benchmarks in the suite.
           *
           * @memberOf Benchmark.Suite
           * @type number
           */
          'length': 0,
    
          /**
           * A flag to indicate if the suite is aborted.
           *
           * @memberOf Benchmark.Suite
           * @type boolean
           */
          'aborted': false,
    
          /**
           * A flag to indicate if the suite is running.
           *
           * @memberOf Benchmark.Suite
           * @type boolean
           */
          'running': false
        });
    
        _.assign(Suite.prototype, {
          'abort': abortSuite,
          'add': add,
          'clone': cloneSuite,
          'emit': emit,
          'filter': filterSuite,
          'join': arrayRef.join,
          'listeners': listeners,
          'off': off,
          'on': on,
          'pop': arrayRef.pop,
          'push': push,
          'reset': resetSuite,
          'run': runSuite,
          'reverse': arrayRef.reverse,
          'shift': shift,
          'slice': slice,
          'sort': arrayRef.sort,
          'splice': arrayRef.splice,
          'unshift': unshift
        });
    
        /*------------------------------------------------------------------------*/
    
        // Expose Deferred, Event, and Suite.
        _.assign(Benchmark, {
          'Deferred': Deferred,
          'Event': Event,
          'Suite': Suite
        });
    
        /*------------------------------------------------------------------------*/
    
        // Add lodash methods as Suite methods.
        _.each(['each', 'forEach', 'indexOf', 'map', 'reduce'], function(methodName) {
          var func = _[methodName];
          Suite.prototype[methodName] = function() {
            var args = [this];
            push.apply(args, arguments);
            return func.apply(_, args);
          };
        });
    
        // Avoid array-like object bugs with `Array#shift` and `Array#splice`
        // in Firefox < 10 and IE < 9.
        _.each(['pop', 'shift', 'splice'], function(methodName) {
          var func = arrayRef[methodName];
    
          Suite.prototype[methodName] = function() {
            var value = this,
                result = func.apply(value, arguments);
    
            if (value.length === 0) {
              delete value[0];
            }
            return result;
          };
        });
    
        // Avoid buggy `Array#unshift` in IE < 8 which doesn't return the new
        // length of the array.
        Suite.prototype.unshift = function() {
          var value = this;
          unshift.apply(value, arguments);
          return value.length;
        };
    
        return Benchmark;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // Export Benchmark.
      // Some AMD build optimizers, like r.js, check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Define as an anonymous module so, through path mapping, it can be aliased.
        define(['lodash', 'platform'], function(_, platform) {
          return runInContext({
            '_': _,
            'platform': platform
          });
        });
      }
      else {
        var Benchmark = runInContext();
    
        // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
        if (freeExports && freeModule) {
          // Export for Node.js.
          if (moduleExports) {
            (freeModule.exports = Benchmark).Benchmark = Benchmark;
          }
          // Export for CommonJS support.
          freeExports.Benchmark = Benchmark;
        }
        else {
          // Export to the global object.
          root.Benchmark = Benchmark;
        }
      }
    }.call(this));
    
  provide("benchmark", module.exports);
}(global));

// pakmanager:is-unc-path
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var regex = require('unc-path-regex');
    
    module.exports = function isUNC(fp) {
      if (typeof fp !== 'string') return false;
      return regex().test(fp);
    };
    
  provide("is-unc-path", module.exports);
}(global));

// pakmanager:end-of-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var once = require('once');
    
    var noop = function() {};
    
    var isRequest = function(stream) {
    	return stream.setHeader && typeof stream.abort === 'function';
    };
    
    var isChildProcess = function(stream) {
    	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
    };
    
    var eos = function(stream, opts, callback) {
    	if (typeof opts === 'function') return eos(stream, null, opts);
    	if (!opts) opts = {};
    
    	callback = once(callback || noop);
    
    	var ws = stream._writableState;
    	var rs = stream._readableState;
    	var readable = opts.readable || (opts.readable !== false && stream.readable);
    	var writable = opts.writable || (opts.writable !== false && stream.writable);
    
    	var onlegacyfinish = function() {
    		if (!stream.writable) onfinish();
    	};
    
    	var onfinish = function() {
    		writable = false;
    		if (!readable) callback();
    	};
    
    	var onend = function() {
    		readable = false;
    		if (!writable) callback();
    	};
    
    	var onexit = function(exitCode) {
    		callback(exitCode ? new Error('exited with error code: ' + exitCode) : null);
    	};
    
    	var onclose = function() {
    		if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
    		if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
    	};
    
    	var onrequest = function() {
    		stream.req.on('finish', onfinish);
    	};
    
    	if (isRequest(stream)) {
    		stream.on('complete', onfinish);
    		stream.on('abort', onclose);
    		if (stream.req) onrequest();
    		else stream.on('request', onrequest);
    	} else if (writable && !ws) { // legacy streams
    		stream.on('end', onlegacyfinish);
    		stream.on('close', onlegacyfinish);
    	}
    
    	if (isChildProcess(stream)) stream.on('exit', onexit);
    
    	stream.on('end', onend);
    	stream.on('finish', onfinish);
    	if (opts.error !== false) stream.on('error', callback);
    	stream.on('close', onclose);
    
    	return function() {
    		stream.removeListener('complete', onfinish);
    		stream.removeListener('abort', onclose);
    		stream.removeListener('request', onrequest);
    		if (stream.req) stream.req.removeListener('finish', onfinish);
    		stream.removeListener('end', onlegacyfinish);
    		stream.removeListener('close', onlegacyfinish);
    		stream.removeListener('finish', onfinish);
    		stream.removeListener('exit', onexit);
    		stream.removeListener('end', onend);
    		stream.removeListener('error', callback);
    		stream.removeListener('close', onclose);
    	};
    };
    
    module.exports = eos;
  provide("end-of-stream", module.exports);
}(global));

// pakmanager:archiver-utils/file.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * archiver-utils
     *
     * Copyright (c) 2012-2014 Chris Talkington, contributors.
     * Licensed under the MIT license.
     * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT
     */
    var fs = require('fs');
    var path = require('path');
    
    var _ = require('lodash');
    var glob = require('glob');
    
    var file = module.exports = {};
    
    var pathSeparatorRe = /[\/\\]/g;
    
    // Process specified wildcard glob patterns or filenames against a
    // callback, excluding and uniquing files in the result set.
    var processPatterns = function(patterns, fn) {
      // Filepaths to return.
      var result = [];
      // Iterate over flattened patterns array.
      _.flatten(patterns).forEach(function(pattern) {
        // If the first character is ! it should be omitted
        var exclusion = pattern.indexOf('!') === 0;
        // If the pattern is an exclusion, remove the !
        if (exclusion) { pattern = pattern.slice(1); }
        // Find all matching files for this pattern.
        var matches = fn(pattern);
        if (exclusion) {
          // If an exclusion, remove matching files.
          result = _.difference(result, matches);
        } else {
          // Otherwise add matching files.
          result = _.union(result, matches);
        }
      });
      return result;
    };
    
    // True if the file path exists.
    file.exists = function() {
      var filepath = path.join.apply(path, arguments);
      return fs.existsSync(filepath);
    };
    
    // Return an array of all file paths that match the given wildcard patterns.
    file.expand = function() {
      var args = _.toArray(arguments);
      // If the first argument is an options object, save those options to pass
      // into the File.prototype.glob.sync method.
      var options = _.isPlainObject(args[0]) ? args.shift() : {};
      // Use the first argument if it's an Array, otherwise convert the arguments
      // object to an array and use that.
      var patterns = Array.isArray(args[0]) ? args[0] : args;
      // Return empty set if there are no patterns or filepaths.
      if (patterns.length === 0) { return []; }
      // Return all matching filepaths.
      var matches = processPatterns(patterns, function(pattern) {
        // Find all matching files for this pattern.
        return glob.sync(pattern, options);
      });
      // Filter result set?
      if (options.filter) {
        matches = matches.filter(function(filepath) {
          filepath = path.join(options.cwd || '', filepath);
          try {
            if (typeof options.filter === 'function') {
              return options.filter(filepath);
            } else {
              // If the file is of the right type and exists, this should work.
              return fs.statSync(filepath)[options.filter]();
            }
          } catch(e) {
            // Otherwise, it's probably not the right type.
            return false;
          }
        });
      }
      return matches;
    };
    
    // Build a multi task "files" object dynamically.
    file.expandMapping = function(patterns, destBase, options) {
      options = _.defaults({}, options, {
        rename: function(destBase, destPath) {
          return path.join(destBase || '', destPath);
        }
      });
      var files = [];
      var fileByDest = {};
      // Find all files matching pattern, using passed-in options.
      file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        // Flatten?
        if (options.flatten) {
          destPath = path.basename(destPath);
        }
        // Change the extension?
        if (options.ext) {
          destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        // Generate destination filename.
        var dest = options.rename(destBase, destPath, options);
        // Prepend cwd to src path if necessary.
        if (options.cwd) { src = path.join(options.cwd, src); }
        // Normalize filepaths to be unix-style.
        dest = dest.replace(pathSeparatorRe, '/');
        src = src.replace(pathSeparatorRe, '/');
        // Map correct src path to dest path.
        if (fileByDest[dest]) {
          // If dest already exists, push this src onto that dest's src array.
          fileByDest[dest].src.push(src);
        } else {
          // Otherwise create a new src-dest file mapping object.
          files.push({
            src: [src],
            dest: dest,
          });
          // And store a reference for later use.
          fileByDest[dest] = files[files.length - 1];
        }
      });
      return files;
    };
    
    // reusing bits of grunt's multi-task source normalization
    file.normalizeFilesArray = function(data) {
      var files = [];
    
      data.forEach(function(obj) {
        var prop;
        if ('src' in obj || 'dest' in obj) {
          files.push(obj);
        }
      });
    
      if (files.length === 0) {
        return [];
      }
    
      files = _(files).chain().forEach(function(obj) {
        if (!('src' in obj) || !obj.src) { return; }
        // Normalize .src properties to flattened array.
        if (Array.isArray(obj.src)) {
          obj.src = _.flatten(obj.src);
        } else {
          obj.src = [obj.src];
        }
      }).map(function(obj) {
        // Build options object, removing unwanted properties.
        var expandOptions = _.extend({}, obj);
        delete expandOptions.src;
        delete expandOptions.dest;
    
        // Expand file mappings.
        if (obj.expand) {
          return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
            // Copy obj properties to result.
            var result = _.extend({}, obj);
            // Make a clone of the orig obj available.
            result.orig = _.extend({}, obj);
            // Set .src and .dest, processing both as templates.
            result.src = mapObj.src;
            result.dest = mapObj.dest;
            // Remove unwanted properties.
            ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {
              delete result[prop];
            });
            return result;
          });
        }
    
        // Copy obj properties to result, adding an .orig property.
        var result = _.extend({}, obj);
        // Make a clone of the orig obj available.
        result.orig = _.extend({}, obj);
    
        if ('src' in result) {
          // Expose an expand-on-demand getter method as .src.
          Object.defineProperty(result, 'src', {
            enumerable: true,
            get: function fn() {
              var src;
              if (!('result' in fn)) {
                src = obj.src;
                // If src is an array, flatten it. Otherwise, make it into an array.
                src = Array.isArray(src) ? _.flatten(src) : [src];
                // Expand src files, memoizing result.
                fn.result = file.expand(expandOptions, src);
              }
              return fn.result;
            }
          });
        }
    
        if ('dest' in result) {
          result.dest = obj.dest;
        }
    
        return result;
      }).flatten().value();
    
      return files;
    };
  provide("archiver-utils/file.js", module.exports);
}(global));

// pakmanager:archiver-utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * archiver-utils
     *
     * Copyright (c) 2015 Chris Talkington.
     * Licensed under the MIT license.
     * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE
     */
    var fs = require('fs');
    var path = require('path');
    var nutil = require('util');
    var lazystream = require('lazystream');
    var normalizePath = require('normalize-path');
    var _ = require('lodash');
    
    var Stream = require('stream').Stream;
    var PassThrough = require('readable-stream').PassThrough;
    
    var utils = module.exports = {};
    utils.file =  require('archiver-utils/file.js');
    
    function assertPath(path) {
      if (typeof path !== 'string') {
        throw new TypeError('Path must be a string. Received ' + nutils.inspect(path));
      }
    }
    
    utils.collectStream = function(source, callback) {
      var collection = [];
      var size = 0;
    
      source.on('error', callback);
    
      source.on('data', function(chunk) {
        collection.push(chunk);
        size += chunk.length;
      });
    
      source.on('end', function() {
        var buf = new Buffer(size, 'utf8');
        var offset = 0;
    
        collection.forEach(function(data) {
          data.copy(buf, offset);
          offset += data.length;
        });
    
        callback(null, buf);
      });
    };
    
    utils.dateify = function(dateish) {
      dateish = dateish || new Date();
    
      if (dateish instanceof Date) {
        dateish = dateish;
      } else if (typeof dateish === 'string') {
        dateish = new Date(dateish);
      } else {
        dateish = new Date();
      }
    
      return dateish;
    };
    
    // this is slightly different from lodash version
    utils.defaults = function(object, source, guard) {
      var args = arguments;
      args[0] = args[0] || {};
    
      return _.defaults.apply(_, args);
    };
    
    utils.isStream = function(source) {
      return source instanceof Stream;
    };
    
    utils.lazyReadStream = function(filepath) {
      return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
      });
    };
    
    utils.normalizeInputSource = function(source) {
      if (source === null) {
        return new Buffer(0);
      } else if (typeof source === 'string') {
        return new Buffer(source);
      } else if (utils.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
    
        return normalized;
      }
    
      return source;
    };
    
    utils.sanitizePath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, '').replace(/^(\.\.\/|\/)+/, '');
    };
    
    utils.trailingSlashIt = function(str) {
      return str.slice(-1) !== '/' ? str + '/' : str;
    };
    
    utils.unixifyPath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, '');
    };
    
    utils.walkdir = function(dirpath, base, callback) {
      var results = [];
    
      if (typeof base === 'function') {
        callback = base;
        base = dirpath;
      }
    
      fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
    
        if (err) {
          return callback(err);
        }
    
        (function next() {
          file = list[i++];
    
          if (!file) {
            return callback(null, results);
          }
    
          filepath = path.join(dirpath, file);
    
          fs.stat(filepath, function(err, stats) {
            results.push({
              path: filepath,
              relative: path.relative(base, filepath).replace(/\\/g, '/'),
              stats: stats
            });
    
            if (stats && stats.isDirectory()) {
              utils.walkdir(filepath, base, function(err, res) {
                results = results.concat(res);
                next();
              });
            } else {
              next();
            }
          });
        })();
      });
    };
  provide("archiver-utils", module.exports);
}(global));

// pakmanager:code-point-at
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var numberIsNan = require('number-is-nan');
    
    module.exports = function (str, pos) {
    	if (str === null || str === undefined) {
    		throw TypeError();
    	}
    
    	str = String(str);
    
    	var size = str.length;
    	var i = pos ? Number(pos) : 0;
    
    	if (numberIsNan(i)) {
    		i = 0;
    	}
    
    	if (i < 0 || i >= size) {
    		return undefined;
    	}
    
    	var first = str.charCodeAt(i);
    
    	if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) {
    		var second = str.charCodeAt(i + 1);
    
    		if (second >= 0xDC00 && second <= 0xDFFF) {
    			return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    		}
    	}
    
    	return first;
    };
    
  provide("code-point-at", module.exports);
}(global));

// pakmanager:is-fullwidth-code-point
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var numberIsNan = require('number-is-nan');
    
    module.exports = function (x) {
    	if (numberIsNan(x)) {
    		return false;
    	}
    
    	// https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1369
    
    	// code points are derived from:
    	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    	if (x >= 0x1100 && (
    		x <= 0x115f ||  // Hangul Jamo
    		0x2329 === x || // LEFT-POINTING ANGLE BRACKET
    		0x232a === x || // RIGHT-POINTING ANGLE BRACKET
    		// CJK Radicals Supplement .. Enclosed CJK Letters and Months
    		(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
    		// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    		0x3250 <= x && x <= 0x4dbf ||
    		// CJK Unified Ideographs .. Yi Radicals
    		0x4e00 <= x && x <= 0xa4c6 ||
    		// Hangul Jamo Extended-A
    		0xa960 <= x && x <= 0xa97c ||
    		// Hangul Syllables
    		0xac00 <= x && x <= 0xd7a3 ||
    		// CJK Compatibility Ideographs
    		0xf900 <= x && x <= 0xfaff ||
    		// Vertical Forms
    		0xfe10 <= x && x <= 0xfe19 ||
    		// CJK Compatibility Forms .. Small Form Variants
    		0xfe30 <= x && x <= 0xfe6b ||
    		// Halfwidth and Fullwidth Forms
    		0xff01 <= x && x <= 0xff60 ||
    		0xffe0 <= x && x <= 0xffe6 ||
    		// Kana Supplement
    		0x1b000 <= x && x <= 0x1b001 ||
    		// Enclosed Ideographic Supplement
    		0x1f200 <= x && x <= 0x1f251 ||
    		// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    		0x20000 <= x && x <= 0x3fffd)) {
    		return true;
    	}
    
    	return false;
    }
    
  provide("is-fullwidth-code-point", module.exports);
}(global));

// pakmanager:pinkie-promise
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = global.Promise || require('pinkie');
    
  provide("pinkie-promise", module.exports);
}(global));

// pakmanager:parse-json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var errorEx = require('error-ex');
    var fallback = require('./vendor/parse');
    
    var JSONError = errorEx('JSONError', {
    	fileName: errorEx.append('in %s')
    });
    
    module.exports = function (x, reviver, filename) {
    	if (typeof reviver === 'string') {
    		filename = reviver;
    		reviver = null;
    	}
    
    	try {
    		try {
    			return JSON.parse(x, reviver);
    		} catch (err) {
    			fallback.parse(x, {
    				mode: 'json',
    				reviver: reviver
    			});
    
    			throw err;
    		}
    	} catch (err) {
    		var jsonErr = new JSONError(err);
    
    		if (filename) {
    			jsonErr.fileName = filename;
    		}
    
    		throw jsonErr;
    	}
    };
    
  provide("parse-json", module.exports);
}(global));

// pakmanager:pify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var processFn = function (fn, P, opts) {
    	return function () {
    		var that = this;
    		var args = new Array(arguments.length);
    
    		for (var i = 0; i < arguments.length; i++) {
    			args[i] = arguments[i];
    		}
    
    		return new P(function (resolve, reject) {
    			args.push(function (err, result) {
    				if (err) {
    					reject(err);
    				} else if (opts.multiArgs) {
    					var results = new Array(arguments.length - 1);
    
    					for (var i = 1; i < arguments.length; i++) {
    						results[i - 1] = arguments[i];
    					}
    
    					resolve(results);
    				} else {
    					resolve(result);
    				}
    			});
    
    			fn.apply(that, args);
    		});
    	};
    };
    
    var pify = module.exports = function (obj, P, opts) {
    	if (typeof P !== 'function') {
    		opts = P;
    		P = Promise;
    	}
    
    	opts = opts || {};
    	opts.exclude = opts.exclude || [/.+Sync$/];
    
    	var filter = function (key) {
    		var match = function (pattern) {
    			return typeof pattern === 'string' ? key === pattern : pattern.test(key);
    		};
    
    		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
    	};
    
    	var ret = typeof obj === 'function' ? function () {
    		if (opts.excludeMain) {
    			return obj.apply(this, arguments);
    		}
    
    		return processFn(obj, P, opts).apply(this, arguments);
    	} : {};
    
    	return Object.keys(obj).reduce(function (ret, key) {
    		var x = obj[key];
    
    		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;
    
    		return ret;
    	}, ret);
    };
    
    pify.all = pify;
    
  provide("pify", module.exports);
}(global));

// pakmanager:strip-bom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var isUtf8 = require('is-utf8');
    
    module.exports = function (x) {
    	// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
    	// conversion translates it to FEFF (UTF-16 BOM)
    	if (typeof x === 'string' && x.charCodeAt(0) === 0xFEFF) {
    		return x.slice(1);
    	}
    
    	if (Buffer.isBuffer(x) && isUtf8(x) &&
    		x[0] === 0xEF && x[1] === 0xBB && x[2] === 0xBF) {
    		return x.slice(3);
    	}
    
    	return x;
    };
    
  provide("strip-bom", module.exports);
}(global));

// pakmanager:hosted-git-info/git-host-info.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    var gitHosts = module.exports = {
      github: {
        // First two are insecure and generally shouldn't be used any more, but
        // they are still supported.
        'protocols': [ 'git', 'http', 'git+ssh', 'git+https', 'ssh', 'https' ],
        'domain': 'github.com',
        'treepath': 'tree',
        'filetemplate': 'https://{auth@}raw.githubusercontent.com/{user}/{project}/{committish}/{path}',
        'bugstemplate': 'https://{domain}/{user}/{project}/issues',
        'gittemplate': 'git://{auth@}{domain}/{user}/{project}.git{#committish}'
      },
      bitbucket: {
        'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],
        'domain': 'bitbucket.org',
        'treepath': 'src'
      },
      gitlab: {
        'protocols': [ 'git+ssh', 'git+https', 'ssh', 'https' ],
        'domain': 'gitlab.com',
        'treepath': 'tree',
        'docstemplate': 'https://{domain}/{user}/{project}{/tree/committish}#README',
        'bugstemplate': 'https://{domain}/{user}/{project}/issues'
      },
      gist: {
        'protocols': [ 'git', 'git+ssh', 'git+https', 'ssh', 'https' ],
        'domain': 'gist.github.com',
        'pathmatch': /^[/](?:([^/]+)[/])?([a-z0-9]+)(?:[.]git)?$/,
        'filetemplate': 'https://gist.githubusercontent.com/{user}/{project}/raw{/committish}/{path}',
        'bugstemplate': 'https://{domain}/{project}',
        'gittemplate': 'git://{domain}/{project}.git{#committish}',
        'sshtemplate': 'git@{domain}:/{project}.git{#committish}',
        'sshurltemplate': 'git+ssh://git@{domain}/{project}.git{#committish}',
        'browsetemplate': 'https://{domain}/{project}{/committish}',
        'docstemplate': 'https://{domain}/{project}{/committish}',
        'httpstemplate': 'git+https://{domain}/{project}.git{#committish}',
        'shortcuttemplate': '{type}:{project}{#committish}',
        'pathtemplate': '{project}{#committish}'
      }
    }
    
    var gitHostDefaults = {
      'sshtemplate': 'git@{domain}:{user}/{project}.git{#committish}',
      'sshurltemplate': 'git+ssh://git@{domain}/{user}/{project}.git{#committish}',
      'browsetemplate': 'https://{domain}/{user}/{project}{/tree/committish}',
      'docstemplate': 'https://{domain}/{user}/{project}{/tree/committish}#readme',
      'httpstemplate': 'git+https://{auth@}{domain}/{user}/{project}.git{#committish}',
      'filetemplate': 'https://{domain}/{user}/{project}/raw/{committish}/{path}',
      'shortcuttemplate': '{type}:{user}/{project}{#committish}',
      'pathtemplate': '{user}/{project}{#committish}',
      'pathmatch': /^[/]([^/]+)[/]([^/]+?)(?:[.]git)?$/
    }
    
    Object.keys(gitHosts).forEach(function (name) {
      Object.keys(gitHostDefaults).forEach(function (key) {
        if (gitHosts[name][key]) return
        gitHosts[name][key] = gitHostDefaults[key]
      })
      gitHosts[name].protocols_re = RegExp('^(' +
        gitHosts[name].protocols.map(function (protocol) {
          return protocol.replace(/([\\+*{}()\[\]$^|])/g, '\\$1')
        }).join('|') + '):$')
    })
    
  provide("hosted-git-info/git-host-info.js", module.exports);
}(global));

// pakmanager:hosted-git-info/git-host.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var gitHosts =  require('hosted-git-info/git-host-info.js')
    
    var GitHost = module.exports = function (type, user, auth, project, committish, defaultRepresentation) {
      var gitHostInfo = this
      gitHostInfo.type = type
      Object.keys(gitHosts[type]).forEach(function (key) {
        gitHostInfo[key] = gitHosts[type][key]
      })
      gitHostInfo.user = user
      gitHostInfo.auth = auth
      gitHostInfo.project = project
      gitHostInfo.committish = committish
      gitHostInfo.default = defaultRepresentation
    }
    GitHost.prototype = {}
    
    GitHost.prototype.hash = function () {
      return this.committish ? '#' + this.committish : ''
    }
    
    GitHost.prototype._fill = function (template, vars) {
      if (!template) return
      if (!vars) vars = {}
      var self = this
      Object.keys(this).forEach(function (key) {
        if (self[key] != null && vars[key] == null) vars[key] = self[key]
      })
      var rawAuth = vars.auth
      var rawComittish = vars.committish
      Object.keys(vars).forEach(function (key) {
        vars[key] = encodeURIComponent(vars[key])
      })
      vars['auth@'] = rawAuth ? rawAuth + '@' : ''
      vars['#committish'] = rawComittish ? '#' + rawComittish : ''
      vars['/tree/committish'] = vars.committish
                              ? '/' + vars.treepath + '/' + vars.committish
                              : ''
      vars['/committish'] = vars.committish ? '/' + vars.committish : ''
      vars.committish = vars.committish || 'master'
      var res = template
      Object.keys(vars).forEach(function (key) {
        res = res.replace(new RegExp('[{]' + key + '[}]', 'g'), vars[key])
      })
      return res
    }
    
    GitHost.prototype.ssh = function () {
      return this._fill(this.sshtemplate)
    }
    
    GitHost.prototype.sshurl = function () {
      return this._fill(this.sshurltemplate)
    }
    
    GitHost.prototype.browse = function () {
      return this._fill(this.browsetemplate)
    }
    
    GitHost.prototype.docs = function () {
      return this._fill(this.docstemplate)
    }
    
    GitHost.prototype.bugs = function () {
      return this._fill(this.bugstemplate)
    }
    
    GitHost.prototype.https = function () {
      return this._fill(this.httpstemplate)
    }
    
    GitHost.prototype.git = function () {
      return this._fill(this.gittemplate)
    }
    
    GitHost.prototype.shortcut = function () {
      return this._fill(this.shortcuttemplate)
    }
    
    GitHost.prototype.path = function () {
      return this._fill(this.pathtemplate)
    }
    
    GitHost.prototype.file = function (P) {
      return this._fill(this.filetemplate, {
        path: P.replace(/^[/]+/g, '')
      })
    }
    
    GitHost.prototype.getDefaultRepresentation = function () {
      return this.default
    }
    
    GitHost.prototype.toString = function () {
      return (this[this.default] || this.sshurl).call(this)
    }
    
  provide("hosted-git-info/git-host.js", module.exports);
}(global));

// pakmanager:hosted-git-info
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    var url = require('url')
    var gitHosts =  require('hosted-git-info/git-host-info.js')
    var GitHost = module.exports =  require('hosted-git-info/git-host.js')
    
    var protocolToRepresentationMap = {
      'git+ssh': 'sshurl',
      'git+https': 'https',
      'ssh': 'sshurl',
      'git': 'git'
    }
    
    function protocolToRepresentation (protocol) {
      if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1)
      return protocolToRepresentationMap[protocol] || protocol
    }
    
    var authProtocols = {
      'git:': true,
      'https:': true,
      'git+https:': true,
      'http:': true,
      'git+http:': true
    }
    
    module.exports.fromUrl = function (giturl) {
      if (giturl == null || giturl === '') return
      var url = fixupUnqualifiedGist(
        isGitHubShorthand(giturl) ? 'github:' + giturl : giturl
      )
      var parsed = parseGitUrl(url)
      var matches = Object.keys(gitHosts).map(function (gitHostName) {
        var gitHostInfo = gitHosts[gitHostName]
        var auth = null
        if (parsed.auth && authProtocols[parsed.protocol]) {
          auth = decodeURIComponent(parsed.auth)
        }
        var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null
        var user = null
        var project = null
        var defaultRepresentation = null
        if (parsed.protocol === gitHostName + ':') {
          user = decodeURIComponent(parsed.host)
          project = parsed.path && decodeURIComponent(parsed.path.replace(/^[/](.*?)(?:[.]git)?$/, '$1'))
          defaultRepresentation = 'shortcut'
        } else {
          if (parsed.host !== gitHostInfo.domain) return
          if (!gitHostInfo.protocols_re.test(parsed.protocol)) return
          var pathmatch = gitHostInfo.pathmatch
          var matched = parsed.path.match(pathmatch)
          if (!matched) return
          if (matched[1] != null) user = decodeURIComponent(matched[1])
          if (matched[2] != null) project = decodeURIComponent(matched[2])
          defaultRepresentation = protocolToRepresentation(parsed.protocol)
        }
        return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation)
      }).filter(function (gitHostInfo) { return gitHostInfo })
      if (matches.length !== 1) return
      return matches[0]
    }
    
    function isGitHubShorthand (arg) {
      // Note: This does not fully test the git ref format.
      // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html
      //
      // The only way to do this properly would be to shell out to
      // git-check-ref-format, and as this is a fast sync function,
      // we don't want to do that.  Just let git fail if it turns
      // out that the commit-ish is invalid.
      // GH usernames cannot start with . or -
      return /^[^:@%/\s.-][^:@%/\s]*[/][^:@\s/%]+(?:#.*)?$/.test(arg)
    }
    
    function fixupUnqualifiedGist (giturl) {
      // necessary for round-tripping gists
      var parsed = url.parse(giturl)
      if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {
        return parsed.protocol + '/' + parsed.host
      } else {
        return giturl
      }
    }
    
    function parseGitUrl (giturl) {
      if (typeof giturl !== 'string') giturl = '' + giturl
      var matched = giturl.match(/^([^@]+)@([^:]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)
      if (!matched) return url.parse(giturl)
      return {
        protocol: 'git+ssh:',
        slashes: true,
        auth: matched[1],
        host: matched[2],
        port: null,
        hostname: matched[2],
        hash: matched[4],
        search: null,
        query: null,
        pathname: '/' + matched[3],
        path: '/' + matched[3],
        href: 'git+ssh://' + matched[1] + '@' + matched[2] +
              '/' + matched[3] + (matched[4] || '')
      }
    }
    
  provide("hosted-git-info", module.exports);
}(global));

// pakmanager:is-builtin-module
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var builtinModules = require('builtin-modules');
    
    module.exports = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return builtinModules.indexOf(str) !== -1;
    };
    
  provide("is-builtin-module", module.exports);
}(global));

// pakmanager:validate-npm-package-license
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parse = require('spdx-expression-parse');
    var correct = require('spdx-correct');
    
    var genericWarning = (
      'license should be ' +
      'a valid SPDX license expression (without "LicenseRef"), ' +
      '"UNLICENSED", or ' +
      '"SEE LICENSE IN <filename>"'
    );
    
    var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
    
    function startsWith(prefix, string) {
      return string.slice(0, prefix.length) === prefix;
    }
    
    function usesLicenseRef(ast) {
      if (ast.hasOwnProperty('license')) {
        var license = ast.license;
        return (
          startsWith('LicenseRef', license) ||
          startsWith('DocumentRef', license)
        );
      } else {
        return (
          usesLicenseRef(ast.left) ||
          usesLicenseRef(ast.right)
        );
      }
    }
    
    module.exports = function(argument) {
      var ast;
    
      try {
        ast = parse(argument);
      } catch (e) {
        var match
        if (
          argument === 'UNLICENSED' ||
          argument === 'UNLICENCED'
        ) {
          return {
            validForOldPackages: true,
            validForNewPackages: true,
            unlicensed: true
          };
        } else if (match = fileReferenceRE.exec(argument)) {
          return {
            validForOldPackages: true,
            validForNewPackages: true,
            inFile: match[1]
          };
        } else {
          var result = {
            validForOldPackages: false,
            validForNewPackages: false,
            warnings: [genericWarning]
          };
          var corrected = correct(argument);
          if (corrected) {
            result.warnings.push(
              'license is similar to the valid expression "' + corrected + '"'
            );
          }
          return result;
        }
      }
    
      if (usesLicenseRef(ast)) {
        return {
          validForNewPackages: false,
          validForOldPackages: false,
          spdx: true,
          warnings: [genericWarning]
        };
      } else {
        return {
          validForNewPackages: true,
          validForOldPackages: true,
          spdx: true
        };
      }
    };
    
  provide("validate-npm-package-license", module.exports);
}(global));

// pakmanager:js-tokens
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright 2014, 2015 Simon Lydell
    // X11 (“MIT”) Licensed. (See LICENSE.)
    
    // This regex comes from regex.coffee, and is inserted here by generate-index.js
    // (run `npm run build`).
    module.exports = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|((?:0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?))|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-*\/%&|^]|<{1,2}|>{1,3}|!=?|={1,2})=?|[?:~]|[;,.[\](){}])|(\s+)|(^$|[\s\S])/g
    
    module.exports.matchToToken = function(match) {
      var token = {type: "invalid", value: match[0]}
           if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
      else if (match[ 5]) token.type = "comment"
      else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
      else if (match[ 8]) token.type = "regex"
      else if (match[ 9]) token.type = "number"
      else if (match[10]) token.type = "name"
      else if (match[11]) token.type = "punctuator"
      else if (match[12]) token.type = "whitespace"
      return token
    }
    
  provide("js-tokens", module.exports);
}(global));

// pakmanager:statuses
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var codes = require('./codes.json');
    
    module.exports = status;
    
    // [Integer...]
    status.codes = Object.keys(codes).map(function (code) {
      code = ~~code;
      var msg = codes[code];
      status[code] = msg;
      status[msg] = status[msg.toLowerCase()] = code;
      return code;
    });
    
    // status codes for redirects
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true,
    };
    
    // status codes for empty bodies
    status.empty = {
      204: true,
      205: true,
      304: true,
    };
    
    // status codes for when you should retry the request
    status.retry = {
      502: true,
      503: true,
      504: true,
    };
    
    function status(code) {
      if (typeof code === 'number') {
        if (!status[code]) throw new Error('invalid status code: ' + code);
        return code;
      }
    
      if (typeof code !== 'string') {
        throw new TypeError('code must be a number or string');
      }
    
      // '403'
      var n = parseInt(code, 10)
      if (!isNaN(n)) {
        if (!status[n]) throw new Error('invalid status code: ' + n);
        return n;
      }
    
      n = status[code.toLowerCase()];
      if (!n) throw new Error('invalid status message: "' + code + '"');
      return n;
    }
    
  provide("statuses", module.exports);
}(global));

// pakmanager:querystringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var has = Object.prototype.hasOwnProperty;
    
    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?&]+)=([^&]*)/g
        , result = {}
        , part;
    
      //
      // Little nifty parsing hack, leverage the fact that RegExp.exec increments
      // the lastIndex property so we can continue executing this loop until we've
      // parsed all results.
      //
      for (;
        part = parser.exec(query);
        result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
      );
    
      return result;
    }
    
    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';
    
      var pairs = [];
    
      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';
    
      for (var key in obj) {
        if (has.call(obj, key)) {
          pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
        }
      }
    
      return pairs.length ? prefix + pairs.join('&') : '';
    }
    
    //
    // Expose the module.
    //
    exports.stringify = querystringify;
    exports.parse = querystring;
    
  provide("querystringify", module.exports);
}(global));

// pakmanager:requires-port
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    module.exports = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;
    
      if (!port) return false;
    
      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;
    
        case 'https':
        case 'wss':
        return port !== 443;
    
        case 'ftp':
        return port !== 21;
    
        case 'gopher':
        return port !== 70;
    
        case 'file':
        return false;
      }
    
      return port !== 0;
    };
    
  provide("requires-port", module.exports);
}(global));

// pakmanager:jsonparse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global Buffer*/
    // Named constants with unique integer values
    var C = {};
    // Tokens
    var LEFT_BRACE    = C.LEFT_BRACE    = 0x1;
    var RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;
    var LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;
    var RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;
    var COLON         = C.COLON         = 0x5;
    var COMMA         = C.COMMA         = 0x6;
    var TRUE          = C.TRUE          = 0x7;
    var FALSE         = C.FALSE         = 0x8;
    var NULL          = C.NULL          = 0x9;
    var STRING        = C.STRING        = 0xa;
    var NUMBER        = C.NUMBER        = 0xb;
    // Tokenizer States
    var START   = C.START   = 0x11;
    var STOP    = C.STOP    = 0x12;
    var TRUE1   = C.TRUE1   = 0x21;
    var TRUE2   = C.TRUE2   = 0x22;
    var TRUE3   = C.TRUE3   = 0x23;
    var FALSE1  = C.FALSE1  = 0x31;
    var FALSE2  = C.FALSE2  = 0x32;
    var FALSE3  = C.FALSE3  = 0x33;
    var FALSE4  = C.FALSE4  = 0x34;
    var NULL1   = C.NULL1   = 0x41;
    var NULL2   = C.NULL2   = 0x42;
    var NULL3   = C.NULL3   = 0x43;
    var NUMBER1 = C.NUMBER1 = 0x51;
    var NUMBER3 = C.NUMBER3 = 0x53;
    var STRING1 = C.STRING1 = 0x61;
    var STRING2 = C.STRING2 = 0x62;
    var STRING3 = C.STRING3 = 0x63;
    var STRING4 = C.STRING4 = 0x64;
    var STRING5 = C.STRING5 = 0x65;
    var STRING6 = C.STRING6 = 0x66;
    // Parser States
    var VALUE   = C.VALUE   = 0x71;
    var KEY     = C.KEY     = 0x72;
    // Parser Modes
    var OBJECT  = C.OBJECT  = 0x81;
    var ARRAY   = C.ARRAY   = 0x82;
    
    
    function Parser() {
      this.tState = START;
      this.value = undefined;
    
      this.string = undefined; // string data
      this.unicode = undefined; // unicode escapes
    
      this.key = undefined;
      this.mode = undefined;
      this.stack = [];
      this.state = VALUE;
      this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
      this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
      this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary is reached
    
      // Stream offset
      this.offset = -1;
    }
    
    // Slow code to string converter (only used when throwing syntax errors)
    Parser.toknam = function (code) {
      var keys = Object.keys(C);
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (C[key] === code) { return key; }
      }
      return code && ("0x" + code.toString(16));
    };
    
    var proto = Parser.prototype;
    proto.onError = function (err) { throw err; };
    proto.charError = function (buffer, i) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + Parser.toknam(this.tState)));
    };
    proto.write = function (buffer) {
      if (typeof buffer === "string") buffer = new Buffer(buffer);
      var n;
      for (var i = 0, l = buffer.length; i < l; i++) {
        if (this.tState === START){
          n = buffer[i];
          this.offset++;
          if(n === 0x7b){ this.onToken(LEFT_BRACE, "{"); // {
          }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, "}"); // }
          }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, "["); // [
          }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, "]"); // ]
          }else if(n === 0x3a){ this.onToken(COLON, ":");  // :
          }else if(n === 0x2c){ this.onToken(COMMA, ","); // ,
          }else if(n === 0x74){ this.tState = TRUE1;  // t
          }else if(n === 0x66){ this.tState = FALSE1;  // f
          }else if(n === 0x6e){ this.tState = NULL1; // n
          }else if(n === 0x22){ this.string = ""; this.tState = STRING1; // "
          }else if(n === 0x2d){ this.string = "-"; this.tState = NUMBER1; // -
          }else{
            if (n >= 0x30 && n < 0x40) { // 1-9
              this.string = String.fromCharCode(n); this.tState = NUMBER3;
            } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {
              // whitespace
            } else {
              return this.charError(buffer, i);
            }
          }
        }else if (this.tState === STRING1){ // After open quote
          n = buffer[i]; // get current byte from buffer
          // check for carry over of a multi byte char split between data chunks
          // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
          if (this.bytes_remaining > 0) {
            for (var j = 0; j < this.bytes_remaining; j++) {
              this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
            }
            this.string += this.temp_buffs[this.bytes_in_sequence].toString();
            this.bytes_in_sequence = this.bytes_remaining = 0;
            i = i + j - 1;
          } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time
            if (n <= 193 || n > 244) {
              return this.onError(new Error("Invalid UTF-8 character at position " + i + " in state " + Parser.toknam(this.tState)));
            }
            if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;
            if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;
            if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;
            if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split
              for (var k = 0; k <= (buffer.length - 1 - i); k++) {
                this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk
              }
              this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;
              i = buffer.length - 1;
            } else {
              this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();
              i = i + this.bytes_in_sequence - 1;
            }
          } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.offset += Buffer.byteLength(this.string, 'utf8') + 1; this.string = undefined; }
          else if (n === 0x5c) { this.tState = STRING2; }
          else if (n >= 0x20) { this.string += String.fromCharCode(n); }
          else {
              return this.charError(buffer, i);
          }
        }else if (this.tState === STRING2){ // After backslash
          n = buffer[i];
          if(n === 0x22){ this.string += "\""; this.tState = STRING1;
          }else if(n === 0x5c){ this.string += "\\"; this.tState = STRING1; 
          }else if(n === 0x2f){ this.string += "\/"; this.tState = STRING1; 
          }else if(n === 0x62){ this.string += "\b"; this.tState = STRING1; 
          }else if(n === 0x66){ this.string += "\f"; this.tState = STRING1; 
          }else if(n === 0x6e){ this.string += "\n"; this.tState = STRING1; 
          }else if(n === 0x72){ this.string += "\r"; this.tState = STRING1; 
          }else if(n === 0x74){ this.string += "\t"; this.tState = STRING1; 
          }else if(n === 0x75){ this.unicode = ""; this.tState = STRING3;
          }else{ 
            return this.charError(buffer, i); 
          }
        }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes
          n = buffer[i];
          // 0-9 A-F a-f
          if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {
            this.unicode += String.fromCharCode(n);
            if (this.tState++ === STRING6) {
              this.string += String.fromCharCode(parseInt(this.unicode, 16));
              this.unicode = undefined;
              this.tState = STRING1; 
            }
          } else {
            return this.charError(buffer, i);
          }
        } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
    
            switch (n) {
              case 0x30: // 0
              case 0x31: // 1
              case 0x32: // 2
              case 0x33: // 3
              case 0x34: // 4
              case 0x35: // 5
              case 0x36: // 6
              case 0x37: // 7
              case 0x38: // 8
              case 0x39: // 9
              case 0x2e: // .
              case 0x65: // e
              case 0x45: // E
              case 0x2b: // +
              case 0x2d: // -
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
    
                if (isNaN(result)){
                  return this.charError(buffer, i);
                }
    
                if ((this.string.match(/[0-9]+/) == this.string) && (result.toString() != this.string)) {
                  // Long string of digits which is an ID string and not valid and/or safe JavaScript integer Number
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
    
                this.offset += this.string.length - 1;
                this.string = undefined;
                i--;
                break;
            }
        }else if (this.tState === TRUE1){ // r
          if (buffer[i] === 0x72) { this.tState = TRUE2; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === TRUE2){ // u
          if (buffer[i] === 0x75) { this.tState = TRUE3; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === TRUE3){ // e
          if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); this.offset+= 3; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === FALSE1){ // a
          if (buffer[i] === 0x61) { this.tState = FALSE2; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === FALSE2){ // l
          if (buffer[i] === 0x6c) { this.tState = FALSE3; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === FALSE3){ // s
          if (buffer[i] === 0x73) { this.tState = FALSE4; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === FALSE4){ // e
          if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); this.offset+= 4; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === NULL1){ // u
          if (buffer[i] === 0x75) { this.tState = NULL2; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === NULL2){ // l
          if (buffer[i] === 0x6c) { this.tState = NULL3; }
          else { return this.charError(buffer, i); }
        }else if (this.tState === NULL3){ // l
          if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); this.offset += 3; }
          else { return this.charError(buffer, i); }
        }
      }
    };
    proto.onToken = function (token, value) {
      // Override this to get events
    };
    
    proto.parseError = function (token, value) {
      this.tState = STOP;
      this.onError(new Error("Unexpected " + Parser.toknam(token) + (value ? ("(" + JSON.stringify(value) + ")") : "") + " in state " + Parser.toknam(this.state)));
    };
    proto.push = function () {
      this.stack.push({value: this.value, key: this.key, mode: this.mode});
    };
    proto.pop = function () {
      var value = this.value;
      var parent = this.stack.pop();
      this.value = parent.value;
      this.key = parent.key;
      this.mode = parent.mode;
      this.emit(value);
      if (!this.mode) { this.state = VALUE; }
    };
    proto.emit = function (value) {
      if (this.mode) { this.state = COMMA; }
      this.onValue(value);
    };
    proto.onValue = function (value) {
      // Override me
    };  
    proto.onToken = function (token, value) {
      if(this.state === VALUE){
        if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){
          if (this.value) {
            this.value[this.key] = value;
          }
          this.emit(value);  
        }else if(token === LEFT_BRACE){
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = {};
          } else {
            this.value = {};
          }
          this.key = undefined;
          this.state = KEY;
          this.mode = OBJECT;
        }else if(token === LEFT_BRACKET){
          this.push();
          if (this.value) {
            this.value = this.value[this.key] = [];
          } else {
            this.value = [];
          }
          this.key = 0;
          this.mode = ARRAY;
          this.state = VALUE;
        }else if(token === RIGHT_BRACE){
          if (this.mode === OBJECT) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        }else if(token === RIGHT_BRACKET){
          if (this.mode === ARRAY) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        }else{
          return this.parseError(token, value);
        }
      }else if(this.state === KEY){
        if (token === STRING) {
          this.key = value;
          this.state = COLON;
        } else if (token === RIGHT_BRACE) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      }else if(this.state === COLON){
        if (token === COLON) { this.state = VALUE; }
        else { return this.parseError(token, value); }
      }else if(this.state === COMMA){
        if (token === COMMA) { 
          if (this.mode === ARRAY) { this.key++; this.state = VALUE; }
          else if (this.mode === OBJECT) { this.state = KEY; }
    
        } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
          this.pop();
        } else {
          return this.parseError(token, value);
        }
      }else{
        return this.parseError(token, value);
      }
    };
    
    Parser.C = C;
    
    module.exports = Parser;
    
  provide("jsonparse", module.exports);
}(global));

// pakmanager:through
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream')
    
    // through
    //
    // a stream that does nothing but re-emit the input.
    // useful for aggregating a series of changing but not ending streams into one stream)
    
    exports = module.exports = through
    through.through = through
    
    //create a readable writable stream.
    
    function through (write, end, opts) {
      write = write || function (data) { this.queue(data) }
      end = end || function () { this.queue(null) }
    
      var ended = false, destroyed = false, buffer = [], _ended = false
      var stream = new Stream()
      stream.readable = stream.writable = true
      stream.paused = false
    
    //  stream.autoPause   = !(opts && opts.autoPause   === false)
      stream.autoDestroy = !(opts && opts.autoDestroy === false)
    
      stream.write = function (data) {
        write.call(this, data)
        return !stream.paused
      }
    
      function drain() {
        while(buffer.length && !stream.paused) {
          var data = buffer.shift()
          if(null === data)
            return stream.emit('end')
          else
            stream.emit('data', data)
        }
      }
    
      stream.queue = stream.push = function (data) {
    //    console.error(ended)
        if(_ended) return stream
        if(data === null) _ended = true
        buffer.push(data)
        drain()
        return stream
      }
    
      //this will be registered as the first 'end' listener
      //must call destroy next tick, to make sure we're after any
      //stream piped from here.
      //this is only a problem if end is not emitted synchronously.
      //a nicer way to do this is to make sure this is the last listener for 'end'
    
      stream.on('end', function () {
        stream.readable = false
        if(!stream.writable && stream.autoDestroy)
          process.nextTick(function () {
            stream.destroy()
          })
      })
    
      function _end () {
        stream.writable = false
        end.call(stream)
        if(!stream.readable && stream.autoDestroy)
          stream.destroy()
      }
    
      stream.end = function (data) {
        if(ended) return
        ended = true
        if(arguments.length) stream.write(data)
        _end() // will emit or queue
        return stream
      }
    
      stream.destroy = function () {
        if(destroyed) return
        destroyed = true
        ended = true
        buffer.length = 0
        stream.writable = stream.readable = false
        stream.emit('close')
        return stream
      }
    
      stream.pause = function () {
        if(stream.paused) return
        stream.paused = true
        return stream
      }
    
      stream.resume = function () {
        if(stream.paused) {
          stream.paused = false
          stream.emit('resume')
        }
        drain()
        //may have become paused again,
        //as drain emits 'data'.
        if(!stream.paused)
          stream.emit('drain')
        return stream
      }
      return stream
    }
    
    
  provide("through", module.exports);
}(global));

// pakmanager:convert-source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var fs = require('fs');
    var path = require('path');
    
    var commentRx = /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+;)?base64,(.*)$/mg;
    var mapFileCommentRx =
      //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):
      //     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */
      /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg
    
    function decodeBase64(base64) {
      return new Buffer(base64, 'base64').toString();
    }
    
    function stripComment(sm) {
      return sm.split(',').pop();
    }
    
    function readFromFileMap(sm, dir) {
      // NOTE: this will only work on the server since it attempts to read the map file
    
      var r = mapFileCommentRx.exec(sm);
      mapFileCommentRx.lastIndex = 0;
    
      // for some odd reason //# .. captures in 1 and /* .. */ in 2
      var filename = r[1] || r[2];
      var filepath = path.join(dir, filename);
    
      try {
        return fs.readFileSync(filepath, 'utf8');
      } catch (e) {
        throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
      }
    }
    
    function Converter (sm, opts) {
      opts = opts || {};
    
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
    
      this.sourcemap = sm;
    }
    
    function convertFromLargeSource(content){
      var lines = content.split('\n');
      var line;
      // find first line which contains a source map starting at end of content
      for (var i = lines.length - 1; i > 0; i--) {
        line = lines[i]
        if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);
      }
    }
    
    Converter.prototype.toJSON = function (space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    
    Converter.prototype.toBase64 = function () {
      var json = this.toJSON();
      return new Buffer(json).toString('base64');
    };
    
    Converter.prototype.toComment = function (options) {
      var base64 = this.toBase64();
      var data = 'sourceMappingURL=data:application/json;base64,' + base64;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };
    
    // returns copy instead of original
    Converter.prototype.toObject = function () {
      return JSON.parse(this.toJSON());
    };
    
    Converter.prototype.addProperty = function (key, value) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };
    
    Converter.prototype.setProperty = function (key, value) {
      this.sourcemap[key] = value;
      return this;
    };
    
    Converter.prototype.getProperty = function (key) {
      return this.sourcemap[key];
    };
    
    exports.fromObject = function (obj) {
      return new Converter(obj);
    };
    
    exports.fromJSON = function (json) {
      return new Converter(json, { isJSON: true });
    };
    
    exports.fromBase64 = function (base64) {
      return new Converter(base64, { isEncoded: true });
    };
    
    exports.fromComment = function (comment) {
      comment = comment
        .replace(/^\/\*/g, '//')
        .replace(/\*\/$/g, '');
    
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    
    exports.fromMapFileComment = function (comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    
    // Finds last sourcemap comment in file or returns null if none was found
    exports.fromSource = function (content, largeSource) {
      if (largeSource) {
        var res = convertFromLargeSource(content);
        return res ? res : null;
      }
    
      var m = content.match(commentRx);
      commentRx.lastIndex = 0;
      return m ? exports.fromComment(m.pop()) : null;
    };
    
    // Finds last sourcemap comment in file or returns null if none was found
    exports.fromMapFileSource = function (content, dir) {
      var m = content.match(mapFileCommentRx);
      mapFileCommentRx.lastIndex = 0;
      return m ? exports.fromMapFileComment(m.pop(), dir) : null;
    };
    
    exports.removeComments = function (src) {
      commentRx.lastIndex = 0;
      return src.replace(commentRx, '');
    };
    
    exports.removeMapFileComments = function (src) {
      mapFileCommentRx.lastIndex = 0;
      return src.replace(mapFileCommentRx, '');
    };
    
    exports.generateMapFileComment = function (file, options) {
      var data = 'sourceMappingURL=' + file;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };
    
    Object.defineProperty(exports, 'commentRegex', {
      get: function getCommentRegex () {
        commentRx.lastIndex = 0;
        return commentRx;
      }
    });
    
    Object.defineProperty(exports, 'mapFileCommentRegex', {
      get: function getMapFileCommentRegex () {
        mapFileCommentRx.lastIndex = 0;
        return mapFileCommentRx;
      }
    });
    
  provide("convert-source-map", module.exports);
}(global));

// pakmanager:inline-source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var SourceMapGenerator = require('source-map').SourceMapGenerator;
    
    function offsetMapping(mapping, offset) {
      return { line: offset.line + mapping.line, column: offset.column + mapping.column };
    }
    
    function newlinesIn(src) {
      if (!src) return 0;
      var newlines = src.match(/\n/g);
    
      return newlines ? newlines.length : 0;
    }
     
    function Generator(opts) {
      opts = opts || {};
      this.generator = new SourceMapGenerator({ file: opts.file || '', sourceRoot: opts.sourceRoot || '' });
      this.sourcesContent = undefined;
      this.opts = opts;
    }
    
    /**
     * Adds the given mappings to the generator and offsets them if offset is given 
     *
     * @name addMappings
     * @function
     * @param sourceFile {String} name of the source file
     * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }
     * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }
     * @return {Object} the generator to allow chaining
     */
    Generator.prototype.addMappings = function (sourceFile, mappings, offset) { 
      var generator = this.generator; 
    
      offset = offset || {};
      offset.line = offset.hasOwnProperty('line') ? offset.line : 0;
      offset.column = offset.hasOwnProperty('column') ? offset.column : 0;
    
      mappings.forEach(function (m) {
        // only set source if we have original position to handle edgecase (see inline-source-map tests)
        generator.addMapping({
            source    :  m.original ? sourceFile : undefined
          , original  :  m.original
          , generated :  offsetMapping(m.generated, offset)
        });
      });
      return this;
    };
    
    /**
     * Generates mappings for the given source, assuming that no translation from original to generated is necessary.
     *
     * @name addGeneratedMappings
     * @function
     * @param sourceFile {String} name of the source file
     * @param source {String} source of the file
     * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }
     * @return {Object} the generator to allow chaining
     */
    Generator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {
      var mappings = []
        , linesToGenerate = newlinesIn(source) + 1;
    
      for (var line = 1; line <= linesToGenerate; line++) {
        var location = { line: line, column: 0 };
        mappings.push({ original: location, generated: location });
      }
    
      return this.addMappings(sourceFile, mappings, offset);
    };
    
    /**
     * Adds source content for the given source file.
     * 
     * @name addSourceContent
     * @function
     * @param sourceFile {String} The source file for which a mapping is included
     * @param sourcesContent {String} The content of the source file
     * @return {Object} The generator to allow chaining
     */
    Generator.prototype.addSourceContent = function (sourceFile, sourcesContent) {
      this.sourcesContent = this.sourcesContent || {};
      this.sourcesContent[sourceFile] = sourcesContent;
      return this;
    };
    
    /**
     * @name base64Encode
     * @function
     * @return {String} bas64 encoded representation of the added mappings
     */
    Generator.prototype.base64Encode = function () {
      var map = this.toString();
      return new Buffer(map).toString('base64');
    };
    
    /**
     * @name inlineMappingUrl
     * @function
     * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. 
     */
    Generator.prototype.inlineMappingUrl = function () {
      var charset = this.opts.charset || 'utf-8';
      return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();
    };
    
    Generator.prototype.toJSON = function () {
      var map = this.generator.toJSON();
      if (!this.sourcesContent) return map;
    
      var toSourcesContent = (function (s) {
        if (typeof this.sourcesContent[s] === 'string') {
          return this.sourcesContent[s];
        } else {
          return null;
        }
      }).bind(this);
      map.sourcesContent = map.sources.map(toSourcesContent);
      return map;
    };
    
    Generator.prototype.toString = function () {
      return JSON.stringify(this);
    };
    
    Generator.prototype._mappings = function () {
      return this.generator._mappings._array;
    };
    
    Generator.prototype.gen = function () {
      return this.generator;
    };
    
    module.exports = function (opts) { return new Generator(opts); };
    module.exports.Generator = Generator;
    
  provide("inline-source-map", module.exports);
}(global));

// pakmanager:lodash.memoize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var MapCache = require('lodash._mapcache');
    
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // modifying the result cache
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // replacing `_.memoize.Cache`
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;
    
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }
    
    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;
    
    module.exports = memoize;
    
  provide("lodash.memoize", module.exports);
}(global));

// pakmanager:browserify-des
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var CipherBase = require('cipher-base')
    var des = require('des.js')
    var inherits = require('inherits')
    
    var modes = {
      'des-ede3-cbc': des.CBC.instantiate(des.EDE),
      'des-ede3': des.EDE,
      'des-ede-cbc': des.CBC.instantiate(des.EDE),
      'des-ede': des.EDE,
      'des-cbc': des.CBC.instantiate(des.DES),
      'des-ecb': des.DES
    }
    modes.des = modes['des-cbc']
    modes.des3 = modes['des-ede3-cbc']
    module.exports = DES
    inherits(DES, CipherBase)
    function DES (opts) {
      CipherBase.call(this)
      var modeName = opts.mode.toLowerCase()
      var mode = modes[modeName]
      var type
      if (opts.decrypt) {
        type = 'decrypt'
      } else {
        type = 'encrypt'
      }
      var key = opts.key
      if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
        key = Buffer.concat([key, key.slice(0, 8)])
      }
      var iv = opts.iv
      this._des = mode.create({
        key: key,
        iv: iv,
        type: type
      })
    }
    DES.prototype._update = function (data) {
      return new Buffer(this._des.update(data))
    }
    DES.prototype._final = function () {
      return new Buffer(this._des.final())
    }
    
  provide("browserify-des", module.exports);
}(global));

// pakmanager:browserify-rsa
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var bn = require('bn.js');
    var randomBytes = require('randombytes');
    module.exports = crt;
    function blind(priv) {
      var r = getr(priv);
      var blinder = r.toRed(bn.mont(priv.modulus))
      .redPow(new bn(priv.publicExponent)).fromRed();
      return {
        blinder: blinder,
        unblinder:r.invm(priv.modulus)
      };
    }
    function crt(msg, priv) {
      var blinds = blind(priv);
      var len = priv.modulus.byteLength();
      var mod = bn.mont(priv.modulus);
      var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
      var c1 = blinded.toRed(bn.mont(priv.prime1));
      var c2 = blinded.toRed(bn.mont(priv.prime2));
      var qinv = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1);
      var m2 = c2.redPow(priv.exponent2);
      m1 = m1.fromRed();
      m2 = m2.fromRed();
      var h = m1.isub(m2).imul(qinv).umod(p);
      h.imul(q);
      m2.iadd(h);
      return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
    }
    crt.getr = getr;
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r = new bn(randomBytes(len));
      while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
        r = new bn(randomBytes(len));
      }
      return r;
    }
    
  provide("browserify-rsa", module.exports);
}(global));

// pakmanager:parse-asn1/asn1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
    // Fedor, you are amazing.
    
    var asn1 = require('asn1.js')
    
    var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
      this.seq().obj(
        this.key('version').int(),
        this.key('modulus').int(),
        this.key('publicExponent').int(),
        this.key('privateExponent').int(),
        this.key('prime1').int(),
        this.key('prime2').int(),
        this.key('exponent1').int(),
        this.key('exponent2').int(),
        this.key('coefficient').int()
      )
    })
    exports.RSAPrivateKey = RSAPrivateKey
    
    var RSAPublicKey = asn1.define('RSAPublicKey', function () {
      this.seq().obj(
        this.key('modulus').int(),
        this.key('publicExponent').int()
      )
    })
    exports.RSAPublicKey = RSAPublicKey
    
    var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
      this.seq().obj(
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('subjectPublicKey').bitstr()
      )
    })
    exports.PublicKey = PublicKey
    
    var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
      this.seq().obj(
        this.key('algorithm').objid(),
        this.key('none').null_().optional(),
        this.key('curve').objid().optional(),
        this.key('params').seq().obj(
          this.key('p').int(),
          this.key('q').int(),
          this.key('g').int()
        ).optional()
      )
    })
    
    var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
      this.seq().obj(
        this.key('version').int(),
        this.key('algorithm').use(AlgorithmIdentifier),
        this.key('subjectPrivateKey').octstr()
      )
    })
    exports.PrivateKey = PrivateKeyInfo
    var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
      this.seq().obj(
        this.key('algorithm').seq().obj(
          this.key('id').objid(),
          this.key('decrypt').seq().obj(
            this.key('kde').seq().obj(
              this.key('id').objid(),
              this.key('kdeparams').seq().obj(
                this.key('salt').octstr(),
                this.key('iters').int()
              )
            ),
            this.key('cipher').seq().obj(
              this.key('algo').objid(),
              this.key('iv').octstr()
            )
          )
        ),
        this.key('subjectPrivateKey').octstr()
      )
    })
    
    exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo
    
    var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
      this.seq().obj(
        this.key('version').int(),
        this.key('p').int(),
        this.key('q').int(),
        this.key('g').int(),
        this.key('pub_key').int(),
        this.key('priv_key').int()
      )
    })
    exports.DSAPrivateKey = DSAPrivateKey
    
    exports.DSAparam = asn1.define('DSAparam', function () {
      this.int()
    })
    var ECPrivateKey = asn1.define('ECPrivateKey', function () {
      this.seq().obj(
        this.key('version').int(),
        this.key('privateKey').octstr(),
        this.key('parameters').optional().explicit(0).use(ECParameters),
        this.key('publicKey').optional().explicit(1).bitstr()
      )
    })
    exports.ECPrivateKey = ECPrivateKey
    var ECParameters = asn1.define('ECParameters', function () {
      this.choice({
        namedCurve: this.objid()
      })
    })
    
    exports.signature = asn1.define('signature', function () {
      this.seq().obj(
        this.key('r').int(),
        this.key('s').int()
      )
    })
    
  provide("parse-asn1/asn1", module.exports);
}(global));

// pakmanager:parse-asn1/fixProc
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // adapted from https://github.com/apatil/pemstrip
    var findProc = /Proc-Type: 4,ENCRYPTED\r?\nDEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\r?\n\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n/m
    var startRegex = /^-----BEGIN (.*) KEY-----\r?\n/m
    var fullRegex = /^-----BEGIN (.*) KEY-----\r?\n([0-9A-z\n\r\+\/\=]+)\r?\n-----END \1 KEY-----$/m
    var evp = require('evp_bytestokey')
    var ciphers = require('browserify-aes')
    module.exports = function (okey, password) {
      var key = okey.toString()
      var match = key.match(findProc)
      var decrypted
      if (!match) {
        var match2 = key.match(fullRegex)
        decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
      } else {
        var suite = 'aes' + match[1]
        var iv = new Buffer(match[2], 'hex')
        var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
        var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
        var out = []
        var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
        out.push(cipher.update(cipherText))
        out.push(cipher.final())
        decrypted = Buffer.concat(out)
      }
      var tag = key.match(startRegex)[1] + ' KEY'
      return {
        tag: tag,
        data: decrypted
      }
    }
    
  provide("parse-asn1/fixProc", module.exports);
}(global));

// pakmanager:parse-asn1
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var asn1 =  require('parse-asn1/asn1')
    var aesid = require('./aesid.json')
    var fixProc =  require('parse-asn1/fixProc')
    var ciphers = require('browserify-aes')
    var compat = require('pbkdf2')
    module.exports = parseKeys
    
    function parseKeys (buffer) {
      var password
      if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase
        buffer = buffer.key
      }
      if (typeof buffer === 'string') {
        buffer = new Buffer(buffer)
      }
    
      var stripped = fixProc(buffer, password)
    
      var type = stripped.tag
      var data = stripped.data
      var subtype, ndata
      switch (type) {
        case 'PUBLIC KEY':
          ndata = asn1.PublicKey.decode(data, 'der')
          subtype = ndata.algorithm.algorithm.join('.')
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
            case '1.2.840.10045.2.1':
              ndata.subjectPrivateKey = ndata.subjectPublicKey
              return {
                type: 'ec',
                data: ndata
              }
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
              return {
                type: 'dsa',
                data: ndata.algorithm.params
              }
            default: throw new Error('unknown key id ' + subtype)
          }
          throw new Error('unknown key type ' + type)
        case 'ENCRYPTED PRIVATE KEY':
          data = asn1.EncryptedPrivateKey.decode(data, 'der')
          data = decrypt(data, password)
          // falls through
        case 'PRIVATE KEY':
          ndata = asn1.PrivateKey.decode(data, 'der')
          subtype = ndata.algorithm.algorithm.join('.')
          switch (subtype) {
            case '1.2.840.113549.1.1.1':
              return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
            case '1.2.840.10045.2.1':
              return {
                curve: ndata.algorithm.curve,
                privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
              }
            case '1.2.840.10040.4.1':
              ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
              return {
                type: 'dsa',
                params: ndata.algorithm.params
              }
            default: throw new Error('unknown key id ' + subtype)
          }
          throw new Error('unknown key type ' + type)
        case 'RSA PUBLIC KEY':
          return asn1.RSAPublicKey.decode(data, 'der')
        case 'RSA PRIVATE KEY':
          return asn1.RSAPrivateKey.decode(data, 'der')
        case 'DSA PRIVATE KEY':
          return {
            type: 'dsa',
            params: asn1.DSAPrivateKey.decode(data, 'der')
          }
        case 'EC PRIVATE KEY':
          data = asn1.ECPrivateKey.decode(data, 'der')
          return {
            curve: data.parameters.value,
            privateKey: data.privateKey
          }
        default: throw new Error('unknown key type ' + type)
      }
    }
    parseKeys.signature = asn1.signature
    function decrypt (data, password) {
      var salt = data.algorithm.decrypt.kde.kdeparams.salt
      var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
      var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
      var iv = data.algorithm.decrypt.cipher.iv
      var cipherText = data.subjectPrivateKey
      var keylen = parseInt(algo.split('-')[1], 10) / 8
      var key = compat.pbkdf2Sync(password, salt, iters, keylen)
      var cipher = ciphers.createDecipheriv(algo, key, iv)
      var out = []
      out.push(cipher.update(cipherText))
      out.push(cipher.final())
      return Buffer.concat(out)
    }
    
  provide("parse-asn1", module.exports);
}(global));

// pakmanager:json-stable-stringify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');
    
    module.exports = function (obj, opts) {
        if (!opts) opts = {};
        if (typeof opts === 'function') opts = { cmp: opts };
        var space = opts.space || '';
        if (typeof space === 'number') space = Array(space+1).join(' ');
        var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
        var replacer = opts.replacer || function(key, value) { return value; };
    
        var cmp = opts.cmp && (function (f) {
            return function (node) {
                return function (a, b) {
                    var aobj = { key: a, value: node[a] };
                    var bobj = { key: b, value: node[b] };
                    return f(aobj, bobj);
                };
            };
        })(opts.cmp);
    
        var seen = [];
        return (function stringify (parent, key, node, level) {
            var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
            var colonSeparator = space ? ': ' : ':';
    
            if (node && node.toJSON && typeof node.toJSON === 'function') {
                node = node.toJSON();
            }
    
            node = replacer.call(parent, key, node);
    
            if (node === undefined) {
                return;
            }
            if (typeof node !== 'object' || node === null) {
                return json.stringify(node);
            }
            if (isArray(node)) {
                var out = [];
                for (var i = 0; i < node.length; i++) {
                    var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                    out.push(indent + space + item);
                }
                return '[' + out.join(',') + indent + ']';
            }
            else {
                if (seen.indexOf(node) !== -1) {
                    if (cycles) return json.stringify('__cycle__');
                    throw new TypeError('Converting circular structure to JSON');
                }
                else seen.push(node);
    
                var keys = objectKeys(node).sort(cmp && cmp(node));
                var out = [];
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var value = stringify(node, key, node[key], level+1);
    
                    if(!value) continue;
    
                    var keyValue = json.stringify(key)
                        + colonSeparator
                        + value;
                    ;
                    out.push(indent + space + keyValue);
                }
                seen.splice(seen.indexOf(node), 1);
                return '{' + out.join(',') + indent + '}';
            }
        })({ '': obj }, '', obj, 0);
    };
    
    var isArray = Array.isArray || function (x) {
        return {}.toString.call(x) === '[object Array]';
    };
    
    var objectKeys = Object.keys || function (obj) {
        var has = Object.prototype.hasOwnProperty || function () { return true };
        var keys = [];
        for (var key in obj) {
            if (has.call(obj, key)) keys.push(key);
        }
        return keys;
    };
    
  provide("json-stable-stringify", module.exports);
}(global));

// pakmanager:typedarray
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var undefined = (void 0); // Paranoia
    
    // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
    // create, and consume so much memory, that the browser appears frozen.
    var MAX_ARRAY_LENGTH = 1e5;
    
    // Approximations of internal ECMAScript conversion functions
    var ECMAScript = (function() {
      // Stash a copy in case other scripts modify these
      var opts = Object.prototype.toString,
          ophop = Object.prototype.hasOwnProperty;
    
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
        HasProperty: function(o, p) { return p in o; },
        HasOwnProperty: function(o, p) { return ophop.call(o, p); },
        IsCallable: function(o) { return typeof o === 'function'; },
        ToInt32: function(v) { return v >> 0; },
        ToUint32: function(v) { return v >>> 0; }
      };
    }());
    
    // Snapshot intrinsics
    var LN2 = Math.LN2,
        abs = Math.abs,
        floor = Math.floor,
        log = Math.log,
        min = Math.min,
        pow = Math.pow,
        round = Math.round;
    
    // ES5: lock down object properties
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    
    // emulate ES5 getter/setter API using legacy APIs
    // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
    // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
    // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
    var defineProp
    if (Object.defineProperty && (function() {
          try {
            Object.defineProperty({}, 'x', {});
            return true;
          } catch (e) {
            return false;
          }
        })()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
        if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
        if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
        return o;
      };
    }
    
    var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
      if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    
    // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
    // for index in 0 ... obj.length
    function makeArrayAccessors(obj) {
      if (!defineProp) { return; }
    
      if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");
    
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          'get': function() { return obj._getter(index); },
          'set': function(v) { obj._setter(index, v); },
          enumerable: true,
          configurable: false
        });
      }
    
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    
    // Internal conversion functions:
    //    pack<Type>()   - take a number (interpreted as Type), output a byte array
    //    unpack<Type>() - take a byte array, output a Type-like number
    
    function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
    function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }
    
    function packI8(n) { return [n & 0xff]; }
    function unpackI8(bytes) { return as_signed(bytes[0], 8); }
    
    function packU8(n) { return [n & 0xff]; }
    function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }
    
    function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }
    
    function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }
    
    function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
    function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }
    
    function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
    function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }
    
    function packIEEE754(v, ebits, fbits) {
    
      var bias = (1 << (ebits - 1)) - 1,
          s, e, f, ln,
          i, bits, str, bytes;
    
      function roundToEven(n) {
        var w = floor(n), f = n - w;
        if (f < 0.5)
          return w;
        if (f > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
    
      // Compute sign, exponent, fraction
      if (v !== v) {
        // NaN
        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
        e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
      } else if (v === 0) {
        e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
    
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            // Overflow
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            // Normalized
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          // Denormalized
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
    
      // Pack sign, exponent, fraction
      bits = [];
      for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
      for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join('');
    
      // Bits to bytes
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    
    function unpackIEEE754(bytes, ebits, fbits) {
    
      // Bytes to bits
      var bits = [], i, j, b, str,
          bias, s, e, f;
    
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0); b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join('');
    
      // Unpack sign, exponent, fraction
      bias = (1 << (ebits - 1)) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
    
      // Produce number
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        // Normalized
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        // Denormalized
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    
    function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
    function packF64(v) { return packIEEE754(v, 11, 52); }
    function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
    function packF32(v) { return packIEEE754(v, 8, 23); }
    
    
    //
    // 3 The ArrayBuffer Type
    //
    
    (function() {
    
      /** @constructor */
      var ArrayBuffer = function ArrayBuffer(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');
    
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
    
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
    
        configureProperties(this);
      };
    
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;
    
      //
      // 4 The ArrayBufferView Type
      //
    
      // NOTE: this constructor is not exported
      /** @constructor */
      var ArrayBufferView = function ArrayBufferView() {
        //this.buffer = null;
        //this.byteOffset = 0;
        //this.byteLength = 0;
      };
    
      //
      // 5 The Typed Array View Types
      //
    
      function makeConstructor(bytesPerElement, pack, unpack) {
        // Each TypedArray type requires a distinct constructor instance with
        // identical logic, which this produces.
    
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
    
          if (!arguments.length || typeof arguments[0] === 'number') {
            // Constructor(unsigned long length)
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');
    
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
            // Constructor(TypedArray array)
            array = arguments[0];
    
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === 'object' &&
                     !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(sequence<type> array)
            sequence = arguments[0];
    
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer(this.byteLength);
            this.byteOffset = 0;
    
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === 'object' &&
                     (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
            // Constructor(ArrayBuffer buffer,
            //             optional unsigned long byteOffset, optional unsigned long length)
            this.buffer = buffer;
    
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
    
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              // The given byteOffset must be a multiple of the element
              // size of the specific type, otherwise an exception is raised.
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
    
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
    
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
    
            if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
    
          this.constructor = ctor;
    
          configureProperties(this);
          makeArrayAccessors(this);
        };
    
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
    
        // getter type (unsigned long index);
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
    
        // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
        ctor.prototype.get = ctor.prototype._getter;
    
        // setter void (unsigned long index, type value);
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2) throw new SyntaxError("Not enough arguments");
    
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined;
          }
    
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
               i < this.BYTES_PER_ELEMENT;
               i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
    
        // void set(TypedArray array, optional unsigned long offset);
        // void set(sequence<type> array, optional unsigned long offset);
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len,
              i, s, d,
              byteOffset, byteLength, tmp;
    
          if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
            // void set(TypedArray array, optional unsigned long offset);
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
    
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset;
                   i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
            // void set(sequence<type> array, optional unsigned long offset);
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
    
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
    
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
    
        // TypedArray subarray(long begin, optional long end);
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }
    
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
    
          if (arguments.length < 1) { start = 0; }
          if (arguments.length < 2) { end = this.length; }
    
          if (start < 0) { start = this.length + start; }
          if (end < 0) { end = this.length + end; }
    
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
    
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
    
          return new this.constructor(
            this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
        };
    
        return ctor;
      }
    
      var Int8Array = makeConstructor(1, packI8, unpackI8);
      var Uint8Array = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array = makeConstructor(2, packI16, unpackI16);
      var Uint16Array = makeConstructor(2, packU16, unpackU16);
      var Int32Array = makeConstructor(4, packI32, unpackI32);
      var Uint32Array = makeConstructor(4, packU32, unpackU32);
      var Float32Array = makeConstructor(4, packF32, unpackF32);
      var Float64Array = makeConstructor(8, packF64, unpackF64);
    
      exports.Int8Array = exports.Int8Array || Int8Array;
      exports.Uint8Array = exports.Uint8Array || Uint8Array;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
      exports.Int16Array = exports.Int16Array || Int16Array;
      exports.Uint16Array = exports.Uint16Array || Uint16Array;
      exports.Int32Array = exports.Int32Array || Int32Array;
      exports.Uint32Array = exports.Uint32Array || Uint32Array;
      exports.Float32Array = exports.Float32Array || Float32Array;
      exports.Float64Array = exports.Float64Array || Float64Array;
    }());
    
    //
    // 6 The DataView View Type
    //
    
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
    
      var IS_BIG_ENDIAN = (function() {
        var u16array = new(exports.Uint16Array)([0x1234]),
            u8array = new(exports.Uint8Array)(u16array.buffer);
        return r(u8array, 0) === 0x12;
      }());
    
      // Constructor(ArrayBuffer buffer,
      //             optional unsigned long byteOffset,
      //             optional unsigned long byteLength)
      /** @constructor */
      var DataView = function DataView(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
          throw new TypeError("TypeError");
        }
    
        this.buffer = buffer || new exports.ArrayBuffer(0);
    
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
    
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
    
        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
    
        configureProperties(this);
      };
    
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
    
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
    
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
              bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
    
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
    
      DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
    
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
    
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
    
          // Get bytes
          var typeArray = new arrayType([value]),
              byteArray = new exports.Uint8Array(typeArray.buffer),
              bytes = [], i, byteView;
    
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
    
          // Flip if necessary
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
    
          // Write them
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
    
      DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
    
      exports.DataView = exports.DataView || DataView;
    
    }());
    
  provide("typedarray", module.exports);
}(global));

// pakmanager:astw
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parse = require('acorn').parse;
    
    module.exports = function (src) {
        var ast = src;
        if (typeof src === 'string') {
            try {
                ast = parse(src, {
                    ecmaVersion: 6,
                    allowReturnOutsideFunction: true
                })
            }
            catch (err) { ast = parse('(' + src + ')') }
        }
        return function (cb) {
            walk(ast, undefined, cb);
        };
    };
    
    function walk (node, parent, cb) {
        var keys = objectKeys(node);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key === 'parent') continue;
            
            var child = node[key];
            if (isArray(child)) {
                for (var j = 0; j < child.length; j++) {
                    var c = child[j];
                    if (c && typeof c.type === 'string') {
                        c.parent = node;
                        walk(c, node, cb);
                    }
                }
            }
            else if (child && typeof child.type === 'string') {
                child.parent = node;
                walk(child, node, cb);
            }
        }
        cb(node);
    }
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    };
    
  provide("astw", module.exports);
}(global));

// pakmanager:resolve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var core = require('./lib/core');
    exports = module.exports = require('./lib/async');
    exports.core = core;
    exports.isCore = function (x) { return core[x] };
    exports.sync = require('./lib/sync');
    
  provide("resolve", module.exports);
}(global));

// pakmanager:defined
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function () {
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) return arguments[i];
        }
    };
    
  provide("defined", module.exports);
}(global));

// pakmanager:path-platform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    
    var isWindows = process.platform === 'win32';
    var util = require('util');
    
    var _path = require('path');
    
    // we are new enough we already have this from the system, just export the
    // system then
    if (_path.posix) {
      module.exports = _path;
      return;
    }
    
    // resolves . and .. elements in a path array with directory names there
    // must be no slashes or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
    
        // ignore empty parts
        if (!p || p === '.')
          continue;
    
        if (p === '..') {
          if (res.length && res[res.length - 1] !== '..') {
            res.pop();
          } else if (allowAboveRoot) {
            res.push('..');
          }
        } else {
          res.push(p);
        }
      }
    
      return res;
    }
    
    // Regex to split a windows path into three parts: [*, device, slash,
    // tail] windows-only
    var splitDeviceRe =
        /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    
    // Regex to split the tail part of the above into [*, dir, basename, ext]
    var splitTailRe =
        /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
    
    var win32 = {};
    
    // Function to split a filename into [root, dir, basename, ext]
    function win32SplitPath(filename) {
      // Separate device+slash from tail
      var result = splitDeviceRe.exec(filename),
          device = (result[1] || '') + (result[2] || ''),
          tail = result[3] || '';
      // Split the tail into dir, basename and extension
      var result2 = splitTailRe.exec(tail),
          dir = result2[1],
          basename = result2[2],
          ext = result2[3];
      return [device, dir, basename, ext];
    }
    
    var normalizeUNCRoot = function(device) {
      return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
    };
    
    // path.resolve([from ...], to)
    win32.resolve = function() {
      var resolvedDevice = '',
          resolvedTail = '',
          resolvedAbsolute = false;
    
      for (var i = arguments.length - 1; i >= -1; i--) {
        var path;
        if (i >= 0) {
          path = arguments[i];
        } else if (!resolvedDevice) {
          path = process.cwd();
        } else {
          // Windows has the concept of drive-specific current working
          // directories. If we've resolved a drive letter but not yet an
          // absolute path, get cwd for that drive. We're sure the device is not
          // an unc path at this points, because unc paths are always absolute.
          path = process.env['=' + resolvedDevice];
          // Verify that a drive-local cwd was found and that it actually points
          // to our drive. If not, default to the drive's root.
          if (!path || path.substr(0, 3).toLowerCase() !==
              resolvedDevice.toLowerCase() + '\\') {
            path = resolvedDevice + '\\';
          }
        }
    
        // Skip empty and invalid entries
        if (!util.isString(path)) {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
    
        var result = splitDeviceRe.exec(path),
            device = result[1] || '',
            isUnc = device && device.charAt(1) !== ':',
            isAbsolute = win32.isAbsolute(path),
            tail = result[3];
    
        if (device &&
            resolvedDevice &&
            device.toLowerCase() !== resolvedDevice.toLowerCase()) {
          // This path points to another device so it is not applicable
          continue;
        }
    
        if (!resolvedDevice) {
          resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
          resolvedTail = tail + '\\' + resolvedTail;
          resolvedAbsolute = isAbsolute;
        }
    
        if (resolvedDevice && resolvedAbsolute) {
          break;
        }
      }
    
      // Convert slashes to backslashes when `resolvedDevice` points to an UNC
      // root. Also squash multiple slashes into a single one where appropriate.
      if (isUnc) {
        resolvedDevice = normalizeUNCRoot(resolvedDevice);
      }
    
      // At this point the path should be resolved to a full absolute path,
      // but handle relative paths to be safe (might happen when process.cwd()
      // fails)
    
      // Normalize the tail path
      resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/),
                                    !resolvedAbsolute).join('\\');
    
      // If device is a drive letter, we'll normalize to lower case.
      if (resolvedDevice && resolvedDevice.charAt(1) === ':') {
        resolvedDevice = resolvedDevice[0].toLowerCase() +
            resolvedDevice.substr(1);
      }
    
      return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
             '.';
    };
    
    
    win32.normalize = function(path) {
      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = device && device.charAt(1) !== ':',
          isAbsolute = win32.isAbsolute(path),
          tail = result[3],
          trailingSlash = /[\\\/]$/.test(tail);
    
      // If device is a drive letter, we'll normalize to lower case.
      if (device && device.charAt(1) === ':') {
        device = device[0].toLowerCase() + device.substr(1);
      }
    
      // Normalize the tail path
      tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');
    
      if (!tail && !isAbsolute) {
        tail = '.';
      }
      if (tail && trailingSlash) {
        tail += '\\';
      }
    
      // Convert slashes to backslashes when `device` points to an UNC root.
      // Also squash multiple slashes into a single one where appropriate.
      if (isUnc) {
        device = normalizeUNCRoot(device);
      }
    
      return device + (isAbsolute ? '\\' : '') + tail;
    };
    
    
    win32.isAbsolute = function(path) {
      var result = splitDeviceRe.exec(path),
          device = result[1] || '',
          isUnc = !!device && device.charAt(1) !== ':';
      // UNC paths are always absolute
      return !!result[2] || isUnc;
    };
    
    win32.join = function() {
      function f(p) {
        if (!util.isString(p)) {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }
    
      var paths = Array.prototype.filter.call(arguments, f);
      var joined = paths.join('\\');
    
      // Make sure that the joined path doesn't start with two slashes, because
      // normalize() will mistake it for an UNC path then.
      //
      // This step is skipped when it is very clear that the user actually
      // intended to point at an UNC path. This is assumed when the first
      // non-empty string arguments starts with exactly two slashes followed by
      // at least one more non-slash character.
      //
      // Note that for normalize() to treat a path as an UNC path it needs to
      // have at least 2 components, so we don't filter for that here.
      // This means that the user can use join to construct UNC paths from
      // a server name and a share name; for example:
      //   path.join('//server', 'share') -> '\\\\server\\share\')
      if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
        joined = joined.replace(/^[\\\/]{2,}/, '\\');
      }
    
      return win32.normalize(joined);
    };
    
    
    // path.relative(from, to)
    // it will solve the relative path from 'from' to 'to', for instance:
    // from = 'C:\\orandea\\test\\aaa'
    // to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    win32.relative = function(from, to) {
      from = win32.resolve(from);
      to = win32.resolve(to);
    
      // windows is not case sensitive
      var lowerFrom = from.toLowerCase();
      var lowerTo = to.toLowerCase();
    
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
    
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
    
        if (start > end) return [];
        return arr.slice(start, end + 1);
      }
    
      var toParts = trim(to.split('\\'));
    
      var lowerFromParts = trim(lowerFrom.split('\\'));
      var lowerToParts = trim(lowerTo.split('\\'));
    
      var length = Math.min(lowerFromParts.length, lowerToParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (lowerFromParts[i] !== lowerToParts[i]) {
          samePartsLength = i;
          break;
        }
      }
    
      if (samePartsLength == 0) {
        return to;
      }
    
      var outputParts = [];
      for (var i = samePartsLength; i < lowerFromParts.length; i++) {
        outputParts.push('..');
      }
    
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
    
      return outputParts.join('\\');
    };
    
    
    win32._makeLong = function(path) {
      // Note: this will *probably* throw somewhere.
      if (!util.isString(path))
        return path;
    
      if (!path) {
        return '';
      }
    
      var resolvedPath = win32.resolve(path);
    
      if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
        // path is local filesystem path, which needs to be converted
        // to long UNC path.
        return '\\\\?\\' + resolvedPath;
      } else if (/^\\\\[^?.]/.test(resolvedPath)) {
        // path is network UNC path, which needs to be converted
        // to long UNC path.
        return '\\\\?\\UNC\\' + resolvedPath.substring(2);
      }
    
      return path;
    };
    
    
    win32.dirname = function(path) {
      var result = win32SplitPath(path),
          root = result[0],
          dir = result[1];
    
      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }
    
      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }
    
      return root + dir;
    };
    
    
    win32.basename = function(path, ext) {
      var f = win32SplitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    
    
    win32.extname = function(path) {
      return win32SplitPath(path)[3];
    };
    
    
    win32.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
            "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
    
      var root = pathObject.root || '';
    
      if (!util.isString(root)) {
        throw new TypeError(
            "'pathObject.root' must be a string or undefined, not " +
            typeof pathObject.root
        );
      }
    
      var dir = pathObject.dir;
      var base = pathObject.base || '';
      if (dir.slice(dir.length - 1, dir.length) === win32.sep) {
        return dir + base;
      }
    
      if (dir) {
        return dir + win32.sep + base;
      }
    
      return base;
    };
    
    
    win32.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
            "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, allParts[1].length - 1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    
    
    win32.sep = '\\';
    win32.delimiter = ';';
    
    
    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var posix = {};
    
    
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    
    
    // path.resolve([from ...], to)
    // posix version
    posix.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
    
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
    
        // Skip empty and invalid entries
        if (!util.isString(path)) {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
    
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
    
      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
    
      // Normalize the path
      resolvedPath = normalizeArray(resolvedPath.split('/'),
                                    !resolvedAbsolute).join('/');
    
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    
    // path.normalize(path)
    // posix version
    posix.normalize = function(path) {
      var isAbsolute = posix.isAbsolute(path),
          trailingSlash = path.substr(-1) === '/';
    
      // Normalize the path
      path = normalizeArray(path.split('/'), !isAbsolute).join('/');
    
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
    
      return (isAbsolute ? '/' : '') + path;
    };
    
    // posix version
    posix.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    
    // posix version
    posix.join = function() {
      var path = '';
      for (var i = 0; i < arguments.length; i++) {
        var segment = arguments[i];
        if (!util.isString(segment)) {
          throw new TypeError('Arguments to path.join must be strings');
        }
        if (segment) {
          if (!path) {
            path += segment;
          } else {
            path += '/' + segment;
          }
        }
      }
      return posix.normalize(path);
    };
    
    
    // path.relative(from, to)
    // posix version
    posix.relative = function(from, to) {
      from = posix.resolve(from).substr(1);
      to = posix.resolve(to).substr(1);
    
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
    
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
    
        if (start > end) return [];
        return arr.slice(start, end + 1);
      }
    
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
    
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
    
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
    
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
    
      return outputParts.join('/');
    };
    
    
    posix._makeLong = function(path) {
      return path;
    };
    
    
    posix.dirname = function(path) {
      var result = posixSplitPath(path),
          root = result[0],
          dir = result[1];
    
      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }
    
      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }
    
      return root + dir;
    };
    
    
    posix.basename = function(path, ext) {
      var f = posixSplitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    
    
    posix.extname = function(path) {
      return posixSplitPath(path)[3];
    };
    
    
    posix.format = function(pathObject) {
      if (!util.isObject(pathObject)) {
        throw new TypeError(
            "Parameter 'pathObject' must be an object, not " + typeof pathObject
        );
      }
    
      var root = pathObject.root || '';
    
      if (!util.isString(root)) {
        throw new TypeError(
            "'pathObject.root' must be a string or undefined, not " +
            typeof pathObject.root
        );
      }
    
      var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
      var base = pathObject.base || '';
      return dir + base;
    };
    
    
    posix.parse = function(pathString) {
      if (!util.isString(pathString)) {
        throw new TypeError(
            "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      allParts[1] = allParts[1] || '';
      allParts[2] = allParts[2] || '';
      allParts[3] = allParts[3] || '';
    
      return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, allParts[1].length - 1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
      };
    };
    
    
    posix.sep = '/';
    posix.delimiter = ':';
    
    
    if (isWindows)
      module.exports = win32;
    else /* posix */
      module.exports = posix;
    
    module.exports.posix = posix;
    module.exports.win32 = win32;
    
  provide("path-platform", module.exports);
}(global));

// pakmanager:duplexer2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    var stream = require("readable-stream");
    
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
    
      stream.Duplex.call(this, options);
    
      if (typeof readable.read !== "function") {
        readable = (new stream.Readable(options)).wrap(readable);
      }
    
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
    
      var self = this;
    
      writable.once("finish", function() {
        self.end();
      });
    
      this.once("finish", function() {
        writable.end();
      });
    
      readable.on("readable", function() {
        if (self._waiting) {
          self._waiting = false;
          self._read();
        }
      });
    
      readable.once("end", function() {
        self.push(null);
      });
    
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self.emit("error", err);
        });
    
        readable.on("error", function(err) {
          self.emit("error", err);
        });
      }
    }
    
    DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});
    
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    
    module.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    
    module.exports.DuplexWrapper = DuplexWrapper;
    
  provide("duplexer2", module.exports);
}(global));

// pakmanager:bytes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * bytes
     * Copyright(c) 2012-2014 TJ Holowaychuk
     * Copyright(c) 2015 Jed Watson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = bytes;
    module.exports.format = format;
    module.exports.parse = parse;
    
    /**
     * Module variables.
     * @private
     */
    
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    
    var map = {
      b:  1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: ((1 << 30) * 1024)
    };
    
    // TODO: use is-finite module?
    var numberIsFinite = Number.isFinite || function (v) { return typeof v === 'number' && isFinite(v); };
    
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;
    
    /**
     * Convert the given value in bytes into a string or parse to string to an integer in bytes.
     *
     * @param {string|number} value
     * @param {{
     *  case: [string],
     *  decimalPlaces: [number]
     *  fixedDecimals: [boolean]
     *  thousandsSeparator: [string]
     *  }} [options] bytes options.
     *
     * @returns {string|number|null}
     */
    
    function bytes(value, options) {
      if (typeof value === 'string') {
        return parse(value);
      }
    
      if (typeof value === 'number') {
        return format(value, options);
      }
    
      return null;
    }
    
    /**
     * Format the given value in bytes into a string.
     *
     * If the value is negative, it is kept as such. If it is a float,
     * it is rounded.
     *
     * @param {number} value
     * @param {object} [options]
     * @param {number} [options.decimalPlaces=2]
     * @param {number} [options.fixedDecimals=false]
     * @param {string} [options.thousandsSeparator=]
     *
     * @returns {string|null}
     * @public
     */
    
    function format(value, options) {
      if (!numberIsFinite(value)) {
        return null;
      }
    
      var mag = Math.abs(value);
      var thousandsSeparator = (options && options.thousandsSeparator) || '';
      var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = 'B';
    
      if (mag >= map.tb) {
        unit = 'TB';
      } else if (mag >= map.gb) {
        unit = 'GB';
      } else if (mag >= map.mb) {
        unit = 'MB';
      } else if (mag >= map.kb) {
        unit = 'kB';
      }
    
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
    
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, '$1');
      }
    
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
    
      return str + unit;
    }
    
    /**
     * Parse the string value into an integer in bytes.
     *
     * If no unit is given, it is assumed the value is in bytes.
     *
     * @param {number|string} val
     *
     * @returns {number|null}
     * @public
     */
    
    function parse(val) {
      if (typeof val === 'number' && !isNaN(val)) {
        return val;
      }
    
      if (typeof val !== 'string') {
        return null;
      }
    
      // Test if the string passed is valid
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = 'b';
    
      if (!results) {
        // Nothing could be extracted from the given string
        floatValue = parseInt(val, 10);
        unit = 'b'
      } else {
        // Retrieve the value and the unit
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
    
      return Math.floor(map[unit] * floatValue);
    }
    
  provide("bytes", module.exports);
}(global));

// pakmanager:unpipe
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * unpipe
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = unpipe
    
    /**
     * Determine if there are Node.js pipe-like data listeners.
     * @private
     */
    
    function hasPipeDataListeners(stream) {
      var listeners = stream.listeners('data')
    
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].name === 'ondata') {
          return true
        }
      }
    
      return false
    }
    
    /**
     * Unpipe a stream from all destinations.
     *
     * @param {object} stream
     * @public
     */
    
    function unpipe(stream) {
      if (!stream) {
        throw new TypeError('argument stream is required')
      }
    
      if (typeof stream.unpipe === 'function') {
        // new-style
        stream.unpipe()
        return
      }
    
      // Node.js 0.8 hack
      if (!hasPipeDataListeners(stream)) {
        return
      }
    
      var listener
      var listeners = stream.listeners('close')
    
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i]
    
        if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
          continue
        }
    
        // invoke the listener
        listener.call(stream)
      }
    }
    
  provide("unpipe", module.exports);
}(global));

// pakmanager:media-typer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * media-typer
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
     *
     * parameter     = token "=" ( token | quoted-string )
     * token         = 1*<any CHAR except CTLs or separators>
     * separators    = "(" | ")" | "<" | ">" | "@"
     *               | "," | ";" | ":" | "\" | <">
     *               | "/" | "[" | "]" | "?" | "="
     *               | "{" | "}" | SP | HT
     * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
     * qdtext        = <any TEXT except <">>
     * quoted-pair   = "\" CHAR
     * CHAR          = <any US-ASCII character (octets 0 - 127)>
     * TEXT          = <any OCTET except CTLs, but including LWS>
     * LWS           = [CRLF] 1*( SP | HT )
     * CRLF          = CR LF
     * CR            = <US-ASCII CR, carriage return (13)>
     * LF            = <US-ASCII LF, linefeed (10)>
     * SP            = <US-ASCII SP, space (32)>
     * SHT           = <US-ASCII HT, horizontal-tab (9)>
     * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
     * OCTET         = <any 8-bit sequence of data>
     */
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
    var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
    
    /**
     * RegExp to match quoted-pair in RFC 2616
     *
     * quoted-pair = "\" CHAR
     * CHAR        = <any US-ASCII character (octets 0 - 127)>
     */
    var qescRegExp = /\\([\u0000-\u007f])/g;
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 2616
     */
    var quoteRegExp = /([\\"])/g;
    
    /**
     * RegExp to match type in RFC 6838
     *
     * type-name = restricted-name
     * subtype-name = restricted-name
     * restricted-name = restricted-name-first *126restricted-name-chars
     * restricted-name-first  = ALPHA / DIGIT
     * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
     *                          "$" / "&" / "-" / "^" / "_"
     * restricted-name-chars =/ "." ; Characters before first dot always
     *                              ; specify a facet name
     * restricted-name-chars =/ "+" ; Characters after last plus always
     *                              ; specify a structured syntax suffix
     * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
     * DIGIT =  %x30-39             ; 0-9
     */
    var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
    var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
    var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    
    /**
     * Module exports.
     */
    
    exports.format = format
    exports.parse = parse
    
    /**
     * Format object to media type.
     *
     * @param {object} obj
     * @return {string}
     * @api public
     */
    
    function format(obj) {
      if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required')
      }
    
      var parameters = obj.parameters
      var subtype = obj.subtype
      var suffix = obj.suffix
      var type = obj.type
    
      if (!type || !typeNameRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      if (!subtype || !subtypeNameRegExp.test(subtype)) {
        throw new TypeError('invalid subtype')
      }
    
      // format as type/subtype
      var string = type + '/' + subtype
    
      // append +suffix
      if (suffix) {
        if (!typeNameRegExp.test(suffix)) {
          throw new TypeError('invalid suffix')
        }
    
        string += '+' + suffix
      }
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          if (!tokenRegExp.test(param)) {
            throw new TypeError('invalid parameter name')
          }
    
          string += '; ' + param + '=' + qstring(parameters[param])
        }
      }
    
      return string
    }
    
    /**
     * Parse media type to object.
     *
     * @param {string|object} string
     * @return {Object}
     * @api public
     */
    
    function parse(string) {
      if (!string) {
        throw new TypeError('argument string is required')
      }
    
      // support req/res-like objects as argument
      if (typeof string === 'object') {
        string = getcontenttype(string)
      }
    
      if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string')
      }
    
      var index = string.indexOf(';')
      var type = index !== -1
        ? string.substr(0, index)
        : string
    
      var key
      var match
      var obj = splitType(type)
      var params = {}
      var value
    
      paramRegExp.lastIndex = index
    
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        params[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      obj.parameters = params
    
      return obj
    }
    
    /**
     * Get content-type from req/res objects.
     *
     * @param {object}
     * @return {Object}
     * @api private
     */
    
    function getcontenttype(obj) {
      if (typeof obj.getHeader === 'function') {
        // res-like
        return obj.getHeader('content-type')
      }
    
      if (typeof obj.headers === 'object') {
        // req-like
        return obj.headers && obj.headers['content-type']
      }
    }
    
    /**
     * Quote a string if necessary.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function qstring(val) {
      var str = String(val)
    
      // no need to quote tokens
      if (tokenRegExp.test(str)) {
        return str
      }
    
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError('invalid parameter value')
      }
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Simply "type/subtype+siffx" into parts.
     *
     * @param {string} string
     * @return {Object}
     * @api private
     */
    
    function splitType(string) {
      var match = typeRegExp.exec(string.toLowerCase())
    
      if (!match) {
        throw new TypeError('invalid media type')
      }
    
      var type = match[1]
      var subtype = match[2]
      var suffix
    
      // suffix after last +
      var index = subtype.lastIndexOf('+')
      if (index !== -1) {
        suffix = subtype.substr(index + 1)
        subtype = subtype.substr(0, index)
      }
    
      var obj = {
        type: type,
        subtype: subtype,
        suffix: suffix
      }
    
      return obj
    }
    
  provide("media-typer", module.exports);
}(global));

// pakmanager:arrify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (val) {
    	if (val === null || val === undefined) {
    		return [];
    	}
    
    	return Array.isArray(val) ? val : [val];
    };
    
  provide("arrify", module.exports);
}(global));

// pakmanager:micromatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * micromatch <https://github.com/jonschlinkert/micromatch>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    var expand = require('./lib/expand');
    var utils = require('./lib/utils');
    
    /**
     * The main function. Pass an array of filepaths,
     * and a string or array of glob patterns
     *
     * @param  {Array|String} `files`
     * @param  {Array|String} `patterns`
     * @param  {Object} `opts`
     * @return {Array} Array of matches
     */
    
    function micromatch(files, patterns, opts) {
      if (!files || !patterns) return [];
      opts = opts || {};
    
      if (typeof opts.cache === 'undefined') {
        opts.cache = true;
      }
    
      if (!Array.isArray(patterns)) {
        return match(files, patterns, opts);
      }
    
      var len = patterns.length, i = 0;
      var omit = [], keep = [];
    
      while (len--) {
        var glob = patterns[i++];
        if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {
          omit.push.apply(omit, match(files, glob.slice(1), opts));
        } else {
          keep.push.apply(keep, match(files, glob, opts));
        }
      }
      return utils.diff(keep, omit);
    }
    
    /**
     * Pass an array of files and a glob pattern as a string.
     *
     * This function is called by the main `micromatch` function
     * If you only need to pass a single pattern you might get
     * very minor speed improvements using this function.
     *
     * @param  {Array} `files`
     * @param  {Array} `pattern`
     * @param  {Object} `options`
     * @return {Array}
     */
    
    function match(files, pattern, opts) {
      if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {
        throw new Error(msg('match', 'files', 'a string or array'));
      }
    
      files = utils.arrayify(files);
      opts = opts || {};
    
      var negate = opts.negate || false;
      var orig = pattern;
    
      if (typeof pattern === 'string') {
        negate = pattern.charAt(0) === '!';
        if (negate) {
          pattern = pattern.slice(1);
        }
    
        // we need to remove the character regardless,
        // so the above logic is still needed
        if (opts.nonegate === true) {
          negate = false;
        }
      }
    
      var _isMatch = matcher(pattern, opts);
      var len = files.length, i = 0;
      var res = [];
    
      while (i < len) {
        var file = files[i++];
        var fp = utils.unixify(file, opts);
    
        if (!_isMatch(fp)) { continue; }
        res.push(fp);
      }
    
      if (res.length === 0) {
        if (opts.failglob === true) {
          throw new Error('micromatch.match() found no matches for: "' + orig + '".');
        }
    
        if (opts.nonull || opts.nullglob) {
          res.push(utils.unescapeGlob(orig));
        }
      }
    
      // if `negate` was defined, diff negated files
      if (negate) { res = utils.diff(files, res); }
    
      // if `ignore` was defined, diff ignored filed
      if (opts.ignore && opts.ignore.length) {
        pattern = opts.ignore;
        opts = utils.omit(opts, ['ignore']);
        res = utils.diff(res, micromatch(res, pattern, opts));
      }
    
      if (opts.nodupes) {
        return utils.unique(res);
      }
      return res;
    }
    
    /**
     * Returns a function that takes a glob pattern or array of glob patterns
     * to be used with `Array#filter()`. (Internally this function generates
     * the matching function using the [matcher] method).
     *
     * ```js
     * var fn = mm.filter('[a-c]');
     * ['a', 'b', 'c', 'd', 'e'].filter(fn);
     * //=> ['a', 'b', 'c']
     * ```
     *
     * @param  {String|Array} `patterns` Can be a glob or array of globs.
     * @param  {Options} `opts` Options to pass to the [matcher] method.
     * @return {Function} Filter function to be passed to `Array#filter()`.
     */
    
    function filter(patterns, opts) {
      if (!Array.isArray(patterns) && typeof patterns !== 'string') {
        throw new TypeError(msg('filter', 'patterns', 'a string or array'));
      }
    
      patterns = utils.arrayify(patterns);
      var len = patterns.length, i = 0;
      var patternMatchers = Array(len);
      while (i < len) {
        patternMatchers[i] = matcher(patterns[i++], opts);
      }
    
      return function(fp) {
        if (fp == null) return [];
        var len = patternMatchers.length, i = 0;
        var res = true;
    
        fp = utils.unixify(fp, opts);
        while (i < len) {
          var fn = patternMatchers[i++];
          if (!fn(fp)) {
            res = false;
            break;
          }
        }
        return res;
      };
    }
    
    /**
     * Returns true if the filepath contains the given
     * pattern. Can also return a function for matching.
     *
     * ```js
     * isMatch('foo.md', '*.md', {});
     * //=> true
     *
     * isMatch('*.md', {})('foo.md')
     * //=> true
     * ```
     *
     * @param  {String} `fp`
     * @param  {String} `pattern`
     * @param  {Object} `opts`
     * @return {Boolean}
     */
    
    function isMatch(fp, pattern, opts) {
      if (typeof fp !== 'string') {
        throw new TypeError(msg('isMatch', 'filepath', 'a string'));
      }
    
      fp = utils.unixify(fp, opts);
      if (utils.typeOf(pattern) === 'object') {
        return matcher(fp, pattern);
      }
      return matcher(pattern, opts)(fp);
    }
    
    /**
     * Returns true if the filepath matches the
     * given pattern.
     */
    
    function contains(fp, pattern, opts) {
      if (typeof fp !== 'string') {
        throw new TypeError(msg('contains', 'pattern', 'a string'));
      }
    
      opts = opts || {};
      opts.contains = (pattern !== '');
      fp = utils.unixify(fp, opts);
    
      if (opts.contains && !utils.isGlob(pattern)) {
        return fp.indexOf(pattern) !== -1;
      }
      return matcher(pattern, opts)(fp);
    }
    
    /**
     * Returns true if a file path matches any of the
     * given patterns.
     *
     * @param  {String} `fp` The filepath to test.
     * @param  {String|Array} `patterns` Glob patterns to use.
     * @param  {Object} `opts` Options to pass to the `matcher()` function.
     * @return {String}
     */
    
    function any(fp, patterns, opts) {
      if (!Array.isArray(patterns) && typeof patterns !== 'string') {
        throw new TypeError(msg('any', 'patterns', 'a string or array'));
      }
    
      patterns = utils.arrayify(patterns);
      var len = patterns.length;
    
      fp = utils.unixify(fp, opts);
      while (len--) {
        var isMatch = matcher(patterns[len], opts);
        if (isMatch(fp)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Filter the keys of an object with the given `glob` pattern
     * and `options`
     *
     * @param  {Object} `object`
     * @param  {Pattern} `object`
     * @return {Array}
     */
    
    function matchKeys(obj, glob, options) {
      if (utils.typeOf(obj) !== 'object') {
        throw new TypeError(msg('matchKeys', 'first argument', 'an object'));
      }
    
      var fn = matcher(glob, options);
      var res = {};
    
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && fn(key)) {
          res[key] = obj[key];
        }
      }
      return res;
    }
    
    /**
     * Return a function for matching based on the
     * given `pattern` and `options`.
     *
     * @param  {String} `pattern`
     * @param  {Object} `options`
     * @return {Function}
     */
    
    function matcher(pattern, opts) {
      // pattern is a function
      if (typeof pattern === 'function') {
        return pattern;
      }
      // pattern is a regex
      if (pattern instanceof RegExp) {
        return function(fp) {
          return pattern.test(fp);
        };
      }
    
      if (typeof pattern !== 'string') {
        throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));
      }
    
      // strings, all the way down...
      pattern = utils.unixify(pattern, opts);
    
      // pattern is a non-glob string
      if (!utils.isGlob(pattern)) {
        return utils.matchPath(pattern, opts);
      }
      // pattern is a glob string
      var re = makeRe(pattern, opts);
    
      // `matchBase` is defined
      if (opts && opts.matchBase) {
        return utils.hasFilename(re, opts);
      }
      // `matchBase` is not defined
      return function(fp) {
        fp = utils.unixify(fp, opts);
        return re.test(fp);
      };
    }
    
    /**
     * Create and cache a regular expression for matching
     * file paths.
     *
     * If the leading character in the `glob` is `!`, a negation
     * regex is returned.
     *
     * @param  {String} `glob`
     * @param  {Object} `options`
     * @return {RegExp}
     */
    
    function toRegex(glob, options) {
      // clone options to prevent  mutating the original object
      var opts = Object.create(options || {});
      var flags = opts.flags || '';
      if (opts.nocase && flags.indexOf('i') === -1) {
        flags += 'i';
      }
    
      var parsed = expand(glob, opts);
    
      // pass in tokens to avoid parsing more than once
      opts.negated = opts.negated || parsed.negated;
      opts.negate = opts.negated;
      glob = wrapGlob(parsed.pattern, opts);
      var re;
    
      try {
        re = new RegExp(glob, flags);
        return re;
      } catch (err) {
        err.reason = 'micromatch invalid regex: (' + re + ')';
        if (opts.strict) throw new SyntaxError(err);
      }
    
      // we're only here if a bad pattern was used and the user
      // passed `options.silent`, so match nothing
      return /$^/;
    }
    
    /**
     * Create the regex to do the matching. If the leading
     * character in the `glob` is `!` a negation regex is returned.
     *
     * @param {String} `glob`
     * @param {Boolean} `negate`
     */
    
    function wrapGlob(glob, opts) {
      var prefix = (opts && !opts.contains) ? '^' : '';
      var after = (opts && !opts.contains) ? '$' : '';
      glob = ('(?:' + glob + ')' + after);
      if (opts && opts.negate) {
        return prefix + ('(?!^' + glob + ').*$');
      }
      return prefix + glob;
    }
    
    /**
     * Wrap `toRegex` to memoize the generated regex when
     * the string and options don't change
     */
    
    function makeRe(glob, opts) {
      if (utils.typeOf(glob) !== 'string') {
        throw new Error(msg('makeRe', 'glob', 'a string'));
      }
      return utils.cache(toRegex, glob, opts);
    }
    
    /**
     * Make error messages consistent. Follows this format:
     *
     * ```js
     * msg(methodName, argNumber, nativeType);
     * // example:
     * msg('matchKeys', 'first', 'an object');
     * ```
     *
     * @param  {String} `method`
     * @param  {String} `num`
     * @param  {String} `type`
     * @return {String}
     */
    
    function msg(method, what, type) {
      return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
    }
    
    /**
     * Public methods
     */
    
    /* eslint no-multi-spaces: 0 */
    micromatch.any       = any;
    micromatch.braces    = micromatch.braceExpand = utils.braces;
    micromatch.contains  = contains;
    micromatch.expand    = expand;
    micromatch.filter    = filter;
    micromatch.isMatch   = isMatch;
    micromatch.makeRe    = makeRe;
    micromatch.match     = match;
    micromatch.matcher   = matcher;
    micromatch.matchKeys = matchKeys;
    
    /**
     * Expose `micromatch`
     */
    
    module.exports = micromatch;
    
  provide("micromatch", module.exports);
}(global));

// pakmanager:nan
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  console.log(require('path').relative('.', __dirname));
    
  provide("nan", module.exports);
}(global));

// pakmanager:escape-html
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * escape-html
     * Copyright(c) 2012-2013 TJ Holowaychuk
     * Copyright(c) 2015 Andreas Lubbe
     * Copyright(c) 2015 Tiancheng "Timothy" Gu
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module variables.
     * @private
     */
    
    var matchHtmlRegExp = /["'&<>]/;
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = escapeHtml;
    
    /**
     * Escape special characters in the given string of html.
     *
     * @param  {string} string The string to escape for inserting into HTML
     * @return {string}
     * @public
     */
    
    function escapeHtml(string) {
      var str = '' + string;
      var match = matchHtmlRegExp.exec(str);
    
      if (!match) {
        return str;
      }
    
      var escape;
      var html = '';
      var index = 0;
      var lastIndex = 0;
    
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34: // "
            escape = '&quot;';
            break;
          case 38: // &
            escape = '&amp;';
            break;
          case 39: // '
            escape = '&#39;';
            break;
          case 60: // <
            escape = '&lt;';
            break;
          case 62: // >
            escape = '&gt;';
            break;
          default:
            continue;
        }
    
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
    
        lastIndex = index + 1;
        html += escape;
      }
    
      return lastIndex !== index
        ? html + str.substring(lastIndex, index)
        : html;
    }
    
  provide("escape-html", module.exports);
}(global));

// pakmanager:on-finished
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * on-finished
     * Copyright(c) 2013 Jonathan Ong
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = onFinished
    module.exports.isFinished = isFinished
    
    /**
     * Module dependencies.
     * @private
     */
    
    var first = require('ee-first')
    
    /**
     * Variables.
     * @private
     */
    
    /* istanbul ignore next */
    var defer = typeof setImmediate === 'function'
      ? setImmediate
      : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
    
    /**
     * Invoke callback when the response has finished, useful for
     * cleaning up resources afterwards.
     *
     * @param {object} msg
     * @param {function} listener
     * @return {object}
     * @public
     */
    
    function onFinished(msg, listener) {
      if (isFinished(msg) !== false) {
        defer(listener, null, msg)
        return msg
      }
    
      // attach the listener to the message
      attachListener(msg, listener)
    
      return msg
    }
    
    /**
     * Determine if message is already finished.
     *
     * @param {object} msg
     * @return {boolean}
     * @public
     */
    
    function isFinished(msg) {
      var socket = msg.socket
    
      if (typeof msg.finished === 'boolean') {
        // OutgoingMessage
        return Boolean(msg.finished || (socket && !socket.writable))
      }
    
      if (typeof msg.complete === 'boolean') {
        // IncomingMessage
        return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
      }
    
      // don't know
      return undefined
    }
    
    /**
     * Attach a finished listener to the message.
     *
     * @param {object} msg
     * @param {function} callback
     * @private
     */
    
    function attachFinishedListener(msg, callback) {
      var eeMsg
      var eeSocket
      var finished = false
    
      function onFinish(error) {
        eeMsg.cancel()
        eeSocket.cancel()
    
        finished = true
        callback(error)
      }
    
      // finished on first message event
      eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)
    
      function onSocket(socket) {
        // remove listener
        msg.removeListener('socket', onSocket)
    
        if (finished) return
        if (eeMsg !== eeSocket) return
    
        // finished on first socket event
        eeSocket = first([[socket, 'error', 'close']], onFinish)
      }
    
      if (msg.socket) {
        // socket already assigned
        onSocket(msg.socket)
        return
      }
    
      // wait for socket to be assigned
      msg.on('socket', onSocket)
    
      if (msg.socket === undefined) {
        // node.js 0.8 patch
        patchAssignSocket(msg, onSocket)
      }
    }
    
    /**
     * Attach the listener to the message.
     *
     * @param {object} msg
     * @return {function}
     * @private
     */
    
    function attachListener(msg, listener) {
      var attached = msg.__onFinished
    
      // create a private single listener with queue
      if (!attached || !attached.queue) {
        attached = msg.__onFinished = createListener(msg)
        attachFinishedListener(msg, attached)
      }
    
      attached.queue.push(listener)
    }
    
    /**
     * Create listener on message.
     *
     * @param {object} msg
     * @return {function}
     * @private
     */
    
    function createListener(msg) {
      function listener(err) {
        if (msg.__onFinished === listener) msg.__onFinished = null
        if (!listener.queue) return
    
        var queue = listener.queue
        listener.queue = null
    
        for (var i = 0; i < queue.length; i++) {
          queue[i](err, msg)
        }
      }
    
      listener.queue = []
    
      return listener
    }
    
    /**
     * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
     *
     * @param {ServerResponse} res
     * @param {function} callback
     * @private
     */
    
    function patchAssignSocket(res, callback) {
      var assignSocket = res.assignSocket
    
      if (typeof assignSocket !== 'function') return
    
      // res.on('socket', callback) is broken in 0.8
      res.assignSocket = function _assignSocket(socket) {
        assignSocket.call(this, socket)
        callback(socket)
      }
    }
    
  provide("on-finished", module.exports);
}(global));

// pakmanager:accepts
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * accepts
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var Negotiator = require('negotiator')
    var mime = require('mime-types')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = Accepts
    
    /**
     * Create a new Accepts object for the given req.
     *
     * @param {object} req
     * @public
     */
    
    function Accepts(req) {
      if (!(this instanceof Accepts))
        return new Accepts(req)
    
      this.headers = req.headers
      this.negotiator = new Negotiator(req)
    }
    
    /**
     * Check if the given `type(s)` is acceptable, returning
     * the best match when true, otherwise `undefined`, in which
     * case you should respond with 406 "Not Acceptable".
     *
     * The `type` value may be a single mime type string
     * such as "application/json", the extension name
     * such as "json" or an array `["json", "html", "text/plain"]`. When a list
     * or array is given the _best_ match, if any is returned.
     *
     * Examples:
     *
     *     // Accept: text/html
     *     this.types('html');
     *     // => "html"
     *
     *     // Accept: text/*, application/json
     *     this.types('html');
     *     // => "html"
     *     this.types('text/html');
     *     // => "text/html"
     *     this.types('json', 'text');
     *     // => "json"
     *     this.types('application/json');
     *     // => "application/json"
     *
     *     // Accept: text/*, application/json
     *     this.types('image/png');
     *     this.types('png');
     *     // => undefined
     *
     *     // Accept: text/*;q=.5, application/json
     *     this.types(['html', 'json']);
     *     this.types('html', 'json');
     *     // => "json"
     *
     * @param {String|Array} types...
     * @return {String|Array|Boolean}
     * @public
     */
    
    Accepts.prototype.type =
    Accepts.prototype.types = function (types_) {
      var types = types_
    
      // support flattened arguments
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length)
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i]
        }
      }
    
      // no types, return all requested types
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes()
      }
    
      if (!this.headers.accept) return types[0];
      var mimes = types.map(extToMime);
      var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      var first = accepts[0];
      if (!first) return false;
      return types[mimes.indexOf(first)];
    }
    
    /**
     * Return accepted encodings or best fit based on `encodings`.
     *
     * Given `Accept-Encoding: gzip, deflate`
     * an array sorted by quality is returned:
     *
     *     ['gzip', 'deflate']
     *
     * @param {String|Array} encodings...
     * @return {String|Array}
     * @public
     */
    
    Accepts.prototype.encoding =
    Accepts.prototype.encodings = function (encodings_) {
      var encodings = encodings_
    
      // support flattened arguments
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length)
        for (var i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i]
        }
      }
    
      // no encodings, return all requested encodings
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings()
      }
    
      return this.negotiator.encodings(encodings)[0] || false
    }
    
    /**
     * Return accepted charsets or best fit based on `charsets`.
     *
     * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
     * an array sorted by quality is returned:
     *
     *     ['utf-8', 'utf-7', 'iso-8859-1']
     *
     * @param {String|Array} charsets...
     * @return {String|Array}
     * @public
     */
    
    Accepts.prototype.charset =
    Accepts.prototype.charsets = function (charsets_) {
      var charsets = charsets_
    
      // support flattened arguments
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length)
        for (var i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i]
        }
      }
    
      // no charsets, return all requested charsets
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets()
      }
    
      return this.negotiator.charsets(charsets)[0] || false
    }
    
    /**
     * Return accepted languages or best fit based on `langs`.
     *
     * Given `Accept-Language: en;q=0.8, es, pt`
     * an array sorted by quality is returned:
     *
     *     ['es', 'pt', 'en']
     *
     * @param {String|Array} langs...
     * @return {Array|String}
     * @public
     */
    
    Accepts.prototype.lang =
    Accepts.prototype.langs =
    Accepts.prototype.language =
    Accepts.prototype.languages = function (languages_) {
      var languages = languages_
    
      // support flattened arguments
      if (languages && !Array.isArray(languages)) {
        languages = new Array(arguments.length)
        for (var i = 0; i < languages.length; i++) {
          languages[i] = arguments[i]
        }
      }
    
      // no languages, return all requested languages
      if (!languages || languages.length === 0) {
        return this.negotiator.languages()
      }
    
      return this.negotiator.languages(languages)[0] || false
    }
    
    /**
     * Convert extnames to mime.
     *
     * @param {String} type
     * @return {String}
     * @private
     */
    
    function extToMime(type) {
      return type.indexOf('/') === -1
        ? mime.lookup(type)
        : type
    }
    
    /**
     * Check if mime is valid.
     *
     * @param {String} type
     * @return {String}
     * @private
     */
    
    function validMime(type) {
      return typeof type === 'string';
    }
    
  provide("accepts", module.exports);
}(global));

// pakmanager:engine.io-client
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports =  require('./lib/');
    
  provide("engine.io-client", module.exports);
}(global));

// pakmanager:component-bind
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Slice reference.
     */
    
    var slice = [].slice;
    
    /**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */
    
    module.exports = function(obj, fn){
      if ('string' == typeof fn) fn = obj[fn];
      if ('function' != typeof fn) throw new Error('bind() requires a function');
      var args = slice.call(arguments, 2);
      return function(){
        return fn.apply(obj, args.concat(slice.call(arguments)));
      }
    };
    
  provide("component-bind", module.exports);
}(global));

// pakmanager:object-component
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * HOP ref.
     */
    
    var has = Object.prototype.hasOwnProperty;
    
    /**
     * Return own keys in `obj`.
     *
     * @param {Object} obj
     * @return {Array}
     * @api public
     */
    
    exports.keys = Object.keys || function(obj){
      var keys = [];
      for (var key in obj) {
        if (has.call(obj, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    
    /**
     * Return own values in `obj`.
     *
     * @param {Object} obj
     * @return {Array}
     * @api public
     */
    
    exports.values = function(obj){
      var vals = [];
      for (var key in obj) {
        if (has.call(obj, key)) {
          vals.push(obj[key]);
        }
      }
      return vals;
    };
    
    /**
     * Merge `b` into `a`.
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object} a
     * @api public
     */
    
    exports.merge = function(a, b){
      for (var key in b) {
        if (has.call(b, key)) {
          a[key] = b[key];
        }
      }
      return a;
    };
    
    /**
     * Return length of `obj`.
     *
     * @param {Object} obj
     * @return {Number}
     * @api public
     */
    
    exports.length = function(obj){
      return exports.keys(obj).length;
    };
    
    /**
     * Check if `obj` is empty.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api public
     */
    
    exports.isEmpty = function(obj){
      return 0 == exports.length(obj);
    };
  provide("object-component", module.exports);
}(global));

// pakmanager:socket.io-parser/is-buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    module.exports = isBuf;
    
    /**
     * Returns true if obj is a buffer or an arraybuffer.
     *
     * @api private
     */
    
    function isBuf(obj) {
      return (global.Buffer && global.Buffer.isBuffer(obj)) ||
             (global.ArrayBuffer && obj instanceof ArrayBuffer);
    }
    
  provide("socket.io-parser/is-buffer", module.exports);
}(global));

// pakmanager:socket.io-parser/binary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global Blob,File*/
    
    /**
     * Module requirements
     */
    
    var isArray = require('isarray');
    var isBuf =  require('socket.io-parser/is-buffer');
    
    /**
     * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
     * Anything with blobs or files should be fed through removeBlobs before coming
     * here.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @api public
     */
    
    exports.deconstructPacket = function(packet){
      var buffers = [];
      var packetData = packet.data;
    
      function _deconstructPacket(data) {
        if (!data) return data;
    
        if (isBuf(data)) {
          var placeholder = { _placeholder: true, num: buffers.length };
          buffers.push(data);
          return placeholder;
        } else if (isArray(data)) {
          var newData = new Array(data.length);
          for (var i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i]);
          }
          return newData;
        } else if ('object' == typeof data && !(data instanceof Date)) {
          var newData = {};
          for (var key in data) {
            newData[key] = _deconstructPacket(data[key]);
          }
          return newData;
        }
        return data;
      }
    
      var pack = packet;
      pack.data = _deconstructPacket(packetData);
      pack.attachments = buffers.length; // number of binary 'attachments'
      return {packet: pack, buffers: buffers};
    };
    
    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @api public
     */
    
    exports.reconstructPacket = function(packet, buffers) {
      var curPlaceHolder = 0;
    
      function _reconstructPacket(data) {
        if (data && data._placeholder) {
          var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
          return buf;
        } else if (isArray(data)) {
          for (var i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i]);
          }
          return data;
        } else if (data && 'object' == typeof data) {
          for (var key in data) {
            data[key] = _reconstructPacket(data[key]);
          }
          return data;
        }
        return data;
      }
    
      packet.data = _reconstructPacket(packet.data);
      packet.attachments = undefined; // no longer useful
      return packet;
    };
    
    /**
     * Asynchronously removes Blobs or Files from data via
     * FileReader's readAsArrayBuffer method. Used before encoding
     * data as msgpack. Calls callback with the blobless data.
     *
     * @param {Object} data
     * @param {Function} callback
     * @api private
     */
    
    exports.removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj) return obj;
    
        // convert any blob
        if ((global.Blob && obj instanceof Blob) ||
            (global.File && obj instanceof File)) {
          pendingBlobs++;
    
          // async filereader
          var fileReader = new FileReader();
          fileReader.onload = function() { // this.result == arraybuffer
            if (containingObject) {
              containingObject[curKey] = this.result;
            }
            else {
              bloblessData = this.result;
            }
    
            // if nothing pending its callback time
            if(! --pendingBlobs) {
              callback(bloblessData);
            }
          };
    
          fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
        } else if (isArray(obj)) { // handle array
          for (var i = 0; i < obj.length; i++) {
            _removeBlobs(obj[i], i, obj);
          }
        } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }
    
      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };
    
  provide("socket.io-parser/binary", module.exports);
}(global));

// pakmanager:socket.io-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var debug = require('debug')('socket.io-parser');
    var json = require('json3');
    var isArray = require('isarray');
    var Emitter = require('component-emitter');
    var binary =  require('socket.io-parser/binary');
    var isBuf =  require('socket.io-parser/is-buffer');
    
    /**
     * Protocol version.
     *
     * @api public
     */
    
    exports.protocol = 4;
    
    /**
     * Packet types.
     *
     * @api public
     */
    
    exports.types = [
      'CONNECT',
      'DISCONNECT',
      'EVENT',
      'ACK',
      'ERROR',
      'BINARY_EVENT',
      'BINARY_ACK'
    ];
    
    /**
     * Packet type `connect`.
     *
     * @api public
     */
    
    exports.CONNECT = 0;
    
    /**
     * Packet type `disconnect`.
     *
     * @api public
     */
    
    exports.DISCONNECT = 1;
    
    /**
     * Packet type `event`.
     *
     * @api public
     */
    
    exports.EVENT = 2;
    
    /**
     * Packet type `ack`.
     *
     * @api public
     */
    
    exports.ACK = 3;
    
    /**
     * Packet type `error`.
     *
     * @api public
     */
    
    exports.ERROR = 4;
    
    /**
     * Packet type 'binary event'
     *
     * @api public
     */
    
    exports.BINARY_EVENT = 5;
    
    /**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */
    
    exports.BINARY_ACK = 6;
    
    /**
     * Encoder constructor.
     *
     * @api public
     */
    
    exports.Encoder = Encoder;
    
    /**
     * Decoder constructor.
     *
     * @api public
     */
    
    exports.Decoder = Decoder;
    
    /**
     * A socket.io Encoder instance
     *
     * @api public
     */
    
    function Encoder() {}
    
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */
    
    Encoder.prototype.encode = function(obj, callback){
      debug('encoding packet %j', obj);
    
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        encodeAsBinary(obj, callback);
      }
      else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };
    
    /**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */
    
    function encodeAsString(obj) {
      var str = '';
      var nsp = false;
    
      // first is type
      str += obj.type;
    
      // attachments if we have them
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        str += obj.attachments;
        str += '-';
      }
    
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && '/' != obj.nsp) {
        nsp = true;
        str += obj.nsp;
      }
    
      // immediately followed by the id
      if (null != obj.id) {
        if (nsp) {
          str += ',';
          nsp = false;
        }
        str += obj.id;
      }
    
      // json data
      if (null != obj.data) {
        if (nsp) str += ',';
        str += json.stringify(obj.data);
      }
    
      debug('encoded %j as %s', obj, str);
      return str;
    }
    
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */
    
    function encodeAsBinary(obj, callback) {
    
      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
    
        buffers.unshift(pack); // add packet info to beginning of data list
        callback(buffers); // write all the buffers
      }
    
      binary.removeBlobs(obj, writeEncoding);
    }
    
    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */
    
    function Decoder() {
      this.reconstructor = null;
    }
    
    /**
     * Mix in `Emitter` with Decoder.
     */
    
    Emitter(Decoder.prototype);
    
    /**
     * Decodes an ecoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */
    
    Decoder.prototype.add = function(obj) {
      var packet;
      if ('string' == typeof obj) {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
    
          // no attachments, labeled binary but no binary data to follow
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit('decoded', packet);
          }
        } else { // non-binary full packet
          this.emit('decoded', packet);
        }
      }
      else if (isBuf(obj) || obj.base64) { // raw binary data
        if (!this.reconstructor) {
          throw new Error('got binary data when not reconstructing a packet');
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) { // received final buffer
            this.reconstructor = null;
            this.emit('decoded', packet);
          }
        }
      }
      else {
        throw new Error('Unknown type: ' + obj);
      }
    };
    
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */
    
    function decodeString(str) {
      var p = {};
      var i = 0;
    
      // look up type
      p.type = Number(str.charAt(0));
      if (null == exports.types[p.type]) return error();
    
      // look up attachments if type binary
      if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
        var buf = '';
        while (str.charAt(++i) != '-') {
          buf += str.charAt(i);
          if (i == str.length) break;
        }
        if (buf != Number(buf) || str.charAt(i) != '-') {
          throw new Error('Illegal attachments');
        }
        p.attachments = Number(buf);
      }
    
      // look up namespace (if any)
      if ('/' == str.charAt(i + 1)) {
        p.nsp = '';
        while (++i) {
          var c = str.charAt(i);
          if (',' == c) break;
          p.nsp += c;
          if (i == str.length) break;
        }
      } else {
        p.nsp = '/';
      }
    
      // look up id
      var next = str.charAt(i + 1);
      if ('' !== next && Number(next) == next) {
        p.id = '';
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          p.id += str.charAt(i);
          if (i == str.length) break;
        }
        p.id = Number(p.id);
      }
    
      // look up json data
      if (str.charAt(++i)) {
        try {
          p.data = json.parse(str.substr(i));
        } catch(e){
          return error();
        }
      }
    
      debug('decoded %s as %j', str, p);
      return p;
    }
    
    /**
     * Deallocates a parser's resources
     *
     * @api public
     */
    
    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };
    
    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */
    
    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }
    
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */
    
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };
    
    /**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */
    
    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };
    
    function error(data){
      return {
        type: exports.ERROR,
        data: 'parser error'
      };
    }
    
  provide("socket.io-parser", module.exports);
}(global));

// pakmanager:to-array
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = toArray
    
    function toArray(list, index) {
        var array = []
    
        index = index || 0
    
        for (var i = index || 0; i < list.length; i++) {
            array[i - index] = list[i]
        }
    
        return array
    }
    
  provide("to-array", module.exports);
}(global));

// pakmanager:backo2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `Backoff`.
     */
    
    module.exports = Backoff;
    
    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */
    
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    
    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */
    
    Backoff.prototype.duration = function(){
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand =  Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    
    /**
     * Reset the number of attempts.
     *
     * @api public
     */
    
    Backoff.prototype.reset = function(){
      this.attempts = 0;
    };
    
    /**
     * Set the minimum duration
     *
     * @api public
     */
    
    Backoff.prototype.setMin = function(min){
      this.ms = min;
    };
    
    /**
     * Set the maximum duration
     *
     * @api public
     */
    
    Backoff.prototype.setMax = function(max){
      this.max = max;
    };
    
    /**
     * Set the jitter
     *
     * @api public
     */
    
    Backoff.prototype.setJitter = function(jitter){
      this.jitter = jitter;
    };
    
    
  provide("backo2", module.exports);
}(global));

// pakmanager:is-relative
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var isUncPath = require('is-unc-path');
    
    module.exports = function isRelative(fp) {
      if (typeof fp !== 'string') {
        throw new TypeError('isRelative expects a string.');
      }
      // Windows UNC paths are always considered to be absolute.
      return !isUncPath(fp) && !/^([a-z]:)?[\\\/]/i.test(fp);
    };
    
  provide("is-relative", module.exports);
}(global));

// pakmanager:is-windows
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*! is-windows v0.1.0 | MIT LICENSE (c) 2015 | https://github.com/jonschlinkert/is-windows */
    (function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
      } else if (typeof exports === 'object') {
        // Node.js
        module.exports = factory;
      } else {
        // Browser
        root.isWindows = factory();
      }
    }(this, function () {
      'use strict';
    
      return (function isWindows() {
        if (typeof process === 'undefined' || !process) {
          return false;
        }
        return process.platform === 'win32';
      }());
    }));
    
  provide("is-windows", module.exports);
}(global));

// pakmanager:agent-base/patch-core
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var url = require('url');
    var http = require('http');
    var https = require('https');
    var semver = require('semver');
    var inherits = require('util').inherits;
    
    
    // we only need to patch the `http.request()` and
    // `http.ClientRequest` on older versions of Node.js
    if (semver.lt(process.version, '0.11.8')) {
      // subclass the native ClientRequest to include the
      // passed in `options` object.
      http.ClientRequest = (function (_ClientRequest) {
        function ClientRequest (options, cb) {
          this._options = options;
          _ClientRequest.call(this, options, cb);
        }
        inherits(ClientRequest, _ClientRequest);
    
        return ClientRequest;
      })(http.ClientRequest);
    
    
      // need to re-define the `request()` method, since on node v0.8/v0.10
      // the closure-local ClientRequest is used, rather than the monkey
      // patched version we have created here.
      http.request = (function (request) {
        return function (options, cb) {
          if (typeof options === 'string') {
            options = url.parse(options);
          }
          if (options.protocol && options.protocol !== 'http:') {
            throw new Error('Protocol:' + options.protocol + ' not supported.');
          }
          return new http.ClientRequest(options, cb);
        };
      })(http.request);
    }
    
    
    // this currently needs to be applied to all Node.js versions
    // (v0.8.x, v0.10.x, v0.12.x), in order to determine if the `req`
    // is an HTTP or HTTPS request. There is currently no PR attempting
    // to move this property upstream.
    https.request = (function (request) {
      return function (options, cb) {
        if (typeof options === 'string') {
          options = url.parse(options);
        }
        if (null == options.port) options.port = 443;
        options.secureEndpoint = true;
        return request.call(https, options, cb);
      };
    })(https.request);
    
  provide("agent-base/patch-core", module.exports);
}(global));

// pakmanager:agent-base
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
     require('agent-base/patch-core');
    var extend = require('extend');
    var inherits = require('util').inherits;
    var EventEmitter = require('events').EventEmitter;
    
    /**
     * Module exports.
     */
    
    module.exports = Agent;
    
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */
    
    function Agent (callback) {
      if (!(this instanceof Agent)) return new Agent(callback);
      if ('function' != typeof callback) throw new Error('Must pass a "callback function"');
      EventEmitter.call(this);
      this.callback = callback;
    }
    inherits(Agent, EventEmitter);
    
    /**
     * Called by node-core's "_http_client.js" module when creating
     * a new HTTP request with this Agent instance.
     *
     * @api public
     */
    
    Agent.prototype.addRequest = function (req, host, port, localAddress) {
      var opts;
      if ('object' == typeof host) {
        // >= v0.11.x API
        opts = extend({}, req._options, host);
      } else {
        // <= v0.10.x API
        opts = extend({}, req._options, { host: host, port: port });
        if (null != localAddress) {
          opts.localAddress = localAddress;
        }
      }
    
      if (opts.host && opts.path) {
        // if both a `host` and `path` are specified then it's most likely the
        // result of a `url.parse()` call... we need to remove the `path` portion so
        // that `net.connect()` doesn't attempt to open that as a unix socket file.
        delete opts.path;
      }
    
      // set default `port` if none was explicitly specified
      if (null == opts.port) {
        opts.port = opts.secureEndpoint ? 443 : 80;
      }
    
      delete opts.agent;
      delete opts.hostname;
      delete opts._defaultAgent;
      delete opts.defaultPort;
      delete opts.createConnection;
    
      // hint to use "Connection: close"
      // XXX: non-documented `http` module API :(
      req._last = true;
      req.shouldKeepAlive = false;
    
      // clean up a bit of memory since we're no longer using this
      req._options = null;
    
      // create the `net.Socket` instance
      var sync = true;
      this.callback(req, opts, function (err, socket) {
        function emitErr () {
          req.emit('error', err);
          // For Safety. Some additional errors might fire later on
          // and we need to make sure we don't double-fire the error event.
          req._hadError = true;
        }
        if (err) {
          if (sync) {
            // need to defer the "error" event, when sync, because by now the `req`
            // instance hasn't event been passed back to the user yet...
            process.nextTick(emitErr);
          } else {
            emitErr();
          }
        } else {
          req.onSocket(socket);
        }
      });
      sync = false;
    };
    
  provide("agent-base", module.exports);
}(global));

// pakmanager:tar-stream/headers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ZEROS = '0000000000000000000'
    var ZERO_OFFSET = '0'.charCodeAt(0)
    var USTAR = 'ustar\x0000'
    var MASK = parseInt('7777', 8)
    
    var clamp = function (index, len, defaultValue) {
      if (typeof index !== 'number') return defaultValue
      index = ~~index  // Coerce to integer.
      if (index >= len) return len
      if (index >= 0) return index
      index += len
      if (index >= 0) return index
      return 0
    }
    
    var toType = function (flag) {
      switch (flag) {
        case 0:
          return 'file'
        case 1:
          return 'link'
        case 2:
          return 'symlink'
        case 3:
          return 'character-device'
        case 4:
          return 'block-device'
        case 5:
          return 'directory'
        case 6:
          return 'fifo'
        case 7:
          return 'contiguous-file'
        case 72:
          return 'pax-header'
        case 55:
          return 'pax-global-header'
        case 27:
          return 'gnu-long-link-path'
        case 28:
        case 30:
          return 'gnu-long-path'
      }
    
      return null
    }
    
    var toTypeflag = function (flag) {
      switch (flag) {
        case 'file':
          return 0
        case 'link':
          return 1
        case 'symlink':
          return 2
        case 'character-device':
          return 3
        case 'block-device':
          return 4
        case 'directory':
          return 5
        case 'fifo':
          return 6
        case 'contiguous-file':
          return 7
        case 'pax-header':
          return 72
      }
    
      return 0
    }
    
    var alloc = function (size) {
      var buf = new Buffer(size)
      buf.fill(0)
      return buf
    }
    
    var indexOf = function (block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num) return offset
      }
      return end
    }
    
    var cksum = function (block) {
      var sum = 8 * 32
      for (var i = 0; i < 148; i++) sum += block[i]
      for (var j = 156; j < 512; j++) sum += block[j]
      return sum
    }
    
    var encodeOct = function (val, n) {
      val = val.toString(8)
      return ZEROS.slice(0, n - val.length) + val + ' '
    }
    
    /* Copied from the node-tar repo and modified to meet
     * tar-stream coding standard.
     *
     * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
     */
    function parse256 (buf) {
      // first byte MUST be either 80 or FF
      // 80 for positive, FF for 2's comp
      var positive
      if (buf[0] === 0x80) positive = true
      else if (buf[0] === 0xFF) positive = false
      else return null
    
      // build up a base-256 tuple from the least sig to the highest
      var zero = false
      var tuple = []
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i]
        if (positive) tuple.push(byte)
        else if (zero && byte === 0) tuple.push(0)
        else if (zero) {
          zero = false
          tuple.push(0x100 - byte)
        } else tuple.push(0xFF - byte)
      }
    
      var sum = 0
      var l = tuple.length
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i)
      }
    
      return positive ? sum : -1 * sum
    }
    
    var decodeOct = function (val, offset) {
      // If prefixed with 0x80 then parse as a base-256 integer
      if (val[offset] & 0x80) {
        return parse256(val.slice(offset, offset + 8))
      } else {
        // Older versions of tar can prefix with spaces
        while (offset < val.length && val[offset] === 32) offset++
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)
        while (offset < end && val[offset] === 0) offset++
        if (end === offset) return 0
        return parseInt(val.slice(offset, end).toString(), 8)
      }
    }
    
    var decodeStr = function (val, offset, length) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString()
    }
    
    var addLength = function (str) {
      var len = Buffer.byteLength(str)
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1
      if (len + digits > Math.pow(10, digits)) digits++
    
      return (len + digits) + str
    }
    
    exports.decodeLongPath = function (buf) {
      return decodeStr(buf, 0, buf.length)
    }
    
    exports.encodePax = function (opts) { // TODO: encode more stuff in pax
      var result = ''
      if (opts.name) result += addLength(' path=' + opts.name + '\n')
      if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n')
      return new Buffer(result)
    }
    
    exports.decodePax = function (buf) {
      var result = {}
    
      while (buf.length) {
        var i = 0
        while (i < buf.length && buf[i] !== 32) i++
        var len = parseInt(buf.slice(0, i).toString(), 10)
        if (!len) return result
    
        var b = buf.slice(i + 1, len - 1).toString()
        var keyIndex = b.indexOf('=')
        if (keyIndex === -1) return result
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)
    
        buf = buf.slice(len)
      }
    
      return result
    }
    
    exports.encode = function (opts) {
      var buf = alloc(512)
      var name = opts.name
      var prefix = ''
    
      if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'
      if (Buffer.byteLength(name) !== name.length) return null // utf-8
    
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf('/')
        if (i === -1) return null
        prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)
        name = name.slice(i + 1)
      }
    
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null
    
      buf.write(name)
      buf.write(encodeOct(opts.mode & MASK, 6), 100)
      buf.write(encodeOct(opts.uid, 6), 108)
      buf.write(encodeOct(opts.gid, 6), 116)
      buf.write(encodeOct(opts.size, 11), 124)
      buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)
    
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type)
    
      if (opts.linkname) buf.write(opts.linkname, 157)
    
      buf.write(USTAR, 257)
      if (opts.uname) buf.write(opts.uname, 265)
      if (opts.gname) buf.write(opts.gname, 297)
      buf.write(encodeOct(opts.devmajor || 0, 6), 329)
      buf.write(encodeOct(opts.devminor || 0, 6), 337)
    
      if (prefix) buf.write(prefix, 345)
    
      buf.write(encodeOct(cksum(buf), 6), 148)
    
      return buf
    }
    
    exports.decode = function (buf) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET
    
      var name = decodeStr(buf, 0, 100)
      var mode = decodeOct(buf, 100)
      var uid = decodeOct(buf, 108)
      var gid = decodeOct(buf, 116)
      var size = decodeOct(buf, 124)
      var mtime = decodeOct(buf, 136)
      var type = toType(typeflag)
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100)
      var uname = decodeStr(buf, 265, 32)
      var gname = decodeStr(buf, 297, 32)
      var devmajor = decodeOct(buf, 329)
      var devminor = decodeOct(buf, 337)
    
      if (buf[345]) name = decodeStr(buf, 345, 155) + '/' + name
    
      // to support old tar versions that use trailing / to indicate dirs
      if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5
    
      var c = cksum(buf)
    
      // checksum is still initial value if header was null.
      if (c === 8 * 32) return null
    
      // valid checksum
      if (c !== decodeOct(buf, 148)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')
    
      return {
        name: name,
        mode: mode,
        uid: uid,
        gid: gid,
        size: size,
        mtime: new Date(1000 * mtime),
        type: type,
        linkname: linkname,
        uname: uname,
        gname: gname,
        devmajor: devmajor,
        devminor: devminor
      }
    }
    
  provide("tar-stream/headers", module.exports);
}(global));

// pakmanager:tar-stream/extract
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('util')
    var bl = require('bl')
    var xtend = require('xtend')
    var headers =  require('tar-stream/headers')
    
    var Writable = require('readable-stream').Writable
    var PassThrough = require('readable-stream').PassThrough
    
    var noop = function () {}
    
    var overflow = function (size) {
      size &= 511
      return size && 512 - size
    }
    
    var emptyStream = function (self, offset) {
      var s = new Source(self, offset)
      s.end()
      return s
    }
    
    var mixinPax = function (header, pax) {
      if (pax.path) header.name = pax.path
      if (pax.linkpath) header.linkname = pax.linkpath
      return header
    }
    
    var Source = function (self, offset) {
      this._parent = self
      this.offset = offset
      PassThrough.call(this)
    }
    
    util.inherits(Source, PassThrough)
    
    Source.prototype.destroy = function (err) {
      this._parent.destroy(err)
    }
    
    var Extract = function (opts) {
      if (!(this instanceof Extract)) return new Extract(opts)
      Writable.call(this, opts)
    
      this._offset = 0
      this._buffer = bl()
      this._missing = 0
      this._onparse = noop
      this._header = null
      this._stream = null
      this._overflow = null
      this._cb = null
      this._locked = false
      this._destroyed = false
      this._pax = null
      this._paxGlobal = null
      this._gnuLongPath = null
      this._gnuLongLinkPath = null
    
      var self = this
      var b = self._buffer
    
      var oncontinue = function () {
        self._continue()
      }
    
      var onunlock = function (err) {
        self._locked = false
        if (err) return self.destroy(err)
        if (!self._stream) oncontinue()
      }
    
      var onstreamend = function () {
        self._stream = null
        var drain = overflow(self._header.size)
        if (drain) self._parse(drain, ondrain)
        else self._parse(512, onheader)
        if (!self._locked) oncontinue()
      }
    
      var ondrain = function () {
        self._buffer.consume(overflow(self._header.size))
        self._parse(512, onheader)
        oncontinue()
      }
    
      var onpaxglobalheader = function () {
        var size = self._header.size
        self._paxGlobal = headers.decodePax(b.slice(0, size))
        b.consume(size)
        onstreamend()
      }
    
      var onpaxheader = function () {
        var size = self._header.size
        self._pax = headers.decodePax(b.slice(0, size))
        if (self._paxGlobal) self._pax = xtend(self._paxGlobal, self._pax)
        b.consume(size)
        onstreamend()
      }
    
      var ongnulongpath = function () {
        var size = self._header.size
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size))
        b.consume(size)
        onstreamend()
      }
    
      var ongnulonglinkpath = function () {
        var size = self._header.size
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size))
        b.consume(size)
        onstreamend()
      }
    
      var onheader = function () {
        var offset = self._offset
        var header
        try {
          header = self._header = headers.decode(b.slice(0, 512))
        } catch (err) {
          self.emit('error', err)
        }
        b.consume(512)
    
        if (!header) {
          self._parse(512, onheader)
          oncontinue()
          return
        }
        if (header.type === 'gnu-long-path') {
          self._parse(header.size, ongnulongpath)
          oncontinue()
          return
        }
        if (header.type === 'gnu-long-link-path') {
          self._parse(header.size, ongnulonglinkpath)
          oncontinue()
          return
        }
        if (header.type === 'pax-global-header') {
          self._parse(header.size, onpaxglobalheader)
          oncontinue()
          return
        }
        if (header.type === 'pax-header') {
          self._parse(header.size, onpaxheader)
          oncontinue()
          return
        }
    
        if (self._gnuLongPath) {
          header.name = self._gnuLongPath
          self._gnuLongPath = null
        }
    
        if (self._gnuLongLinkPath) {
          header.linkname = self._gnuLongLinkPath
          self._gnuLongLinkPath = null
        }
    
        if (self._pax) {
          self._header = header = mixinPax(header, self._pax)
          self._pax = null
        }
    
        self._locked = true
    
        if (!header.size) {
          self._parse(512, onheader)
          self.emit('entry', header, emptyStream(self, offset), onunlock)
          return
        }
    
        self._stream = new Source(self, offset)
    
        self.emit('entry', header, self._stream, onunlock)
        self._parse(header.size, onstreamend)
        oncontinue()
      }
    
      this._parse(512, onheader)
    }
    
    util.inherits(Extract, Writable)
    
    Extract.prototype.destroy = function (err) {
      if (this._destroyed) return
      this._destroyed = true
    
      if (err) this.emit('error', err)
      this.emit('close')
      if (this._stream) this._stream.emit('close')
    }
    
    Extract.prototype._parse = function (size, onparse) {
      if (this._destroyed) return
      this._offset += size
      this._missing = size
      this._onparse = onparse
    }
    
    Extract.prototype._continue = function () {
      if (this._destroyed) return
      var cb = this._cb
      this._cb = noop
      if (this._overflow) this._write(this._overflow, undefined, cb)
      else cb()
    }
    
    Extract.prototype._write = function (data, enc, cb) {
      if (this._destroyed) return
    
      var s = this._stream
      var b = this._buffer
      var missing = this._missing
    
      // we do not reach end-of-chunk now. just forward it
    
      if (data.length < missing) {
        this._missing -= data.length
        this._overflow = null
        if (s) return s.write(data, cb)
        b.append(data)
        return cb()
      }
    
      // end-of-chunk. the parser should call cb.
    
      this._cb = cb
      this._missing = 0
    
      var overflow = null
      if (data.length > missing) {
        overflow = data.slice(missing)
        data = data.slice(0, missing)
      }
    
      if (s) s.end(data)
      else b.append(data)
    
      this._overflow = overflow
      this._onparse()
    }
    
    module.exports = Extract
    
  provide("tar-stream/extract", module.exports);
}(global));

// pakmanager:tar-stream/pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var constants = require('constants')
    var eos = require('end-of-stream')
    var util = require('util')
    
    var Readable = require('readable-stream').Readable
    var Writable = require('readable-stream').Writable
    var StringDecoder = require('string_decoder').StringDecoder
    
    var headers =  require('tar-stream/headers')
    
    var DMODE = parseInt('755', 8)
    var FMODE = parseInt('644', 8)
    
    var END_OF_TAR = new Buffer(1024)
    END_OF_TAR.fill(0)
    
    var noop = function () {}
    
    var overflow = function (self, size) {
      size &= 511
      if (size) self.push(END_OF_TAR.slice(0, 512 - size))
    }
    
    function modeToType (mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK: return 'block-device'
        case constants.S_IFCHR: return 'character-device'
        case constants.S_IFDIR: return 'directory'
        case constants.S_IFIFO: return 'fifo'
        case constants.S_IFLNK: return 'symlink'
      }
    
      return 'file'
    }
    
    var Sink = function (to) {
      Writable.call(this)
      this.written = 0
      this._to = to
      this._destroyed = false
    }
    
    util.inherits(Sink, Writable)
    
    Sink.prototype._write = function (data, enc, cb) {
      this.written += data.length
      if (this._to.push(data)) return cb()
      this._to._drain = cb
    }
    
    Sink.prototype.destroy = function () {
      if (this._destroyed) return
      this._destroyed = true
      this.emit('close')
    }
    
    var LinkSink = function () {
      Writable.call(this)
      this.linkname = ''
      this._decoder = new StringDecoder('utf-8')
      this._destroyed = false
    }
    
    util.inherits(LinkSink, Writable)
    
    LinkSink.prototype._write = function (data, enc, cb) {
      this.linkname += this._decoder.write(data)
      cb()
    }
    
    LinkSink.prototype.destroy = function () {
      if (this._destroyed) return
      this._destroyed = true
      this.emit('close')
    }
    
    var Void = function () {
      Writable.call(this)
      this._destroyed = false
    }
    
    util.inherits(Void, Writable)
    
    Void.prototype._write = function (data, enc, cb) {
      cb(new Error('No body allowed for this entry'))
    }
    
    Void.prototype.destroy = function () {
      if (this._destroyed) return
      this._destroyed = true
      this.emit('close')
    }
    
    var Pack = function (opts) {
      if (!(this instanceof Pack)) return new Pack(opts)
      Readable.call(this, opts)
    
      this._drain = noop
      this._finalized = false
      this._finalizing = false
      this._destroyed = false
      this._stream = null
    }
    
    util.inherits(Pack, Readable)
    
    Pack.prototype.entry = function (header, buffer, callback) {
      if (this._stream) throw new Error('already piping an entry')
      if (this._finalized || this._destroyed) return
    
      if (typeof buffer === 'function') {
        callback = buffer
        buffer = null
      }
    
      if (!callback) callback = noop
    
      var self = this
    
      if (!header.size) header.size = 0
      if (!header.type) header.type = modeToType(header.mode)
      if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE
      if (!header.uid) header.uid = 0
      if (!header.gid) header.gid = 0
      if (!header.mtime) header.mtime = new Date()
    
      if (typeof buffer === 'string') buffer = new Buffer(buffer)
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length
        this._encode(header)
        this.push(buffer)
        overflow(self, header.size)
        process.nextTick(callback)
        return new Void()
      }
    
      if (header.type === 'symlink' && !header.linkname) {
        var linkSink = new LinkSink()
        eos(linkSink, function (err) {
          if (err) { // stream was closed
            self.destroy()
            return callback(err)
          }
    
          header.linkname = linkSink.linkname
          self._encode(header)
          callback()
        })
    
        return linkSink
      }
    
      this._encode(header)
    
      if (header.type !== 'file' && header.type !== 'contigious-file') {
        process.nextTick(callback)
        return new Void()
      }
    
      var sink = new Sink(this)
    
      this._stream = sink
    
      eos(sink, function (err) {
        self._stream = null
    
        if (err) { // stream was closed
          self.destroy()
          return callback(err)
        }
    
        if (sink.written !== header.size) { // corrupting tar
          self.destroy()
          return callback(new Error('size mismatch'))
        }
    
        overflow(self, header.size)
        if (self._finalizing) self.finalize()
        callback()
      })
    
      return sink
    }
    
    Pack.prototype.finalize = function () {
      if (this._stream) {
        this._finalizing = true
        return
      }
    
      if (this._finalized) return
      this._finalized = true
      this.push(END_OF_TAR)
      this.push(null)
    }
    
    Pack.prototype.destroy = function (err) {
      if (this._destroyed) return
      this._destroyed = true
    
      if (err) this.emit('error', err)
      this.emit('close')
      if (this._stream && this._stream.destroy) this._stream.destroy()
    }
    
    Pack.prototype._encode = function (header) {
      var buf = headers.encode(header)
      if (buf) this.push(buf)
      else this._encodePax(header)
    }
    
    Pack.prototype._encodePax = function (header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname
      })
    
      var newHeader = {
        name: 'PaxHeader',
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: 'pax-header',
        linkname: header.linkname && 'PaxHeader',
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      }
    
      this.push(headers.encode(newHeader))
      this.push(paxHeader)
      overflow(this, paxHeader.length)
    
      newHeader.size = header.size
      newHeader.type = header.type
      this.push(headers.encode(newHeader))
    }
    
    Pack.prototype._read = function (n) {
      var drain = this._drain
      this._drain = noop
      drain()
    }
    
    module.exports = Pack
    
  provide("tar-stream/pack", module.exports);
}(global));

// pakmanager:tar-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.extract =  require('tar-stream/extract')
    exports.pack =  require('tar-stream/pack')
    
  provide("tar-stream", module.exports);
}(global));

// pakmanager:string-width
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var stripAnsi = require('strip-ansi');
    var codePointAt = require('code-point-at');
    var isFullwidthCodePoint = require('is-fullwidth-code-point');
    
    // https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1345
    module.exports = function (str) {
    	if (typeof str !== 'string' || str.length === 0) {
    		return 0;
    	}
    
    	var width = 0;
    
    	str = stripAnsi(str);
    
    	for (var i = 0; i < str.length; i++) {
    		var code = codePointAt(str, i);
    
    		// surrogates
    		if (code >= 0x10000) {
    			i++;
    		}
    
    		if (isFullwidthCodePoint(code)) {
    			width += 2;
    		} else {
    			width++;
    		}
    	}
    
    	return width;
    };
    
  provide("string-width", module.exports);
}(global));

// pakmanager:invert-kv
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (obj) {
    	if (typeof obj !== 'object') {
    		throw new TypeError('Expected an object');
    	}
    
    	var ret = {};
    
    	for (var key in obj) {
    		var val = obj[key];
    		ret[val] = key;
    	}
    
    	return ret;
    };
    
  provide("invert-kv", module.exports);
}(global));

// pakmanager:path-exists
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var fs = require('fs');
    var Promise = require('pinkie-promise');
    
    module.exports = function (fp) {
    	var fn = typeof fs.access === 'function' ? fs.access : fs.stat;
    
    	return new Promise(function (resolve) {
    		fn(fp, function (err) {
    			resolve(!err);
    		});
    	});
    };
    
    module.exports.sync = function (fp) {
    	var fn = typeof fs.accessSync === 'function' ? fs.accessSync : fs.statSync;
    
    	try {
    		fn(fp);
    		return true;
    	} catch (err) {
    		return false;
    	}
    };
    
  provide("path-exists", module.exports);
}(global));

// pakmanager:load-json-file
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var fs = require('graceful-fs');
    var stripBom = require('strip-bom');
    var parseJson = require('parse-json');
    var Promise = require('pinkie-promise');
    var pify = require('pify');
    
    function parse(x, fp) {
    	return parseJson(stripBom(x), path.relative(process.cwd(), fp));
    }
    
    module.exports = function (fp) {
    	return pify(fs.readFile, Promise)(fp, 'utf8').then(function (data) {
    		return parse(data, fp);
    	});
    };
    
    module.exports.sync = function (fp) {
    	return parse(fs.readFileSync(fp, 'utf8'), fp);
    };
    
  provide("load-json-file", module.exports);
}(global));

// pakmanager:path-type
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var fs = require('graceful-fs');
    var Promise = require('pinkie-promise');
    var pify = require('pify');
    
    function type(fn, fn2, fp) {
    	if (typeof fp !== 'string') {
    		return Promise.reject(new TypeError('Expected a string'));
    	}
    
    	return pify(fs[fn], Promise)(fp).then(function (stats) {
    		return stats[fn2]();
    	});
    }
    
    function typeSync(fn, fn2, fp) {
    	if (typeof fp !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return fs[fn](fp)[fn2]();
    }
    
    exports.file = type.bind(null, 'stat', 'isFile');
    exports.dir = type.bind(null, 'stat', 'isDirectory');
    exports.symlink = type.bind(null, 'lstat', 'isSymbolicLink');
    exports.fileSync = typeSync.bind(null, 'statSync', 'isFile');
    exports.dirSync = typeSync.bind(null, 'statSync', 'isDirectory');
    exports.symlinkSync = typeSync.bind(null, 'lstatSync', 'isSymbolicLink');
    
  provide("path-type", module.exports);
}(global));

// pakmanager:lodash.keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.5 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        stringTag = '[object String]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
    
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var getPrototypeOf = Object.getPrototypeOf,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = Object.keys;
    
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty.call(object, key) ||
        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
    }
    
    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) &&
          (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;
    
      for (var key in object) {
        if (baseHas(object, key) &&
            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
            !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }
    
    module.exports = keys;
    
  provide("lodash.keys", module.exports);
}(global));

// pakmanager:lodash.rest
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      var length = args.length;
      switch (length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;
    
    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as an array.
     *
     * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);
    
        while (++index < length) {
          array[index] = args[start + index];
        }
        switch (start) {
          case 0: return func.call(this, array);
          case 1: return func.call(this, args[0], array);
          case 2: return func.call(this, args[0], args[1], array);
        }
        var otherArgs = Array(start + 1);
        index = -1;
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to an integer.
     *
     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3');
     * // => 3
     */
    function toInteger(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      var remainder = value % 1;
      return value === value ? (remainder ? value - remainder : value) : 0;
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    module.exports = rest;
    
  provide("lodash.rest", module.exports);
}(global));

// pakmanager:loose-envify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =   require('loose-envify')(process.env);
    
  provide("loose-envify", module.exports);
}(global));

// pakmanager:depd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * depd
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module dependencies.
     */
    
    var callSiteToString = require('./lib/compat').callSiteToString
    var eventListenerCount = require('./lib/compat').eventListenerCount
    var relative = require('path').relative
    
    /**
     * Module exports.
     */
    
    module.exports = depd
    
    /**
     * Get the path to base files on.
     */
    
    var basePath = process.cwd()
    
    /**
     * Determine if namespace is contained in the string.
     */
    
    function containsNamespace(str, namespace) {
      var val = str.split(/[ ,]+/)
    
      namespace = String(namespace).toLowerCase()
    
      for (var i = 0 ; i < val.length; i++) {
        if (!(str = val[i])) continue;
    
        // namespace contained
        if (str === '*' || str.toLowerCase() === namespace) {
          return true
        }
      }
    
      return false
    }
    
    /**
     * Convert a data descriptor to accessor descriptor.
     */
    
    function convertDataDescriptorToAccessor(obj, prop, message) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
      var value = descriptor.value
    
      descriptor.get = function getter() { return value }
    
      if (descriptor.writable) {
        descriptor.set = function setter(val) { return value = val }
      }
    
      delete descriptor.value
      delete descriptor.writable
    
      Object.defineProperty(obj, prop, descriptor)
    
      return descriptor
    }
    
    /**
     * Create arguments string to keep arity.
     */
    
    function createArgumentsString(arity) {
      var str = ''
    
      for (var i = 0; i < arity; i++) {
        str += ', arg' + i
      }
    
      return str.substr(2)
    }
    
    /**
     * Create stack string from stack.
     */
    
    function createStackString(stack) {
      var str = this.name + ': ' + this.namespace
    
      if (this.message) {
        str += ' deprecated ' + this.message
      }
    
      for (var i = 0; i < stack.length; i++) {
        str += '\n    at ' + callSiteToString(stack[i])
      }
    
      return str
    }
    
    /**
     * Create deprecate for namespace in caller.
     */
    
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError('argument namespace is required')
      }
    
      var stack = getStack()
      var site = callSiteLocation(stack[1])
      var file = site[0]
    
      function deprecate(message) {
        // call to self as log
        log.call(deprecate, message)
      }
    
      deprecate._file = file
      deprecate._ignored = isignored(namespace)
      deprecate._namespace = namespace
      deprecate._traced = istraced(namespace)
      deprecate._warned = Object.create(null)
    
      deprecate.function = wrapfunction
      deprecate.property = wrapproperty
    
      return deprecate
    }
    
    /**
     * Determine if namespace is ignored.
     */
    
    function isignored(namespace) {
      /* istanbul ignore next: tested in a child processs */
      if (process.noDeprecation) {
        // --no-deprecation support
        return true
      }
    
      var str = process.env.NO_DEPRECATION || ''
    
      // namespace ignored
      return containsNamespace(str, namespace)
    }
    
    /**
     * Determine if namespace is traced.
     */
    
    function istraced(namespace) {
      /* istanbul ignore next: tested in a child processs */
      if (process.traceDeprecation) {
        // --trace-deprecation support
        return true
      }
    
      var str = process.env.TRACE_DEPRECATION || ''
    
      // namespace traced
      return containsNamespace(str, namespace)
    }
    
    /**
     * Display deprecation message.
     */
    
    function log(message, site) {
      var haslisteners = eventListenerCount(process, 'deprecation') !== 0
    
      // abort early if no destination
      if (!haslisteners && this._ignored) {
        return
      }
    
      var caller
      var callFile
      var callSite
      var i = 0
      var seen = false
      var stack = getStack()
      var file = this._file
    
      if (site) {
        // provided site
        callSite = callSiteLocation(stack[1])
        callSite.name = site.name
        file = callSite[0]
      } else {
        // get call site
        i = 2
        site = callSiteLocation(stack[i])
        callSite = site
      }
    
      // get caller of deprecated thing in relation to file
      for (; i < stack.length; i++) {
        caller = callSiteLocation(stack[i])
        callFile = caller[0]
    
        if (callFile === file) {
          seen = true
        } else if (callFile === this._file) {
          file = this._file
        } else if (seen) {
          break
        }
      }
    
      var key = caller
        ? site.join(':') + '__' + caller.join(':')
        : undefined
    
      if (key !== undefined && key in this._warned) {
        // already warned
        return
      }
    
      this._warned[key] = true
    
      // generate automatic message from call site
      if (!message) {
        message = callSite === site || !callSite.name
          ? defaultMessage(site)
          : defaultMessage(callSite)
      }
    
      // emit deprecation if listeners exist
      if (haslisteners) {
        var err = DeprecationError(this._namespace, message, stack.slice(i))
        process.emit('deprecation', err)
        return
      }
    
      // format and write message
      var format = process.stderr.isTTY
        ? formatColor
        : formatPlain
      var msg = format.call(this, message, caller, stack.slice(i))
      process.stderr.write(msg + '\n', 'utf8')
    
      return
    }
    
    /**
     * Get call site location as array.
     */
    
    function callSiteLocation(callSite) {
      var file = callSite.getFileName() || '<anonymous>'
      var line = callSite.getLineNumber()
      var colm = callSite.getColumnNumber()
    
      if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ', ' + file
      }
    
      var site = [file, line, colm]
    
      site.callSite = callSite
      site.name = callSite.getFunctionName()
    
      return site
    }
    
    /**
     * Generate a default message from the site.
     */
    
    function defaultMessage(site) {
      var callSite = site.callSite
      var funcName = site.name
    
      // make useful anonymous name
      if (!funcName) {
        funcName = '<anonymous@' + formatLocation(site) + '>'
      }
    
      var context = callSite.getThis()
      var typeName = context && callSite.getTypeName()
    
      // ignore useless type name
      if (typeName === 'Object') {
        typeName = undefined
      }
    
      // make useful type name
      if (typeName === 'Function') {
        typeName = context.name || typeName
      }
    
      return typeName && callSite.getMethodName()
        ? typeName + '.' + funcName
        : funcName
    }
    
    /**
     * Format deprecation message without color.
     */
    
    function formatPlain(msg, caller, stack) {
      var timestamp = new Date().toUTCString()
    
      var formatted = timestamp
        + ' ' + this._namespace
        + ' deprecated ' + msg
    
      // add stack trace
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += '\n    at ' + callSiteToString(stack[i])
        }
    
        return formatted
      }
    
      if (caller) {
        formatted += ' at ' + formatLocation(caller)
      }
    
      return formatted
    }
    
    /**
     * Format deprecation message with color.
     */
    
    function formatColor(msg, caller, stack) {
      var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' // bold cyan
        + ' \x1b[33;1mdeprecated\x1b[22;39m' // bold yellow
        + ' \x1b[0m' + msg + '\x1b[39m' // reset
    
      // add stack trace
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += '\n    \x1b[36mat ' + callSiteToString(stack[i]) + '\x1b[39m' // cyan
        }
    
        return formatted
      }
    
      if (caller) {
        formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m' // cyan
      }
    
      return formatted
    }
    
    /**
     * Format call site location.
     */
    
    function formatLocation(callSite) {
      return relative(basePath, callSite[0])
        + ':' + callSite[1]
        + ':' + callSite[2]
    }
    
    /**
     * Get the stack as array of call sites.
     */
    
    function getStack() {
      var limit = Error.stackTraceLimit
      var obj = {}
      var prep = Error.prepareStackTrace
    
      Error.prepareStackTrace = prepareObjectStackTrace
      Error.stackTraceLimit = Math.max(10, limit)
    
      // capture the stack
      Error.captureStackTrace(obj)
    
      // slice this function off the top
      var stack = obj.stack.slice(1)
    
      Error.prepareStackTrace = prep
      Error.stackTraceLimit = limit
    
      return stack
    }
    
    /**
     * Capture call site stack from v8.
     */
    
    function prepareObjectStackTrace(obj, stack) {
      return stack
    }
    
    /**
     * Return a wrapped function in a deprecation message.
     */
    
    function wrapfunction(fn, message) {
      if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function')
      }
    
      var args = createArgumentsString(fn.length)
      var deprecate = this
      var stack = getStack()
      var site = callSiteLocation(stack[1])
    
      site.name = fn.name
    
      var deprecatedfn = eval('(function (' + args + ') {\n'
        + '"use strict"\n'
        + 'log.call(deprecate, message, site)\n'
        + 'return fn.apply(this, arguments)\n'
        + '})')
    
      return deprecatedfn
    }
    
    /**
     * Wrap property in a deprecation message.
     */
    
    function wrapproperty(obj, prop, message) {
      if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
        throw new TypeError('argument obj must be object')
      }
    
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop)
    
      if (!descriptor) {
        throw new TypeError('must call property on owner object')
      }
    
      if (!descriptor.configurable) {
        throw new TypeError('property must be configurable')
      }
    
      var deprecate = this
      var stack = getStack()
      var site = callSiteLocation(stack[1])
    
      // set site name
      site.name = prop
    
      // convert data descriptor
      if ('value' in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message)
      }
    
      var get = descriptor.get
      var set = descriptor.set
    
      // wrap getter
      if (typeof get === 'function') {
        descriptor.get = function getter() {
          log.call(deprecate, message, site)
          return get.apply(this, arguments)
        }
      }
    
      // wrap setter
      if (typeof set === 'function') {
        descriptor.set = function setter() {
          log.call(deprecate, message, site)
          return set.apply(this, arguments)
        }
      }
    
      Object.defineProperty(obj, prop, descriptor)
    }
    
    /**
     * Create DeprecationError for deprecation
     */
    
    function DeprecationError(namespace, message, stack) {
      var error = new Error()
      var stackString
    
      Object.defineProperty(error, 'constructor', {
        value: DeprecationError
      })
    
      Object.defineProperty(error, 'message', {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
      })
    
      Object.defineProperty(error, 'name', {
        enumerable: false,
        configurable: true,
        value: 'DeprecationError',
        writable: true
      })
    
      Object.defineProperty(error, 'namespace', {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
      })
    
      Object.defineProperty(error, 'stack', {
        configurable: true,
        enumerable: false,
        get: function () {
          if (stackString !== undefined) {
            return stackString
          }
    
          // prepare stack trace
          return stackString = createStackString.call(this, stack)
        },
        set: function setter(val) {
          stackString = val
        }
      })
    
      return error
    }
    
  provide("depd", module.exports);
}(global));

// pakmanager:destroy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * destroy
     * Copyright(c) 2014 Jonathan Ong
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var ReadStream = require('fs').ReadStream
    var Stream = require('stream')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = destroy
    
    /**
     * Destroy a stream.
     *
     * @param {object} stream
     * @public
     */
    
    function destroy(stream) {
      if (stream instanceof ReadStream) {
        return destroyReadStream(stream)
      }
    
      if (!(stream instanceof Stream)) {
        return stream
      }
    
      if (typeof stream.destroy === 'function') {
        stream.destroy()
      }
    
      return stream
    }
    
    /**
     * Destroy a ReadStream.
     *
     * @param {object} stream
     * @private
     */
    
    function destroyReadStream(stream) {
      stream.destroy()
    
      if (typeof stream.close === 'function') {
        // node.js core bug work-around
        stream.on('open', onOpenClose)
      }
    
      return stream
    }
    
    /**
     * On open handler to close stream.
     * @private
     */
    
    function onOpenClose() {
      if (typeof this.fd === 'number') {
        // actually close down the fd
        this.close()
      }
    }
    
  provide("destroy", module.exports);
}(global));

// pakmanager:etag
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * etag
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = etag
    
    /**
     * Module dependencies.
     * @private
     */
    
    var crypto = require('crypto')
    var Stats = require('fs').Stats
    
    /**
     * Module variables.
     * @private
     */
    
    var base64PadCharRegExp = /=+$/
    var toString = Object.prototype.toString
    
    /**
     * Generate an entity tag.
     *
     * @param {Buffer|string} entity
     * @return {string}
     * @private
     */
    
    function entitytag(entity) {
      if (entity.length === 0) {
        // fast-path empty
        return '"0-1B2M2Y8AsgTpgAmY7PhCfg"'
      }
    
      // compute hash of entity
      var hash = crypto
        .createHash('md5')
        .update(entity, 'utf8')
        .digest('base64')
        .replace(base64PadCharRegExp, '')
    
      // compute length of entity
      var len = typeof entity === 'string'
        ? Buffer.byteLength(entity, 'utf8')
        : entity.length
    
      return '"' + len.toString(16) + '-' + hash + '"'
    }
    
    /**
     * Create a simple ETag.
     *
     * @param {string|Buffer|Stats} entity
     * @param {object} [options]
     * @param {boolean} [options.weak]
     * @return {String}
     * @public
     */
    
    function etag(entity, options) {
      if (entity == null) {
        throw new TypeError('argument entity is required')
      }
    
      // support fs.Stats object
      var isStats = isstats(entity)
      var weak = options && typeof options.weak === 'boolean'
        ? options.weak
        : isStats
    
      // validate argument
      if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
        throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
      }
    
      // generate entity tag
      var tag = isStats
        ? stattag(entity)
        : entitytag(entity)
    
      return weak
        ? 'W/' + tag
        : tag
    }
    
    /**
     * Determine if object is a Stats object.
     *
     * @param {object} obj
     * @return {boolean}
     * @api private
     */
    
    function isstats(obj) {
      // genuine fs.Stats
      if (typeof Stats === 'function' && obj instanceof Stats) {
        return true
      }
    
      // quack quack
      return obj && typeof obj === 'object'
        && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]'
        && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]'
        && 'ino' in obj && typeof obj.ino === 'number'
        && 'size' in obj && typeof obj.size === 'number'
    }
    
    /**
     * Generate a tag for a stat.
     *
     * @param {object} stat
     * @return {string}
     * @private
     */
    
    function stattag(stat) {
      var mtime = stat.mtime.getTime().toString(16)
      var size = stat.size.toString(16)
    
      return '"' + size + '-' + mtime + '"'
    }
    
  provide("etag", module.exports);
}(global));

// pakmanager:fresh
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Expose `fresh()`.
     */
    
    module.exports = fresh;
    
    /**
     * Check freshness of `req` and `res` headers.
     *
     * When the cache is "fresh" __true__ is returned,
     * otherwise __false__ is returned to indicate that
     * the cache is now stale.
     *
     * @param {Object} req
     * @param {Object} res
     * @return {Boolean}
     * @api public
     */
    
    function fresh(req, res) {
      // defaults
      var etagMatches = true;
      var notModified = true;
    
      // fields
      var modifiedSince = req['if-modified-since'];
      var noneMatch = req['if-none-match'];
      var lastModified = res['last-modified'];
      var etag = res['etag'];
      var cc = req['cache-control'];
    
      // unconditional request
      if (!modifiedSince && !noneMatch) return false;
    
      // check for no-cache cache request directive
      if (cc && cc.indexOf('no-cache') !== -1) return false;  
    
      // parse if-none-match
      if (noneMatch) noneMatch = noneMatch.split(/ *, */);
    
      // if-none-match
      if (noneMatch) {
        etagMatches = noneMatch.some(function (match) {
          return match === '*' || match === etag || match === 'W/' + etag;
        });
      }
    
      // if-modified-since
      if (modifiedSince) {
        modifiedSince = new Date(modifiedSince);
        lastModified = new Date(lastModified);
        notModified = lastModified <= modifiedSince;
      }
    
      return !! (etagMatches && notModified);
    }
    
  provide("fresh", module.exports);
}(global));

// pakmanager:http-errors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var statuses = require('statuses');
    var inherits = require('inherits');
    
    function toIdentifier(str) {
      return str.split(' ').map(function (token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1)
      }).join('').replace(/[^ _0-9a-z]/gi, '')
    }
    
    exports = module.exports = function httpError() {
      // so much arity going on ~_~
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
          continue;
        }
        switch (typeof arg) {
          case 'string':
            msg = arg;
            break;
          case 'number':
            status = arg;
            break;
          case 'object':
            props = arg;
            break;
        }
      }
    
      if (typeof status !== 'number' || !statuses[status]) {
        status = 500
      }
    
      // constructor
      var HttpError = exports[status]
    
      if (!err) {
        // create error
        err = HttpError
          ? new HttpError(msg)
          : new Error(msg || statuses[status])
        Error.captureStackTrace(err, httpError)
      }
    
      if (!HttpError || !(err instanceof HttpError)) {
        // add properties to generic error
        err.expose = status < 500
        err.status = err.statusCode = status
      }
    
      for (var key in props) {
        if (key !== 'status' && key !== 'statusCode') {
          err[key] = props[key]
        }
      }
    
      return err;
    };
    
    var HttpError = exports.HttpError = function HttpError() {
      throw new TypeError('cannot construct abstract class');
    };
    
    inherits(HttpError, Error);
    
    // create generic error objects
    var codes = statuses.codes.filter(function (num) {
      return num >= 400;
    });
    
    codes.forEach(function (code) {
      var name = toIdentifier(statuses[code])
      var className = name.match(/Error$/) ? name : name + 'Error'
    
      if (code >= 500) {
        var ServerError = function ServerError(msg) {
          var self = new Error(msg != null ? msg : statuses[code])
          Error.captureStackTrace(self, ServerError)
          self.__proto__ = ServerError.prototype
          Object.defineProperty(self, 'name', {
            enumerable: false,
            configurable: true,
            value: className,
            writable: true
          })
          return self
        }
        inherits(ServerError, HttpError);
        ServerError.prototype.status =
        ServerError.prototype.statusCode = code;
        ServerError.prototype.expose = false;
        exports[code] =
        exports[name] = ServerError
        return;
      }
    
      var ClientError = function ClientError(msg) {
        var self = new Error(msg != null ? msg : statuses[code])
        Error.captureStackTrace(self, ClientError)
        self.__proto__ = ClientError.prototype
        Object.defineProperty(self, 'name', {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        })
        return self
      }
      inherits(ClientError, HttpError);
      ClientError.prototype.status =
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      exports[code] =
      exports[name] = ClientError
      return;
    });
    
    // backwards-compatibility
    exports["I'mateapot"] = exports.ImATeapot
    
  provide("http-errors", module.exports);
}(global));

// pakmanager:mime
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var fs = require('fs');
    
    function Mime() {
      // Map of extension -> mime type
      this.types = Object.create(null);
    
      // Map of mime type -> extension
      this.extensions = Object.create(null);
    }
    
    /**
     * Define mimetype -> extension mappings.  Each key is a mime-type that maps
     * to an array of extensions associated with the type.  The first extension is
     * used as the default extension for the type.
     *
     * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
     *
     * @param map (Object) type definitions
     */
    Mime.prototype.define = function (map) {
      for (var type in map) {
        var exts = map[type];
        for (var i = 0; i < exts.length; i++) {
          if (process.env.DEBUG_MIME && this.types[exts]) {
            console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
              this.types[exts] + ' to ' + type);
          }
    
          this.types[exts[i]] = type;
        }
    
        // Default extension is the first one we encounter
        if (!this.extensions[type]) {
          this.extensions[type] = exts[0];
        }
      }
    };
    
    /**
     * Load an Apache2-style ".types" file
     *
     * This may be called multiple times (it's expected).  Where files declare
     * overlapping types/extensions, the last file wins.
     *
     * @param file (String) path of file to load.
     */
    Mime.prototype.load = function(file) {
      this._loading = file;
      // Read file and split into lines
      var map = {},
          content = fs.readFileSync(file, 'ascii'),
          lines = content.split(/[\r\n]+/);
    
      lines.forEach(function(line) {
        // Clean up whitespace/comments, and split into fields
        var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
        map[fields.shift()] = fields;
      });
    
      this.define(map);
    
      this._loading = null;
    };
    
    /**
     * Lookup a mime type based on extension
     */
    Mime.prototype.lookup = function(path, fallback) {
      var ext = path.replace(/.*[\.\/\\]/, '').toLowerCase();
    
      return this.types[ext] || fallback || this.default_type;
    };
    
    /**
     * Return file extension associated with a mime type
     */
    Mime.prototype.extension = function(mimeType) {
      var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
      return this.extensions[type];
    };
    
    // Default instance
    var mime = new Mime();
    
    // Define built-in types
    mime.define(require('./types.json'));
    
    // Default type
    mime.default_type = mime.lookup('bin');
    
    //
    // Additional API specific to the default instance
    //
    
    mime.Mime = Mime;
    
    /**
     * Lookup a charset based on mime type.
     */
    mime.charsets = {
      lookup: function(mimeType, fallback) {
        // Assume text types are utf8
        return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
      }
    };
    
    module.exports = mime;
    
  provide("mime", module.exports);
}(global));

// pakmanager:range-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * range-parser
     * Copyright(c) 2012-2014 TJ Holowaychuk
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = rangeParser;
    
    /**
     * Parse "Range" header `str` relative to the given file `size`.
     *
     * @param {Number} size
     * @param {String} str
     * @return {Array}
     * @public
     */
    
    function rangeParser(size, str) {
      var valid = true;
      var i = str.indexOf('=');
    
      if (-1 == i) return -2;
    
      var arr = str.slice(i + 1).split(',').map(function(range){
        var range = range.split('-')
          , start = parseInt(range[0], 10)
          , end = parseInt(range[1], 10);
    
        // -nnn
        if (isNaN(start)) {
          start = size - end;
          end = size - 1;
        // nnn-
        } else if (isNaN(end)) {
          end = size - 1;
        }
    
        // limit last-byte-pos to current length
        if (end > size - 1) end = size - 1;
    
        // invalid
        if (isNaN(start)
          || isNaN(end)
          || start > end
          || start < 0) valid = false;
    
        return {
          start: start,
          end: end
        };
      });
    
      arr.type = str.slice(0, i);
    
      return valid ? arr : -1;
    }
    
  provide("range-parser", module.exports);
}(global));

// pakmanager:url-parse/lolcation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as the a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 }
      , URL;
    
    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @api public
     */
    module.exports = function lolcation(loc) {
      loc = loc || global.location || {};
      URL = URL || require('./');
    
      var finaldestination = {}
        , type = typeof loc
        , key;
    
      if ('blob:' === loc.protocol) {
        finaldestination = new URL(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new URL(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) for (key in loc) {
        if (key in ignore) continue;
        finaldestination[key] = loc[key];
      }
    
      return finaldestination;
    };
    
  provide("url-parse/lolcation", module.exports);
}(global));

// pakmanager:url-parse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var required = require('requires-port')
      , lolcation =  require('url-parse/lolcation')
      , qs = require('querystringify')
      , relativere = /^\/(?!\/)/;
    
    /**
     * These are the parse instructions for the URL parsers, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var instructions = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      ['//', 'protocol', 2, 1, 1],          // Extract from the front.
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/\:(\d+)$/, 'port'],                 // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];
    
    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my CDO.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Boolean|function} parser Parser for the query string.
     * @param {Object} location Location defaults for relative paths.
     * @api public
     */
    function URL(address, location, parser) {
      if (!(this instanceof URL)) {
        return new URL(address, location, parser);
      }
    
      var relative = relativere.test(address)
        , parse, instruction, index, key
        , type = typeof location
        , url = this
        , i = 0;
    
      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }
    
      if (parser && 'function' !== typeof parser) {
        parser = qs.parse;
      }
    
      location = lolcation(location);
    
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        parse = instruction[0];
        key = instruction[1];
    
        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, address.length - index[0].length);
        }
    
        url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');
    
        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) {
          url[key] = url[key].toLowerCase();
        }
      }
    
      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);
    
      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }
    
      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }
    
      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }
    
    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} prop Property we need to adjust.
     * @param {Mixed} value The newly assigned value.
     * @returns {URL}
     * @api public
     */
    URL.prototype.set = function set(part, value, fn) {
      var url = this;
    
      if ('query' === part) {
        if ('string' === typeof value && value.length) {
          value = (fn || qs.parse)(value);
        }
    
        url[part] = value;
      } else if ('port' === part) {
        url[part] = value;
    
        if (!required(value, url.protocol)) {
          url.host = url.hostname;
          url[part] = '';
        } else if (value) {
          url.host = url.hostname +':'+ value;
        }
      } else if ('hostname' === part) {
        url[part] = value;
    
        if (url.port) value += ':'+ url.port;
        url.host = value;
      } else if ('host' === part) {
        url[part] = value;
    
        if (/\:\d+/.test(value)) {
          value = value.split(':');
          url.hostname = value[0];
          url.port = value[1];
        }
      } else {
        url[part] = value;
      }
    
      url.href = url.toString();
      return url;
    };
    
    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String}
     * @api public
     */
    URL.prototype.toString = function toString(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
    
      var query
        , url = this
        , result = url.protocol +'//';
    
      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }
    
      result += url.hostname;
      if (url.port) result += ':'+ url.port;
    
      result += url.pathname;
    
      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
    
      if (url.hash) result += url.hash;
    
      return result;
    };
    
    //
    // Expose the URL parser and some additional properties that might be useful for
    // others.
    //
    URL.qs = qs;
    URL.location = lolcation;
    module.exports = URL;
    
  provide("url-parse", module.exports);
}(global));

// pakmanager:prr
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
      * prr
      * (c) 2013 Rod Vagg <rod@vagg.org>
      * https://github.com/rvagg/prr
      * License: MIT
      */
    
    (function (name, context, definition) {
      if (typeof module != 'undefined' && module.exports)
        module.exports = definition()
      else
        context[name] = definition()
    })('prr', this, function() {
    
      var setProperty = typeof Object.defineProperty == 'function'
          ? function (obj, key, options) {
              Object.defineProperty(obj, key, options)
              return obj
            }
          : function (obj, key, options) { // < es5
              obj[key] = options.value
              return obj
            }
    
        , makeOptions = function (value, options) {
            var oo = typeof options == 'object'
              , os = !oo && typeof options == 'string'
              , op = function (p) {
                  return oo
                    ? !!options[p]
                    : os
                      ? options.indexOf(p[0]) > -1
                      : false
                }
    
            return {
                enumerable   : op('enumerable')
              , configurable : op('configurable')
              , writable     : op('writable')
              , value        : value
            }
          }
    
        , prr = function (obj, key, value, options) {
            var k
    
            options = makeOptions(value, options)
    
            if (typeof key == 'object') {
              for (k in key) {
                if (Object.hasOwnProperty.call(key, k)) {
                  options.value = key[k]
                  setProperty(obj, k, options)
                }
              }
              return obj
            }
    
            return setProperty(obj, key, options)
          }
    
      return prr
    })
  provide("prr", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:dashify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * dashify <https://github.com/jonschlinkert/dashify>
     *
     * Copyright (c) 2015 Jon Schlinkert.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    module.exports = function dashify(str) {
      if (typeof str !== 'string') {
        throw new TypeError('dashify expects a string.');
      }
      str = str.replace(/([a-z])([A-Z])/g, '$1-$2');
      str = str.replace(/[ \t\W]/g, '-');
      str = str.replace(/^\W+/, '');
      return str.toLowerCase();
    };
    
  provide("dashify", module.exports);
}(global));

// pakmanager:lodash._baseeach
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        stringTag = '[object String]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
    
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var getPrototypeOf = Object.getPrototypeOf,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = Object.keys;
    
    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);
    
    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();
    
    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty.call(object, key) ||
        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
    }
    
    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);
    
        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    
    /**
     * Creates a base function for methods like `_.forIn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;
    
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) &&
          (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;
    
      for (var key in object) {
        if (baseHas(object, key) &&
            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
            !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }
    
    module.exports = baseEach;
    
  provide("lodash._baseeach", module.exports);
}(global));

// pakmanager:lodash._baseiteratee
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.5.2 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    
    /** Used to compose bitmasks for comparison styles. */
    var UNORDERED_COMPARE_FLAG = 1,
        PARTIAL_COMPARE_FLAG = 2;
    
    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    
    var arrayBufferTag = '[object ArrayBuffer]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    
    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    
    /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    
    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;
    
    /** Used to detect host constructors (Safari > 5). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dateTag] = typedArrayTags[errorTag] =
    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
    typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);
    
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;
    
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
    
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    
    /**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the new array of key-value pairs.
     */
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /**
     * Converts `map` to an array.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the converted array.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
    
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    
    /**
     * Converts `set` to an array.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the converted array.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
    
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    
    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;
    
    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );
    
    /** Built-in value references. */
    var Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        getPrototypeOf = Object.getPrototypeOf,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = Object.keys;
    
    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    
    /** Used to detect maps, sets, and weakmaps. */
    var mapCtorString = Map ? funcToString.call(Map) : '',
        setCtorString = Set ? funcToString.call(Set) : '',
        weakMapCtorString = WeakMap ? funcToString.call(WeakMap) : '';
    
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;
    
    /**
     * Creates an hash object.
     *
     * @private
     * @constructor
     * @returns {Object} Returns the new hash object.
     */
    function Hash() {}
    
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(hash, key) {
      return hashHas(hash, key) && delete hash[key];
    }
    
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(hash, key) {
      if (nativeCreate) {
        var result = hash[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
    }
    
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(hash, key) {
      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
    }
    
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function hashSet(hash, key, value) {
      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    }
    
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function MapCache(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapClear() {
      this.__data__ = {
        'hash': new Hash,
        'map': Map ? new Map : [],
        'string': new Hash
      };
    }
    
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapDelete(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
    }
    
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapGet(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.get(key) : assocGet(data.map, key);
    }
    
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.has(key) : assocHas(data.map, key);
    }
    
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache object.
     */
    function mapSet(key, value) {
      var data = this.__data__;
      if (isKeyable(key)) {
        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
      } else if (Map) {
        data.map.set(key, value);
      } else {
        assocSet(data.map, key, value);
      }
      return this;
    }
    
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function Stack(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = { 'array': [], 'map': null };
    }
    
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocDelete(array, key) : data.map['delete'](key);
    }
    
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocGet(array, key) : data.map.get(key);
    }
    
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocHas(array, key) : data.map.has(key);
    }
    
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache object.
     */
    function stackSet(key, value) {
      var data = this.__data__,
          array = data.array;
    
      if (array) {
        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
          assocSet(array, key, value);
        } else {
          data.array = null;
          data.map = new MapCache(array);
        }
      }
      var map = data.map;
      if (map) {
        map.set(key, value);
      }
      return this;
    }
    
    /**
     * Removes `key` and its value from the associative array.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function assocDelete(array, key) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = array.length - 1;
      if (index == lastIndex) {
        array.pop();
      } else {
        splice.call(array, index, 1);
      }
      return true;
    }
    
    /**
     * Gets the associative array value for `key`.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function assocGet(array, key) {
      var index = assocIndexOf(array, key);
      return index < 0 ? undefined : array[index][1];
    }
    
    /**
     * Checks if an associative array value for `key` exists.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function assocHas(array, key) {
      return assocIndexOf(array, key) > -1;
    }
    
    /**
     * Gets the index at which the first occurrence of `key` is found in `array`
     * of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    
    /**
     * Sets the associative array `key` to `value`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function assocSet(array, key, value) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        array.push([key, value]);
      } else {
        array[index][1] = value;
      }
    }
    
    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
    function baseCastPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    
    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = isKey(path, object) ? [path + ''] : baseCastPath(path);
    
      var index = 0,
          length = path.length;
    
      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index == length) ? object : undefined;
    }
    
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty.call(object, key) ||
        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
    }
    
    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return key in Object(object);
    }
    
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {boolean} [bitmask] The bitmask of comparison flags.
     *  The bitmask may be composed of the following flags:
     *     1 - Unordered comparison
     *     2 - Partial comparison
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;
    
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;
    
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
          : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    
        if (objIsWrapped || othIsWrapped) {
          stack || (stack = new Stack);
          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;
    
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];
    
        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack,
              result = customizer ? customizer(objValue, srcValue, key, object, source, stack) : undefined;
    
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }
    
    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      var type = typeof value;
      if (type == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (type == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }
    
    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    
    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        var key = matchData[0][0],
            value = matchData[0][1];
    
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === value &&
            (value !== undefined || (key in Object(object)));
        };
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(path, srcValue) {
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    
    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;
    
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;
    
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var index = -1,
          isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,
          arrLength = array.length,
          othLength = other.length;
    
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked) {
        return stacked == other;
      }
      var result = true;
      stack.set(array, other);
    
      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];
    
        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (isUnordered) {
          if (!arraySome(other, function(othValue) {
                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);
              })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      return result;
    }
    
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
    
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;
    
        case errorTag:
          return object.name == other.name && object.message == other.message;
    
        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object) ? other != +other : object == +other;
    
        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
    
        case mapTag:
          var convert = mapToArray;
    
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
    
          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          // Recursively compare objects (susceptible to call stack limits).
          return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask | UNORDERED_COMPARE_FLAG, stack.set(object, other));
    
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} customizer The function to customize comparisons.
     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual` for more details.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
          objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;
    
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : baseHas(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
    
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];
    
        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;
    
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      return result;
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = toPairs(object),
          length = result.length;
    
      while (length--) {
        result[length][2] = isStrictComparable(result[length][1]);
      }
      return result;
    }
    
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }
    
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function getTag(value) {
      return objectToString.call(value);
    }
    
    // Fallback for IE 11 providing `toStringTag` values for maps, sets, and weakmaps.
    if ((Map && getTag(new Map) != mapTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : null,
            ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';
    
        if (ctorString) {
          switch (ctorString) {
            case mapCtorString: return mapTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }
    
    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      if (object == null) {
        return false;
      }
      var result = hasFunc(object, path);
      if (!result && !isKey(path)) {
        path = baseCastPath(path);
        object = parent(object, path);
        if (object != null) {
          path = last(path);
          result = hasFunc(object, path);
        }
      }
      var length = object ? object.length : undefined;
      return result || (
        !!length && isLength(length) && isIndex(path, length) &&
        (isArray(object) || isString(object) || isArguments(object))
      );
    }
    
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) &&
          (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (typeof value == 'number') {
        return true;
      }
      return !isArray(value) &&
        (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
          (object != null && value in Object(object)));
    }
    
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return type == 'number' || type == 'boolean' ||
        (type == 'string' && value != '__proto__') || value == null;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    
    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length == 1 ? object : get(object, baseSlice(path, 0, -1));
    }
    
    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    function stringToPath(string) {
      var result = [];
      toString(string).replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }
    
    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(funcToString.call(value));
      }
      return isObjectLike(value) &&
        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && objectToString.call(value) == symbolTag);
    }
    
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    
    /**
     * Converts `value` to a string if it's not one. An empty string is returned
     * for `null` and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (value == null) {
        return '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }
    
    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    
    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b.c');
     * // => true
     *
     * _.hasIn(object, ['a', 'b', 'c']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return hasPath(object, path, baseHasIn);
    }
    
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;
    
      for (var key in object) {
        if (baseHas(object, key) &&
            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
            !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }
    
    /**
     * Creates an array of own enumerable key-value pairs for `object` which
     * can be consumed by `_.fromPairs`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    function toPairs(object) {
      return baseToPairs(object, keys(object));
    }
    
    /**
     * This method returns the first argument given to it.
     *
     * @static
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }
    
    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': { 'c': 2 } } },
     *   { 'a': { 'b': { 'c': 1 } } }
     * ];
     *
     * _.map(objects, _.property('a.b.c'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
    }
    
    // Avoid inheriting from `Object.prototype` when possible.
    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
    
    // Add functions to the `MapCache`.
    MapCache.prototype.clear = mapClear;
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;
    
    // Add functions to the `Stack` cache.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    
    module.exports = baseIteratee;
    
  provide("lodash._baseiteratee", module.exports);
}(global));

// pakmanager:lodash._basereduce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 3.0.2 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }
    
    module.exports = baseReduce;
    
  provide("lodash._basereduce", module.exports);
}(global));

// pakmanager:util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }
    
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };
    
    
    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function(fn, msg) {
      // Allow for deprecating things in the process of starting up.
      if (isUndefined(global.process)) {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
    
      if (process.noDeprecation === true) {
        return fn;
      }
    
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
    
      return deprecated;
    };
    
    
    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };
    
    
    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    
    
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };
    
    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };
    
    
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
    
      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }
    
    
    function stylizeNoColor(str, styleType) {
      return str;
    }
    
    
    function arrayToHash(array) {
      var hash = {};
    
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
    
      return hash;
    }
    
    
    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
    
      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
    
      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
    
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
    
      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }
    
      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
    
      var base = '', array = false, braces = ['{', '}'];
    
      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }
    
      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }
    
      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }
    
      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }
    
      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
    
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
    
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
    
      ctx.seen.push(value);
    
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
    
      ctx.seen.pop();
    
      return reduceToSingleString(output, base, braces);
    }
    
    
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }
    
    
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    
    
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }
    
    
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
    
      return name + ': ' + str;
    }
    
    
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
    
      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }
    
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }
    
    
    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;
    
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;
    
    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;
    
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;
    
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;
    
    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;
    
    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;
    
    exports.isBuffer = require('./support/isBuffer');
    
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    
    
    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }
    
    
    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];
    
    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }
    
    
    // log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };
    
    
    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */
    exports.inherits = require('inherits');
    
    exports._extend = function(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;
    
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
  provide("util", module.exports);
}(global));

// pakmanager:JSONStream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  #! /usr/bin/env node
    
    'use strict'
    
    var Parser = require('jsonparse')
      , through = require('through')
    
    /*
    
      the value of this.stack that creationix's jsonparse has is weird.
    
      it makes this code ugly, but his problem is way harder that mine,
      so i'll forgive him.
    
    */
    
    exports.parse = function (path, map) {
    
      var parser = new Parser()
      var stream = through(function (chunk) {
        if('string' === typeof chunk)
          chunk = new Buffer(chunk)
        parser.write(chunk)
      },
      function (data) {
        if(data)
          stream.write(data)
        stream.queue(null)
      })
    
      if('string' === typeof path)
        path = path.split('.').map(function (e) {
          if (e === '$*')
            return {emitKey: true}
          else if (e === '*')
            return true
          else if (e === '') // '..'.split('.') returns an empty string
            return {recurse: true}
          else
            return e
        })
    
    
      var count = 0, _key
      if(!path || !path.length)
        path = null
    
      parser.onValue = function (value) {
        if (!this.root)
          stream.root = value
    
        if(! path) return
    
        var i = 0 // iterates on path
        var j  = 0 // iterates on stack
        var emitKey = false;
        while (i < path.length) {
          var key = path[i]
          var c
          j++
    
          if (key && !key.recurse) {
            c = (j === this.stack.length) ? this : this.stack[j]
            if (!c) return
            if (! check(key, c.key)) return
            emitKey = !!key.emitKey;
            i++
          } else {
            i++
            var nextKey = path[i]
            if (! nextKey) return
            while (true) {
              c = (j === this.stack.length) ? this : this.stack[j]
              if (!c) return
              if (check(nextKey, c.key)) {
                i++;
                this.stack[j].value = null
                break
              }
              j++
            }
          }
    
        }
        if (j !== this.stack.length) return
    
        count ++
        var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])
        var data = this.value[this.key]
        if(null != data)
          if(null != (data = map ? map(data, actualPath) : data)) {
            data = emitKey ? { value: data, key: this.key } : data;
            stream.queue(data)
          }
        delete this.value[this.key]
        for(var k in this.stack)
          this.stack[k].value = null
      }
      parser._onToken = parser.onToken;
    
      parser.onToken = function (token, value) {
        parser._onToken(token, value);
        if (this.stack.length === 0) {
          if (stream.root) {
            if(!path)
              stream.queue(stream.root)
            count = 0;
            stream.root = null;
          }
        }
      }
      
      parser.onError = function (err) {
        if(err.message.indexOf("at position") > -1)
          err.message = "Invalid JSON (" + err.message + ")";
        stream.emit('error', err)
      }
    
    
      return stream
    }
    
    function check (x, y) {
      if ('string' === typeof x)
        return y == x
      else if (x && 'function' === typeof x.exec)
        return x.exec(y)
      else if ('boolean' === typeof x || 'object' === typeof x)
        return x
      else if ('function' === typeof x)
        return x(y)
      return false
    }
    
    exports.stringify = function (op, sep, cl, indent) {
      indent = indent || 0
      if (op === false){
        op = ''
        sep = '\n'
        cl = ''
      } else if (op == null) {
    
        op = '[\n'
        sep = '\n,\n'
        cl = '\n]\n'
    
      }
    
      //else, what ever you like
    
      var stream
        , first = true
        , anyData = false
      stream = through(function (data) {
        anyData = true
        var json = JSON.stringify(data, null, indent)
        if(first) { first = false ; stream.queue(op + json)}
        else stream.queue(sep + json)
      },
      function (data) {
        if(!anyData)
          stream.queue(op)
        stream.queue(cl)
        stream.queue(null)
      })
    
      return stream
    }
    
    exports.stringifyObject = function (op, sep, cl, indent) {
      indent = indent || 0
      if (op === false){
        op = ''
        sep = '\n'
        cl = ''
      } else if (op == null) {
    
        op = '{\n'
        sep = '\n,\n'
        cl = '\n}\n'
    
      }
    
      //else, what ever you like
    
      var first = true
      var anyData = false
      var stream = through(function (data) {
        anyData = true
        var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)
        if(first) { first = false ; this.queue(op + json)}
        else this.queue(sep + json)
      },
      function (data) {
        if(!anyData) this.queue(op)
        this.queue(cl)
    
        this.queue(null)
      })
    
      return stream
    }
    
    if(!module.parent && process.title !== 'browser') {
      process.stdin
        .pipe(exports.parse(process.argv[2]))
        .pipe(exports.stringify('[', ',\n', ']\n', 2))
        .pipe(process.stdout)
    }
    
  provide("JSONStream", module.exports);
}(global));

// pakmanager:combine-source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var path            =  require('path');
    var convert         =  require('convert-source-map');
    var memoize         =  require('lodash.memoize');
    var createGenerator =  require('inline-source-map');
    var pathIsAbsolute  =  require('./lib/path-is-absolute');
    var mappingsFromMap =  require('./lib/mappings-from-map');
    
    var protocolRx = /^[a-z]+:\/\//;
    
    /**
     * Rebases a relative path in 'sourceFile' to be relative
     * to the path where 'sourceFile' is located.
     * 
     * This is necessary before adding relative paths to the
     * new combined map to ensure all paths are relative to their
     * original source.
     * 
     * The 'sourceRoot' from the original source map is joined
     * as well to ensure the complete path.
     *
     * Resulting paths that are absolute are passed along directly.
     *
     * @param sourceFile {String} path to the original source file that references a map
     * @param relativeRoot {String} sourceRoot in sourceFile's map to combine with relativePath
     * @param relativePath {String} source path from sourceFile's map
     */
    var rebaseRelativePath = memoize(function(sourceFile, relativeRoot, relativePath) {
      if (!relativePath) {
        return relativePath;
      }
    
      // join relative path to root (e.g. 'src/' + 'file.js')
      var relativeRootedPath = relativeRoot ? path.join(relativeRoot, relativePath) : relativePath;
    
      if (sourceFile === relativeRootedPath ||    // same path,
          pathIsAbsolute(relativeRootedPath) ||   // absolute path, nor
          protocolRx.test(relativeRootedPath)) {  // absolute protocol need rebasing
        return relativeRootedPath;
      }
    
      // make relative to source file
      return path.join(path.dirname(sourceFile), relativeRootedPath);
    }, function(a, b, c) {
      return a + '::' + b + '::' + c;
    });
    
    function resolveMap(source) {
      var gen = convert.fromSource(source);
      return gen ? gen.toObject() : null;
    }
    
    function hasInlinedSource(existingMap) {
      return existingMap.sourcesContent && !!existingMap.sourcesContent[0];
    }
    
    function Combiner(file, sourceRoot) {
      // since we include the original code in the map sourceRoot actually not needed
      this.generator = createGenerator({ file: file || 'generated.js', sourceRoot: sourceRoot });
    }
    
    Combiner.prototype._addGeneratedMap = function (sourceFile, source, offset) {
      this.generator.addGeneratedMappings(sourceFile, source, offset);
      this.generator.addSourceContent(sourceFile, source);
      return this;
    };
    
    Combiner.prototype._addExistingMap = function (sourceFile, source, existingMap, offset) {
      var mappings = mappingsFromMap(existingMap);
    
      // add all of the sources from the map
      for (var i = 0, len = existingMap.sources.length; i < len; i++) {
        if (!existingMap.sourcesContent) continue;
    
        this.generator.addSourceContent(
          rebaseRelativePath(sourceFile, existingMap.sourceRoot, existingMap.sources[i]),
          existingMap.sourcesContent[i]);
      }
    
      // add the mappings, preserving the original mapping 'source'
      mappings.forEach(function(mapping) {
        // Add the mappings one at a time because 'inline-source-map' doesn't handle
        // mapping source filenames. The mapping.source already takes sourceRoot into account
        // per the SMConsumer.eachMapping function, so pass null for the root here.
        this.generator.addMappings(
          rebaseRelativePath(sourceFile, null, mapping.source), [mapping], offset);
      }, this);
    
      return this;
    };
    
    /**
     * Adds map to underlying source map.
     * If source contains a source map comment that has the source of the original file inlined it will offset these
     * mappings and include them.
     * If no source map comment is found or it has no source inlined, mappings for the file will be generated and included
     *
     * @name addMap
     * @function
     * @param opts {Object} { sourceFile: {String}, source: {String} }
     * @param offset {Object} { line: {Number}, column: {Number} }
     */
    Combiner.prototype.addFile = function (opts, offset) {
    
      offset = offset || {};
      if (!offset.hasOwnProperty('line'))  offset.line    =  0;
      if (!offset.hasOwnProperty('column')) offset.column =  0;
    
      var existingMap = resolveMap(opts.source);
    
      return existingMap && hasInlinedSource(existingMap)
        ? this._addExistingMap(opts.sourceFile, opts.source, existingMap, offset)
        : this._addGeneratedMap(opts.sourceFile, opts.source, offset);
    };
    
    /**
    * @name base64
    * @function
    * @return {String} base64 encoded combined source map
    */
    Combiner.prototype.base64 = function () {
      return this.generator.base64Encode();
    };
    
    /**
     * @name comment
     * @function
     * @return {String} base64 encoded sourceMappingUrl comment of the combined source map
     */
    Combiner.prototype.comment = function () {
      return this.generator.inlineMappingUrl();
    };
    
    /**
     * @name create
     * @function
     * @param file {String} optional name of the generated file
     * @param sourceRoot {String} optional sourceRoot of the map to be generated
     * @return {Object} Combiner instance to which source maps can be added and later combined
     */
    exports.create = function (file, sourceRoot) { return new Combiner(file, sourceRoot); };
    
    /**
     * @name removeComments
     * @function
     * @param src
     * @return {String} src with all sourceMappingUrl comments removed
     */
    exports.removeComments = function (src) {
      if (!src.replace) return src;
      return src.replace(convert.commentRegex, '').replace(convert.mapFileCommentRegex, '');
    };
    
  provide("combine-source-map", module.exports);
}(global));

// pakmanager:through2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Transform = require('readable-stream/transform')
      , inherits  = require('util').inherits
      , xtend     = require('xtend')
    
    function DestroyableTransform(opts) {
      Transform.call(this, opts)
      this._destroyed = false
    }
    
    inherits(DestroyableTransform, Transform)
    
    DestroyableTransform.prototype.destroy = function(err) {
      if (this._destroyed) return
      this._destroyed = true
      
      var self = this
      process.nextTick(function() {
        if (err)
          self.emit('error', err)
        self.emit('close')
      })
    }
    
    // a noop _transform function
    function noop (chunk, enc, callback) {
      callback(null, chunk)
    }
    
    
    // create a new export function, used by both the main export and
    // the .ctor export, contains common logic for dealing with arguments
    function through2 (construct) {
      return function (options, transform, flush) {
        if (typeof options == 'function') {
          flush     = transform
          transform = options
          options   = {}
        }
    
        if (typeof transform != 'function')
          transform = noop
    
        if (typeof flush != 'function')
          flush = null
    
        return construct(options, transform, flush)
      }
    }
    
    
    // main export, just make me a transform stream!
    module.exports = through2(function (options, transform, flush) {
      var t2 = new DestroyableTransform(options)
    
      t2._transform = transform
    
      if (flush)
        t2._flush = flush
    
      return t2
    })
    
    
    // make me a reusable prototype that I can `new`, or implicitly `new`
    // with a constructor call
    module.exports.ctor = through2(function (options, transform, flush) {
      function Through2 (override) {
        if (!(this instanceof Through2))
          return new Through2(override)
    
        this.options = xtend(options, override)
    
        DestroyableTransform.call(this, this.options)
      }
    
      inherits(Through2, DestroyableTransform)
    
      Through2.prototype._transform = transform
    
      if (flush)
        Through2.prototype._flush = flush
    
      return Through2
    })
    
    
    module.exports.obj = through2(function (options, transform, flush) {
      var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))
    
      t2._transform = transform
    
      if (flush)
        t2._flush = flush
    
      return t2
    })
    
  provide("through2", module.exports);
}(global));

// pakmanager:umd
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    
    var templateSTR = "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}defineNamespace()}})(function(){source()});";
    
    function template(moduleName, options) {
      if (typeof options === 'boolean') {
        options = {commonJS: options};
      } else if (!options) {
        options = {};
      }
      var str = templateSTR.replace(/defineNamespace\(\)/g, compileNamespace(moduleName))
        .split('source()')
      str[0] = str[0].trim();
      //make sure these are undefined so as to not get confused if modules have inner UMD systems
      str[0] += 'var define,module,exports;';
      if (options.commonJS) str[0] += 'module={exports:(exports={})};';
      str[0] += '\n';
      if (options.commonJS) str[1] = 'return module.exports;' + str[1];
      str[1] = '\n' + str[1];
      return str;
    }
    
    exports = module.exports = function (name, src, options) {
      if (typeof options === 'string' && typeof src === 'object') {
        var tmp = options;
        options = src;
        src = tmp;
      }
      return exports.prelude(name, options) + src + exports.postlude(name, options);
    };
    
    exports.prelude = function (moduleName, options) {
      return template(moduleName, options)[0];
    };
    exports.postlude = function (moduleName, options) {
      return template(moduleName, options)[1];
    };
    
    
    function camelCase(name) {
      name = name.replace(/\-([a-z])/g, function (_, char) { return char.toUpperCase(); });
      if (!/^[a-zA-Z_$]$/.test(name[0])) {
        name = name.substr(1);
      }
      var result = name.replace(/[^\w$]+/g, '')
      if (!result) {
        throw new Error('Invalid JavaScript identifier resulted from camel-casing');
      }
      return result
    }
    
    
    function compileNamespace(name) {
      var names = name.split('.')
    
      // No namespaces, yield the best case 'global.NAME = VALUE'
      if (names.length === 1) {
        return 'g.' + camelCase(name) + ' = f()';
    
      // Acceptable case, with reasonable compilation
      } else if (names.length === 2) {
        names = names.map(camelCase);
        return '(g.' + names[0] + ' || (g.' + names[0] + ' = {})).' + names[1] + ' = f()';
    
      // Worst case, too many namespaces to care about
      } else {
        var valueContainer = names.pop()
        return names.map(compileNamespaceStep)
                    .concat(['g.' + camelCase(valueContainer) + ' = f()'])
                    .join(';');
      }
    }
    
    function compileNamespaceStep(name) {
      name = camelCase(name);
      return 'g=(g.' + name + '||(g.' + name + ' = {}))';
    }
    
  provide("umd", module.exports);
}(global));

// pakmanager:pako
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Top level file is just a mixin of submodules & constants
    'use strict';
    
    var assign    = require('./lib/utils/common').assign;
    
    var deflate   = require('./lib/deflate');
    var inflate   = require('./lib/inflate');
    var constants = require('./lib/zlib/constants');
    
    var pako = {};
    
    assign(pako, deflate, inflate, constants);
    
    module.exports = pako;
    
  provide("pako", module.exports);
}(global));

// pakmanager:ieee754
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
    
      i += d
    
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = nBytes * 8 - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
    
      value = Math.abs(value)
    
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
    
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
    
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
      buffer[offset + i - d] |= s * 128
    }
    
  provide("ieee754", module.exports);
}(global));

// pakmanager:date-now
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = Date.now || now
    
    function now() {
        return new Date().getTime()
    }
    
  provide("date-now", module.exports);
}(global));

// pakmanager:browserify-cipher
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
    
    exports.createCipher = exports.Cipher = crypto.createCipher
    exports.createCipheriv = exports.Cipheriv = crypto.createCipheriv
    exports.createDecipher = exports.Decipher = crypto.createDecipher
    exports.createDecipheriv = exports.Decipheriv = crypto.createDecipheriv
    exports.listCiphers = exports.getCiphers = crypto.getCiphers
    
  provide("browserify-cipher", module.exports);
}(global));

// pakmanager:browserify-sign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
    
    exports.createSign = crypto.createSign
    exports.Sign = crypto.Sign
    
    exports.createVerify = crypto.createVerify
    exports.Verify = crypto.Verify
    
  provide("browserify-sign", module.exports);
}(global));

// pakmanager:create-ecdh/browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var elliptic = require('elliptic');
    var BN = require('bn.js');
    
    module.exports = function createECDH(curve) {
    	return new ECDH(curve);
    };
    
    var aliases = {
    	secp256k1: {
    		name: 'secp256k1',
    		byteLength: 32
    	},
    	secp224r1: {
    		name: 'p224',
    		byteLength: 28
    	},
    	prime256v1: {
    		name: 'p256',
    		byteLength: 32
    	},
    	prime192v1: {
    		name: 'p192',
    		byteLength: 24
    	},
    	ed25519: {
    		name: 'ed25519',
    		byteLength: 32
    	},
    	secp384r1: {
    		name: 'p384',
    		byteLength: 48
    	},
    	secp521r1: {
    		name: 'p521',
    		byteLength: 66
    	}
    };
    
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    
    function ECDH(curve) {
    	this.curveType = aliases[curve];
    	if (!this.curveType ) {
    		this.curveType = {
    			name: curve
    		};
    	}
    	this.curve = new elliptic.ec(this.curveType.name);
    	this.keys = void 0;
    }
    
    ECDH.prototype.generateKeys = function (enc, format) {
    	this.keys = this.curve.genKeyPair();
    	return this.getPublicKey(enc, format);
    };
    
    ECDH.prototype.computeSecret = function (other, inenc, enc) {
    	inenc = inenc || 'utf8';
    	if (!Buffer.isBuffer(other)) {
    		other = new Buffer(other, inenc);
    	}
    	var otherPub = this.curve.keyFromPublic(other).getPublic();
    	var out = otherPub.mul(this.keys.getPrivate()).getX();
    	return formatReturnValue(out, enc, this.curveType.byteLength);
    };
    
    ECDH.prototype.getPublicKey = function (enc, format) {
    	var key = this.keys.getPublic(format === 'compressed', true);
    	if (format === 'hybrid') {
    		if (key[key.length - 1] % 2) {
    			key[0] = 7;
    		} else {
    			key [0] = 6;
    		}
    	}
    	return formatReturnValue(key, enc);
    };
    
    ECDH.prototype.getPrivateKey = function (enc) {
    	return formatReturnValue(this.keys.getPrivate(), enc);
    };
    
    ECDH.prototype.setPublicKey = function (pub, enc) {
    	enc = enc || 'utf8';
    	if (!Buffer.isBuffer(pub)) {
    		pub = new Buffer(pub, enc);
    	}
    	this.keys._importPublic(pub);
    	return this;
    };
    
    ECDH.prototype.setPrivateKey = function (priv, enc) {
    	enc = enc || 'utf8';
    	if (!Buffer.isBuffer(priv)) {
    		priv = new Buffer(priv, enc);
    	}
    	var _priv = new BN(priv);
    	_priv = _priv.toString(16);
    	this.keys._importPrivate(_priv);
    	return this;
    };
    
    function formatReturnValue(bn, enc, len) {
    	if (!Array.isArray(bn)) {
    		bn = bn.toArray();
    	}
    	var buf = new Buffer(bn);
    	if (len && buf.length < len) {
    		var zeros = new Buffer(len - buf.length);
    		zeros.fill(0);
    		buf = Buffer.concat([zeros, buf]);
    	}
    	if (!enc) {
    		return buf;
    	} else {
    		return buf.toString(enc);
    	}
    }
    
  provide("create-ecdh/browser", module.exports);
}(global));

// pakmanager:create-ecdh
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var createECDH = require('crypto').createECDH;
    
    module.exports = createECDH ||  require('create-ecdh/browser');
  provide("create-ecdh", module.exports);
}(global));

// pakmanager:diffie-hellman
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto')
    
    // getDiffieHellman
    exports.DiffieHellmanGroup = crypto.DiffieHellmanGroup
    exports.createDiffieHellmanGroup = crypto.createDiffieHellmanGroup
    exports.getDiffieHellman = crypto.getDiffieHellman
    
    // createDiffieHellman
    exports.createDiffieHellman = crypto.createDiffieHellman
    exports.DiffieHellman = crypto.DiffieHellman
    
  provide("diffie-hellman", module.exports);
}(global));

// pakmanager:public-encrypt/mgf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var createHash = require('create-hash');
    module.exports = function (seed, len) {
      var t = new Buffer('');
      var  i = 0, c;
      while (t.length < len) {
        c = i2ops(i++);
        t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
      }
      return t.slice(0, len);
    };
    
    function i2ops(c) {
      var out = new Buffer(4);
      out.writeUInt32BE(c,0);
      return out;
    }
  provide("public-encrypt/mgf", module.exports);
}(global));

// pakmanager:public-encrypt/xor
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function xor(a, b) {
      var len = a.length;
      var i = -1;
      while (++i < len) {
        a[i] ^= b[i];
      }
      return a
    };
  provide("public-encrypt/xor", module.exports);
}(global));

// pakmanager:public-encrypt/withPublic
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var bn = require('bn.js');
    function withPublic(paddedMsg, key) {
      return new Buffer(paddedMsg
        .toRed(bn.mont(key.modulus))
        .redPow(new bn(key.publicExponent))
        .fromRed()
        .toArray());
    }
    
    module.exports = withPublic;
  provide("public-encrypt/withPublic", module.exports);
}(global));

// pakmanager:public-encrypt/publicEncrypt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parseKeys = require('parse-asn1');
    var randomBytes = require('randombytes');
    var createHash = require('create-hash');
    var mgf =  require('public-encrypt/mgf');
    var xor =  require('public-encrypt/xor');
    var bn = require('bn.js');
    var withPublic =  require('public-encrypt/withPublic');
    var crt = require('browserify-rsa');
    
    var constants = {
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_PKCS1_PADDIN: 1,
      RSA_NO_PADDING: 3
    };
    
    module.exports = function publicEncrypt(public_key, msg, reverse) {
      var padding;
      if (public_key.padding) {
        padding = public_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      var key = parseKeys(public_key);
      var paddedMsg;
      if (padding === 4) {
        paddedMsg = oaep(key, msg);
      } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        paddedMsg = new bn(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
          throw new Error('data too long for modulus');
        }
      } else {
        throw new Error('unknown padding');
      }
      if (reverse) {
        return crt(paddedMsg, key);
      } else {
        return withPublic(paddedMsg, key);
      }
    };
    
    function oaep(key, msg){
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (mLen > k - hLen2 - 2) {
        throw new Error('message too long');
      }
      var ps = new Buffer(k - mLen - hLen2 - 2);
      ps.fill(0);
      var dblen = k - hLen - 1;
      var seed = randomBytes(hLen);
      var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
      var maskedSeed = xor(seed, mgf(maskedDb, hLen));
      return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
    }
    function pkcs1(key, msg, reverse){
      var mLen = msg.length;
      var k = key.modulus.byteLength();
      if (mLen > k - 11) {
        throw new Error('message too long');
      }
      var ps;
      if (reverse) {
        ps = new Buffer(k - mLen - 3);
        ps.fill(0xff);
      } else {
        ps = nonZero(k - mLen - 3);
      }
      return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
    }
    function nonZero(len, crypto) {
      var out = new Buffer(len);
      var i = 0;
      var cache = randomBytes(len*2);
      var cur = 0;
      var num;
      while (i < len) {
        if (cur === cache.length) {
          cache = randomBytes(len*2);
          cur = 0;
        }
        num = cache[cur++];
        if (num) {
          out[i++] = num;
        }
      }
      return out;
    }
  provide("public-encrypt/publicEncrypt", module.exports);
}(global));

// pakmanager:public-encrypt/privateDecrypt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parseKeys = require('parse-asn1');
    var mgf =  require('public-encrypt/mgf');
    var xor =  require('public-encrypt/xor');
    var bn = require('bn.js');
    var crt = require('browserify-rsa');
    var createHash = require('create-hash');
    var withPublic =  require('public-encrypt/withPublic');
    module.exports = function privateDecrypt(private_key, enc, reverse) {
      var padding;
      if (private_key.padding) {
        padding = private_key.padding;
      } else if (reverse) {
        padding = 1;
      } else {
        padding = 4;
      }
      
      var key = parseKeys(private_key);
      var k = key.modulus.byteLength();
      if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
        throw new Error('decryption error');
      }
      var msg;
      if (reverse) {
        msg = withPublic(new bn(enc), key);
      } else {
        msg = crt(enc, key);
      }
      var zBuffer = new Buffer(k - msg.length);
      zBuffer.fill(0);
      msg = Buffer.concat([zBuffer, msg], k);
      if (padding === 4) {
        return oaep(key, msg);
      } else if (padding === 1) {
        return pkcs1(key, msg, reverse);
      } else if (padding === 3) {
        return msg;
      } else {
        throw new Error('unknown padding');
      }
    };
    
    function oaep(key, msg){
      var n = key.modulus;
      var k = key.modulus.byteLength();
      var mLen = msg.length;
      var iHash = createHash('sha1').update(new Buffer('')).digest();
      var hLen = iHash.length;
      var hLen2 = 2 * hLen;
      if (msg[0] !== 0) {
        throw new Error('decryption error');
      }
      var maskedSeed = msg.slice(1, hLen + 1);
      var maskedDb =  msg.slice(hLen + 1);
      var seed = xor(maskedSeed, mgf(maskedDb, hLen));
      var db = xor(maskedDb, mgf(seed, k - hLen - 1));
      if (compare(iHash, db.slice(0, hLen))) {
        throw new Error('decryption error');
      }
      var i = hLen;
      while (db[i] === 0) {
        i++;
      }
      if (db[i++] !== 1) {
        throw new Error('decryption error');
      }
      return db.slice(i);
    }
    
    function pkcs1(key, msg, reverse){
      var p1 = msg.slice(0, 2);
      var i = 2;
      var status = 0;
      while (msg[i++] !== 0) {
        if (i >= msg.length) {
          status++;
          break;
        }
      }
      var ps = msg.slice(2, i - 1);
      var p2 = msg.slice(i - 1, i);
    
      if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
        status++;
      }
      if (ps.length < 8) {
        status++;
      }
      if (status) {
        throw new Error('decryption error');
      }
      return  msg.slice(i);
    }
    function compare(a, b){
      a = new Buffer(a);
      b = new Buffer(b);
      var dif = 0;
      var len = a.length;
      if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
      }
      var i = -1;
      while (++i < len) {
        dif += (a[i] ^ b[i]);
      }
      return dif;
    }
  provide("public-encrypt/privateDecrypt", module.exports);
}(global));

// pakmanager:public-encrypt/browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.publicEncrypt =  require('public-encrypt/publicEncrypt');
    exports.privateDecrypt =  require('public-encrypt/privateDecrypt');
    
    exports.privateEncrypt = function privateEncrypt(key, buf) {
      return exports.publicEncrypt(key, buf, true);
    };
    
    exports.publicDecrypt = function publicDecrypt(key, buf) {
      return exports.privateDecrypt(key, buf, true);
    };
  provide("public-encrypt/browser", module.exports);
}(global));

// pakmanager:public-encrypt
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var crypto = require('crypto');
    if (typeof crypto.publicEncrypt !== 'function') {
      crypto =  require('public-encrypt/browser');
    }
    exports.publicEncrypt = crypto.publicEncrypt;
    exports.privateDecrypt = crypto.privateDecrypt;
    
    if (typeof crypto.privateEncrypt !== 'function') {
      exports.privateEncrypt =  require('public-encrypt/browser').privateEncrypt;
    } else {
      exports.privateEncrypt = crypto.privateEncrypt;
    }
    
    if (typeof crypto.publicDecrypt !== 'function') {
      exports.publicDecrypt =  require('public-encrypt/browser').publicDecrypt;
    } else {
      exports.publicDecrypt = crypto.publicDecrypt;
    }
  provide("public-encrypt", module.exports);
}(global));

// pakmanager:shasum
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var createHash = require('crypto').createHash 
    var Buffer = require('buffer').Buffer
    var stringify = require('json-stable-stringify')
    
    module.exports = function hash (str, alg, format) {
      str = 'string' === typeof str ? str
        : Buffer.isBuffer(str) ? str
        : stringify(str)
      return createHash(alg || 'sha1')
        .update(str, Buffer.isBuffer(str) ? null : 'utf8').digest(format || 'hex')
    }
    
    
  provide("shasum", module.exports);
}(global));

// pakmanager:subarg
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var minimist = require('minimist');
    
    module.exports = function parse (args, opts) {
        var level = 0, index;
        var args_ = [];
        
        for (var i = 0; i < args.length; i++) {
            if (typeof args[i] === 'string' && /^\[/.test(args[i])) {
                if (level ++ === 0) {
                    index = i;
                }
            }
            if (typeof args[i] === 'string' && /\]$/.test(args[i])) {
                if (-- level > 0) continue;
                
                var sub = args.slice(index, i + 1);
                if (typeof sub[0] === 'string') {
                    sub[0] = sub[0].replace(/^\[/, '');
                }
                if (sub[0] === '') sub.shift();
                
                var n = sub.length - 1;
                if (typeof sub[n] === 'string') {
                    sub[n] = sub[n].replace(/\]$/, '');
                }
                if (sub[n] === '') sub.pop();
                
                args_.push(parse(sub));
            }
            else if (level === 0) args_.push(args[i]);
        }
        
        var argv = minimist(args_, opts);
        return argv;
    };
    
  provide("subarg", module.exports);
}(global));

// pakmanager:function-bind/implementation
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = '[object Function]';
    
    module.exports = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
    
        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };
    
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }
    
        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);
    
        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }
    
        return bound;
    };
    
  provide("function-bind/implementation", module.exports);
}(global));

// pakmanager:function-bind
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var implementation =  require('function-bind/implementation');
    
    module.exports = Function.prototype.bind || implementation;
    
  provide("function-bind", module.exports);
}(global));

// pakmanager:builtin-status-codes
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    module.exports = require('http').STATUS_CODES
    
  provide("builtin-status-codes", module.exports);
}(global));

// pakmanager:to-arraybuffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Buffer = require('buffer').Buffer
    
    module.exports = function (buf) {
    	// If the buffer is backed by a Uint8Array, a faster version will work
    	if (buf instanceof Uint8Array) {
    		// If the buffer isn't a subarray, return the underlying ArrayBuffer
    		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
    			return buf.buffer
    		} else if (typeof buf.buffer.slice === 'function') {
    			// Otherwise we need to get a proper copy
    			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
    		}
    	}
    
    	if (Buffer.isBuffer(buf)) {
    		// This is the slow version that will work with any Buffer
    		// implementation (even in old browsers)
    		var arrayCopy = new Uint8Array(buf.length)
    		var len = buf.length
    		for (var i = 0; i < len; i++) {
    			arrayCopy[i] = buf[i]
    		}
    		return arrayCopy.buffer
    	} else {
    		throw new Error('Argument must be a Buffer')
    	}
    }
    
  provide("to-arraybuffer", module.exports);
}(global));

// pakmanager:concat-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Writable = require('readable-stream').Writable
    var inherits = require('inherits')
    
    if (typeof Uint8Array === 'undefined') {
      var U8 = require('typedarray').Uint8Array
    } else {
      var U8 = Uint8Array
    }
    
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)
    
      if (typeof opts === 'function') {
        cb = opts
        opts = {}
      }
      if (!opts) opts = {}
    
      var encoding = opts.encoding
      var shouldInferEncoding = false
    
      if (!encoding) {
        shouldInferEncoding = true
      } else {
        encoding =  String(encoding).toLowerCase()
        if (encoding === 'u8' || encoding === 'uint8') {
          encoding = 'uint8array'
        }
      }
    
      Writable.call(this, { objectMode: true })
    
      this.encoding = encoding
      this.shouldInferEncoding = shouldInferEncoding
    
      if (cb) this.on('finish', function () { cb(this.getBody()) })
      this.body = []
    }
    
    module.exports = ConcatStream
    inherits(ConcatStream, Writable)
    
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk)
      next()
    }
    
    ConcatStream.prototype.inferEncoding = function (buff) {
      var firstBuffer = buff === undefined ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer)) return 'buffer'
      if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
      if (Array.isArray(firstBuffer)) return 'array'
      if (typeof firstBuffer === 'string') return 'string'
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
      return 'buffer'
    }
    
    ConcatStream.prototype.getBody = function () {
      if (!this.encoding && this.body.length === 0) return []
      if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
      if (this.encoding === 'array') return arrayConcat(this.body)
      if (this.encoding === 'string') return stringConcat(this.body)
      if (this.encoding === 'buffer') return bufferConcat(this.body)
      if (this.encoding === 'uint8array') return u8Concat(this.body)
      return this.body
    }
    
    var isArray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
    
    function isArrayish (arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr))
    }
    
    function stringConcat (parts) {
      var strings = []
      var needsToString = false
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (typeof p === 'string') {
          strings.push(p)
        } else if (Buffer.isBuffer(p)) {
          strings.push(p)
        } else {
          strings.push(Buffer(p))
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings)
        strings = strings.toString('utf8')
      } else {
        strings = strings.join('')
      }
      return strings
    }
    
    function bufferConcat (parts) {
      var bufs = []
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i]
        if (Buffer.isBuffer(p)) {
          bufs.push(p)
        } else if (typeof p === 'string' || isArrayish(p)
        || (p && typeof p.subarray === 'function')) {
          bufs.push(Buffer(p))
        } else bufs.push(Buffer(String(p)))
      }
      return Buffer.concat(bufs)
    }
    
    function arrayConcat (parts) {
      var res = []
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i])
      }
      return res
    }
    
    function u8Concat (parts) {
      var len = 0
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === 'string') {
          parts[i] = Buffer(parts[i])
        }
        len += parts[i].length
      }
      var u8 = new U8(len)
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i]
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j]
        }
      }
      return u8
    }
    
  provide("concat-stream", module.exports);
}(global));

// pakmanager:lexical-scope
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var astw = require('astw');
    
    module.exports = function (src) {
        var locals = {};
        var implicit = {};
        var exported = {};
        var implicitProps = {};
        
        if (typeof src === 'string') {
            src = String(src).replace(/^#![^\n]*\n/, '');
        }
        if (src && typeof src === 'object'
        && typeof src.copy === 'function' && typeof src.toString === 'function') {
            src = src.toString('utf8');
        }
        var walk = astw(src);
        
        walk(function (node) {
            if (node.type === 'VariableDeclaration') {
                // take off the leading `var `
                var id = getScope(node);
                for (var i = 0; i < node.declarations.length; i++) {
                    var d = node.declarations[i];
                    locals[id][d.id.name] = d;
                }
            }
            else if (node.type === 'CatchClause') {
                var id = getScope(node);
                locals[id][node.param.name] = node.param
            }
            else if (isFunction(node)) {
                var id = getScope(node.parent);
                if (node.id) locals[id][node.id.name] = node;
                var nid = node.params.length && getScope(node);
                if (nid && !locals[nid]) locals[nid] = {};
                for (var i = 0; i < node.params.length; i++) {
                    var p = node.params[i];
                    locals[nid][p.name] = p;
                }
            }
        });
        
        walk(function (node) {
            if (node.type === 'Identifier'
            && lookup(node) === undefined) {
                if (node.parent.type === 'Property'
                && node.parent.key === node) return;
                if (node.parent.type === 'MemberExpression'
                && node.parent.property === node) return;
                if (isFunction(node.parent)) return;
                if (node.parent.type === 'LabeledStatement') return;
                if (node.parent.type === 'ContinueStatement') return;
                if (node.parent.type === 'BreakStatement') return;
             
                if (node.parent.type === 'AssignmentExpression') {
                    var isLeft0 = node.parent.left.type === 'MemberExpression'
                        && node.parent.left.object === node.name
                    ;
                    var isLeft1 = node.parent.left.type === 'Identifier'
                        && node.parent.left.name === node.name
                    ;
                    if (isLeft0 || isLeft1) {
                        exported[node.name] = keyOf(node).length;
                    }
                }
                if (!exported[node.name]
                || exported[node.name] < keyOf(node).length) {
                    implicit[node.name] = keyOf(node).length;
                    if (!implicitProps[node.name]) implicitProps[node.name] = {};
                    if (node.parent && node.parent.type === 'MemberExpression'
                    && node.parent.property.type === 'Identifier') {
                        implicitProps[node.name][node.parent.property.name] = true;
                    }
                    else if (node.parent && node.parent.type === 'CallExpression'
                    && node.parent.callee === node) {
                        implicitProps[node.name]['()'] = true;
                    }
                    else {
                        implicitProps[node.name]['*'] = true;
                    }
                }
            }
        });
        
        var localScopes = {};
        var lks = objectKeys(locals);
        for (var i = 0; i < lks.length; i++) {
            var key = lks[i];
            localScopes[key] = objectKeys(locals[key]);
        }
    
        var props = {};
        var pkeys = objectKeys(implicitProps);
        for (var i = 0; i < pkeys.length; i++) {
            props[pkeys[i]] = objectKeys(implicitProps[pkeys[i]]);
        }
        return {
            locals: localScopes,
            globals: {
                implicit: objectKeys(implicit),
                implicitProperties: props,
                exported: objectKeys(exported)
            }
        };
        
        function lookup (node) {
            for (var p = node; p; p = p.parent) {
                if (isFunction(p) || p.type === 'Program') {
                    var id = getScope(p);
                    if (locals[id][node.name]) {
                        return id;
                    }
                }
            }
            return undefined;
        }
        
        function getScope (node) {
            for (
                var p = node;
                !isFunction(p) && p.type !== 'Program';
                p = p.parent
            );
            var id = idOf(p);
            if (!locals[id]) locals[id] = {};
            return id;
        }
        
    };
    
    function isFunction (x) {
        return x.type === 'FunctionDeclaration'
            || x.type === 'FunctionExpression'
        ;
    }
    
    function idOf (node) {
        var id = [];
        for (var n = node; n.type !== 'Program'; n = n.parent) {
            var key = keyOf(n).join('.');
            id.unshift(key);
        }
        return id.join('.');
    }
    
    function keyOf (node) {
        if (node.lexicalScopeKey) return node.lexicalScopeKey;
        var p = node.parent;
        var ks = objectKeys(p);
        var kv = { keys : [], values : [], top : [] };
        
        for (var i = 0; i < ks.length; i++) {
            var key = ks[i];
            kv.keys.push(key);
            kv.values.push(p[key]);
            kv.top.push(undefined);
            
            if (isArray(p[key])) {
                var keys = objectKeys(p[key]);
                kv.keys.push.apply(kv.keys, keys);
                kv.values.push.apply(kv.values, p[key]);
                
                var nkeys = [];
                for (var j = 0; j < keys.length; j++) nkeys.push(key);
                kv.top.push.apply(kv.top, nkeys);
            }
        }
        var ix = indexOf(kv.values, node);
        var res = [];
        if (kv.top[ix]) res.push(kv.top[ix]);
        if (kv.keys[ix]) res.push(kv.keys[ix]);
        if (node.parent.type === 'CallExpression') {
            res.unshift.apply(res, keyOf(node.parent.parent));
        }
        return node.lexicalScopeKey = res;
    }
    
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    };
    
    function indexOf (xs, x) {
        if (xs.indexOf) return xs.indexOf(x);
        for (var i = 0; i < xs.length; i++) {
            if (x === xs[i]) return i;
        }
        return -1;
    }
    
  provide("lexical-scope", module.exports);
}(global));

// pakmanager:process
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // for now just expose the builtin process global from node.js
    module.exports = global.process;
    
  provide("process", module.exports);
}(global));

// pakmanager:stream-splicer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Duplex = require('readable-stream').Duplex;
    var PassThrough = require('readable-stream').PassThrough;
    var Readable = require('readable-stream').Readable;
    var inherits = require('inherits');
    
    var nextTick = typeof setImmediate !== 'undefined'
        ? setImmediate : process.nextTick
    ;
    
    module.exports = Pipeline;
    inherits(Pipeline, Duplex);
    
    module.exports.obj = function (streams, opts) {
        if (!opts && !Array.isArray(streams)) {
            opts = streams;
            streams = [];
        }
        if (!streams) streams = [];
        if (!opts) opts = {};
        opts.objectMode = true;
        return new Pipeline(streams, opts);
    };
    
    function Pipeline (streams, opts) {
        if (!(this instanceof Pipeline)) return new Pipeline(streams, opts);
        if (!opts && !Array.isArray(streams)) {
            opts = streams;
            streams = [];
        }
        if (!streams) streams = [];
        if (!opts) opts = {};
        Duplex.call(this, opts);
        
        var self = this;
        this._options = opts;
        this._wrapOptions = { objectMode: opts.objectMode !== false };
        this._streams = [];
        
        this.splice.apply(this, [ 0, 0 ].concat(streams));
        
        this.once('finish', function () {
            self._notEmpty();
            self._streams[0].end();
        });
    }
    
    Pipeline.prototype._read = function () {
        var self = this;
        this._notEmpty();
        
        var r = this._streams[this._streams.length-1];
        var buf, reads = 0;
        while ((buf = r.read()) !== null) {
            Duplex.prototype.push.call(this, buf);
            reads ++;
        }
        if (reads === 0) {
            var onreadable = function () {
                r.removeListener('readable', onreadable);
                self.removeListener('_mutate', onreadable);
                self._read()
            };
            r.once('readable', onreadable);
            self.once('_mutate', onreadable);
        }
    };
    
    Pipeline.prototype._write = function (buf, enc, next) {
        this._notEmpty();
        this._streams[0]._write(buf, enc, next);
    };
    
    Pipeline.prototype._notEmpty = function () {
        var self = this;
        if (this._streams.length > 0) return;
        var stream = new PassThrough(this._options);
        stream.once('end', function () {
            var ix = self._streams.indexOf(stream);
            if (ix >= 0 && ix === self._streams.length - 1) {
                Duplex.prototype.push.call(self, null);
            }
        });
        this._streams.push(stream);
        this.length = this._streams.length;
    };
    
    Pipeline.prototype.push = function (stream) {
        var args = [ this._streams.length, 0 ].concat([].slice.call(arguments));
        this.splice.apply(this, args);
        return this._streams.length;
    };
    
    Pipeline.prototype.pop = function () {
        return this.splice(this._streams.length-1,1)[0];
    };
    
    Pipeline.prototype.shift = function () {
        return this.splice(0,1)[0];
    };
    
    Pipeline.prototype.unshift = function () {
        this.splice.apply(this, [0,0].concat([].slice.call(arguments)));
        return this._streams.length;
    };
    
    Pipeline.prototype.splice = function (start, removeLen) {
        var self = this;
        var len = this._streams.length;
        start = start < 0 ? len - start : start;
        if (removeLen === undefined) removeLen = len - start;
        removeLen = Math.max(0, Math.min(len - start, removeLen));
        
        for (var i = start; i < start + removeLen; i++) {
            if (self._streams[i-1]) {
                self._streams[i-1].unpipe(self._streams[i]);
            }
        }
        if (self._streams[i-1] && self._streams[i]) {
            self._streams[i-1].unpipe(self._streams[i]);
        }
        var end = i;
        
        var reps = [], args = arguments;
        for (var j = 2; j < args.length; j++) (function (stream) {
            if (Array.isArray(stream)) {
                stream = new Pipeline(stream, self._options);
            }
            stream.on('error', function (err) {
                err.stream = this;
                self.emit('error', err);
            });
            stream = self._wrapStream(stream);
            stream.once('end', function () {
                var ix = self._streams.indexOf(stream);
                if (ix >= 0 && ix === self._streams.length - 1) {
                    Duplex.prototype.push.call(self, null);
                }
            });
            reps.push(stream);
        })(arguments[j]);
        
        for (var i = 0; i < reps.length - 1; i++) {
            reps[i].pipe(reps[i+1]);
        }
        
        if (reps.length && self._streams[end]) {
            reps[reps.length-1].pipe(self._streams[end]);
        }
        if (reps[0] && self._streams[start-1]) {
            self._streams[start-1].pipe(reps[0]);
        }
        
        var sargs = [start,removeLen].concat(reps);
        var removed = self._streams.splice.apply(self._streams, sargs);
        
        for (var i = 0; i < reps.length; i++) {
            reps[i].read(0);
        }
        
        this.emit('_mutate');
        this.length = this._streams.length;
        return removed;
    };
    
    Pipeline.prototype.get = function () {
        if (arguments.length === 0) return undefined;
        
        var base = this;
        for (var i = 0; i < arguments.length; i++) {
            var index = arguments[i];
            if (index < 0) {
                base = base._streams[base._streams.length + index];
            }
            else {
                base = base._streams[index];
            }
            if (!base) return undefined;
        }
        return base;
    };
    
    Pipeline.prototype.indexOf = function (stream) {
        return this._streams.indexOf(stream);
    };
    
    Pipeline.prototype._wrapStream = function (stream) {
        if (typeof stream.read === 'function') return stream;
        var w = new Readable(this._wrapOptions).wrap(stream);
        w._write = function (buf, enc, next) {
            if (stream.write(buf) === false) {
                stream.once('drain', next);
            }
            else nextTick(next);
        };
        return w;
    };
    
  provide("stream-splicer", module.exports);
}(global));

// pakmanager:browser-resolve
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // builtin
    var fs = require('fs');
    var path = require('path');
    
    // vendor
    var resv = require('resolve');
    
    // given a path, create an array of node_module paths for it
    // borrowed from substack/resolve
    function nodeModulesPaths (start, cb) {
        var splitRe = process.platform === 'win32' ? /[\/\\]/ : /\/+/;
        var parts = start.split(splitRe);
    
        var dirs = [];
        for (var i = parts.length - 1; i >= 0; i--) {
            if (parts[i] === 'node_modules') continue;
            var dir = path.join.apply(
                path, parts.slice(0, i + 1).concat(['node_modules'])
            );
            if (!parts[0].match(/([A-Za-z]:)/)) {
                dir = '/' + dir;
            }
            dirs.push(dir);
        }
        return dirs;
    }
    
    function find_shims_in_package(pkgJson, cur_path, shims, browser) {
        try {
            var info = JSON.parse(pkgJson);
        }
        catch (err) {
            err.message = pkgJson + ' : ' + err.message
            throw err;
        }
    
        var replacements = getReplacements(info, browser);
    
        // no replacements, skip shims
        if (!replacements) {
            return;
        }
    
        // if browser mapping is a string
        // then it just replaces the main entry point
        if (typeof replacements === 'string') {
            var key = path.resolve(cur_path, info.main || 'index.js');
            shims[key] = path.resolve(cur_path, replacements);
            return;
        }
    
        // http://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders
        Object.keys(replacements).forEach(function(key) {
            var val;
            if (replacements[key] === false) {
                val = __dirname + '/empty.js';
            }
            else {
                val = replacements[key];
                // if target is a relative path, then resolve
                // otherwise we assume target is a module
                if (val[0] === '.') {
                    val = path.resolve(cur_path, val);
                }
            }
    
            if (key[0] === '/' || key[0] === '.') {
                // if begins with / ../ or ./ then we must resolve to a full path
                key = path.resolve(cur_path, key);
            }
            shims[key] = val;
        });
    
        [ '.js', '.json' ].forEach(function (ext) {
            Object.keys(shims).forEach(function (key) {
                if (!shims[key + ext]) {
                    shims[key + ext] = shims[key];
                }
            });
        });
    }
    
    // paths is mutated
    // load shims from first package.json file found
    function load_shims(paths, browser, cb) {
        // identify if our file should be replaced per the browser field
        // original filename|id -> replacement
        var shims = Object.create(null);
    
        (function next() {
            var cur_path = paths.shift();
            if (!cur_path) {
                return cb(null, shims);
            }
    
            var pkg_path = path.join(cur_path, 'package.json');
    
            fs.readFile(pkg_path, 'utf8', function(err, data) {
                if (err) {
                    // ignore paths we can't open
                    // avoids an exists check
                    if (err.code === 'ENOENT') {
                        return next();
                    }
    
                    return cb(err);
                }
                try {
                    find_shims_in_package(data, cur_path, shims, browser);
                    return cb(null, shims);
                }
                catch (err) {
                    return cb(err);
                }
            });
        })();
    };
    
    // paths is mutated
    // synchronously load shims from first package.json file found
    function load_shims_sync(paths, browser) {
        // identify if our file should be replaced per the browser field
        // original filename|id -> replacement
        var shims = Object.create(null);
        var cur_path;
    
        while (cur_path = paths.shift()) {
            var pkg_path = path.join(cur_path, 'package.json');
    
            try {
                var data = fs.readFileSync(pkg_path, 'utf8');
                find_shims_in_package(data, cur_path, shims, browser);
                return shims;
            }
            catch (err) {
                // ignore paths we can't open
                // avoids an exists check
                if (err.code === 'ENOENT') {
                    continue;
                }
    
                throw err;
            }
        }
        return shims;
    }
    
    function build_resolve_opts(opts, base) {
        var packageFilter = opts.packageFilter;
        var browser = normalizeBrowserFieldName(opts.browser)
    
        opts.basedir = base;
        opts.packageFilter = function (info, pkgdir) {
            if (packageFilter) info = packageFilter(info, pkgdir);
    
            var replacements = getReplacements(info, browser);
    
            // no browser field, keep info unchanged
            if (!replacements) {
                return info;
            }
    
            info[browser] = replacements;
    
            // replace main
            if (typeof replacements === 'string') {
                info.main = replacements;
                return info;
            }
    
            var replace_main = replacements[info.main || './index.js'] ||
                replacements['./' + info.main || './index.js'];
    
            info.main = replace_main || info.main;
            return info;
        };
    
        var pathFilter = opts.pathFilter;
        opts.pathFilter = function(info, resvPath, relativePath) {
            if (relativePath[0] != '.') {
                relativePath = './' + relativePath;
            }
            var mappedPath;
            if (pathFilter) {
                mappedPath = pathFilter.apply(this, arguments);
            }
            if (mappedPath) {
                return mappedPath;
            }
    
            var replacements = info[browser];
            if (!replacements) {
                return;
            }
    
            mappedPath = replacements[relativePath];
            if (!mappedPath && path.extname(relativePath) === '') {
                mappedPath = replacements[relativePath + '.js'];
                if (!mappedPath) {
                    mappedPath = replacements[relativePath + '.json'];
                }
            }
            return mappedPath;
        };
    
        return opts;
    }
    
    function resolve(id, opts, cb) {
    
        // opts.filename
        // opts.paths
        // opts.modules
        // opts.packageFilter
    
        opts = opts || {};
    
        var base = path.dirname(opts.filename);
    
        if (opts.basedir) {
            base = opts.basedir;
        }
    
        var paths = nodeModulesPaths(base);
    
        if (opts.paths) {
            paths.push.apply(paths, opts.paths);
        }
    
        paths = paths.map(function(p) {
            return path.dirname(p);
        });
    
        // we must always load shims because the browser field could shim out a module
        load_shims(paths, opts.browser, function(err, shims) {
            if (err) {
                return cb(err);
            }
    
            var resid = path.resolve(opts.basedir || path.dirname(opts.filename), id);
            if (shims[id] || shims[resid]) {
                var xid = shims[id] ? id : resid;
                // if the shim was is an absolute path, it was fully resolved
                if (shims[xid][0] === '/') {
                    return resv(shims[xid], build_resolve_opts(opts, base), function(err, full, pkg) {
                        cb(null, full, pkg);
                    });
                }
    
                // module -> alt-module shims
                id = shims[xid];
            }
    
            var modules = opts.modules || Object.create(null);
            var shim_path = modules[id];
            if (shim_path) {
                return cb(null, shim_path);
            }
    
            // our browser field resolver
            // if browser field is an object tho?
            var full = resv(id, build_resolve_opts(opts, base), function(err, full, pkg) {
                if (err) {
                    return cb(err);
                }
    
                var resolved = (shims) ? shims[full] || full : full;
                cb(null, resolved, pkg);
            });
        });
    };
    
    resolve.sync = function (id, opts) {
    
        // opts.filename
        // opts.paths
        // opts.modules
        // opts.packageFilter
    
        opts = opts || {};
        var base = path.dirname(opts.filename);
    
        if (opts.basedir) {
            base = opts.basedir;
        }
    
        var paths = nodeModulesPaths(base);
    
        if (opts.paths) {
            paths.push.apply(paths, opts.paths);
        }
    
        paths = paths.map(function(p) {
            return path.dirname(p);
        });
    
        // we must always load shims because the browser field could shim out a module
        var shims = load_shims_sync(paths, opts.browser);
    
        if (shims[id]) {
            // if the shim was is an absolute path, it was fully resolved
            if (shims[id][0] === '/') {
                return shims[id];
            }
    
            // module -> alt-module shims
            id = shims[id];
        }
    
        var modules = opts.modules || Object.create(null);
        var shim_path = modules[id];
        if (shim_path) {
            return shim_path;
        }
    
        // our browser field resolver
        // if browser field is an object tho?
        var full = resv.sync(id, build_resolve_opts(opts, base));
    
        return (shims) ? shims[full] || full : full;
    };
    
    function normalizeBrowserFieldName(browser) {
        return browser || 'browser';
    }
    
    function getReplacements(info, browser) {
        browser = normalizeBrowserFieldName(browser);
        var replacements = info[browser] || info.browser;
    
        // support legacy browserify field for easier migration from legacy
        // many packages used this field historically
        if (typeof info.browserify === 'string' && !replacements) {
            replacements = info.browserify;
        }
    
        return replacements;
    }
    
    module.exports = resolve;
    
  provide("browser-resolve", module.exports);
}(global));

// pakmanager:detective
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var acorn = require('acorn');
    var walk = require('acorn/dist/walk');
    var defined = require('defined');
    
    var requireRe = /\brequire\b/;
    
    function parse (src, opts) {
        if (!opts) opts = {};
        return acorn.parse(src, {
            ecmaVersion: defined(opts.ecmaVersion, 6),
            sourceType: opts.sourceType,
            ranges: defined(opts.ranges, opts.range),
            locations: defined(opts.locations, opts.loc),
            allowReserved: defined(opts.allowReserved, true),
            allowReturnOutsideFunction: defined(
                opts.allowReturnOutsideFunction, true
            ),
            allowHashBang: defined(opts.allowHashBang, true)
        });
    }
    
    var exports = module.exports = function (src, opts) {
        return exports.find(src, opts).strings;
    };
    
    exports.find = function (src, opts) {
        if (!opts) opts = {};
        
        var word = opts.word === undefined ? 'require' : opts.word;
        if (typeof src !== 'string') src = String(src);
        
        var isRequire = opts.isRequire || function (node) {
            return node.callee.type === 'Identifier'
                && node.callee.name === word
            ;
        };
        
        var modules = { strings : [], expressions : [] };
        if (opts.nodes) modules.nodes = [];
        
        var wordRe = word === 'require' ? requireRe : RegExp('\\b' + word + '\\b');
        if (!wordRe.test(src)) return modules;
        
        var ast = parse(src, opts.parse);
        
        function visit(node, st, c) {
            var hasRequire = wordRe.test(src.slice(node.start, node.end));
            if (!hasRequire) return;
            walk.base[node.type](node, st, c);
            if (node.type !== 'CallExpression') return;
            if (isRequire(node)) {
                if (node.arguments.length) {
                    var arg = node.arguments[0];
                    if (arg.type === 'Literal') {
                        modules.strings.push(arg.value);
                    }
                    else {
                        modules.expressions.push(src.slice(arg.start, arg.end));
                    }
                }
                if (opts.nodes) modules.nodes.push(node);
            }
        }
        
        walk.recursive(ast, null, {
            Statement: visit,
            Expression: visit
        });
        
        return modules;
    };
    
  provide("detective", module.exports);
}(global));

// pakmanager:parents
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pathPlatform = require('path-platform');
    
    module.exports = function (cwd, opts) {
        if (cwd === undefined) cwd = process.cwd();
        if (!opts) opts = {};
        var platform = opts.platform || process.platform;
        
        var isWindows = /^win/.test(platform);
        var path = isWindows ? pathPlatform.win32 : pathPlatform;
        var normalize = !isWindows ? path.normalize :
            path.normalize('c:') === 'c:.' ? fixNormalize(path.normalize) :
            path.normalize;
        var sep = isWindows ? /[\\\/]/ : '/';
        var init = isWindows ? '' : '/';
        
        var join = function (x, y) {
            var ps = [ x, y ].filter(function (p) {
                return p && typeof p === 'string'
            });
    
            return normalize(ps.join(isWindows ? '\\' : '/'));
        };
        
        var res = normalize(cwd)
            .split(sep)
            .reduce(function (acc,dir,ix) {
                return acc.concat(join(acc[ix], dir))
            }, [init])
            .slice(1)
            .reverse()
        ;
        if (res[0] === res[1]) return [ res[0] ];
        if (isWindows && /^\\/.test(cwd)) {
            return res.slice(0,-1).map(function (d) {
                var ch = d.charAt(0)
                return ch === '\\' ? d :
                  ch === '.' ? '\\' + d.slice(1) :
                  '\\' + d
            });
        }
        return res;
    
        function fixNormalize(fn) {
          return function(p) {
            return fn(p).replace(/:\.$/, ':')
          }
        }
    }
    
  provide("parents", module.exports);
}(global));

// pakmanager:stream-combiner2
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var PassThrough = require('readable-stream').PassThrough
    var Readable = require('readable-stream').Readable
    var duplexer = require('duplexer2')
    
    module.exports = function () {
      var streams
      if(arguments.length == 1 && Array.isArray(arguments[0])) {
        streams = arguments[0]
      } else {
        streams = [].slice.call(arguments)
      }
      return combine(streams)
    }
    
    module.exports.obj = function () {
      var streams
      if(arguments.length == 1 && Array.isArray(arguments[0])) {
        streams = arguments[0]
      } else {
        streams = [].slice.call(arguments)
      }
      return combine(streams, { objectMode: true })
    }
    
      
    function combine (streams, opts) {
    
      for (var i = 0; i < streams.length; i++)
        streams[i] = wrap(streams[i], opts)
    
      if(streams.length == 0)
        return new PassThrough(opts)
      else if(streams.length == 1)
        return streams[0]
    
      var first = streams[0]
        , last = streams[streams.length - 1]
        , thepipe = duplexer(opts, first, last)
    
      //pipe all the streams together
    
      function recurse (streams) {
        if(streams.length < 2)
          return
        streams[0].pipe(streams[1])
        recurse(streams.slice(1))
      }
    
      recurse(streams)
    
      function onerror () {
        var args = [].slice.call(arguments)
        args.unshift('error')
        thepipe.emit.apply(thepipe, args)
      }
    
      //es.duplex already reemits the error from the first and last stream.
      //add a listener for the inner streams in the pipeline.
      for(var i = 1; i < streams.length - 1; i ++)
        streams[i].on('error', onerror)
    
      return thepipe
    }
    
    function wrap (tr, opts) {
      if (typeof tr.read === 'function') return tr
      return new Readable(opts).wrap(tr)
    }
    
  provide("stream-combiner2", module.exports);
}(global));

// pakmanager:array-filter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Array#filter.
     *
     * @param {Array} arr
     * @param {Function} fn
     * @param {Object=} self
     * @return {Array}
     * @throw TypeError
     */
    
    module.exports = function (arr, fn, self) {
      if (arr.filter) return arr.filter(fn, self);
      if (void 0 === arr || null === arr) throw new TypeError;
      if ('function' != typeof fn) throw new TypeError;
      var ret = [];
      for (var i = 0; i < arr.length; i++) {
        if (!hasOwn.call(arr, i)) continue;
        var val = arr[i];
        if (fn.call(self, val, i, arr)) ret.push(val);
      }
      return ret;
    };
    
    var hasOwn = Object.prototype.hasOwnProperty;
    
  provide("array-filter", module.exports);
}(global));

// pakmanager:array-reduce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var hasOwn = Object.prototype.hasOwnProperty;
    
    module.exports = function (xs, f, acc) {
        var hasAcc = arguments.length >= 3;
        if (hasAcc && xs.reduce) return xs.reduce(f, acc);
        if (xs.reduce) return xs.reduce(f);
        
        for (var i = 0; i < xs.length; i++) {
            if (!hasOwn.call(xs, i)) continue;
            if (!hasAcc) {
                acc = xs[i];
                hasAcc = true;
                continue;
            }
            acc = f(acc, xs[i], i);
        }
        return acc;
    };
    
  provide("array-reduce", module.exports);
}(global));

// pakmanager:array-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            var x = xs[i];
            if (hasOwn.call(xs, i)) res.push(f(x, i, xs));
        }
        return res;
    };
    
    var hasOwn = Object.prototype.hasOwnProperty;
    
  provide("array-map", module.exports);
}(global));

// pakmanager:punycode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*! https://mths.be/punycode v1.4.1 by @mathias */
    ;(function(root) {
    
    	/** Detect free variables */
    	var freeExports = typeof exports == 'object' && exports &&
    		!exports.nodeType && exports;
    	var freeModule = typeof module == 'object' && module &&
    		!module.nodeType && module;
    	var freeGlobal = typeof global == 'object' && global;
    	if (
    		freeGlobal.global === freeGlobal ||
    		freeGlobal.window === freeGlobal ||
    		freeGlobal.self === freeGlobal
    	) {
    		root = freeGlobal;
    	}
    
    	/**
    	 * The `punycode` object.
    	 * @name punycode
    	 * @type Object
    	 */
    	var punycode,
    
    	/** Highest positive signed 32-bit float value */
    	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
    
    	/** Bootstring parameters */
    	base = 36,
    	tMin = 1,
    	tMax = 26,
    	skew = 38,
    	damp = 700,
    	initialBias = 72,
    	initialN = 128, // 0x80
    	delimiter = '-', // '\x2D'
    
    	/** Regular expressions */
    	regexPunycode = /^xn--/,
    	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
    	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
    
    	/** Error messages */
    	errors = {
    		'overflow': 'Overflow: input needs wider integers to process',
    		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    		'invalid-input': 'Invalid input'
    	},
    
    	/** Convenience shortcuts */
    	baseMinusTMin = base - tMin,
    	floor = Math.floor,
    	stringFromCharCode = String.fromCharCode,
    
    	/** Temporary variable */
    	key;
    
    	/*--------------------------------------------------------------------------*/
    
    	/**
    	 * A generic error utility function.
    	 * @private
    	 * @param {String} type The error type.
    	 * @returns {Error} Throws a `RangeError` with the applicable error message.
    	 */
    	function error(type) {
    		throw new RangeError(errors[type]);
    	}
    
    	/**
    	 * A generic `Array#map` utility function.
    	 * @private
    	 * @param {Array} array The array to iterate over.
    	 * @param {Function} callback The function that gets called for every array
    	 * item.
    	 * @returns {Array} A new array of values returned by the callback function.
    	 */
    	function map(array, fn) {
    		var length = array.length;
    		var result = [];
    		while (length--) {
    			result[length] = fn(array[length]);
    		}
    		return result;
    	}
    
    	/**
    	 * A simple `Array#map`-like wrapper to work with domain name strings or email
    	 * addresses.
    	 * @private
    	 * @param {String} domain The domain name or email address.
    	 * @param {Function} callback The function that gets called for every
    	 * character.
    	 * @returns {Array} A new string of characters returned by the callback
    	 * function.
    	 */
    	function mapDomain(string, fn) {
    		var parts = string.split('@');
    		var result = '';
    		if (parts.length > 1) {
    			// In email addresses, only the domain name should be punycoded. Leave
    			// the local part (i.e. everything up to `@`) intact.
    			result = parts[0] + '@';
    			string = parts[1];
    		}
    		// Avoid `split(regex)` for IE8 compatibility. See #17.
    		string = string.replace(regexSeparators, '\x2E');
    		var labels = string.split('.');
    		var encoded = map(labels, fn).join('.');
    		return result + encoded;
    	}
    
    	/**
    	 * Creates an array containing the numeric code points of each Unicode
    	 * character in the string. While JavaScript uses UCS-2 internally,
    	 * this function will convert a pair of surrogate halves (each of which
    	 * UCS-2 exposes as separate characters) into a single code point,
    	 * matching UTF-16.
    	 * @see `punycode.ucs2.encode`
    	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    	 * @memberOf punycode.ucs2
    	 * @name decode
    	 * @param {String} string The Unicode input string (UCS-2).
    	 * @returns {Array} The new array of code points.
    	 */
    	function ucs2decode(string) {
    		var output = [],
    		    counter = 0,
    		    length = string.length,
    		    value,
    		    extra;
    		while (counter < length) {
    			value = string.charCodeAt(counter++);
    			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
    				// high surrogate, and there is a next character
    				extra = string.charCodeAt(counter++);
    				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    				} else {
    					// unmatched surrogate; only append this code unit, in case the next
    					// code unit is the high surrogate of a surrogate pair
    					output.push(value);
    					counter--;
    				}
    			} else {
    				output.push(value);
    			}
    		}
    		return output;
    	}
    
    	/**
    	 * Creates a string based on an array of numeric code points.
    	 * @see `punycode.ucs2.decode`
    	 * @memberOf punycode.ucs2
    	 * @name encode
    	 * @param {Array} codePoints The array of numeric code points.
    	 * @returns {String} The new Unicode string (UCS-2).
    	 */
    	function ucs2encode(array) {
    		return map(array, function(value) {
    			var output = '';
    			if (value > 0xFFFF) {
    				value -= 0x10000;
    				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    				value = 0xDC00 | value & 0x3FF;
    			}
    			output += stringFromCharCode(value);
    			return output;
    		}).join('');
    	}
    
    	/**
    	 * Converts a basic code point into a digit/integer.
    	 * @see `digitToBasic()`
    	 * @private
    	 * @param {Number} codePoint The basic numeric code point value.
    	 * @returns {Number} The numeric value of a basic code point (for use in
    	 * representing integers) in the range `0` to `base - 1`, or `base` if
    	 * the code point does not represent a value.
    	 */
    	function basicToDigit(codePoint) {
    		if (codePoint - 48 < 10) {
    			return codePoint - 22;
    		}
    		if (codePoint - 65 < 26) {
    			return codePoint - 65;
    		}
    		if (codePoint - 97 < 26) {
    			return codePoint - 97;
    		}
    		return base;
    	}
    
    	/**
    	 * Converts a digit/integer into a basic code point.
    	 * @see `basicToDigit()`
    	 * @private
    	 * @param {Number} digit The numeric value of a basic code point.
    	 * @returns {Number} The basic code point whose value (when used for
    	 * representing integers) is `digit`, which needs to be in the range
    	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
    	 * used; else, the lowercase form is used. The behavior is undefined
    	 * if `flag` is non-zero and `digit` has no uppercase form.
    	 */
    	function digitToBasic(digit, flag) {
    		//  0..25 map to ASCII a..z or A..Z
    		// 26..35 map to ASCII 0..9
    		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    	}
    
    	/**
    	 * Bias adaptation function as per section 3.4 of RFC 3492.
    	 * https://tools.ietf.org/html/rfc3492#section-3.4
    	 * @private
    	 */
    	function adapt(delta, numPoints, firstTime) {
    		var k = 0;
    		delta = firstTime ? floor(delta / damp) : delta >> 1;
    		delta += floor(delta / numPoints);
    		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    			delta = floor(delta / baseMinusTMin);
    		}
    		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    	}
    
    	/**
    	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
    	 * symbols.
    	 * @memberOf punycode
    	 * @param {String} input The Punycode string of ASCII-only symbols.
    	 * @returns {String} The resulting string of Unicode symbols.
    	 */
    	function decode(input) {
    		// Don't use UCS-2
    		var output = [],
    		    inputLength = input.length,
    		    out,
    		    i = 0,
    		    n = initialN,
    		    bias = initialBias,
    		    basic,
    		    j,
    		    index,
    		    oldi,
    		    w,
    		    k,
    		    digit,
    		    t,
    		    /** Cached calculation results */
    		    baseMinusT;
    
    		// Handle the basic code points: let `basic` be the number of input code
    		// points before the last delimiter, or `0` if there is none, then copy
    		// the first basic code points to the output.
    
    		basic = input.lastIndexOf(delimiter);
    		if (basic < 0) {
    			basic = 0;
    		}
    
    		for (j = 0; j < basic; ++j) {
    			// if it's not a basic code point
    			if (input.charCodeAt(j) >= 0x80) {
    				error('not-basic');
    			}
    			output.push(input.charCodeAt(j));
    		}
    
    		// Main decoding loop: start just after the last delimiter if any basic code
    		// points were copied; start at the beginning otherwise.
    
    		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
    
    			// `index` is the index of the next character to be consumed.
    			// Decode a generalized variable-length integer into `delta`,
    			// which gets added to `i`. The overflow checking is easier
    			// if we increase `i` as we go, then subtract off its starting
    			// value at the end to obtain `delta`.
    			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
    
    				if (index >= inputLength) {
    					error('invalid-input');
    				}
    
    				digit = basicToDigit(input.charCodeAt(index++));
    
    				if (digit >= base || digit > floor((maxInt - i) / w)) {
    					error('overflow');
    				}
    
    				i += digit * w;
    				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    
    				if (digit < t) {
    					break;
    				}
    
    				baseMinusT = base - t;
    				if (w > floor(maxInt / baseMinusT)) {
    					error('overflow');
    				}
    
    				w *= baseMinusT;
    
    			}
    
    			out = output.length + 1;
    			bias = adapt(i - oldi, out, oldi == 0);
    
    			// `i` was supposed to wrap around from `out` to `0`,
    			// incrementing `n` each time, so we'll fix that now:
    			if (floor(i / out) > maxInt - n) {
    				error('overflow');
    			}
    
    			n += floor(i / out);
    			i %= out;
    
    			// Insert `n` at position `i` of the output
    			output.splice(i++, 0, n);
    
    		}
    
    		return ucs2encode(output);
    	}
    
    	/**
    	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
    	 * Punycode string of ASCII-only symbols.
    	 * @memberOf punycode
    	 * @param {String} input The string of Unicode symbols.
    	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
    	 */
    	function encode(input) {
    		var n,
    		    delta,
    		    handledCPCount,
    		    basicLength,
    		    bias,
    		    j,
    		    m,
    		    q,
    		    k,
    		    t,
    		    currentValue,
    		    output = [],
    		    /** `inputLength` will hold the number of code points in `input`. */
    		    inputLength,
    		    /** Cached calculation results */
    		    handledCPCountPlusOne,
    		    baseMinusT,
    		    qMinusT;
    
    		// Convert the input in UCS-2 to Unicode
    		input = ucs2decode(input);
    
    		// Cache the length
    		inputLength = input.length;
    
    		// Initialize the state
    		n = initialN;
    		delta = 0;
    		bias = initialBias;
    
    		// Handle the basic code points
    		for (j = 0; j < inputLength; ++j) {
    			currentValue = input[j];
    			if (currentValue < 0x80) {
    				output.push(stringFromCharCode(currentValue));
    			}
    		}
    
    		handledCPCount = basicLength = output.length;
    
    		// `handledCPCount` is the number of code points that have been handled;
    		// `basicLength` is the number of basic code points.
    
    		// Finish the basic string - if it is not empty - with a delimiter
    		if (basicLength) {
    			output.push(delimiter);
    		}
    
    		// Main encoding loop:
    		while (handledCPCount < inputLength) {
    
    			// All non-basic code points < n have been handled already. Find the next
    			// larger one:
    			for (m = maxInt, j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    				if (currentValue >= n && currentValue < m) {
    					m = currentValue;
    				}
    			}
    
    			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    			// but guard against overflow
    			handledCPCountPlusOne = handledCPCount + 1;
    			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    				error('overflow');
    			}
    
    			delta += (m - n) * handledCPCountPlusOne;
    			n = m;
    
    			for (j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    
    				if (currentValue < n && ++delta > maxInt) {
    					error('overflow');
    				}
    
    				if (currentValue == n) {
    					// Represent delta as a generalized variable-length integer
    					for (q = delta, k = base; /* no condition */; k += base) {
    						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    						if (q < t) {
    							break;
    						}
    						qMinusT = q - t;
    						baseMinusT = base - t;
    						output.push(
    							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
    						);
    						q = floor(qMinusT / baseMinusT);
    					}
    
    					output.push(stringFromCharCode(digitToBasic(q, 0)));
    					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    					delta = 0;
    					++handledCPCount;
    				}
    			}
    
    			++delta;
    			++n;
    
    		}
    		return output.join('');
    	}
    
    	/**
    	 * Converts a Punycode string representing a domain name or an email address
    	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
    	 * it doesn't matter if you call it on a string that has already been
    	 * converted to Unicode.
    	 * @memberOf punycode
    	 * @param {String} input The Punycoded domain name or email address to
    	 * convert to Unicode.
    	 * @returns {String} The Unicode representation of the given Punycode
    	 * string.
    	 */
    	function toUnicode(input) {
    		return mapDomain(input, function(string) {
    			return regexPunycode.test(string)
    				? decode(string.slice(4).toLowerCase())
    				: string;
    		});
    	}
    
    	/**
    	 * Converts a Unicode string representing a domain name or an email address to
    	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
    	 * i.e. it doesn't matter if you call it with a domain that's already in
    	 * ASCII.
    	 * @memberOf punycode
    	 * @param {String} input The domain name or email address to convert, as a
    	 * Unicode string.
    	 * @returns {String} The Punycode representation of the given domain name or
    	 * email address.
    	 */
    	function toASCII(input) {
    		return mapDomain(input, function(string) {
    			return regexNonASCII.test(string)
    				? 'xn--' + encode(string)
    				: string;
    		});
    	}
    
    	/*--------------------------------------------------------------------------*/
    
    	/** Define the public API */
    	punycode = {
    		/**
    		 * A string representing the current Punycode.js version number.
    		 * @memberOf punycode
    		 * @type String
    		 */
    		'version': '1.4.1',
    		/**
    		 * An object of methods to convert from JavaScript's internal character
    		 * representation (UCS-2) to Unicode code points, and back.
    		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
    		 * @memberOf punycode
    		 * @type Object
    		 */
    		'ucs2': {
    			'decode': ucs2decode,
    			'encode': ucs2encode
    		},
    		'decode': decode,
    		'encode': encode,
    		'toASCII': toASCII,
    		'toUnicode': toUnicode
    	};
    
    	/** Expose `punycode` */
    	// Some AMD build optimizers, like r.js, check for specific condition patterns
    	// like the following:
    	if (
    		typeof define == 'function' &&
    		typeof define.amd == 'object' &&
    		define.amd
    	) {
    		define('punycode', function() {
    			return punycode;
    		});
    	} else if (freeExports && freeModule) {
    		if (module.exports == freeExports) {
    			// in Node.js, io.js, or RingoJS v0.8.0+
    			freeModule.exports = punycode;
    		} else {
    			// in Narwhal or RingoJS v0.7.0-
    			for (key in punycode) {
    				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    			}
    		}
    	} else {
    		// in Rhino or a web browser
    		root.punycode = punycode;
    	}
    
    }(this));
    
  provide("punycode", module.exports);
}(global));

// pakmanager:querystring/decode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    'use strict';
    
    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
    module.exports = function(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};
    
      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }
    
      var regexp = /\+/g;
      qs = qs.split(sep);
    
      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }
    
      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
    
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;
    
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }
    
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
    
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
    
      return obj;
    };
    
  provide("querystring/decode", module.exports);
}(global));

// pakmanager:querystring/encode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    'use strict';
    
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;
    
        case 'boolean':
          return v ? 'true' : 'false';
    
        case 'number':
          return isFinite(v) ? v : '';
    
        default:
          return '';
      }
    };
    
    module.exports = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }
    
      if (typeof obj === 'object') {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
    
      }
    
      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    };
    
  provide("querystring/encode", module.exports);
}(global));

// pakmanager:querystring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.decode = exports.parse =  require('querystring/decode');
    exports.encode = exports.stringify =  require('querystring/encode');
    
  provide("querystring", module.exports);
}(global));

// pakmanager:type-detect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    /* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */
    var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
    var promiseExists = typeof Promise === 'function';
    var globalObject = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : self; // eslint-disable-line
    var isDom = 'location' in globalObject && 'document' in globalObject;
    var htmlElementExists = typeof HTMLElement !== 'undefined';
    var isArrayExists = typeof Array.isArray === 'function';
    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && Symbol.iterator;
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    /**
     * ### typeOf (obj)
     *
     * Uses `Object.prototype.toString` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */
    module.exports = function typeDetect(obj) {
      /* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */
      var typeofObj = typeof obj;
      if (typeofObj !== 'object') {
        return typeofObj;
      }
    
      /* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */
      if (obj === null) {
        return 'null';
      }
    
      /* ! Spec Conformance
       * Test: `Object.prototype.toString.call(window)``
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: `Object.prototype.toString.call(this)``
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */
      if (obj === globalObject) {
        return 'global';
      }
    
      /* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */
      if (isArrayExists && Array.isArray(obj)) {
        return 'array';
      }
    
      if (isDom) {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The `Location` interface
         * Test: `Object.prototype.toString.call(window.location)``
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */
        if (obj === globalObject.location) {
          return 'location';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The `Document` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: `Object.prototype.toString.call(document)``
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */
        if (obj === globalObject.document) {
          return 'document';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
         * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
         *  - IE <=10 === "[object MSMimeTypesCollection]"
         */
        if (obj === (globalObject.navigator || {}).mimeTypes) {
          return 'mimetypearray';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
         * Test: `Object.prototype.toString.call(navigator.plugins)``
         *  - IE <=10 === "[object MSPluginsCollection]"
         */
        if (obj === (globalObject.navigator || {}).plugins) {
          return 'pluginarray';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
         * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
         * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
         *  - IE <=10 === "[object HTMLBlockElement]"
         */
        if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
          return 'htmlquoteelement';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltabledatacellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('td'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
          return 'htmltabledatacellelement';
        }
    
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#htmltableheadercellelement)
         * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         * Test: Object.prototype.toString.call(document.createElement('th'))
         *  - Chrome === "[object HTMLTableCellElement]"
         *  - Firefox === "[object HTMLTableCellElement]"
         *  - Safari === "[object HTMLTableCellElement]"
         */
        if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
          return 'htmltableheadercellelement';
        }
      }
    
      if (getPrototypeOfExists && (symbolExists === false || typeof obj[Symbol.toStringTag] === 'undefined')) {
        var objPrototype = Object.getPrototypeOf(obj);
        /* ! Speed optimisation
        * Pre:
        *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
        *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
        * Post:
        *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
        *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
        */
        if (objPrototype === RegExp.prototype) {
          return 'regexp';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
        * Post:
        *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
        */
        if (objPrototype === Date.prototype) {
          return 'date';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
         * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
         * Test: `Object.prototype.toString.call(Promise.resolve())``
         *  - Chrome <=47 === "[object Object]"
         *  - Edge <=20 === "[object Object]"
         *  - Firefox 29-Latest === "[object Promise]"
         *  - Safari 7.1-Latest === "[object Promise]"
         */
        if (promiseExists && objPrototype === Promise.prototype) {
          return 'promise';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
        * Post:
        *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
        */
        if (setExists && objPrototype === Set.prototype) {
          return 'set';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
        * Post:
        *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
        */
        if (mapExists && objPrototype === Map.prototype) {
          return 'map';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
        * Post:
        *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
        */
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return 'weakset';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
        * Post:
        *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
        */
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return 'weakmap';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
         * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
         * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
         *  - Edge <=13 === "[object Object]"
         */
        if (dataViewExists && objPrototype === DataView.prototype) {
          return 'dataview';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
         * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
         * Test: `Object.prototype.toString.call(new Map().entries())``
         *  - Edge <=13 === "[object Object]"
         */
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return 'map iterator';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
         * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
         * Test: `Object.prototype.toString.call(new Set().entries())``
         *  - Edge <=13 === "[object Object]"
         */
        if (setExists && objPrototype === setIteratorPrototype) {
          return 'set iterator';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
         * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
         * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
         *  - Edge <=13 === "[object Object]"
         */
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return 'array iterator';
        }
    
        /* ! Spec Conformance
         * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
         * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
         * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
         *  - Edge <=13 === "[object Object]"
         */
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return 'string iterator';
        }
    
        /* ! Speed optimisation
        * Pre:
        *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
        * Post:
        *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
        */
        if (objPrototype === null) {
          return 'object';
        }
      }
    
      return Object
        .prototype
        .toString
        .call(obj)
        .slice(toStringLeftSliceLength, toStringRightSliceLength)
        .toLowerCase();
    };
    
    module.exports.typeDetect = module.exports;
    
  provide("type-detect", module.exports);
}(global));

// pakmanager:content-type
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * content-type
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
     *
     * parameter     = token "=" ( token / quoted-string )
     * token         = 1*tchar
     * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
     *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
     *               / DIGIT / ALPHA
     *               ; any VCHAR, except delimiters
     * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
     * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
     * obs-text      = %x80-FF
     * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
     */
    var paramRegExp = /; *([!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+) */g
    var textRegExp = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
    
    /**
     * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
     *
     * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
     * obs-text    = %x80-FF
     */
    var qescRegExp = /\\([\u000b\u0020-\u00ff])/g
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
     */
    var quoteRegExp = /([\\"])/g
    
    /**
     * RegExp to match type in RFC 6838
     *
     * media-type = type "/" subtype
     * type       = token
     * subtype    = token
     */
    var typeRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+\/[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
    
    /**
     * Module exports.
     * @public
     */
    
    exports.format = format
    exports.parse = parse
    
    /**
     * Format object to media type.
     *
     * @param {object} obj
     * @return {string}
     * @public
     */
    
    function format(obj) {
      if (!obj || typeof obj !== 'object') {
        throw new TypeError('argument obj is required')
      }
    
      var parameters = obj.parameters
      var type = obj.type
    
      if (!type || !typeRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      var string = type
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          if (!tokenRegExp.test(param)) {
            throw new TypeError('invalid parameter name')
          }
    
          string += '; ' + param + '=' + qstring(parameters[param])
        }
      }
    
      return string
    }
    
    /**
     * Parse media type to object.
     *
     * @param {string|object} string
     * @return {Object}
     * @public
     */
    
    function parse(string) {
      if (!string) {
        throw new TypeError('argument string is required')
      }
    
      if (typeof string === 'object') {
        // support req/res-like objects as argument
        string = getcontenttype(string)
    
        if (typeof string !== 'string') {
          throw new TypeError('content-type header is missing from object');
        }
      }
    
      if (typeof string !== 'string') {
        throw new TypeError('argument string is required to be a string')
      }
    
      var index = string.indexOf(';')
      var type = index !== -1
        ? string.substr(0, index).trim()
        : string.trim()
    
      if (!typeRegExp.test(type)) {
        throw new TypeError('invalid media type')
      }
    
      var key
      var match
      var obj = new ContentType(type.toLowerCase())
      var value
    
      paramRegExp.lastIndex = index
    
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        obj.parameters[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      return obj
    }
    
    /**
     * Get content-type from req/res objects.
     *
     * @param {object}
     * @return {Object}
     * @private
     */
    
    function getcontenttype(obj) {
      if (typeof obj.getHeader === 'function') {
        // res-like
        return obj.getHeader('content-type')
      }
    
      if (typeof obj.headers === 'object') {
        // req-like
        return obj.headers && obj.headers['content-type']
      }
    }
    
    /**
     * Quote a string if necessary.
     *
     * @param {string} val
     * @return {string}
     * @private
     */
    
    function qstring(val) {
      var str = String(val)
    
      // no need to quote tokens
      if (tokenRegExp.test(str)) {
        return str
      }
    
      if (str.length > 0 && !textRegExp.test(str)) {
        throw new TypeError('invalid parameter value')
      }
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Class to represent a content type.
     * @private
     */
    function ContentType(type) {
      this.parameters = Object.create(null)
      this.type = type
    }
    
  provide("content-type", module.exports);
}(global));

// pakmanager:raw-body
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * raw-body
     * Copyright(c) 2013-2014 Jonathan Ong
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var bytes = require('bytes')
    var iconv = require('iconv-lite')
    var unpipe = require('unpipe')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = getRawBody
    
    /**
     * Module variables.
     * @private
     */
    
    var iconvEncodingMessageRegExp = /^Encoding not recognized: /
    
    /**
     * Get the decoder for a given encoding.
     *
     * @param {string} encoding
     * @private
     */
    
    function getDecoder(encoding) {
      if (!encoding) return null
    
      try {
        return iconv.getDecoder(encoding)
      } catch (e) {
        // error getting decoder
        if (!iconvEncodingMessageRegExp.test(e.message)) throw e
    
        // the encoding was not found
        throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', {
          encoding: encoding
        })
      }
    }
    
    /**
     * Get the raw body of a stream (typically HTTP).
     *
     * @param {object} stream
     * @param {object|string|function} [options]
     * @param {function} [callback]
     * @public
     */
    
    function getRawBody(stream, options, callback) {
      var done = callback
      var opts = options || {}
    
      if (options === true || typeof options === 'string') {
        // short cut for encoding
        opts = {
          encoding: options
        }
      }
    
      if (typeof options === 'function') {
        done = options
        opts = {}
      }
    
      // validate callback is a function, if provided
      if (done !== undefined && typeof done !== 'function') {
        throw new TypeError('argument callback must be a function')
      }
    
      // require the callback without promises
      if (!done && !global.Promise) {
        throw new TypeError('argument callback is required')
      }
    
      // get encoding
      var encoding = opts.encoding !== true
        ? opts.encoding
        : 'utf-8'
    
      // convert the limit to an integer
      var limit = bytes.parse(opts.limit)
    
      // convert the expected length to an integer
      var length = opts.length != null && !isNaN(opts.length)
        ? parseInt(opts.length, 10)
        : null
    
      if (done) {
        // classic callback style
        return readStream(stream, encoding, length, limit, done)
      }
    
      return new Promise(function executor(resolve, reject) {
        readStream(stream, encoding, length, limit, function onRead(err, buf) {
          if (err) return reject(err)
          resolve(buf)
        })
      })
    }
    
    /**
     * Halt a stream.
     *
     * @param {Object} stream
     * @private
     */
    
    function halt(stream) {
      // unpipe everything from the stream
      unpipe(stream)
    
      // pause stream
      if (typeof stream.pause === 'function') {
        stream.pause()
      }
    }
    
    /**
     * Make a serializable error object.
     *
     * To create serializable errors you must re-set message so
     * that it is enumerable and you must re configure the type
     * property so that is writable and enumerable.
     *
     * @param {number} status
     * @param {string} message
     * @param {string} type
     * @param {object} props
     * @private
     */
    
    function createError(status, message, type, props) {
      var error = new Error()
    
      // capture stack trace
      Error.captureStackTrace(error, createError)
    
      // set free-form properties
      for (var prop in props) {
        error[prop] = props[prop]
      }
    
      // set message
      error.message = message
    
      // set status
      error.status = status
      error.statusCode = status
    
      // set type
      Object.defineProperty(error, 'type', {
        value: type,
        enumerable: true,
        writable: true,
        configurable: true
      })
    
      return error
    }
    
    /**
     * Read the data from the stream.
     *
     * @param {object} stream
     * @param {string} encoding
     * @param {number} length
     * @param {number} limit
     * @param {function} callback
     * @public
     */
    
    function readStream(stream, encoding, length, limit, callback) {
      var complete = false
      var sync = true
    
      // check the length and limit options.
      // note: we intentionally leave the stream paused,
      // so users should handle the stream themselves.
      if (limit !== null && length !== null && length > limit) {
        return done(createError(413, 'request entity too large', 'entity.too.large', {
          expected: length,
          length: length,
          limit: limit
        }))
      }
    
      // streams1: assert request encoding is buffer.
      // streams2+: assert the stream encoding is buffer.
      //   stream._decoder: streams1
      //   state.encoding: streams2
      //   state.decoder: streams2, specifically < 0.10.6
      var state = stream._readableState
      if (stream._decoder || (state && (state.encoding || state.decoder))) {
        // developer error
        return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'))
      }
    
      var received = 0
      var decoder
    
      try {
        decoder = getDecoder(encoding)
      } catch (err) {
        return done(err)
      }
    
      var buffer = decoder
        ? ''
        : []
    
      // attach listeners
      stream.on('aborted', onAborted)
      stream.on('close', cleanup)
      stream.on('data', onData)
      stream.on('end', onEnd)
      stream.on('error', onEnd)
    
      // mark sync section complete
      sync = false
    
      function done() {
        var args = new Array(arguments.length)
    
        // copy arguments
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i]
        }
    
        // mark complete
        complete = true
    
        if (sync) {
          process.nextTick(invokeCallback)
        } else {
          invokeCallback()
        }
    
        function invokeCallback() {
          cleanup()
    
          if (args[0]) {
            // halt the stream on error
            halt(stream)
          }
    
          callback.apply(null, args)
        }
      }
    
      function onAborted() {
        if (complete) return
    
        done(createError(400, 'request aborted', 'request.aborted', {
          code: 'ECONNABORTED',
          expected: length,
          length: length,
          received: received
        }))
      }
    
      function onData(chunk) {
        if (complete) return
    
        received += chunk.length
        decoder
          ? buffer += decoder.write(chunk)
          : buffer.push(chunk)
    
        if (limit !== null && received > limit) {
          done(createError(413, 'request entity too large', 'entity.too.large', {
            limit: limit,
            received: received
          }))
        }
      }
    
      function onEnd(err) {
        if (complete) return
        if (err) return done(err)
    
        if (length !== null && received !== length) {
          done(createError(400, 'request size did not match content length', 'request.size.invalid', {
            expected: length,
            length: length,
            received: received
          }))
        } else {
          var string = decoder
            ? buffer + (decoder.end() || '')
            : Buffer.concat(buffer)
          cleanup()
          done(null, string)
        }
      }
    
      function cleanup() {
        buffer = null
    
        stream.removeListener('aborted', onAborted)
        stream.removeListener('data', onData)
        stream.removeListener('end', onEnd)
        stream.removeListener('error', onEnd)
        stream.removeListener('close', cleanup)
      }
    }
    
  provide("raw-body", module.exports);
}(global));

// pakmanager:type-is
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * type-is
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var typer = require('media-typer')
    var mime = require('mime-types')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = typeofrequest
    module.exports.is = typeis
    module.exports.hasBody = hasbody
    module.exports.normalize = normalize
    module.exports.match = mimeMatch
    
    /**
     * Compare a `value` content-type with `types`.
     * Each `type` can be an extension like `html`,
     * a special shortcut like `multipart` or `urlencoded`,
     * or a mime type.
     *
     * If no types match, `false` is returned.
     * Otherwise, the first `type` that matches is returned.
     *
     * @param {String} value
     * @param {Array} types
     * @public
     */
    
    function typeis(value, types_) {
      var i
      var types = types_
    
      // remove parameters and normalize
      var val = tryNormalizeType(value)
    
      // no type or invalid
      if (!val) {
        return false
      }
    
      // support flattened arguments
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length - 1)
        for (i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1]
        }
      }
    
      // no types, return the content type
      if (!types || !types.length) {
        return val
      }
    
      var type
      for (i = 0; i < types.length; i++) {
        if (mimeMatch(normalize(type = types[i]), val)) {
          return type[0] === '+' || type.indexOf('*') !== -1
            ? val
            : type
        }
      }
    
      // no matches
      return false
    }
    
    /**
     * Check if a request has a request body.
     * A request with a body __must__ either have `transfer-encoding`
     * or `content-length` headers set.
     * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
     *
     * @param {Object} request
     * @return {Boolean}
     * @public
     */
    
    function hasbody(req) {
      return req.headers['transfer-encoding'] !== undefined
        || !isNaN(req.headers['content-length'])
    }
    
    /**
     * Check if the incoming request contains the "Content-Type"
     * header field, and it contains any of the give mime `type`s.
     * If there is no request body, `null` is returned.
     * If there is no content type, `false` is returned.
     * Otherwise, it returns the first `type` that matches.
     *
     * Examples:
     *
     *     // With Content-Type: text/html; charset=utf-8
     *     this.is('html'); // => 'html'
     *     this.is('text/html'); // => 'text/html'
     *     this.is('text/*', 'application/json'); // => 'text/html'
     *
     *     // When Content-Type is application/json
     *     this.is('json', 'urlencoded'); // => 'json'
     *     this.is('application/json'); // => 'application/json'
     *     this.is('html', 'application/*'); // => 'application/json'
     *
     *     this.is('html'); // => false
     *
     * @param {String|Array} types...
     * @return {String|false|null}
     * @public
     */
    
    function typeofrequest(req, types_) {
      var types = types_
    
      // no body
      if (!hasbody(req)) {
        return null
      }
    
      // support flattened arguments
      if (arguments.length > 2) {
        types = new Array(arguments.length - 1)
        for (var i = 0; i < types.length; i++) {
          types[i] = arguments[i + 1]
        }
      }
    
      // request content type
      var value = req.headers['content-type']
    
      return typeis(value, types)
    }
    
    /**
     * Normalize a mime type.
     * If it's a shorthand, expand it to a valid mime type.
     *
     * In general, you probably want:
     *
     *   var type = is(req, ['urlencoded', 'json', 'multipart']);
     *
     * Then use the appropriate body parsers.
     * These three are the most common request body types
     * and are thus ensured to work.
     *
     * @param {String} type
     * @private
     */
    
    function normalize(type) {
      if (typeof type !== 'string') {
        // invalid type
        return false
      }
    
      switch (type) {
        case 'urlencoded':
          return 'application/x-www-form-urlencoded'
        case 'multipart':
          return 'multipart/*'
      }
    
      if (type[0] === '+') {
        // "+json" -> "*/*+json" expando
        return '*/*' + type
      }
    
      return type.indexOf('/') === -1
        ? mime.lookup(type)
        : type
    }
    
    /**
     * Check if `expected` mime type
     * matches `actual` mime type with
     * wildcard and +suffix support.
     *
     * @param {String} expected
     * @param {String} actual
     * @return {Boolean}
     * @private
     */
    
    function mimeMatch(expected, actual) {
      // invalid type
      if (expected === false) {
        return false
      }
    
      // split types
      var actualParts = actual.split('/')
      var expectedParts = expected.split('/')
    
      // invalid format
      if (actualParts.length !== 2 || expectedParts.length !== 2) {
        return false
      }
    
      // validate type
      if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
        return false
      }
    
      // validate suffix wildcard
      if (expectedParts[1].substr(0, 2) === '*+') {
        return expectedParts[1].length <= actualParts[1].length + 1
          && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)
      }
    
      // validate subtype
      if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
        return false
      }
    
      return true
    }
    
    /**
     * Normalize a type and remove parameters.
     *
     * @param {string} value
     * @return {string}
     * @private
     */
    
    function normalizeType(value) {
      // parse the type
      var type = typer.parse(value)
    
      // remove the parameters
      type.parameters = undefined
    
      // reformat it
      return typer.format(type)
    }
    
    /**
     * Try to normalize a type and remove parameters.
     *
     * @param {string} value
     * @return {string}
     * @private
     */
    
    function tryNormalizeType(value) {
      try {
        return normalizeType(value)
      } catch (err) {
        return null
      }
    }
    
  provide("type-is", module.exports);
}(global));

// pakmanager:anymatch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var arrify = require('arrify');
    var micromatch = require('micromatch');
    var path = require('path');
    
    var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
      criteria = arrify(criteria);
      value = arrify(value);
      if (arguments.length === 1) {
        return anymatch.bind(null, criteria.map(function(criterion) {
          return typeof criterion === 'string' && criterion[0] !== '!' ?
            micromatch.matcher(criterion) : criterion;
        }));
      }
      startIndex = startIndex || 0;
      var string = value[0];
      var altString;
      var matched = false;
      var matchIndex = -1;
      function testCriteria (criterion, index) {
        var result;
        switch (toString.call(criterion)) {
        case '[object String]':
          result = string === criterion || altString && altString === criterion;
          result = result || micromatch.isMatch(string, criterion);
          break;
        case '[object RegExp]':
          result = criterion.test(string) || altString && criterion.test(altString);
          break;
        case '[object Function]':
          result = criterion.apply(null, value);
          break;
        default:
          result = false;
        }
        if (result) {
          matchIndex = index + startIndex;
        }
        return result;
      }
      var crit = criteria;
      var negGlobs = crit.reduce(function(arr, criterion, index) {
        if (typeof criterion === 'string' && criterion[0] === '!') {
          if (crit === criteria) {
            // make a copy before modifying
            crit = crit.slice();
          }
          crit[index] = null;
          arr.push(criterion.substr(1));
        }
        return arr;
      }, []);
      if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
        if (path.sep === '\\' && typeof string === 'string') {
          altString = string.split('\\').join('/');
          altString = altString === string ? null : altString;
        }
        matched = crit.slice(startIndex, endIndex).some(testCriteria);
      }
      return returnIndex === true ? matchIndex : matched;
    };
    
    module.exports = anymatch;
    
  provide("anymatch", module.exports);
}(global));

// pakmanager:async-each
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // async-each MIT license (by Paul Miller from http://paulmillr.com).
    (function(globals) {
      'use strict';
      var each = function(items, next, callback) {
        if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
        if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
        if (typeof callback !== 'function') callback = Function.prototype; // no-op
    
        if (items.length === 0) return callback(undefined, items);
    
        var transformed = new Array(items.length);
        var count = 0;
        var returned = false;
    
        items.forEach(function(item, index) {
          next(item, function(error, transformedItem) {
            if (returned) return;
            if (error) {
              returned = true;
              return callback(error);
            }
            transformed[index] = transformedItem;
            count += 1;
            if (count === items.length) return callback(undefined, transformed);
          });
        });
      };
    
      if (typeof define !== 'undefined' && define.amd) {
        define([], function() {
          return each;
        }); // RequireJS
      } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = each; // CommonJS
      } else {
        globals.asyncEach = each; // <script>
      }
    })(this);
    
  provide("async-each", module.exports);
}(global));

// pakmanager:is-binary-path
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var binaryExtensions = require('binary-extensions');
    var exts = Object.create(null);
    
    binaryExtensions.forEach(function (el) {
    	exts[el] = true;
    });
    
    module.exports = function (filepath) {
    	return path.extname(filepath).slice(1).toLowerCase() in exts;
    };
    
  provide("is-binary-path", module.exports);
}(global));

// pakmanager:readdirp/stream-api
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var si = typeof setImmediate !== 'undefined' ? setImmediate : function (fn) { setTimeout(fn, 0) };
    
    var stream = require('readable-stream');
    var util = require('util');
    
    var Readable = stream.Readable;
    
    module.exports = ReaddirpReadable;
    
    util.inherits(ReaddirpReadable, Readable);
    
    function ReaddirpReadable (opts) {
      if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);
    
      opts = opts || {};
      
      opts.objectMode = true;
      Readable.call(this, opts);
    
      // backpressure not implemented at this point
      this.highWaterMark = Infinity;
    
      this._destroyed = false;
      this._paused = false;
      this._warnings = [];
      this._errors = [];
    
      this._pauseResumeErrors();
    }
    
    var proto = ReaddirpReadable.prototype;
    
    proto._pauseResumeErrors = function () {
      var self = this;
      self.on('pause', function () { self._paused = true });
      self.on('resume', function () {
        if (self._destroyed) return;
        self._paused = false;
    
        self._warnings.forEach(function (err) { self.emit('warn', err) });
        self._warnings.length = 0;
    
        self._errors.forEach(function (err) { self.emit('error', err) });
        self._errors.length = 0;
      })
    }
    
    // called for each entry
    proto._processEntry = function (entry) {
      if (this._destroyed) return;
      this.push(entry);
    }
    
    proto._read = function () { }
    
    proto.destroy = function () {
      // when stream is destroyed it will emit nothing further, not even errors or warnings
      this.push(null);
      this.readable = false;
      this._destroyed = true;
      this.emit('close');
    }
    
    proto._done = function () {
      this.push(null);
    }
    
    // we emit errors and warnings async since we may handle errors like invalid args
    // within the initial event loop before any event listeners subscribed
    proto._handleError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._warnings.push(err);
        if (!self._destroyed) self.emit('warn', err);
      });
    }
    
    proto._handleFatalError = function (err) {
      var self = this;
      si(function () { 
        if (self._paused) return self._errors.push(err);
        if (!self._destroyed) self.emit('error', err);
      });
    }
    
    function createStreamAPI () {
      var stream = new ReaddirpReadable();
    
      return { 
          stream           :  stream
        , processEntry     :  stream._processEntry.bind(stream)
        , done             :  stream._done.bind(stream)
        , handleError      :  stream._handleError.bind(stream)
        , handleFatalError :  stream._handleFatalError.bind(stream)
      };
    }
    
    module.exports = createStreamAPI;
    
  provide("readdirp/stream-api", module.exports);
}(global));

// pakmanager:readdirp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var fs        =  require('graceful-fs')
      , path      =  require('path')
      , minimatch =  require('minimatch')
      , toString  =  Object.prototype.toString
      ;
    
    // Standard helpers
    function isFunction (obj) {
      return toString.call(obj) === '[object Function]';
    }
    
    function isString (obj) {
      return toString.call(obj) === '[object String]';
    }
    
    function isRegExp (obj) {
      return toString.call(obj) === '[object RegExp]';
    }
    
    function isUndefined (obj) {
      return obj === void 0;
    }
    
    /** 
     * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
     * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
     * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
     *                                when callback2 is not given, it behaves like explained in callback2
     * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
     *                                function (err, fileInfos) { ... }
     */
    function readdir(opts, callback1, callback2) {
      var stream
        , handleError
        , handleFatalError
        , pending = 0
        , errors = []
        , readdirResult = {
            directories: []
          , files: []
        }
        , fileProcessed
        , allProcessed
        , realRoot
        , aborted = false
        ;
    
      // If no callbacks were given we will use a streaming interface
      if (isUndefined(callback1)) {
        var api          =   require('readdirp/stream-api')();
        stream           =  api.stream;
        callback1        =  api.processEntry;
        callback2        =  api.done;
        handleError      =  api.handleError;
        handleFatalError =  api.handleFatalError;
    
        stream.on('close', function () { aborted = true; });
      } else {
        handleError      =  function (err) { errors.push(err); };
        handleFatalError =  function (err) {
          handleError(err);
          allProcessed(errors, null);
        };
      }
    
      if (isUndefined(opts)){
        handleFatalError(new Error (
          'Need to pass at least one argument: opts! \n' +
          'https://github.com/thlorenz/readdirp#options'
          )
        );
        return stream;
      }
    
      opts.root            =  opts.root            || '.';
      opts.fileFilter      =  opts.fileFilter      || function() { return true; };
      opts.directoryFilter =  opts.directoryFilter || function() { return true; };
      opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
      opts.entryType       =  opts.entryType       || 'files';
    
      var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
    
      if (isUndefined(callback2)) {
        fileProcessed = function() { };
        allProcessed = callback1;
      } else {
        fileProcessed = callback1;
        allProcessed = callback2;
      }
    
      function normalizeFilter (filter) {
    
        if (isUndefined(filter)) return undefined;
    
        function isNegated (filters) {
    
          function negated(f) { 
            return f.indexOf('!') === 0; 
          }
    
          var some = filters.some(negated);
          if (!some) {
            return false;
          } else {
            if (filters.every(negated)) {
              return true;
            } else {
              // if we detect illegal filters, bail out immediately
              throw new Error(
                'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
                'https://github.com/thlorenz/readdirp#filters'
              );
            }
          }
        }
    
        // Turn all filters into a function
        if (isFunction(filter)) {
    
          return filter;
    
        } else if (isString(filter)) {
    
          return function (entryInfo) {
            return minimatch(entryInfo.name, filter.trim());
          };
    
        } else if (filter && Array.isArray(filter)) {
    
          if (filter) filter = filter.map(function (f) {
            return f.trim();
          });
    
          return isNegated(filter) ?
            // use AND to concat multiple negated filters
            function (entryInfo) {
              return filter.every(function (f) {
                return minimatch(entryInfo.name, f);
              });
            }
            :
            // use OR to concat multiple inclusive filters
            function (entryInfo) {
              return filter.some(function (f) {
                return minimatch(entryInfo.name, f);
              });
            };
        }
      }
    
      function processDir(currentDir, entries, callProcessed) {
        if (aborted) return;
        var total = entries.length
          , processed = 0
          , entryInfos = []
          ;
    
        fs.realpath(currentDir, function(err, realCurrentDir) {
          if (aborted) return;
          if (err) {
            handleError(err);
            callProcessed(entryInfos);
            return;
          }
    
          var relDir = path.relative(realRoot, realCurrentDir);
    
          if (entries.length === 0) {
            callProcessed([]);
          } else {
            entries.forEach(function (entry) { 
    
              var fullPath = path.join(realCurrentDir, entry)
                , relPath  = path.join(relDir, entry);
    
              statfn(fullPath, function (err, stat) {
                if (err) {
                  handleError(err);
                } else {
                  entryInfos.push({
                      name          :  entry
                    , path          :  relPath   // relative to root
                    , fullPath      :  fullPath
    
                    , parentDir     :  relDir    // relative to root
                    , fullParentDir :  realCurrentDir
    
                    , stat          :  stat
                  });
                }
                processed++;
                if (processed === total) callProcessed(entryInfos);
              });
            });
          }
        });
      }
    
      function readdirRec(currentDir, depth, callCurrentDirProcessed) {
        if (aborted) return;
    
        fs.readdir(currentDir, function (err, entries) {
          if (err) {
            handleError(err);
            callCurrentDirProcessed();
            return;
          }
    
          processDir(currentDir, entries, function(entryInfos) {
    
            var subdirs = entryInfos
              .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });
    
            subdirs.forEach(function (di) {
              if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
                fileProcessed(di);
              }
              readdirResult.directories.push(di); 
            });
    
            entryInfos
              .filter(function(ei) {
                var isCorrectType = opts.entryType === 'all' ?
                  !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
                return isCorrectType && opts.fileFilter(ei);
              })
              .forEach(function (fi) {
                if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
                  fileProcessed(fi);
                }
                readdirResult.files.push(fi); 
              });
    
            var pendingSubdirs = subdirs.length;
    
            // Be done if no more subfolders exist or we reached the maximum desired depth
            if(pendingSubdirs === 0 || depth === opts.depth) {
              callCurrentDirProcessed();
            } else {
              // recurse into subdirs, keeping track of which ones are done 
              // and call back once all are processed
              subdirs.forEach(function (subdir) {
                readdirRec(subdir.fullPath, depth + 1, function () {
                  pendingSubdirs = pendingSubdirs - 1;
                  if(pendingSubdirs === 0) { 
                    callCurrentDirProcessed();
                  }
                });
              });
            }
          });
        });
      }
    
      // Validate and normalize filters
      try {
        opts.fileFilter = normalizeFilter(opts.fileFilter);
        opts.directoryFilter = normalizeFilter(opts.directoryFilter);
      } catch (err) {
        // if we detect illegal filters, bail out immediately
        handleFatalError(err);
        return stream;
      }
    
      // If filters were valid get on with the show
      fs.realpath(opts.root, function(err, res) {
        if (err) {
          handleFatalError(err);
          return stream;
        }
    
        realRoot = res;
        readdirRec(opts.root, 0, function () { 
          // All errors are collected into the errors array
          if (errors.length > 0) {
            allProcessed(errors, readdirResult); 
          } else {
            allProcessed(null, readdirResult);
          }
        });
      });
    
      return stream;
    }
    
    module.exports = readdir;
    
  provide("readdirp", module.exports);
}(global));

// pakmanager:finalhandler
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * finalhandler
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var debug = require('debug')('finalhandler')
    var escapeHtml = require('escape-html')
    var http = require('http')
    var onFinished = require('on-finished')
    var unpipe = require('unpipe')
    
    /**
     * Module variables.
     * @private
     */
    
    /* istanbul ignore next */
    var defer = typeof setImmediate === 'function'
      ? setImmediate
      : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
    var isFinished = onFinished.isFinished
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = finalhandler
    
    /**
     * Create a function to handle the final response.
     *
     * @param {Request} req
     * @param {Response} res
     * @param {Object} [options]
     * @return {Function}
     * @public
     */
    
    function finalhandler(req, res, options) {
      var opts = options || {}
    
      // get environment
      var env = opts.env || process.env.NODE_ENV || 'development'
    
      // get error callback
      var onerror = opts.onerror
    
      return function (err) {
        var status = res.statusCode
    
        // ignore 404 on in-flight response
        if (!err && res._header) {
          debug('cannot 404 after headers sent')
          return
        }
    
        // unhandled error
        if (err) {
          // respect err.statusCode
          if (err.statusCode) {
            status = err.statusCode
          }
    
          // respect err.status
          if (err.status) {
            status = err.status
          }
    
          // default status code to 500
          if (!status || status < 400) {
            status = 500
          }
    
          // production gets a basic error message
          var msg = env === 'production'
            ? http.STATUS_CODES[status]
            : err.stack || err.toString()
          msg = escapeHtml(msg)
            .replace(/\n/g, '<br>')
            .replace(/  /g, ' &nbsp;') + '\n'
        } else {
          status = 404
          msg = 'Cannot ' + escapeHtml(req.method) + ' ' + escapeHtml(req.originalUrl || req.url) + '\n'
        }
    
        debug('default %s', status)
    
        // schedule onerror callback
        if (err && onerror) {
          defer(onerror, err, req, res)
        }
    
        // cannot actually respond
        if (res._header) {
          return req.socket.destroy()
        }
    
        send(req, res, status, msg)
      }
    }
    
    /**
     * Send response.
     *
     * @param {IncomingMessage} req
     * @param {OutgoingMessage} res
     * @param {number} status
     * @param {string} body
     * @private
     */
    
    function send(req, res, status, body) {
      function write() {
        res.statusCode = status
    
        // security header for content sniffing
        res.setHeader('X-Content-Type-Options', 'nosniff')
    
        // standard headers
        res.setHeader('Content-Type', 'text/html; charset=utf-8')
        res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))
    
        if (req.method === 'HEAD') {
          res.end()
          return
        }
    
        res.end(body, 'utf8')
      }
    
      if (isFinished(req)) {
        write()
        return
      }
    
      // unpipe everything from the request
      unpipe(req)
    
      // flush the request
      onFinished(req, write)
      req.resume()
    }
    
  provide("finalhandler", module.exports);
}(global));

// pakmanager:parseurl
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * parseurl
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     */
    
    var url = require('url')
    var parse = url.parse
    var Url = url.Url
    
    /**
     * Pattern for a simple path case.
     * See: https://github.com/joyent/node/pull/7878
     */
    
    var simplePathRegExp = /^(\/\/?(?!\/)[^\?#\s]*)(\?[^#\s]*)?$/
    
    /**
     * Exports.
     */
    
    module.exports = parseurl
    module.exports.original = originalurl
    
    /**
     * Parse the `req` url with memoization.
     *
     * @param {ServerRequest} req
     * @return {Object}
     * @api public
     */
    
    function parseurl(req) {
      var url = req.url
    
      if (url === undefined) {
        // URL is undefined
        return undefined
      }
    
      var parsed = req._parsedUrl
    
      if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed
      }
    
      // Parse the URL
      parsed = fastparse(url)
      parsed._raw = url
    
      return req._parsedUrl = parsed
    };
    
    /**
     * Parse the `req` original url with fallback and memoization.
     *
     * @param {ServerRequest} req
     * @return {Object}
     * @api public
     */
    
    function originalurl(req) {
      var url = req.originalUrl
    
      if (typeof url !== 'string') {
        // Fallback
        return parseurl(req)
      }
    
      var parsed = req._parsedOriginalUrl
    
      if (fresh(url, parsed)) {
        // Return cached URL parse
        return parsed
      }
    
      // Parse the URL
      parsed = fastparse(url)
      parsed._raw = url
    
      return req._parsedOriginalUrl = parsed
    };
    
    /**
     * Parse the `str` url with fast-path short-cut.
     *
     * @param {string} str
     * @return {Object}
     * @api private
     */
    
    function fastparse(str) {
      // Try fast path regexp
      // See: https://github.com/joyent/node/pull/7878
      var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)
    
      // Construct simple URL
      if (simplePath) {
        var pathname = simplePath[1]
        var search = simplePath[2] || null
        var url = Url !== undefined
          ? new Url()
          : {}
        url.path = str
        url.href = str
        url.pathname = pathname
        url.search = search
        url.query = search && search.substr(1)
    
        return url
      }
    
      return parse(str)
    }
    
    /**
     * Determine if parsed is still fresh for url.
     *
     * @param {string} url
     * @param {object} parsedUrl
     * @return {boolean}
     * @api private
     */
    
    function fresh(url, parsedUrl) {
      return typeof parsedUrl === 'object'
        && parsedUrl !== null
        && (Url === undefined || parsedUrl instanceof Url)
        && parsedUrl._raw === url
    }
    
  provide("parseurl", module.exports);
}(global));

// pakmanager:utils-merge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Merge object b with object a.
     *
     *     var a = { foo: 'bar' }
     *       , b = { bar: 'baz' };
     *
     *     merge(a, b);
     *     // => { foo: 'bar', bar: 'baz' }
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @api public
     */
    
    exports = module.exports = function(a, b){
      if (a && b) {
        for (var key in b) {
          a[key] = b[key];
        }
      }
      return a;
    };
    
  provide("utils-merge", module.exports);
}(global));

// pakmanager:custom-event
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var NativeCustomEvent = global.CustomEvent;
    
    function useNative () {
      try {
        var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
        return  'cat' === p.type && 'bar' === p.detail.foo;
      } catch (e) {
      }
      return false;
    }
    
    /**
     * Cross-browser `CustomEvent` constructor.
     *
     * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
     *
     * @public
     */
    
    module.exports = useNative() ? NativeCustomEvent :
    
    // IE >= 9
    'function' === typeof document.createEvent ? function CustomEvent (type, params) {
      var e = document.createEvent('CustomEvent');
      if (params) {
        e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
      } else {
        e.initCustomEvent(type, false, false, void 0);
      }
      return e;
    } :
    
    // IE <= 8
    function CustomEvent (type, params) {
      var e = document.createEventObject();
      e.type = type;
      if (params) {
        e.bubbles = Boolean(params.bubbles);
        e.cancelable = Boolean(params.cancelable);
        e.detail = params.detail;
      } else {
        e.bubbles = false;
        e.cancelable = false;
        e.detail = void 0;
      }
      return e;
    }
    
  provide("custom-event", module.exports);
}(global));

// pakmanager:ent/encode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var punycode = require('punycode');
    var revEntities = require('./reversed.json');
    
    module.exports = encode;
    
    function encode (str, opts) {
        if (typeof str !== 'string') {
            throw new TypeError('Expected a String');
        }
        if (!opts) opts = {};
    
        var numeric = true;
        if (opts.named) numeric = false;
        if (opts.numeric !== undefined) numeric = opts.numeric;
    
        var special = opts.special || {
            '"': true, "'": true,
            '<': true, '>': true,
            '&': true
        };
    
        var codePoints = punycode.ucs2.decode(str);
        var chars = [];
        for (var i = 0; i < codePoints.length; i++) {
            var cc = codePoints[i];
            var c = punycode.ucs2.encode([ cc ]);
            var e = revEntities[cc];
            if (e && (cc >= 127 || special[c]) && !numeric) {
                chars.push('&' + (/;$/.test(e) ? e : e + ';'));
            }
            else if (cc < 32 || cc >= 127 || special[c]) {
                chars.push('&#' + cc + ';');
            }
            else {
                chars.push(c);
            }
        }
        return chars.join('');
    }
    
  provide("ent/encode", module.exports);
}(global));

// pakmanager:ent/decode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var punycode = require('punycode');
    var entities = require('./entities.json');
    
    module.exports = decode;
    
    function decode (str) {
        if (typeof str !== 'string') {
            throw new TypeError('Expected a String');
        }
    
        return str.replace(/&(#?[^;\W]+;?)/g, function (_, match) {
            var m;
            if (m = /^#(\d+);?$/.exec(match)) {
                return punycode.ucs2.encode([ parseInt(m[1], 10) ]);
            } else if (m = /^#[Xx]([A-Fa-f0-9]+);?/.exec(match)) {
                return punycode.ucs2.encode([ parseInt(m[1], 16) ]);
            } else {
                // named entity
                var hasSemi = /;$/.test(match);
                var withoutSemi = hasSemi ? match.replace(/;$/, '') : match;
                var target = entities[withoutSemi] || (hasSemi && entities[match]);
    
                if (typeof target === 'number') {
                    return punycode.ucs2.encode([ target ]);
                } else if (typeof target === 'string') {
                    return target;
                } else {
                    return '&' + match;
                }
            }
        });
    }
    
  provide("ent/decode", module.exports);
}(global));

// pakmanager:ent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.encode =  require('ent/encode');
    exports.decode =  require('ent/decode');
    
  provide("ent", module.exports);
}(global));

// pakmanager:void-elements
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * This file automatically generated from `pre-publish.js`.
     * Do not manually edit.
     */
    
    module.exports = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "keygen": true,
      "link": true,
      "menuitem": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
    
  provide("void-elements", module.exports);
}(global));

// pakmanager:array-slice
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * array-slice <https://github.com/jonschlinkert/array-slice>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    
    'use strict';
    
    module.exports = function slice(arr, start, end) {
      var len = arr.length >>> 0;
      var range = [];
    
      start = idx(arr, start);
      end = idx(arr, end, len);
    
      while (start < end) {
        range.push(arr[start++]);
      }
      return range;
    };
    
    
    function idx(arr, pos, end) {
      var len = arr.length >>> 0;
    
      if (pos == null) {
        pos = end || 0;
      } else if (pos < 0) {
        pos = Math.max(len + pos, 0);
      } else {
        pos = Math.min(pos, len);
      }
    
      return pos;
    }
  provide("array-slice", module.exports);
}(global));

// pakmanager:eventemitter3
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var has = Object.prototype.hasOwnProperty;
    
    //
    // We store our EE objects in a plain object whose properties are event names.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // `~` to make sure that the built-in object properties are not overridden or
    // used as an attack vector.
    // We also assume that `Object.create(null)` is available when the event name
    // is an ES6 Symbol.
    //
    var prefix = typeof Object.create !== 'function' ? '~' : false;
    
    /**
     * Representation of a single EventEmitter function.
     *
     * @param {Function} fn Event handler to be called.
     * @param {Mixed} context Context for function execution.
     * @param {Boolean} [once=false] Only emit once
     * @api private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    
    /**
     * Minimal EventEmitter interface that is molded against the Node.js
     * EventEmitter interface.
     *
     * @constructor
     * @api public
     */
    function EventEmitter() { /* Nothing to set */ }
    
    /**
     * Hold the assigned EventEmitters by name.
     *
     * @type {Object}
     * @private
     */
    EventEmitter.prototype._events = undefined;
    
    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @api public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var events = this._events
        , names = []
        , name;
    
      if (!events) return names;
    
      for (name in events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
    
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
    
      return names;
    };
    
    /**
     * Return a list of assigned event listeners.
     *
     * @param {String} event The events that should be listed.
     * @param {Boolean} exists We only need to know if there are listeners.
     * @returns {Array|Boolean}
     * @api public
     */
    EventEmitter.prototype.listeners = function listeners(event, exists) {
      var evt = prefix ? prefix + event : event
        , available = this._events && this._events[evt];
    
      if (exists) return !!available;
      if (!available) return [];
      if (available.fn) return [available.fn];
    
      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
        ee[i] = available[i].fn;
      }
    
      return ee;
    };
    
    /**
     * Emit an event to all registered event listeners.
     *
     * @param {String} event The name of the event.
     * @returns {Boolean} Indication if we've emitted an event.
     * @api public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events || !this._events[evt]) return false;
    
      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;
    
      if ('function' === typeof listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
    
        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
    
        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
    
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;
    
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
    
          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
    
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
    
      return true;
    };
    
    /**
     * Register a new EventListener for the given event.
     *
     * @param {String} event Name of the event.
     * @param {Function} fn Callback function.
     * @param {Mixed} [context=this] The context of the function.
     * @api public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      var listener = new EE(fn, context || this)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events) this._events = prefix ? {} : Object.create(null);
      if (!this._events[evt]) this._events[evt] = listener;
      else {
        if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [
          this._events[evt], listener
        ];
      }
    
      return this;
    };
    
    /**
     * Add an EventListener that's only called once.
     *
     * @param {String} event Name of the event.
     * @param {Function} fn Callback function.
     * @param {Mixed} [context=this] The context of the function.
     * @api public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      var listener = new EE(fn, context || this, true)
        , evt = prefix ? prefix + event : event;
    
      if (!this._events) this._events = prefix ? {} : Object.create(null);
      if (!this._events[evt]) this._events[evt] = listener;
      else {
        if (!this._events[evt].fn) this._events[evt].push(listener);
        else this._events[evt] = [
          this._events[evt], listener
        ];
      }
    
      return this;
    };
    
    /**
     * Remove event listeners.
     *
     * @param {String} event The event we want to remove.
     * @param {Function} fn The listener that we need to find.
     * @param {Mixed} context Only remove listeners matching this context.
     * @param {Boolean} once Only remove once listeners.
     * @api public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
    
      if (!this._events || !this._events[evt]) return this;
    
      var listeners = this._events[evt]
        , events = [];
    
      if (fn) {
        if (listeners.fn) {
          if (
               listeners.fn !== fn
            || (once && !listeners.once)
            || (context && listeners.context !== context)
          ) {
            events.push(listeners);
          }
        } else {
          for (var i = 0, length = listeners.length; i < length; i++) {
            if (
                 listeners[i].fn !== fn
              || (once && !listeners[i].once)
              || (context && listeners[i].context !== context)
            ) {
              events.push(listeners[i]);
            }
          }
        }
      }
    
      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) {
        this._events[evt] = events.length === 1 ? events[0] : events;
      } else {
        delete this._events[evt];
      }
    
      return this;
    };
    
    /**
     * Remove all listeners or only the listeners for the specified event.
     *
     * @param {String} event The event want to remove all listeners for.
     * @api public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      if (!this._events) return this;
    
      if (event) delete this._events[prefix ? prefix + event : event];
      else this._events = prefix ? {} : Object.create(null);
    
      return this;
    };
    
    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    
    //
    // This function doesn't apply anymore.
    //
    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
      return this;
    };
    
    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;
    
    //
    // Expose the module.
    //
    if ('undefined' !== typeof module) {
      module.exports = EventEmitter;
    }
    
  provide("eventemitter3", module.exports);
}(global));

// pakmanager:wordwrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var wordwrap = module.exports = function (start, stop, params) {
        if (typeof start === 'object') {
            params = start;
            start = params.start;
            stop = params.stop;
        }
        
        if (typeof stop === 'object') {
            params = stop;
            start = start || params.start;
            stop = undefined;
        }
        
        if (!stop) {
            stop = start;
            start = 0;
        }
        
        if (!params) params = {};
        var mode = params.mode || 'soft';
        var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
        
        return function (text) {
            var chunks = text.toString()
                .split(re)
                .reduce(function (acc, x) {
                    if (mode === 'hard') {
                        for (var i = 0; i < x.length; i += stop - start) {
                            acc.push(x.slice(i, i + stop - start));
                        }
                    }
                    else acc.push(x)
                    return acc;
                }, [])
            ;
            
            return chunks.reduce(function (lines, rawChunk) {
                if (rawChunk === '') return lines;
                
                var chunk = rawChunk.replace(/\t/g, '    ');
                
                var i = lines.length - 1;
                if (lines[i].length + chunk.length > stop) {
                    lines[i] = lines[i].replace(/\s+$/, '');
                    
                    chunk.split(/\n/).forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else if (chunk.match(/\n/)) {
                    var xs = chunk.split(/\n/);
                    lines[i] += xs.shift();
                    xs.forEach(function (c) {
                        lines.push(
                            new Array(start + 1).join(' ')
                            + c.replace(/^\s+/, '')
                        );
                    });
                }
                else {
                    lines[i] += chunk;
                }
                
                return lines;
            }, [ new Array(start + 1).join(' ') ]).join('\n');
        };
    };
    
    wordwrap.soft = wordwrap;
    
    wordwrap.hard = function (start, stop) {
        return wordwrap(start, stop, { mode : 'hard' });
    };
    
  provide("wordwrap", module.exports);
}(global));

// pakmanager:socket.io-adapter
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var Emitter = require('events').EventEmitter;
    var parser = require('socket.io-parser');
    
    /**
     * Module exports.
     */
    
    module.exports = Adapter;
    
    /**
     * Memory adapter constructor.
     *
     * @param {Namespace} nsp
     * @api public
     */
    
    function Adapter(nsp){
      this.nsp = nsp;
      this.rooms = {};
      this.sids = {};
      this.encoder = new parser.Encoder();
    }
    
    /**
     * Inherits from `EventEmitter`.
     */
    
    Adapter.prototype.__proto__ = Emitter.prototype;
    
    /**
     * Adds a socket to a room.
     *
     * @param {String} socket id
     * @param {String} room name
     * @param {Function} callback
     * @api public
     */
    
    Adapter.prototype.add = function(id, room, fn){
      this.sids[id] = this.sids[id] || {};
      this.sids[id][room] = true;
      this.rooms[room] = this.rooms[room] || Room();
      this.rooms[room].add(id);
      if (fn) process.nextTick(fn.bind(null, null));
    };
    
    /**
     * Removes a socket from a room.
     *
     * @param {String} socket id
     * @param {String} room name
     * @param {Function} callback
     * @api public
     */
    
    Adapter.prototype.del = function(id, room, fn){
      this.sids[id] = this.sids[id] || {};
      delete this.sids[id][room];
      if (this.rooms.hasOwnProperty(room)) {
        this.rooms[room].del(id);
        if (this.rooms[room].length === 0) delete this.rooms[room];
      }
    
      if (fn) process.nextTick(fn.bind(null, null));
    };
    
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param {String} socket id
     * @param {Function} callback
     * @api public
     */
    
    Adapter.prototype.delAll = function(id, fn){
      var rooms = this.sids[id];
      if (rooms) {
        for (var room in rooms) {
          if (this.rooms.hasOwnProperty(room)) {
            this.rooms[room].del(id);
            if (this.rooms[room].length === 0) delete this.rooms[room];
          }
        }
      }
      delete this.sids[id];
    
      if (fn) process.nextTick(fn.bind(null, null));
    };
    
    /**
     * Broadcasts a packet.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet object
     * @api public
     */
    
    Adapter.prototype.broadcast = function(packet, opts){
      var rooms = opts.rooms || [];
      var except = opts.except || [];
      var flags = opts.flags || {};
      var packetOpts = {
        preEncoded: true,
        volatile: flags.volatile,
        compress: flags.compress
      };
      var ids = {};
      var self = this;
      var socket;
    
      packet.nsp = this.nsp.name;
      this.encoder.encode(packet, function(encodedPackets) {
        if (rooms.length) {
          for (var i = 0; i < rooms.length; i++) {
            var room = self.rooms[rooms[i]];
            if (!room) continue;
            var sockets = room.sockets;
            for (var id in sockets) {
              if (sockets.hasOwnProperty(id)) {
                if (ids[id] || ~except.indexOf(id)) continue;
                socket = self.nsp.connected[id];
                if (socket) {
                  socket.packet(encodedPackets, packetOpts);
                  ids[id] = true;
                }
              }
            }
          }
        } else {
          for (var id in self.sids) {
            if (self.sids.hasOwnProperty(id)) {
              if (~except.indexOf(id)) continue;
              socket = self.nsp.connected[id];
              if (socket) socket.packet(encodedPackets, packetOpts);
            }
          }
        }
      });
    };
    
    /**
     * Gets a list of clients by sid.
     *
     * @param {Array} explicit set of rooms to check.
     * @api public
     */
    
    Adapter.prototype.clients = function(rooms, fn){
      if ('function' == typeof rooms){
        fn = rooms;
        rooms = null;
      }
    
      rooms = rooms || [];
    
      var ids = {};
      var self = this;
      var sids = [];
      var socket;
    
      if (rooms.length) {
        for (var i = 0; i < rooms.length; i++) {
          var room = self.rooms[rooms[i]];
          if (!room) continue;
          var sockets = room.sockets;
          for (var id in sockets) {
            if (sockets.hasOwnProperty(id)) {
              if (ids[id]) continue;
              socket = self.nsp.connected[id];
              if (socket) {
                sids.push(id);
                ids[id] = true;
              }
            }
          }
        }
      } else {
        for (var id in self.sids) {
          if (self.sids.hasOwnProperty(id)) {
            socket = self.nsp.connected[id];
            if (socket) sids.push(id);
          }
        }
      }
    
      if (fn) process.nextTick(fn.bind(null, null, sids));
    };
    
    /**
    * Room constructor.
    *
    * @api private
    */
    
    function Room(){
      if (!(this instanceof Room)) return new Room();
      this.sockets = {};
      this.length = 0;
    }
    
    /**
     * Adds a socket to a room.
     *
     * @param {String} socket id
     * @api private
     */
    
    Room.prototype.add = function(id){
      if (!this.sockets.hasOwnProperty(id)) {
        this.sockets[id] = true;
        this.length++;
      }
    };
    
    /**
     * Removes a socket from a room.
     *
     * @param {String} socket id
     * @api private
     */
    
    Room.prototype.del = function(id){
      if (this.sockets.hasOwnProperty(id)) {
        delete this.sockets[id];
        this.length--;
      }
    };
    
  provide("socket.io-adapter", module.exports);
}(global));

// pakmanager:null-check
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (pth) {
    	if (String(pth).indexOf('\u0000') !== -1) {
    		var err = new Error('Path must be a string without null bytes.');
    		err.code = 'ENOENT';
    
    		throw err;
    	}
    };
    
  provide("null-check", module.exports);
}(global));

// pakmanager:is-absolute
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var isRelative = require('is-relative');
    var isWindows = require('is-windows');
    
    /**
     * Expose `isAbsolute`
     */
    
    module.exports = isAbsolute;
    
    /**
     * Returns true if a file path is absolute.
     *
     * @param  {String} `fp`
     * @return {Boolean}
     */
    
    function isAbsolute(fp) {
      if (typeof fp !== 'string') {
        throw new TypeError('isAbsolute expects a string.');
      }
      if (!isWindows() && isAbsolute.posix(fp)) {
        return true;
      }
      return isAbsolute.win32(fp);
    }
    
    /**
     * Test posix paths.
     */
    
    isAbsolute.posix = function posixPath(fp) {
      return fp.charAt(0) === '/';
    };
    
    /**
     * Test windows paths.
     */
    
    isAbsolute.win32 = function win32(fp) {
      if (/[a-z]/i.test(fp.charAt(0)) && fp.charAt(1) === ':' && fp.charAt(2) === '\\') {
        return true;
      }
      // Microsoft Azure absolute filepath
      if (fp.slice(0, 2) === '\\\\') {
        return true;
      }
      return !isRelative(fp);
    };
    
  provide("is-absolute", module.exports);
}(global));

// pakmanager:isexe/windows.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = isexe
    isexe.sync = sync
    
    var fs = require('fs')
    
    function checkPathExt (path, options) {
      var pathext = options.pathExt !== undefined ?
        options.pathExt : process.env.PATHEXT
    
      if (!pathext) {
        return true
      }
    
      pathext = pathext.split(';')
      if (pathext.indexOf('') !== -1) {
        return true
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase()
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true
        }
      }
      return false
    }
    
    function isexe (path, options, cb) {
      fs.stat(path, function (er, st) {
        cb(er, er ? false : checkPathExt(path, options))
      })
    }
    
    function sync (path, options) {
      fs.statSync(path)
      return checkPathExt(path, options)
    }
    
  provide("isexe/windows.js", module.exports);
}(global));

// pakmanager:isexe/access.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = isexe
    isexe.sync = sync
    
    var fs = require('fs')
    
    function isexe (path, _, cb) {
      fs.access(path, fs.X_OK, function (er) {
        cb(er, !er)
      })
    }
    
    function sync (path, _) {
      fs.accessSync(path, fs.X_OK)
      return true
    }
    
  provide("isexe/access.js", module.exports);
}(global));

// pakmanager:isexe/mode.js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = isexe
    isexe.sync = sync
    
    var fs = require('fs')
    
    function isexe (path, options, cb) {
      fs.stat(path, function (er, st) {
        cb(er, er ? false : checkMode(st, options))
      })
    }
    
    function sync (path, options) {
      return checkMode(fs.statSync(path), options)
    }
    
    function checkMode (stat, options) {
      var mod = stat.mode
      var uid = stat.uid
      var gid = stat.gid
    
      var myUid = options.uid !== undefined ?
        options.uid : process.getuid && process.getuid()
      var myGid = options.gid !== undefined ?
        options.gid : process.getgid && process.getgid()
    
      var u = parseInt('100', 8)
      var g = parseInt('010', 8)
      var o = parseInt('001', 8)
      var ug = u | g
    
      var ret = (mod & o) ||
        (mod & g) && gid === myGid ||
        (mod & u) && uid === myUid ||
        (mod & ug) && myUid === 0
    
      return ret
    }
    
  provide("isexe/mode.js", module.exports);
}(global));

// pakmanager:isexe
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var core
    if (process.platform === 'win32' || global.TESTING_WINDOWS) {
      core =  require('isexe/windows.js')
    } else if (typeof fs.access === 'function') {
      core =  require('isexe/access.js')
    } else {
      core =  require('isexe/mode.js')
    }
    
    module.exports = isexe
    isexe.sync = sync
    
    function isexe (path, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = {}
      }
    
      if (!cb) {
        if (typeof Promise !== 'function') {
          throw new TypeError('callback not provided')
        }
    
        return new Promise(function (resolve, reject) {
          isexe(path, options || {}, function (er, is) {
            if (er) {
              reject(er)
            } else {
              resolve(is)
            }
          })
        })
      }
    
      core(path, options || {}, function (er, is) {
        // ignore EACCES because that just means we aren't allowed to run it
        if (er) {
          if (er.code === 'EACCES' || options && options.ignoreErrors) {
            er = null
            is = false
          }
        }
        cb(er, is)
      })
    }
    
    function sync (path, options) {
      // my kingdom for a filtered catch
      try {
        return core.sync(path, options || {})
      } catch (er) {
        if (options && options.ignoreErrors || er.code === 'EACCES') {
          return false
        } else {
          throw er
        }
      }
    }
    
  provide("isexe", module.exports);
}(global));

// pakmanager:adm-zip/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require("./utils");
    module.exports.Constants = require("./constants");
    module.exports.Errors = require("./errors");
    module.exports.FileAttr = require("./fattr");
  provide("adm-zip/util", module.exports);
}(global));

// pakmanager:adm-zip/headers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.EntryHeader = require("./entryHeader");
    exports.MainHeader = require("./mainHeader");
    
  provide("adm-zip/headers", module.exports);
}(global));

// pakmanager:adm-zip/methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.Deflater = require("./deflater");
    exports.Inflater = require("./inflater");
  provide("adm-zip/methods", module.exports);
}(global));

// pakmanager:adm-zip/zipEntry
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Utils =  require('adm-zip/util'),
        Headers =  require('adm-zip/headers'),
        Constants = Utils.Constants,
        Methods =  require('adm-zip/methods');
    
    module.exports = function (/*Buffer*/input) {
    
        var _entryHeader = new Headers.EntryHeader(),
            _entryName = new Buffer(0),
            _comment = new Buffer(0),
            _isDirectory = false,
            uncompressedData = null,
            _extra = new Buffer(0);
    
        function getCompressedDataFromZip() {
            if (!input || !Buffer.isBuffer(input)) {
                return new Buffer(0);
            }
            _entryHeader.loadDataHeaderFromBinary(input);
            return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize)
        }
    
        function crc32OK(data) {
            // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written
            if (_entryHeader.flags & 0x8 != 0x8) {
               if (Utils.crc32(data) != _entryHeader.crc) {
                   return false;
               }
            } else {
                // @TODO: load and check data descriptor header
                // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure
                // (optionally preceded by a 4-byte signature) immediately after the compressed data:
            }
            return true;
        }
    
        function decompress(/*Boolean*/async, /*Function*/callback, /*String*/pass) {
            if(typeof callback === 'undefined' && typeof async === 'string') {
                pass=async;
                async=void 0;
            }
            if (_isDirectory) {
                if (async && callback) {
                    callback(new Buffer(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.
                }
                return new Buffer(0);
            }
    
            var compressedData = getCompressedDataFromZip();
           
            if (compressedData.length == 0) {
                if (async && callback) callback(compressedData, Utils.Errors.NO_DATA);//si added error.
                return compressedData;
            }
    
            var data = new Buffer(_entryHeader.size);
            data.fill(0);
    
            switch (_entryHeader.method) {
                case Utils.Constants.STORED:
                    compressedData.copy(data);
                    if (!crc32OK(data)) {
                        if (async && callback) callback(data, Utils.Errors.BAD_CRC);//si added error
                        return Utils.Errors.BAD_CRC;
                    } else {//si added otherwise did not seem to return data.
                        if (async && callback) callback(data);
                        return data;
                    }
                    break;
                case Utils.Constants.DEFLATED:
                    var inflater = new Methods.Inflater(compressedData);
                    if (!async) {
                        inflater.inflate(data);
                        if (!crc32OK(data)) {
                            console.warn(Utils.Errors.BAD_CRC + " " + _entryName.toString())
                        }
                        return data;
                    } else {
                        inflater.inflateAsync(function(result) {
                            result.copy(data, 0);
                            if (!crc32OK(data)) {
                                if (callback) callback(data, Utils.Errors.BAD_CRC); //si added error
                            } else { //si added otherwise did not seem to return data.
                                if (callback) callback(data);
                            }
                        })
                    }
                    break;
                default:
                    if (async && callback) callback(new Buffer(0), Utils.Errors.UNKNOWN_METHOD);
                    return Utils.Errors.UNKNOWN_METHOD;
            }
        }
    
        function compress(/*Boolean*/async, /*Function*/callback) {
            if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
                // no data set or the data wasn't changed to require recompression
                if (async && callback) callback(getCompressedDataFromZip());
                return getCompressedDataFromZip();
            }
    
            if (uncompressedData.length && !_isDirectory) {
                var compressedData;
                // Local file header
                switch (_entryHeader.method) {
                    case Utils.Constants.STORED:
                        _entryHeader.compressedSize = _entryHeader.size;
    
                        compressedData = new Buffer(uncompressedData.length);
                        uncompressedData.copy(compressedData);
    
                        if (async && callback) callback(compressedData);
                        return compressedData;
    
                        break;
                    default:
                    case Utils.Constants.DEFLATED:
    
                        var deflater = new Methods.Deflater(uncompressedData);
                        if (!async) {
                            var deflated = deflater.deflate();
                            _entryHeader.compressedSize = deflated.length;
                            return deflated;
                        } else {
                            deflater.deflateAsync(function(data) {
                                compressedData = new Buffer(data.length);
                                _entryHeader.compressedSize = data.length;
                                data.copy(compressedData);
                                callback && callback(compressedData);
                            })
                        }
                        deflater = null;
                        break;
                }
            } else {
                if (async && callback) {
                    callback(new Buffer(0));
                } else {
                    return new Buffer(0);
                }
            }
        }
    
        function readUInt64LE(buffer, offset) {
            return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
        }
    
        function parseExtra(data) {
            var offset = 0;
            var signature, size, part;
            while(offset<data.length) {
                signature = data.readUInt16LE(offset);
                offset += 2;
                size = data.readUInt16LE(offset);
                offset += 2;
                part = data.slice(offset, offset+size);
                offset += size;
                if(Constants.ID_ZIP64 === signature) {
                    parseZip64ExtendedInformation(part);
                }
            }
        }
    
        //Override header field values with values from the ZIP64 extra field
        function parseZip64ExtendedInformation(data) {
            var size, compressedSize, offset, diskNumStart;
    
            if(data.length >= Constants.EF_ZIP64_SCOMP) {
                size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);
                if(_entryHeader.size === Constants.EF_ZIP64_OR_32) {
                    _entryHeader.size = size;
                }
            }
            if(data.length >= Constants.EF_ZIP64_RHO) {
                compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);
                if(_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
                    _entryHeader.compressedSize = compressedSize;
                }
            }
            if(data.length >= Constants.EF_ZIP64_DSN) {
                offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);
                if(_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
                    _entryHeader.offset = offset;
                }
            }
            if(data.length >= Constants.EF_ZIP64_DSN+4) {
                diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
                if(_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
                    _entryHeader.diskNumStart = diskNumStart;
                }
            }
        }
    
    
        return {
            get entryName () { return _entryName.toString(); },
            get rawEntryName() { return _entryName; },
            set entryName (val) {
                _entryName = Utils.toBuffer(val);
                var lastChar = _entryName[_entryName.length - 1];
                _isDirectory = (lastChar == 47) || (lastChar == 92);
                _entryHeader.fileNameLength = _entryName.length;
            },
    
            get extra () { return _extra; },
            set extra (val) {
                _extra = val;
                _entryHeader.extraLength = val.length;
                parseExtra(val);
            },
    
            get comment () { return _comment.toString(); },
            set comment (val) {
                _comment = Utils.toBuffer(val);
                _entryHeader.commentLength = _comment.length;
            },
    
            get name () { var n = _entryName.toString(); return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop(); },
            get isDirectory () { return _isDirectory },
    
            getCompressedData : function() {
                return compress(false, null)
            },
    
            getCompressedDataAsync : function(/*Function*/callback) {
                compress(true, callback)
            },
    
            setData : function(value) {
                uncompressedData = Utils.toBuffer(value);
                if (!_isDirectory && uncompressedData.length) {
                    _entryHeader.size = uncompressedData.length;
                    _entryHeader.method = Utils.Constants.DEFLATED;
                    _entryHeader.crc = Utils.crc32(value);
                } else { // folders and blank files should be stored
                    _entryHeader.method = Utils.Constants.STORED;
                }
            },
    
            getData : function(pass) {
                return decompress(false, null, pass);
            },
    
            getDataAsync : function(/*Function*/callback, pass) {
                decompress(true, callback, pass)
            },
    
            set attr(attr) { _entryHeader.attr = attr; },
            get attr() { return _entryHeader.attr; },
    
            set header(/*Buffer*/data) {
                _entryHeader.loadFromBinary(data);
            },
    
            get header() {
                return _entryHeader;
            },
    
            packHeader : function() {
                var header = _entryHeader.entryHeaderToBinary();
                // add
                _entryName.copy(header, Utils.Constants.CENHDR);
                if (_entryHeader.extraLength) {
                    _extra.copy(header, Utils.Constants.CENHDR + _entryName.length)
                }
                if (_entryHeader.commentLength) {
                    _comment.copy(header, Utils.Constants.CENHDR + _entryName.length + _entryHeader.extraLength, _comment.length);
                }
                return header;
            },
    
            toString : function() {
                return '{\n' +
                    '\t"entryName" : "' + _entryName.toString() + "\",\n" +
                    '\t"name" : "' + _entryName.toString().split("/").pop() + "\",\n" +
                    '\t"comment" : "' + _comment.toString() + "\",\n" +
                    '\t"isDirectory" : ' + _isDirectory + ",\n" +
                    '\t"header" : ' + _entryHeader.toString().replace(/\t/mg, "\t\t") + ",\n" +
                    '\t"compressedData" : <' + (input && input.length  + " bytes buffer" || "null") + ">\n" +
                    '\t"data" : <' + (uncompressedData && uncompressedData.length  + " bytes buffer" || "null") + ">\n" +
                    '}';
            }
        }
    };
    
  provide("adm-zip/zipEntry", module.exports);
}(global));

// pakmanager:adm-zip/zipFile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ZipEntry =  require('adm-zip/zipEntry'),
        Headers =  require('adm-zip/headers'),
        Utils =  require('adm-zip/util');
    
    module.exports = function(/*String|Buffer*/input, /*Number*/inputType) {
        var entryList = [],
            entryTable = {},
            _comment = new Buffer(0),
            filename = "",
            fs = require("fs"),
            inBuffer = null,
            mainHeader = new Headers.MainHeader();
    
        if (inputType == Utils.Constants.FILE) {
            // is a filename
            filename = input;
            inBuffer = fs.readFileSync(filename);
            readMainHeader();
        } else if (inputType == Utils.Constants.BUFFER) {
            // is a memory buffer
            inBuffer = input;
            readMainHeader();
        } else {
            // none. is a new file
        }
    
        function readEntries() {
            entryTable = {};
            entryList = new Array(mainHeader.diskEntries);  // total number of entries
            var index = mainHeader.offset;  // offset of first CEN header
            for(var i = 0; i < entryList.length; i++) {
    
                var tmp = index,
                    entry = new ZipEntry(inBuffer);
                entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
    
                entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
    
                if (entry.header.extraLength) {
                    entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
                }
    
                if (entry.header.commentLength)
                    entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
    
                index += entry.header.entryHeaderSize;
    
                entryList[i] = entry;
                entryTable[entry.entryName] = entry;
            }
        }
    
        function readMainHeader() {
            var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size
                n = Math.max(0, i - 0xFFFF), // 0xFFFF is the max zip file comment length
                endOffset = -1; // Start offset of the END header
    
            for (i; i >= n; i--) {
                if (inBuffer[i] != 0x50) continue; // quick check that the byte is 'P'
                if (inBuffer.readUInt32LE(i) == Utils.Constants.ENDSIG) { // "PK\005\006"
                    endOffset = i;
                    break;
                }
            }
            if (!~endOffset)
                throw Utils.Errors.INVALID_FORMAT;
    
            mainHeader.loadFromBinary(inBuffer.slice(endOffset, endOffset + Utils.Constants.ENDHDR));
            if (mainHeader.commentLength) {
                _comment = inBuffer.slice(endOffset + Utils.Constants.ENDHDR);
            }
            readEntries();
        }
    
        return {
            /**
             * Returns an array of ZipEntry objects existent in the current opened archive
             * @return Array
             */
            get entries () {
                return entryList;
            },
    
            /**
             * Archive comment
             * @return {String}
             */
            get comment () { return _comment.toString(); },
            set comment(val) {
                mainHeader.commentLength = val.length;
                _comment = val;
            },
    
            /**
             * Returns a reference to the entry with the given name or null if entry is inexistent
             *
             * @param entryName
             * @return ZipEntry
             */
            getEntry : function(/*String*/entryName) {
                return entryTable[entryName] || null;
            },
    
            /**
             * Adds the given entry to the entry list
             *
             * @param entry
             */
            setEntry : function(/*ZipEntry*/entry) {
                entryList.push(entry);
                entryTable[entry.entryName] = entry;
                mainHeader.totalEntries = entryList.length;
            },
    
            /**
             * Removes the entry with the given name from the entry list.
             *
             * If the entry is a directory, then all nested files and directories will be removed
             * @param entryName
             */
            deleteEntry : function(/*String*/entryName) {
                var entry = entryTable[entryName];
                if (entry && entry.isDirectory) {
                    var _self = this;
                    this.getEntryChildren(entry).forEach(function(child) {
                        if (child.entryName != entryName) {
                            _self.deleteEntry(child.entryName)
                        }
                    })
                }
                entryList.splice(entryList.indexOf(entry), 1);
                delete(entryTable[entryName]);
                mainHeader.totalEntries = entryList.length;
            },
    
            /**
             *  Iterates and returns all nested files and directories of the given entry
             *
             * @param entry
             * @return Array
             */
            getEntryChildren : function(/*ZipEntry*/entry) {
                if (entry.isDirectory) {
                    var list = [],
                        name = entry.entryName,
                        len = name.length;
    
                    entryList.forEach(function(zipEntry) {
                        if (zipEntry.entryName.substr(0, len) == name) {
                            list.push(zipEntry);
                        }
                    });
                    return list;
                }
                return []
            },
    
            /**
             * Returns the zip file
             *
             * @return Buffer
             */
            compressToBuffer : function() {
                if (entryList.length > 1) {
                    entryList.sort(function(a, b) {
                        var nameA = a.entryName.toLowerCase();
                        var nameB = b.entryName.toLowerCase();
                        if (nameA < nameB) {return -1}
                        if (nameA > nameB) {return 1}
                        return 0;
                    });
                }
    
                var totalSize = 0,
                    dataBlock = [],
                    entryHeaders = [],
                    dindex = 0;
    
                mainHeader.size = 0;
                mainHeader.offset = 0;
    
                entryList.forEach(function(entry) {
                    entry.header.offset = dindex;
    
                    // compress data and set local and entry header accordingly. Reason why is called first
                    var compressedData = entry.getCompressedData();
                    // data header
                    var dataHeader = entry.header.dataHeaderToBinary();
                    var postHeader = new Buffer(entry.entryName + entry.extra.toString());
                    var dataLength = dataHeader.length + postHeader.length + compressedData.length;
    
                    dindex += dataLength;
    
                    dataBlock.push(dataHeader);
                    dataBlock.push(postHeader);
                    dataBlock.push(compressedData);
    
                    var entryHeader = entry.packHeader();
                    entryHeaders.push(entryHeader);
                    mainHeader.size += entryHeader.length;
                    totalSize += (dataLength + entryHeader.length);
                });
    
                totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                // point to end of data and begining of central directory first record
                mainHeader.offset = dindex;
    
                dindex = 0;
                var outBuffer = new Buffer(totalSize);
                dataBlock.forEach(function(content) {
                    content.copy(outBuffer, dindex); // write data blocks
                    dindex += content.length;
                });
                entryHeaders.forEach(function(content) {
                    content.copy(outBuffer, dindex); // write central directory entries
                    dindex += content.length;
                });
    
                var mh = mainHeader.toBinary();
                if (_comment) {
                    _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                }
    
                mh.copy(outBuffer, dindex); // write main header
    
                return outBuffer
            },
    
            toAsyncBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {
                if (entryList.length > 1) {
                    entryList.sort(function(a, b) {
                        var nameA = a.entryName.toLowerCase();
                        var nameB = b.entryName.toLowerCase();
                        if (nameA > nameB) {return -1}
                        if (nameA < nameB) {return 1}
                        return 0;
                    });
                }
    
                var totalSize = 0,
                    dataBlock = [],
                    entryHeaders = [],
                    dindex = 0;
    
                mainHeader.size = 0;
                mainHeader.offset = 0;
    
                var compress=function(entryList){
                    var self=arguments.callee;
                    var entry;
                    if(entryList.length){
                        var entry=entryList.pop();
                        var name=entry.entryName + entry.extra.toString();
                        if(onItemStart)onItemStart(name);
                        entry.getCompressedDataAsync(function(compressedData){
                            if(onItemEnd)onItemEnd(name);
    
                            entry.header.offset = dindex;
                            // data header
                            var dataHeader = entry.header.dataHeaderToBinary();
                            var postHeader = new Buffer(name);
                            var dataLength = dataHeader.length + postHeader.length + compressedData.length;
    
                            dindex += dataLength;
    
                            dataBlock.push(dataHeader);
                            dataBlock.push(postHeader);
                            dataBlock.push(compressedData);
    
                            var entryHeader = entry.packHeader();
                            entryHeaders.push(entryHeader);
                            mainHeader.size += entryHeader.length;
                            totalSize += (dataLength + entryHeader.length);
    
                            if(entryList.length){
                                self(entryList);
                            }else{
    
    
                                totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length
                                // point to end of data and begining of central directory first record
                                mainHeader.offset = dindex;
    
                                dindex = 0;
                                var outBuffer = new Buffer(totalSize);
                                dataBlock.forEach(function(content) {
                                    content.copy(outBuffer, dindex); // write data blocks
                                    dindex += content.length;
                                });
                                entryHeaders.forEach(function(content) {
                                    content.copy(outBuffer, dindex); // write central directory entries
                                    dindex += content.length;
                                });
    
                                var mh = mainHeader.toBinary();
                                if (_comment) {
                                    _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment
                                }
    
                                mh.copy(outBuffer, dindex); // write main header
    
                                onSuccess(outBuffer);
                            }
                        });
                    }
                };
    
                compress(entryList);
            }
        }
    };
    
  provide("adm-zip/zipFile", module.exports);
}(global));

// pakmanager:adm-zip
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require("fs"),
        pth = require("path");
    
    fs.existsSync = fs.existsSync || pth.existsSync;
    
    var ZipEntry =  require('adm-zip/zipEntry'),
        ZipFile =   require('adm-zip/zipFile'),
        Utils =  require('adm-zip/util');
    
    module.exports = function(/*String*/input) {
        var _zip = undefined,
            _filename = "";
    
        if (input && typeof input === "string") { // load zip file
            if (fs.existsSync(input)) {
                _filename = input;
                _zip = new ZipFile(input, Utils.Constants.FILE);
            } else {
               throw Utils.Errors.INVALID_FILENAME;
            }
        } else if(input && Buffer.isBuffer(input)) { // load buffer
            _zip = new ZipFile(input, Utils.Constants.BUFFER);
        } else { // create new zip file
            _zip = new ZipFile(null, Utils.Constants.NONE);
        }
    
        function getEntry(/*Object*/entry) {
            if (entry && _zip) {
                var item;
                // If entry was given as a file name
                if (typeof entry === "string")
                    item = _zip.getEntry(entry);
                // if entry was given as a ZipEntry object
                if (typeof entry === "object" && entry.entryName != undefined && entry.header != undefined)
                    item =  _zip.getEntry(entry.entryName);
    
                if (item) {
                    return item;
                }
            }
            return null;
        }
    
        return {
            /**
             * Extracts the given entry from the archive and returns the content as a Buffer object
             * @param entry ZipEntry object or String with the full path of the entry
             *
             * @return Buffer or Null in case of error
             */
            readFile : function(/*Object*/entry) {
                var item = getEntry(entry);
                return item && item.getData() || null;
            },
    
            /**
             * Asynchronous readFile
             * @param entry ZipEntry object or String with the full path of the entry
             * @param callback
             *
             * @return Buffer or Null in case of error
             */
            readFileAsync : function(/*Object*/entry, /*Function*/callback) {
                var item = getEntry(entry);
                if (item) {
                    item.getDataAsync(callback);
                } else {
                    callback(null,"getEntry failed for:" + entry)
                }
            },
    
            /**
             * Extracts the given entry from the archive and returns the content as plain text in the given encoding
             * @param entry ZipEntry object or String with the full path of the entry
             * @param encoding Optional. If no encoding is specified utf8 is used
             *
             * @return String
             */
            readAsText : function(/*Object*/entry, /*String - Optional*/encoding) {
                var item = getEntry(entry);
                if (item) {
                    var data = item.getData();
                    if (data && data.length) {
                        return data.toString(encoding || "utf8");
                    }
                }
                return "";
            },
    
            /**
             * Asynchronous readAsText
             * @param entry ZipEntry object or String with the full path of the entry
             * @param callback
             * @param encoding Optional. If no encoding is specified utf8 is used
             *
             * @return String
             */
            readAsTextAsync : function(/*Object*/entry, /*Function*/callback, /*String - Optional*/encoding) {
                var item = getEntry(entry);
                if (item) {
                    item.getDataAsync(function(data) {
                        if (data && data.length) {
                            callback(data.toString(encoding || "utf8"));
                        } else {
                            callback("");
                        }
                    })
                } else {
                    callback("");
                }
            },
    
            /**
             * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory
             *
             * @param entry
             */
            deleteFile : function(/*Object*/entry) { // @TODO: test deleteFile
                var item = getEntry(entry);
                if (item) {
                    _zip.deleteEntry(item.entryName);
                }
            },
    
            /**
             * Adds a comment to the zip. The zip must be rewritten after adding the comment.
             *
             * @param comment
             */
            addZipComment : function(/*String*/comment) { // @TODO: test addZipComment
                _zip.comment = comment;
            },
    
            /**
             * Returns the zip comment
             *
             * @return String
             */
            getZipComment : function() {
                return _zip.comment || '';
            },
    
            /**
             * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment
             * The comment cannot exceed 65535 characters in length
             *
             * @param entry
             * @param comment
             */
            addZipEntryComment : function(/*Object*/entry,/*String*/comment) {
                var item = getEntry(entry);
                if (item) {
                    item.comment = comment;
                }
            },
    
            /**
             * Returns the comment of the specified entry
             *
             * @param entry
             * @return String
             */
            getZipEntryComment : function(/*Object*/entry) {
                var item = getEntry(entry);
                if (item) {
                    return item.comment || '';
                }
                return ''
            },
    
            /**
             * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content
             *
             * @param entry
             * @param content
             */
            updateFile : function(/*Object*/entry, /*Buffer*/content) {
                var item = getEntry(entry);
                if (item) {
                    item.setData(content);
                }
            },
    
            /**
             * Adds a file from the disk to the archive
             *
             * @param localPath
             */
            addLocalFile : function(/*String*/localPath, /*String*/zipPath, /*String*/zipName) {
                 if (fs.existsSync(localPath)) {
                    if(zipPath){
                        zipPath=zipPath.split("\\").join("/");
                        if(zipPath.charAt(zipPath.length - 1) != "/"){
                            zipPath += "/";
                        }
                    }else{
                        zipPath="";
                    }
                     var p = localPath.split("\\").join("/").split("/").pop();
                    
                     if(zipName){
                        this.addFile(zipPath+zipName, fs.readFileSync(localPath), "", 0)
                     }else{
                        this.addFile(zipPath+p, fs.readFileSync(localPath), "", 0)
                     }
                 } else {
                     throw Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath);
                 }
            },
    
            /**
             * Adds a local directory and all its nested files and directories to the archive
             *
             * @param localPath
             * @param zipPath optional path inside zip
             * @param filter optional RegExp or Function if files match will
             *               be included.
             */
            addLocalFolder : function(/*String*/localPath, /*String*/zipPath, /*RegExp|Function*/filter) {
                if (filter === undefined) {
                  filter = function() { return true; };
                } else if (filter instanceof RegExp) {
                  filter = function(filter) {
                    return function(filename) {
                      return filter.test(filename);
                    }
                  }(filter);
                }
    
                if(zipPath){
                    zipPath=zipPath.split("\\").join("/");
                    if(zipPath.charAt(zipPath.length - 1) != "/"){
                        zipPath += "/";
                    }
                }else{
                    zipPath="";
                }
    			localPath = localPath.split("\\").join("/"); //windows fix
                localPath = pth.normalize(localPath);
                if (localPath.charAt(localPath.length - 1) != "/")
                    localPath += "/";
    
                if (fs.existsSync(localPath)) {
    
                    var items = Utils.findFiles(localPath),
                        self = this;
    
                    if (items.length) {
                        items.forEach(function(path) {
    						var p = path.split("\\").join("/").replace( new RegExp(localPath, 'i'), ""); //windows fix
                            if (filter(p)) {
                                if (p.charAt(p.length - 1) !== "/") {
                                    self.addFile(zipPath+p, fs.readFileSync(path), "", 0)
                                } else {
                                    self.addFile(zipPath+p, new Buffer(0), "", 0)
                                }
                            }
                        });
                    }
                } else {
                    throw Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath);
                }
            },
    
            /**
             * Allows you to create a entry (file or directory) in the zip file.
             * If you want to create a directory the entryName must end in / and a null buffer should be provided.
             * Comment and attributes are optional
             *
             * @param entryName
             * @param content
             * @param comment
             * @param attr
             */
            addFile : function(/*String*/entryName, /*Buffer*/content, /*String*/comment, /*Number*/attr) {
                var entry = new ZipEntry();
                entry.entryName = entryName;
                entry.comment = comment || "";
                entry.attr = attr || 438; //0666;
                if (entry.isDirectory && content.length) {
                   // throw Utils.Errors.DIRECTORY_CONTENT_ERROR;
                }
                entry.setData(content);
                _zip.setEntry(entry);
            },
    
            /**
             * Returns an array of ZipEntry objects representing the files and folders inside the archive
             *
             * @return Array
             */
            getEntries : function() {
                if (_zip) {
                   return _zip.entries;
                } else {
                    return [];
                }
            },
    
            /**
             * Returns a ZipEntry object representing the file or folder specified by ``name``.
             *
             * @param name
             * @return ZipEntry
             */
            getEntry : function(/*String*/name) {
                return getEntry(name);
            },
    
            /**
             * Extracts the given entry to the given targetPath
             * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted
             *
             * @param entry ZipEntry object or String with the full path of the entry
             * @param targetPath Target folder where to write the file
             * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder
             *                          will be created in targetPath as well. Default is TRUE
             * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
             *                  Default is FALSE
             *
             * @return Boolean
             */
            extractEntryTo : function(/*Object*/entry, /*String*/targetPath, /*Boolean*/maintainEntryPath, /*Boolean*/overwrite) {
                overwrite = overwrite || false;
                maintainEntryPath = typeof maintainEntryPath == "undefined" ? true : maintainEntryPath;
    
                var item = getEntry(entry);
                if (!item) {
                    throw Utils.Errors.NO_ENTRY;
                }
    
                var target = pth.resolve(targetPath, maintainEntryPath ? item.entryName : pth.basename(item.entryName));
    
                if (item.isDirectory) {
                    target = pth.resolve(target, "..");
                    var children = _zip.getEntryChildren(item);
                    children.forEach(function(child) {
                        if (child.isDirectory) return;
                        var content = child.getData();
                        if (!content) {
                            throw Utils.Errors.CANT_EXTRACT_FILE;
                        }
                        Utils.writeFileTo(pth.resolve(targetPath, maintainEntryPath ? child.entryName : child.entryName.substr(item.entryName.length)), content, overwrite);
                    });
                    return true;
                }
    
                var content = item.getData();
                if (!content) throw Utils.Errors.CANT_EXTRACT_FILE;
    
                if (fs.existsSync(target) && !overwrite) {
                    throw Utils.Errors.CANT_OVERRIDE;
                }
                Utils.writeFileTo(target, content, overwrite);
    
                return true;
            },
    
            /**
             * Extracts the entire archive to the given location
             *
             * @param targetPath Target location
             * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
             *                  Default is FALSE
             */
            extractAllTo : function(/*String*/targetPath, /*Boolean*/overwrite) {
                overwrite = overwrite || false;
                if (!_zip) {
                    throw Utils.Errors.NO_ZIP;
                }
    
                _zip.entries.forEach(function(entry) {
                    if (entry.isDirectory) {
                        Utils.makeDir(pth.resolve(targetPath, entry.entryName.toString()));
                        return;
                    }
                    var content = entry.getData();
                    if (!content) {
                        throw Utils.Errors.CANT_EXTRACT_FILE + "2";
                    }
                    Utils.writeFileTo(pth.resolve(targetPath, entry.entryName.toString()), content, overwrite);
                })
            },
    
            /**
             * Asynchronous extractAllTo
             *
             * @param targetPath Target location
             * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.
             *                  Default is FALSE
             * @param callback
             */
            extractAllToAsync : function(/*String*/targetPath, /*Boolean*/overwrite, /*Function*/callback) {
                overwrite = overwrite || false;
                if (!_zip) {
                    callback(new Error(Utils.Errors.NO_ZIP));
                    return;
                }
    
                var entries = _zip.entries;
                var i = entries.length; 
                entries.forEach(function(entry) {
                    if(i <= 0) return; // Had an error already
    
                    if (entry.isDirectory) {
                        Utils.makeDir(pth.resolve(targetPath, entry.entryName.toString()));
                        if(--i == 0)
                            callback(undefined);
                        return;
                    }
                    entry.getDataAsync(function(content) {
                        if(i <= 0) return;
                        if (!content) {
                            i = 0;
                            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE + "2"));
                            return;
                        }
                        Utils.writeFileToAsync(pth.resolve(targetPath, entry.entryName.toString()), content, overwrite, function(succ) {
                            if(i <= 0) return;
    
                            if(!succ) {
                                i = 0;
                                callback(new Error('Unable to write'));
                                return;
                            }
    
                            if(--i == 0)
                                callback(undefined);
                        });
                        
                    });
                })
            },
    
            /**
             * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip
             *
             * @param targetFileName
             * @param callback
             */
            writeZip : function(/*String*/targetFileName, /*Function*/callback) {
                if (arguments.length == 1) {
                    if (typeof targetFileName == "function") {
                        callback = targetFileName;
                        targetFileName = "";
                    }
                }
    
                if (!targetFileName && _filename) {
                    targetFileName = _filename;
                }
                if (!targetFileName) return;
    
                var zipData = _zip.compressToBuffer();
                if (zipData) {
                    var ok = Utils.writeFileTo(targetFileName, zipData, true);
                    if (typeof callback == 'function') callback(!ok? new Error("failed"): null, "");
                }
            },
    
            /**
             * Returns the content of the entire zip file as a Buffer object
             *
             * @return Buffer
             */
            toBuffer : function(/*Function*/onSuccess,/*Function*/onFail,/*Function*/onItemStart,/*Function*/onItemEnd) {
                this.valueOf = 2;
                if (typeof onSuccess == "function") {
                    _zip.toAsyncBuffer(onSuccess,onFail,onItemStart,onItemEnd);
                    return null;
                }
                return _zip.compressToBuffer()
            }
        }
    };
    
  provide("adm-zip", module.exports);
}(global));

// pakmanager:https-proxy-agent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var net = require('net');
    var tls = require('tls');
    var url = require('url');
    var extend = require('extend');
    var Agent = require('agent-base');
    var inherits = require('util').inherits;
    var debug = require('debug')('https-proxy-agent');
    
    /**
     * Module exports.
     */
    
    module.exports = HttpsProxyAgent;
    
    /**
     * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the
     * specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
     *
     * @api public
     */
    
    function HttpsProxyAgent (opts) {
      if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);
      if ('string' == typeof opts) opts = url.parse(opts);
      if (!opts) throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
      debug('creating new HttpsProxyAgent instance: %o', opts);
      Agent.call(this, connect);
    
      var proxy = extend({}, opts);
    
      // if `true`, then connect to the proxy server over TLS. defaults to `false`.
      this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;
    
      // prefer `hostname` over `host`, and set the `port` if needed
      proxy.host = proxy.hostname || proxy.host;
      proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);
    
      if (proxy.host && proxy.path) {
        // if both a `host` and `path` are specified then it's most likely the
        // result of a `url.parse()` call... we need to remove the `path` portion so
        // that `net.connect()` doesn't attempt to open that as a unix socket file.
        delete proxy.path;
        delete proxy.pathname;
      }
    
      this.proxy = proxy;
    }
    inherits(HttpsProxyAgent, Agent);
    
    /**
     * Called when the node-core HTTP client library is creating a new HTTP request.
     *
     * @api public
     */
    
    function connect (req, opts, fn) {
    
      var proxy = this.proxy;
    
      // create a socket connection to the proxy server
      var socket;
      if (this.secureProxy) {
        socket = tls.connect(proxy);
      } else {
        socket = net.connect(proxy);
      }
    
      // we need to buffer any HTTP traffic that happens with the proxy before we get
      // the CONNECT response, so that if the response is anything other than an "200"
      // response code, then we can re-play the "data" events on the socket once the
      // HTTP parser is hooked up...
      var buffers = [];
      var buffersLength = 0;
    
      function read () {
        var b = socket.read();
        if (b) ondata(b);
        else socket.once('readable', read);
      }
    
      function cleanup () {
        socket.removeListener('data', ondata);
        socket.removeListener('end', onend);
        socket.removeListener('error', onerror);
        socket.removeListener('close', onclose);
        socket.removeListener('readable', read);
      }
    
      function onclose (err) {
        debug('onclose had error %o', err);
      }
    
      function onend () {
        debug('onend');
      }
    
      function onerror (err) {
        cleanup();
        fn(err);
      }
    
      function ondata (b) {
        buffers.push(b);
        buffersLength += b.length;
        var buffered = Buffer.concat(buffers, buffersLength);
        var str = buffered.toString('ascii');
    
        if (!~str.indexOf('\r\n\r\n')) {
          // keep buffering
          debug('have not received end of HTTP headers yet...');
          if (socket.read) {
            read();
          } else {
            socket.once('data', ondata);
          }
          return;
        }
    
        var firstLine = str.substring(0, str.indexOf('\r\n'));
        var statusCode = +firstLine.split(' ')[1];
        debug('got proxy server response: %o', firstLine);
    
        if (200 == statusCode) {
          // 200 Connected status code!
          var sock = socket;
    
          // nullify the buffered data since we won't be needing it
          buffers = buffered = null;
    
          if (opts.secureEndpoint) {
            // since the proxy is connecting to an SSL server, we have
            // to upgrade this socket connection to an SSL connection
            debug('upgrading proxy-connected socket to TLS connection: %o', opts.host);
            opts.socket = socket;
            opts.servername = opts.host;
            opts.host = null;
            opts.hostname = null;
            opts.port = null;
            sock = tls.connect(opts);
          }
    
          cleanup();
          fn(null, sock);
        } else {
          // some other status code that's not 200... need to re-play the HTTP header
          // "data" events onto the socket once the HTTP machinery is attached so that
          // the user can parse and handle the error status code
          cleanup();
    
          // save a reference to the concat'd Buffer for the `onsocket` callback
          buffers = buffered;
    
          // need to wait for the "socket" event to re-play the "data" events
          req.once('socket', onsocket);
          fn(null, socket);
        }
      }
    
      function onsocket (socket) {
        // replay the "buffers" Buffer onto the `socket`, since at this point
        // the HTTP module machinery has been hooked up for the user
        if ('function' == typeof socket.ondata) {
          // node <= v0.11.3, the `ondata` function is set on the socket
          socket.ondata(buffers, 0, buffers.length);
        } else if (socket.listeners('data').length > 0) {
          // node > v0.11.3, the "data" event is listened for directly
          socket.emit('data', buffers);
        } else {
          // never?
          throw new Error('should not happen...');
        }
    
        // nullify the cached Buffer instance
        buffers = null;
      }
    
      socket.on('error', onerror);
      socket.on('close', onclose);
      socket.on('end', onend);
    
      if (socket.read) {
        read();
      } else {
        socket.once('data', ondata);
      }
    
      var hostname = opts.host + ':' + opts.port;
      var msg = 'CONNECT ' + hostname + ' HTTP/1.1\r\n';
      var auth = proxy.auth;
      if (auth) {
        msg += 'Proxy-Authorization: Basic ' + new Buffer(auth).toString('base64') + '\r\n';
      }
      msg += 'Host: ' + hostname + '\r\n' +
             'Connection: close\r\n' +
             '\r\n';
      socket.write(msg);
    };
    
  provide("https-proxy-agent", module.exports);
}(global));

// pakmanager:archiver
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Archiver Vending
     *
     * @ignore
     * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
     * @copyright (c) 2012-2014 Chris Talkington, contributors.
     */
    var Archiver = require('./lib/core');
    
    var formats = {};
    
    /**
     * Dispenses a new Archiver instance.
     *
     * @constructor
     * @param  {String} format The archive format to use.
     * @param  {Object} options See [Archiver]{@link Archiver}
     * @return {Archiver}
     */
    var vending = function(format, options) {
      return vending.create(format, options);
    };
    
    /**
     * Creates a new Archiver instance.
     *
     * @param  {String} format The archive format to use.
     * @param  {Object} options See [Archiver]{@link Archiver}
     * @return {Archiver}
     */
    vending.create = function(format, options) {
      if (formats[format]) {
        var instance = new Archiver(format, options);
        instance.setFormat(format);
        instance.setModule(new formats[format](options));
    
        return instance;
      } else {
        throw new Error('create(' + format + '): format not registered');
      }
    };
    
    /**
     * Registers a format for use with archiver.
     *
     * @param  {String} format The name of the format.
     * @param  {Function} module The function for archiver to interact with.
     * @return void
     */
    vending.registerFormat = function(format, module) {
      if (formats[format]) {
        throw new Error('register(' + format + '): format already registered');
      }
    
      if (typeof module !== 'function') {
        throw new Error('register(' + format + '): format module invalid');
      }
    
      if (typeof module.prototype.append !== 'function' || typeof module.prototype.finalize !== 'function') {
        throw new Error('register(' + format + '): format module missing methods');
      }
    
      formats[format] = module;
    };
    
    vending.registerFormat('zip', require('./lib/plugins/zip'));
    vending.registerFormat('tar', require('./lib/plugins/tar'));
    vending.registerFormat('json', require('./lib/plugins/json'));
    
    module.exports = vending;
  provide("archiver", module.exports);
}(global));

// pakmanager:q
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // vim:ts=4:sts=4:sw=4:
    /*!
     *
     * Copyright 2009-2012 Kris Kowal under the terms of the MIT
     * license found at http://github.com/kriskowal/q/raw/master/LICENSE
     *
     * With parts by Tyler Close
     * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
     * at http://www.opensource.org/licenses/mit-license.html
     * Forked at ref_send.js version: 2009-05-11
     *
     * With parts by Mark Miller
     * Copyright (C) 2011 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     */
    
    (function (definition) {
        "use strict";
    
        // This file will function properly as a <script> tag, or a module
        // using CommonJS and NodeJS or RequireJS module formats.  In
        // Common/Node/RequireJS, the module exports the Q API and when
        // executed as a simple <script>, it creates a Q global instead.
    
        // Montage Require
        if (typeof bootstrap === "function") {
            bootstrap("promise", definition);
    
        // CommonJS
        } else if (typeof exports === "object" && typeof module === "object") {
            module.exports = definition();
    
        // RequireJS
        } else if (typeof define === "function" && define.amd) {
            define(definition);
    
        // SES (Secure EcmaScript)
        } else if (typeof ses !== "undefined") {
            if (!ses.ok()) {
                return;
            } else {
                ses.makeQ = definition;
            }
    
        // <script>
        } else if (typeof window !== "undefined" || typeof self !== "undefined") {
            // Prefer window over self for add-on scripts. Use self for
            // non-windowed contexts.
            var global = typeof window !== "undefined" ? window : self;
    
            // Get the `window` object, save the previous Q global
            // and initialize Q as a global.
            var previousQ = global.Q;
            global.Q = definition();
    
            // Add a noConflict function so Q can be removed from the
            // global namespace.
            global.Q.noConflict = function () {
                global.Q = previousQ;
                return this;
            };
    
        } else {
            throw new Error("This environment was not anticipated by Q. Please file a bug.");
        }
    
    })(function () {
    "use strict";
    
    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }
    
    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;
    
    // shims
    
    // used for fallback in "allResolved"
    var noop = function () {};
    
    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick =(function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null};
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        // queue for late tasks, used by unhandled rejection tracking
        var laterQueue = [];
    
        function flush() {
            /* jshint loopfunc: true */
            var task, domain;
    
            while (head.next) {
                head = head.next;
                task = head.task;
                head.task = void 0;
                domain = head.domain;
    
                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
                runSingle(task, domain);
    
            }
            while (laterQueue.length) {
                task = laterQueue.pop();
                runSingle(task);
            }
            flushing = false;
        }
        // runs a single function in the async queue
        function runSingle(task, domain) {
            try {
                task();
    
            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!
    
                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }
    
                    throw e;
    
                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
            }
    
            if (domain) {
                domain.exit();
            }
        }
    
        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };
    
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
    
        if (typeof process === "object" &&
            process.toString() === "[object process]" && process.nextTick) {
            // Ensure Q is in a real Node environment, with a `process.nextTick`.
            // To see through fake Node environments:
            // * Mocha test runner - exposes a `process` global without a `nextTick`
            // * Browserify - exposes a `process.nexTick` function that uses
            //   `setTimeout`. In this case `setImmediate` is preferred because
            //    it is faster. Browserify's `process.toString()` yields
            //   "[object Object]", while in a real Node environment
            //   `process.nextTick()` yields "[object process]".
            isNodeJS = true;
    
            requestTick = function () {
                process.nextTick(flush);
            };
    
        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }
    
        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };
    
        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }
        // runs a task after all other tasks have been run
        // this is useful for unhandled rejection tracking that needs to happen
        // after all `then`d tasks have been run.
        nextTick.runAfter = function (task) {
            laterQueue.push(task);
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        return nextTick;
    })();
    
    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you don’t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Miller’s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis
    
    var array_slice = uncurryThis(Array.prototype.slice);
    
    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );
    
    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );
    
    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );
    
    var object_create = Object.create || function (prototype) {
        function Type() { }
        Type.prototype = prototype;
        return new Type();
    };
    
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    
    var object_keys = Object.keys || function (object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    
    var object_toString = uncurryThis(Object.prototype.toString);
    
    function isObject(value) {
        return value === Object(value);
    }
    
    // generator related shims
    
    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }
    
    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }
    
    // long stack traces
    
    var STACK_JUMP_SEPARATOR = "From previous event:";
    
    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);
    
            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }
    
    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];
    
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }
    
    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
               stackLine.indexOf("(node.js:") !== -1;
    }
    
    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }
    
        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }
    
        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }
    
    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
    
        if (!fileNameAndLineNumber) {
            return false;
        }
    
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
    
        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }
    
    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }
    
        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }
    
            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }
    
    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                             " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }
    
    // end of shims
    // beginning of real work
    
    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }
    
        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;
    
    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;
    
    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;
    
    // enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }
    
    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;
    
        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };
    
        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };
    
        promise.inspect = function () {
            if (!resolvedPromise) {
                return { state: "pending" };
            }
            return resolvedPromise.inspect();
        };
    
        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }
    
        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.
    
        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;
    
            array_reduce(messages, function (undefined, message) {
                Q.nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);
    
            messages = void 0;
            progressListeners = void 0;
        }
    
        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(Q(value));
        };
    
        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }
    
            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }
    
            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }
    
            array_reduce(progressListeners, function (undefined, progressListener) {
                Q.nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };
    
        return deferred;
    }
    
    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };
    
    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }
    
    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6
    
    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };
    
    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };
    
    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };
    
    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };
    
    /**
     * Returns a promise for the first of an array of promises to become settled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be settled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function (resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function (answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }
    
    Promise.prototype.race = function () {
        return this.then(Q.race);
    };
    
    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return {state: "unknown"};
            };
        }
    
        var promise = object_create(Promise.prototype);
    
        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };
    
        promise.inspect = inspect;
    
        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }
    
            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }
    
        return promise;
    }
    
    Promise.prototype.toString = function () {
        return "[object Promise]";
    };
    
    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
                            // single call to one of the callbacks
    
        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }
    
        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }
    
        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }
    
        Q.nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;
    
                deferred.resolve(_rejected(exception));
            }]);
        });
    
        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }
    
            if (!threw) {
                deferred.notify(newValue);
            }
        }]);
    
        return deferred.promise;
    };
    
    Q.tap = function (promise, callback) {
        return Q(promise).tap(callback);
    };
    
    /**
     * Works almost like "finally", but not called for rejections.
     * Original resolution value is passed through callback unaffected.
     * Callback may return a promise that will be awaited for.
     * @param {Function} callback
     * @returns {Q.Promise}
     * @example
     * doSomething()
     *   .then(...)
     *   .tap(console.log)
     *   .then(...);
     */
    Promise.prototype.tap = function (callback) {
        callback = Q(callback);
    
        return this.then(function (value) {
            return callback.fcall(value).thenResolve(value);
        });
    };
    
    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }
    
    Promise.prototype.thenResolve = function (value) {
        return this.then(function () { return value; });
    };
    
    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };
    
    Promise.prototype.thenReject = function (reason) {
        return this.then(function () { throw reason; });
    };
    
    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };
    
    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If it’s a fulfilled promise, the fulfillment value is nearer.
     * If it’s a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */
    
    // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }
    
    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }
    
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }
    
    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }
    
    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };
    
    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    
    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };
    
    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }
    
    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };
    
    //// BEGIN UNHANDLED REJECTION TRACKING
    
    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    
    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
    
        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }
    
    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                if (array_indexOf(unhandledRejections, promise) !== -1) {
                    process.emit("unhandledRejection", reason, promise);
                    reportedUnhandledRejections.push(promise);
                }
            });
        }
    
        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }
    
    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }
    
        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
                Q.nextTick.runAfter(function () {
                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
                    if (atReport !== -1) {
                        process.emit("rejectionHandled", unhandledReasons[at], promise);
                        reportedUnhandledRejections.splice(atReport, 1);
                    }
                });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }
    
    Q.resetUnhandledRejections = resetUnhandledRejections;
    
    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };
    
    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };
    
    resetUnhandledRejections();
    
    //// END UNHANDLED REJECTION TRACKING
    
    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return { state: "rejected", reason: reason };
        });
    
        // Note that the reason has not been handled.
        trackRejection(rejection, reason);
    
        return rejection;
    }
    
    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return { state: "fulfilled", value: value };
        });
    }
    
    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }
    
    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () {}
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }
    
    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }
    
    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };
    
    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;
    
                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.
    
                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }
    
    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }
    
    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }
    
    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }
    
    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }
    
    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };
    
    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };
    
    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };
    
    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };
    
    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };
    
    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
    Q["delete"] = function (object, key) {
        return Q(object).dispatch("delete", [key]);
    };
    
    Promise.prototype.del = // XXX legacy
    Promise.prototype["delete"] = function (key) {
        return this.dispatch("delete", [key]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
    Q.post = function (object, name, args) {
        return Q(object).dispatch("post", [name, args]);
    };
    
    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
    Promise.prototype.post = function (name, args) {
        return this.dispatch("post", [name, args]);
    };
    
    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
    Q.mcall = // XXX As proposed by "Redsandro"
    Q.invoke = function (object, name /*...args*/) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    
    Promise.prototype.send = // XXX Mark Miller's proposed parlance
    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
    Promise.prototype.invoke = function (name /*...args*/) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    
    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };
    
    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };
    
    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
    Q.fcall = function (object /* ...args*/) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
    };
    
    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };
    
    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    
    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };
    
    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };
    
    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++pendingCount;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--pendingCount === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({ index: index, value: progress });
                        }
                    );
                }
            }, void 0);
            if (pendingCount === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }
    
    Promise.prototype.all = function () {
        return all(this);
    };
    
    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     * @param {Array*} an array containing values or promises for values
     * @returns a promise fulfilled with the value of the first resolved promise,
     * or a rejected promise if all promises are rejected.
     */
    Q.any = any;
    
    function any(promises) {
        if (promises.length === 0) {
            return Q.resolve();
        }
    
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function (prev, current, index) {
            var promise = promises[index];
    
            pendingCount++;
    
            when(promise, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
                deferred.resolve(result);
            }
            function onRejected() {
                pendingCount--;
                if (pendingCount === 0) {
                    deferred.reject(new Error(
                        "Can't get fulfillment value from any promise, all " +
                        "promises were rejected."
                    ));
                }
            }
            function onProgress(progress) {
                deferred.notify({
                    index: index,
                    value: progress
                });
            }
        }, undefined);
    
        return deferred.promise;
    }
    
    Promise.prototype.any = function () {
        return any(this);
    };
    
    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }
    
    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };
    
    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }
    
    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };
    
    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
    Q["catch"] = function (object, rejected) {
        return Q(object).then(void 0, rejected);
    };
    
    Promise.prototype.fail = // XXX legacy
    Promise.prototype["catch"] = function (rejected) {
        return this.then(void 0, rejected);
    };
    
    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }
    
    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };
    
    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
    Q["finally"] = function (object, callback) {
        return Q(object)["finally"](callback);
    };
    
    Promise.prototype.fin = // XXX legacy
    Promise.prototype["finally"] = function (callback) {
        callback = Q(callback);
        return this.then(function (value) {
            return callback.fcall().then(function () {
                return value;
            });
        }, function (reason) {
            // TODO attempt to recycle the rejection with "this".
            return callback.fcall().then(function () {
                throw reason;
            });
        });
    };
    
    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };
    
    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };
    
        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;
    
        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }
    
        promise.then(void 0, onUnhandledError);
    };
    
    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {Any*} custom error message or Error object (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, error) {
        return Q(object).timeout(ms, error);
    };
    
    Promise.prototype.timeout = function (ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);
    
        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);
    
        return deferred.promise;
    };
    
    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };
    
    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };
    
    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
    Q.denodeify = function (callback /*...args*/) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nfbind =
    Promise.prototype.denodeify = function (/*...args*/) {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
    };
    
    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };
    
    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
    Q.npost = function (object, name, args) {
        return Q(object).npost(name, args);
    };
    
    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
    Promise.prototype.npost = function (name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
    Q.nmcall = // XXX Based on "Redsandro's" proposal
    Q.ninvoke = function (object, name /*...args*/) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
    Promise.prototype.ninvoke = function (name /*...args*/) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };
    
    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }
    
    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                Q.nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                Q.nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };
    
    Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
    };
    
    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();
    
    return Q;
    
    });
    
  provide("q", module.exports);
}(global));

// pakmanager:underscore.string/chars
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function chars(str) {
      return makeString(str).split('');
    };
    
  provide("underscore.string/chars", module.exports);
}(global));

// pakmanager:underscore.string/trim
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
    var nativeTrim = String.prototype.trim;
    
    module.exports = function trim(str, characters) {
      str = makeString(str);
      if (!characters && nativeTrim) return nativeTrim.call(str);
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
    };
    
  provide("underscore.string/trim", module.exports);
}(global));

// pakmanager:underscore.string/decapitalize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function decapitalize(str) {
      str = makeString(str);
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    
  provide("underscore.string/decapitalize", module.exports);
}(global));

// pakmanager:underscore.string/rtrim
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
    var nativeTrimRight = String.prototype.trimRight;
    
    module.exports = function rtrim(str, characters) {
      str = makeString(str);
      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp(characters + '+$'), '');
    };
    
  provide("underscore.string/rtrim", module.exports);
}(global));

// pakmanager:underscore.string/splice
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var chars =  require('underscore.string/chars');
    
    module.exports = function splice(str, i, howmany, substr) {
      var arr = chars(str);
      arr.splice(~~i, ~~howmany, substr);
      return arr.join('');
    };
    
  provide("underscore.string/splice", module.exports);
}(global));

// pakmanager:underscore.string/capitalize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function capitalize(str, lowercaseRest) {
      str = makeString(str);
      var remainingChars = !lowercaseRest ? str.slice(1) : str.slice(1).toLowerCase();
    
      return str.charAt(0).toUpperCase() + remainingChars;
    };
    
  provide("underscore.string/capitalize", module.exports);
}(global));

// pakmanager:underscore.string/camelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    var decap =  require('underscore.string/decapitalize');
    
    module.exports = function camelize(str, decapitalize) {
      str = trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
        return c ? c.toUpperCase() : '';
      });
    
      if (decapitalize === true) {
        return decap(str);
      } else {
        return str;
      }
    };
    
  provide("underscore.string/camelize", module.exports);
}(global));

// pakmanager:underscore.string/underscored
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    
    module.exports = function underscored(str) {
      return trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
    };
    
  provide("underscore.string/underscored", module.exports);
}(global));

// pakmanager:underscore.string/isBlank
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function isBlank(str) {
      return (/^\s*$/).test(makeString(str));
    };
    
  provide("underscore.string/isBlank", module.exports);
}(global));

// pakmanager:underscore.string/pad
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var strRepeat = require('./helper/strRepeat');
    
    module.exports = function pad(str, length, padStr, type) {
      str = makeString(str);
      length = ~~length;
    
      var padlen = 0;
    
      if (!padStr)
        padStr = ' ';
      else if (padStr.length > 1)
        padStr = padStr.charAt(0);
    
      switch (type) {
      case 'right':
        padlen = length - str.length;
        return str + strRepeat(padStr, padlen);
      case 'both':
        padlen = length - str.length;
        return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
      default: // 'left'
        padlen = length - str.length;
        return strRepeat(padStr, padlen) + str;
      }
    };
    
  provide("underscore.string/pad", module.exports);
}(global));

// pakmanager:underscore.string/toSentence
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var rtrim =  require('underscore.string/rtrim');
    
    module.exports = function toSentence(array, separator, lastSeparator, serial) {
      separator = separator || ', ';
      lastSeparator = lastSeparator || ' and ';
      var a = array.slice(),
        lastMember = a.pop();
    
      if (array.length > 2 && serial) lastSeparator = rtrim(separator) + lastSeparator;
    
      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
    };
    
  provide("underscore.string/toSentence", module.exports);
}(global));

// pakmanager:underscore.string/dasherize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    
    module.exports = function dasherize(str) {
      return trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
    };
    
  provide("underscore.string/dasherize", module.exports);
}(global));

// pakmanager:underscore.string/cleanDiacritics
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    var makeString = require('./helper/makeString');
    
    var from  = 'ąàáäâãåæăćčĉęèéëêĝĥìíïîĵłľńňòóöőôõðøśșşšŝťțţŭùúüűûñÿýçżźž',
      to    = 'aaaaaaaaaccceeeeeghiiiijllnnoooooooossssstttuuuuuunyyczzz';
    
    from += from.toUpperCase();
    to += to.toUpperCase();
    
    to = to.split('');
    
    // for tokens requireing multitoken output
    from += 'ß';
    to.push('ss');
    
    
    module.exports = function cleanDiacritics(str) {
      return makeString(str).replace(/.{1}/g, function(c){
        var index = from.indexOf(c);
        return index === -1 ? c : to[index];
      });
    };
    
  provide("underscore.string/cleanDiacritics", module.exports);
}(global));

// pakmanager:underscore.string/surround
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function surround(str, wrapper) {
      return [wrapper, str, wrapper].join('');
    };
    
  provide("underscore.string/surround", module.exports);
}(global));

// pakmanager:underscore.string/stripTags
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function stripTags(str) {
      return makeString(str).replace(/<\/?[^>]+>/g, '');
    };
    
  provide("underscore.string/stripTags", module.exports);
}(global));

// pakmanager:underscore.string/chop
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function chop(str, step) {
      if (str == null) return [];
      str = String(str);
      step = ~~step;
      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
    };
    
  provide("underscore.string/chop", module.exports);
}(global));

// pakmanager:underscore.string/clean
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    
    module.exports = function clean(str) {
      return trim(str).replace(/\s\s+/g, ' ');
    };
    
  provide("underscore.string/clean", module.exports);
}(global));

// pakmanager:underscore.string/count
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function(str, substr) {
      str = makeString(str);
      substr = makeString(substr);
    
      if (str.length === 0 || substr.length === 0) return 0;
      
      return str.split(substr).length - 1;
    };
    
  provide("underscore.string/count", module.exports);
}(global));

// pakmanager:underscore.string/swapCase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function swapCase(str) {
      return makeString(str).replace(/\S/g, function(c) {
        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
      });
    };
    
  provide("underscore.string/swapCase", module.exports);
}(global));

// pakmanager:underscore.string/escapeHTML
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var escapeChars = require('./helper/escapeChars');
    
    var regexString = '[';
    for(var key in escapeChars) {
      regexString += key;
    }
    regexString += ']';
    
    var regex = new RegExp( regexString, 'g');
    
    module.exports = function escapeHTML(str) {
    
      return makeString(str).replace(regex, function(m) {
        return '&' + escapeChars[m] + ';';
      });
    };
    
  provide("underscore.string/escapeHTML", module.exports);
}(global));

// pakmanager:underscore.string/unescapeHTML
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var htmlEntities = require('./helper/htmlEntities');
    
    module.exports = function unescapeHTML(str) {
      return makeString(str).replace(/\&([^;]+);/g, function(entity, entityCode) {
        var match;
    
        if (entityCode in htmlEntities) {
          return htmlEntities[entityCode];
        /*eslint no-cond-assign: 0*/
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        /*eslint no-cond-assign: 0*/
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      });
    };
    
  provide("underscore.string/unescapeHTML", module.exports);
}(global));

// pakmanager:underscore.string/insert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var splice =  require('underscore.string/splice');
    
    module.exports = function insert(str, i, substr) {
      return splice(str, i, 0, substr);
    };
    
  provide("underscore.string/insert", module.exports);
}(global));

// pakmanager:underscore.string/replaceAll
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function replaceAll(str, find, replace, ignorecase) {
      var flags = (ignorecase === true)?'gi':'g';
      var reg = new RegExp(find, flags);
    
      return makeString(str).replace(reg, replace);
    };
    
  provide("underscore.string/replaceAll", module.exports);
}(global));

// pakmanager:underscore.string/include
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function include(str, needle) {
      if (needle === '') return true;
      return makeString(str).indexOf(needle) !== -1;
    };
    
  provide("underscore.string/include", module.exports);
}(global));

// pakmanager:underscore.string/join
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var slice = [].slice;
    
    module.exports = function join() {
      var args = slice.call(arguments),
        separator = args.shift();
    
      return args.join(makeString(separator));
    };
    
  provide("underscore.string/join", module.exports);
}(global));

// pakmanager:underscore.string/lines
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function lines(str) {
      if (str == null) return [];
      return String(str).split(/\r\n?|\n/);
    };
    
  provide("underscore.string/lines", module.exports);
}(global));

// pakmanager:underscore.string/dedent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    function getIndent(str) {
      var matches = str.match(/^[\s\\t]*/gm);
      var indent = matches[0].length;
      
      for (var i = 1; i < matches.length; i++) {
        indent = Math.min(matches[i].length, indent);
      }
    
      return indent;
    }
    
    module.exports = function dedent(str, pattern) {
      str = makeString(str);
      var indent = getIndent(str);
      var reg;
    
      if (indent === 0) return str;
    
      if (typeof pattern === 'string') {
        reg = new RegExp('^' + pattern, 'gm');
      } else {
        reg = new RegExp('^[ \\t]{' + indent + '}', 'gm');
      }
    
      return str.replace(reg, '');
    };
    
  provide("underscore.string/dedent", module.exports);
}(global));

// pakmanager:underscore.string/reverse
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var chars =  require('underscore.string/chars');
    
    module.exports = function reverse(str) {
      return chars(str).reverse().join('');
    };
    
  provide("underscore.string/reverse", module.exports);
}(global));

// pakmanager:underscore.string/startsWith
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var toPositive = require('./helper/toPositive');
    
    module.exports = function startsWith(str, starts, position) {
      str = makeString(str);
      starts = '' + starts;
      position = position == null ? 0 : Math.min(toPositive(position), str.length);
      return str.lastIndexOf(starts, position) === position;
    };
    
  provide("underscore.string/startsWith", module.exports);
}(global));

// pakmanager:underscore.string/endsWith
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var toPositive = require('./helper/toPositive');
    
    module.exports = function endsWith(str, ends, position) {
      str = makeString(str);
      ends = '' + ends;
      if (typeof position == 'undefined') {
        position = str.length - ends.length;
      } else {
        position = Math.min(toPositive(position), str.length) - ends.length;
      }
      return position >= 0 && str.indexOf(ends, position) === position;
    };
    
  provide("underscore.string/endsWith", module.exports);
}(global));

// pakmanager:underscore.string/pred
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var adjacent = require('./helper/adjacent');
    
    module.exports = function succ(str) {
      return adjacent(str, -1);
    };
    
  provide("underscore.string/pred", module.exports);
}(global));

// pakmanager:underscore.string/succ
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var adjacent = require('./helper/adjacent');
    
    module.exports = function succ(str) {
      return adjacent(str, 1);
    };
    
  provide("underscore.string/succ", module.exports);
}(global));

// pakmanager:underscore.string/titleize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function titleize(str) {
      return makeString(str).toLowerCase().replace(/(?:^|\s|-)\S/g, function(c) {
        return c.toUpperCase();
      });
    };
    
  provide("underscore.string/titleize", module.exports);
}(global));

// pakmanager:underscore.string/classify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var capitalize =  require('underscore.string/capitalize');
    var camelize =  require('underscore.string/camelize');
    var makeString = require('./helper/makeString');
    
    module.exports = function classify(str) {
      str = makeString(str);
      return capitalize(camelize(str.replace(/[\W_]/g, ' ')).replace(/\s/g, ''));
    };
    
  provide("underscore.string/classify", module.exports);
}(global));

// pakmanager:underscore.string/humanize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var capitalize =  require('underscore.string/capitalize');
    var underscored =  require('underscore.string/underscored');
    var trim =  require('underscore.string/trim');
    
    module.exports = function humanize(str) {
      return capitalize(trim(underscored(str).replace(/_id$/, '').replace(/_/g, ' ')));
    };
    
  provide("underscore.string/humanize", module.exports);
}(global));

// pakmanager:underscore.string/ltrim
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var defaultToWhiteSpace = require('./helper/defaultToWhiteSpace');
    var nativeTrimLeft = String.prototype.trimLeft;
    
    module.exports = function ltrim(str, characters) {
      str = makeString(str);
      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
      characters = defaultToWhiteSpace(characters);
      return str.replace(new RegExp('^' + characters + '+'), '');
    };
    
  provide("underscore.string/ltrim", module.exports);
}(global));

// pakmanager:underscore.string/truncate
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function truncate(str, length, truncateStr) {
      str = makeString(str);
      truncateStr = truncateStr || '...';
      length = ~~length;
      return str.length > length ? str.slice(0, length) + truncateStr : str;
    };
    
  provide("underscore.string/truncate", module.exports);
}(global));

// pakmanager:underscore.string/prune
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * _s.prune: a more elegant version of truncate
     * prune extra chars, never leaving a half-chopped word.
     * @author github.com/rwz
     */
    var makeString = require('./helper/makeString');
    var rtrim =  require('underscore.string/rtrim');
    
    module.exports = function prune(str, length, pruneStr) {
      str = makeString(str);
      length = ~~length;
      pruneStr = pruneStr != null ? String(pruneStr) : '...';
    
      if (str.length <= length) return str;
    
      var tmpl = function(c) {
          return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
        },
        template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'
    
      if (template.slice(template.length - 2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, '');
      else
        template = rtrim(template.slice(0, template.length - 1));
    
      return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
    };
    
  provide("underscore.string/prune", module.exports);
}(global));

// pakmanager:underscore.string/words
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isBlank =  require('underscore.string/isBlank');
    var trim =  require('underscore.string/trim');
    
    module.exports = function words(str, delimiter) {
      if (isBlank(str)) return [];
      return trim(str, delimiter).split(delimiter || /\s+/);
    };
    
  provide("underscore.string/words", module.exports);
}(global));

// pakmanager:underscore.string/lpad
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pad =  require('underscore.string/pad');
    
    module.exports = function lpad(str, length, padStr) {
      return pad(str, length, padStr);
    };
    
  provide("underscore.string/lpad", module.exports);
}(global));

// pakmanager:underscore.string/rpad
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pad =  require('underscore.string/pad');
    
    module.exports = function rpad(str, length, padStr) {
      return pad(str, length, padStr, 'right');
    };
    
  provide("underscore.string/rpad", module.exports);
}(global));

// pakmanager:underscore.string/lrpad
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var pad =  require('underscore.string/pad');
    
    module.exports = function lrpad(str, length, padStr) {
      return pad(str, length, padStr, 'both');
    };
    
  provide("underscore.string/lrpad", module.exports);
}(global));

// pakmanager:underscore.string/sprintf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var deprecate = require('util-deprecate');
    
    module.exports = deprecate(require('sprintf-js').sprintf,
      'sprintf() will be removed in the next major release, use the sprintf-js package instead.');
    
  provide("underscore.string/sprintf", module.exports);
}(global));

// pakmanager:underscore.string/vsprintf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var deprecate = require('util-deprecate');
    
    module.exports = deprecate(require('sprintf-js').vsprintf,
      'vsprintf() will be removed in the next major release, use the sprintf-js package instead.');
    
  provide("underscore.string/vsprintf", module.exports);
}(global));

// pakmanager:underscore.string/toNumber
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function toNumber(num, precision) {
      if (num == null) return 0;
      var factor = Math.pow(10, isFinite(precision) ? precision : 0);
      return Math.round(num * factor) / factor;
    };
    
  provide("underscore.string/toNumber", module.exports);
}(global));

// pakmanager:underscore.string/numberFormat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function numberFormat(number, dec, dsep, tsep) {
      if (isNaN(number) || number == null) return '';
    
      number = number.toFixed(~~dec);
      tsep = typeof tsep == 'string' ? tsep : ',';
    
      var parts = number.split('.'),
        fnums = parts[0],
        decimals = parts[1] ? (dsep || '.') + parts[1] : '';
    
      return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
    };
    
  provide("underscore.string/numberFormat", module.exports);
}(global));

// pakmanager:underscore.string/strRight
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function strRight(str, sep) {
      str = makeString(str);
      sep = makeString(sep);
      var pos = !sep ? -1 : str.indexOf(sep);
      return~ pos ? str.slice(pos + sep.length, str.length) : str;
    };
    
  provide("underscore.string/strRight", module.exports);
}(global));

// pakmanager:underscore.string/strRightBack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function strRightBack(str, sep) {
      str = makeString(str);
      sep = makeString(sep);
      var pos = !sep ? -1 : str.lastIndexOf(sep);
      return~ pos ? str.slice(pos + sep.length, str.length) : str;
    };
    
  provide("underscore.string/strRightBack", module.exports);
}(global));

// pakmanager:underscore.string/strLeft
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function strLeft(str, sep) {
      str = makeString(str);
      sep = makeString(sep);
      var pos = !sep ? -1 : str.indexOf(sep);
      return~ pos ? str.slice(0, pos) : str;
    };
    
  provide("underscore.string/strLeft", module.exports);
}(global));

// pakmanager:underscore.string/strLeftBack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function strLeftBack(str, sep) {
      str = makeString(str);
      sep = makeString(sep);
      var pos = str.lastIndexOf(sep);
      return~ pos ? str.slice(0, pos) : str;
    };
    
  provide("underscore.string/strLeftBack", module.exports);
}(global));

// pakmanager:underscore.string/toSentenceSerial
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var toSentence =  require('underscore.string/toSentence');
    
    module.exports = function toSentenceSerial(array, sep, lastSep) {
      return toSentence(array, sep, lastSep, true);
    };
    
  provide("underscore.string/toSentenceSerial", module.exports);
}(global));

// pakmanager:underscore.string/slugify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    var dasherize =  require('underscore.string/dasherize');
    var cleanDiacritics =  require('underscore.string/cleanDiacritics');
    
    module.exports = function slugify(str) {
      return trim(dasherize(cleanDiacritics(str).replace(/[^\w\s-]/g, '-').toLowerCase()), '-');
    };
    
  provide("underscore.string/slugify", module.exports);
}(global));

// pakmanager:underscore.string/quote
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var surround =  require('underscore.string/surround');
    
    module.exports = function quote(str, quoteChar) {
      return surround(str, quoteChar || '"');
    };
    
  provide("underscore.string/quote", module.exports);
}(global));

// pakmanager:underscore.string/unquote
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function unquote(str, quoteChar) {
      quoteChar = quoteChar || '"';
      if (str[0] === quoteChar && str[str.length - 1] === quoteChar)
        return str.slice(1, str.length - 1);
      else return str;
    };
    
  provide("underscore.string/unquote", module.exports);
}(global));

// pakmanager:underscore.string/repeat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    var strRepeat = require('./helper/strRepeat');
    
    module.exports = function repeat(str, qty, separator) {
      str = makeString(str);
    
      qty = ~~qty;
    
      // using faster implementation if separator is not needed;
      if (separator == null) return strRepeat(str, qty);
    
      // this one is about 300x slower in Google Chrome
      /*eslint no-empty: 0*/
      for (var repeat = []; qty > 0; repeat[--qty] = str) {}
      return repeat.join(separator);
    };
    
  provide("underscore.string/repeat", module.exports);
}(global));

// pakmanager:underscore.string/naturalCmp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function naturalCmp(str1, str2) {
      if (str1 == str2) return 0;
      if (!str1) return -1;
      if (!str2) return 1;
    
      var cmpRegex = /(\.\d+|\d+|\D+)/g,
        tokens1 = String(str1).match(cmpRegex),
        tokens2 = String(str2).match(cmpRegex),
        count = Math.min(tokens1.length, tokens2.length);
    
      for (var i = 0; i < count; i++) {
        var a = tokens1[i],
          b = tokens2[i];
    
        if (a !== b) {
          var num1 = +a;
          var num2 = +b;
          if (num1 === num1 && num2 === num2) {
            return num1 > num2 ? 1 : -1;
          }
          return a < b ? -1 : 1;
        }
      }
    
      if (tokens1.length != tokens2.length)
        return tokens1.length - tokens2.length;
    
      return str1 < str2 ? -1 : 1;
    };
    
  provide("underscore.string/naturalCmp", module.exports);
}(global));

// pakmanager:underscore.string/levenshtein
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    /**
     * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein
     */
    module.exports = function levenshtein(str1, str2) {
      'use strict';
      str1 = makeString(str1);
      str2 = makeString(str2);
    
      // Short cut cases  
      if (str1 === str2) return 0;
      if (!str1 || !str2) return Math.max(str1.length, str2.length);
    
      // two rows
      var prevRow = new Array(str2.length + 1);
    
      // initialise previous row
      for (var i = 0; i < prevRow.length; ++i) {
        prevRow[i] = i;
      }
    
      // calculate current row distance from previous row
      for (i = 0; i < str1.length; ++i) {
        var nextCol = i + 1;
    
        for (var j = 0; j < str2.length; ++j) {
          var curCol = nextCol;
    
          // substution
          nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
          // insertion
          var tmp = curCol + 1;
          if (nextCol > tmp) {
            nextCol = tmp;
          }
          // deletion
          tmp = prevRow[j + 1] + 1;
          if (nextCol > tmp) {
            nextCol = tmp;
          }
    
          // copy current col value into previous (in preparation for next iteration)
          prevRow[j] = curCol;
        }
    
        // copy last col value into previous (in preparation for next iteration)
        prevRow[j] = nextCol;
      }
    
      return nextCol;
    };
    
  provide("underscore.string/levenshtein", module.exports);
}(global));

// pakmanager:underscore.string/toBoolean
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var trim =  require('underscore.string/trim');
    
    function boolMatch(s, matchers) {
      var i, matcher, down = s.toLowerCase();
      matchers = [].concat(matchers);
      for (i = 0; i < matchers.length; i += 1) {
        matcher = matchers[i];
        if (!matcher) continue;
        if (matcher.test && matcher.test(s)) return true;
        if (matcher.toLowerCase() === down) return true;
      }
    }
    
    module.exports = function toBoolean(str, trueValues, falseValues) {
      if (typeof str === 'number') str = '' + str;
      if (typeof str !== 'string') return !!str;
      str = trim(str);
      if (boolMatch(str, trueValues || ['true', '1'])) return true;
      if (boolMatch(str, falseValues || ['false', '0'])) return false;
    };
    
  provide("underscore.string/toBoolean", module.exports);
}(global));

// pakmanager:underscore.string/exports
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function() {
      var result = {};
    
      for (var prop in this) {
        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse|join|map|wrap)$/)) continue;
        result[prop] = this[prop];
      }
    
      return result;
    };
    
  provide("underscore.string/exports", module.exports);
}(global));

// pakmanager:underscore.string/wrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Wrap
    // wraps a string by a certain width
    
    var makeString = require('./helper/makeString');
    
    module.exports = function wrap(str, options){
      str = makeString(str);
      
      options = options || {};
      
      var width = options.width || 75;
      var seperator = options.seperator || '\n';
      var cut = options.cut || false;
      var preserveSpaces = options.preserveSpaces || false;
      var trailingSpaces = options.trailingSpaces || false;
      
      var result;
      
      if(width <= 0){
        return str;
      }
      
      else if(!cut){
      
        var words = str.split(' ');
        var current_column = 0;
        result = '';
      
        while(words.length > 0){
          
          // if adding a space and the next word would cause this line to be longer than width...
          if(1 + words[0].length + current_column > width){
            //start a new line if this line is not already empty
            if(current_column > 0){
              // add a space at the end of the line is preserveSpaces is true
              if (preserveSpaces){
                result += ' ';
                current_column++;
              }
              // fill the rest of the line with spaces if trailingSpaces option is true
              else if(trailingSpaces){
                while(current_column < width){
                  result += ' ';
                  current_column++;
                }            
              }
              //start new line
              result += seperator;
              current_column = 0;
            }
          }
      
          // if not at the begining of the line, add a space in front of the word
          if(current_column > 0){
            result += ' ';
            current_column++;
          }
      
          // tack on the next word, update current column, a pop words array
          result += words[0];
          current_column += words[0].length;
          words.shift();
      
        }
      
        // fill the rest of the line with spaces if trailingSpaces option is true
        if(trailingSpaces){
          while(current_column < width){
            result += ' ';
            current_column++;
          }            
        }
      
        return result;
      
      }
      
      else {
      
        var index = 0;
        result = '';
      
        // walk through each character and add seperators where appropriate
        while(index < str.length){
          if(index % width == 0 && index > 0){
            result += seperator;
          }
          result += str.charAt(index);
          index++;
        }
      
        // fill the rest of the line with spaces if trailingSpaces option is true
        if(trailingSpaces){
          while(index % width > 0){
            result += ' ';
            index++;
          }            
        }
        
        return result;
      }
    };
    
  provide("underscore.string/wrap", module.exports);
}(global));

// pakmanager:underscore.string/map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var makeString = require('./helper/makeString');
    
    module.exports = function(str, callback) {
      str = makeString(str);
    
      if (str.length === 0 || typeof callback !== 'function') return str;
    
      return str.replace(/./g, callback);
    };
    
  provide("underscore.string/map", module.exports);
}(global));

// pakmanager:underscore.string
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    * Underscore.string
    * (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
    * Underscore.string is freely distributable under the terms of the MIT license.
    * Documentation: https://github.com/epeli/underscore.string
    * Some code is borrowed from MooTools and Alexandru Marasteanu.
    * Version '3.3.4'
    * @preserve
    */
    
    'use strict';
    
    function s(value) {
      /* jshint validthis: true */
      if (!(this instanceof s)) return new s(value);
      this._wrapped = value;
    }
    
    s.VERSION = '3.3.4';
    
    s.isBlank          =  require('underscore.string/isBlank');
    s.stripTags        =  require('underscore.string/stripTags');
    s.capitalize       =  require('underscore.string/capitalize');
    s.decapitalize     =  require('underscore.string/decapitalize');
    s.chop             =  require('underscore.string/chop');
    s.trim             =  require('underscore.string/trim');
    s.clean            =  require('underscore.string/clean');
    s.cleanDiacritics  =  require('underscore.string/cleanDiacritics');
    s.count            =  require('underscore.string/count');
    s.chars            =  require('underscore.string/chars');
    s.swapCase         =  require('underscore.string/swapCase');
    s.escapeHTML       =  require('underscore.string/escapeHTML');
    s.unescapeHTML     =  require('underscore.string/unescapeHTML');
    s.splice           =  require('underscore.string/splice');
    s.insert           =  require('underscore.string/insert');
    s.replaceAll       =  require('underscore.string/replaceAll');
    s.include          =  require('underscore.string/include');
    s.join             =  require('underscore.string/join');
    s.lines            =  require('underscore.string/lines');
    s.dedent           =  require('underscore.string/dedent');
    s.reverse          =  require('underscore.string/reverse');
    s.startsWith       =  require('underscore.string/startsWith');
    s.endsWith         =  require('underscore.string/endsWith');
    s.pred             =  require('underscore.string/pred');
    s.succ             =  require('underscore.string/succ');
    s.titleize         =  require('underscore.string/titleize');
    s.camelize         =  require('underscore.string/camelize');
    s.underscored      =  require('underscore.string/underscored');
    s.dasherize        =  require('underscore.string/dasherize');
    s.classify         =  require('underscore.string/classify');
    s.humanize         =  require('underscore.string/humanize');
    s.ltrim            =  require('underscore.string/ltrim');
    s.rtrim            =  require('underscore.string/rtrim');
    s.truncate         =  require('underscore.string/truncate');
    s.prune            =  require('underscore.string/prune');
    s.words            =  require('underscore.string/words');
    s.pad              =  require('underscore.string/pad');
    s.lpad             =  require('underscore.string/lpad');
    s.rpad             =  require('underscore.string/rpad');
    s.lrpad            =  require('underscore.string/lrpad');
    s.sprintf          =  require('underscore.string/sprintf');
    s.vsprintf         =  require('underscore.string/vsprintf');
    s.toNumber         =  require('underscore.string/toNumber');
    s.numberFormat     =  require('underscore.string/numberFormat');
    s.strRight         =  require('underscore.string/strRight');
    s.strRightBack     =  require('underscore.string/strRightBack');
    s.strLeft          =  require('underscore.string/strLeft');
    s.strLeftBack      =  require('underscore.string/strLeftBack');
    s.toSentence       =  require('underscore.string/toSentence');
    s.toSentenceSerial =  require('underscore.string/toSentenceSerial');
    s.slugify          =  require('underscore.string/slugify');
    s.surround         =  require('underscore.string/surround');
    s.quote            =  require('underscore.string/quote');
    s.unquote          =  require('underscore.string/unquote');
    s.repeat           =  require('underscore.string/repeat');
    s.naturalCmp       =  require('underscore.string/naturalCmp');
    s.levenshtein      =  require('underscore.string/levenshtein');
    s.toBoolean        =  require('underscore.string/toBoolean');
    s.exports          =  require('underscore.string/exports');
    s.escapeRegExp     = require('./helper/escapeRegExp');
    s.wrap             =  require('underscore.string/wrap');
    s.map              =  require('underscore.string/map');
    
    // Aliases
    s.strip     = s.trim;
    s.lstrip    = s.ltrim;
    s.rstrip    = s.rtrim;
    s.center    = s.lrpad;
    s.rjust     = s.lpad;
    s.ljust     = s.rpad;
    s.contains  = s.include;
    s.q         = s.quote;
    s.toBool    = s.toBoolean;
    s.camelcase = s.camelize;
    s.mapChars  = s.map;
    
    
    // Implement chaining
    s.prototype = {
      value: function value() {
        return this._wrapped;
      }
    };
    
    function fn2method(key, fn) {
      if (typeof fn !== 'function') return;
      s.prototype[key] = function() {
        var args = [this._wrapped].concat(Array.prototype.slice.call(arguments));
        var res = fn.apply(null, args);
        // if the result is non-string stop the chain and return the value
        return typeof res === 'string' ? new s(res) : res;
      };
    }
    
    // Copy functions to instance methods for chaining
    for (var key in s) fn2method(key, s[key]);
    
    fn2method('tap', function tap(string, fn) {
      return fn(string);
    });
    
    function prototype2method(methodName) {
      fn2method(methodName, function(context) {
        var args = Array.prototype.slice.call(arguments, 1);
        return String.prototype[methodName].apply(context, args);
      });
    }
    
    var prototypeMethods = [
      'toUpperCase',
      'toLowerCase',
      'split',
      'replace',
      'slice',
      'substring',
      'substr',
      'concat'
    ];
    
    for (var method in prototypeMethods) prototype2method(prototypeMethods[method]);
    
    
    module.exports = s;
    
  provide("underscore.string", module.exports);
}(global));

// pakmanager:wrap-ansi
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var stringWidth = require('string-width');
    
    var ESCAPES = [
    	'\u001b',
    	'\u009b'
    ];
    
    var END_CODE = 39;
    
    var ESCAPE_CODES = {
    	0: 0,
    	1: 22,
    	2: 22,
    	3: 23,
    	4: 24,
    	7: 27,
    	8: 28,
    	9: 29,
    	30: 39,
    	31: 39,
    	32: 39,
    	33: 39,
    	34: 39,
    	35: 39,
    	36: 39,
    	37: 39,
    	90: 39,
    	40: 49,
    	41: 49,
    	42: 49,
    	43: 49,
    	44: 49,
    	45: 49,
    	46: 49,
    	47: 49
    };
    
    function wrapAnsi(code) {
    	return ESCAPES[0] + '[' + code + 'm';
    }
    
    // calculate the length of words split on ' ', ignoring
    // the extra characters added by ansi escape codes.
    function wordLengths(str) {
    	return str.split(' ').map(function (s) {
    		return stringWidth(s);
    	});
    }
    
    // wrap a long word across multiple rows.
    // ansi escape codes do not count towards length.
    function wrapWord(rows, word, cols) {
    	var insideEscape = false;
    	var visible = rows[rows.length - 1].length;
    
    	for (var i = 0; i < word.length; i++) {
    		var x = word[i];
    
    		rows[rows.length - 1] += x;
    
    		if (ESCAPES.indexOf(x) !== -1) {
    			insideEscape = true;
    		} else if (insideEscape && x === 'm') {
    			insideEscape = false;
    			continue;
    		}
    
    		if (insideEscape) {
    			continue;
    		}
    
    		visible++;
    
    		if (visible >= cols && i < word.length - 1) {
    			rows.push('');
    			visible = 0;
    		}
    	}
    
    	// it's possible that the last row we copy over is only
    	// ansi escape characters, handle this edge-case.
    	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
    		rows[rows.length - 2] += rows.pop();
    	}
    }
    
    // the wrap-ansi module can be invoked
    // in either 'hard' or 'soft' wrap mode.
    //
    // 'hard' will never allow a string to take up more
    // than cols characters.
    //
    // 'soft' allows long words to expand past the column length.
    function exec(str, cols, opts) {
    	var options = opts || {};
    
    	var pre = '';
    	var ret = '';
    	var escapeCode;
    
    	var lengths = wordLengths(str);
    	var words = str.split(' ');
    	var rows = [''];
    
    	for (var i = 0, word; (word = words[i]) !== undefined; i++) {
    		var rowLength = stringWidth(rows[rows.length - 1]);
    
    		if (rowLength) {
    			rows[rows.length - 1] += ' ';
    			rowLength++;
    		}
    
    		// in 'hard' wrap mode, the length of a line is
    		// never allowed to extend past 'cols'.
    		if (lengths[i] > cols && options.hard) {
    			if (rowLength) {
    				rows.push('');
    			}
    			wrapWord(rows, word, cols);
    			continue;
    		}
    
    		if (rowLength + lengths[i] > cols && rowLength > 0) {
    			rows.push('');
    		}
    
    		rows[rows.length - 1] += word;
    	}
    
    	pre = rows.map(function (r) {
    		return r.trim();
    	}).join('\n');
    
    	for (var j = 0; j < pre.length; j++) {
    		var y = pre[j];
    
    		ret += y;
    
    		if (ESCAPES.indexOf(y) !== -1) {
    			var code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));
    			escapeCode = code === END_CODE ? null : code;
    		}
    
    		if (escapeCode && ESCAPE_CODES[escapeCode]) {
    			if (pre[j + 1] === '\n') {
    				ret += wrapAnsi(ESCAPE_CODES[escapeCode]);
    			} else if (y === '\n') {
    				ret += wrapAnsi(escapeCode);
    			}
    		}
    	}
    
    	return ret;
    }
    
    // for each line break, invoke the method separately.
    module.exports = function (str, cols, opts) {
    	return String(str).split('\n').map(function (substr) {
    		return exec(substr, cols, opts);
    	}).join('\n');
    };
    
  provide("wrap-ansi", module.exports);
}(global));

// pakmanager:lcid
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var invertKv = require('invert-kv');
    var all = require('./lcid.json');
    var inverted = invertKv(all);
    
    exports.from = function (lcidCode) {
    	if (typeof lcidCode !== 'number') {
    		throw new TypeError('Expected a number');
    	}
    
    	return inverted[lcidCode];
    };
    
    exports.to = function (localeId) {
    	if (typeof localeId !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	return all[localeId];
    };
    
    exports.all = all;
    
  provide("lcid", module.exports);
}(global));

// pakmanager:find-up
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var pathExists = require('path-exists');
    var Promise = require('pinkie-promise');
    
    function splitPath(x) {
    	return path.resolve(x || '').split(path.sep);
    }
    
    function join(parts, filename) {
    	return path.resolve(parts.join(path.sep) + path.sep, filename);
    }
    
    module.exports = function (filename, opts) {
    	opts = opts || {};
    
    	var parts = splitPath(opts.cwd);
    
    	return new Promise(function (resolve) {
    		(function find() {
    			var fp = join(parts, filename);
    
    			pathExists(fp).then(function (exists) {
    				if (exists) {
    					resolve(fp);
    				} else if (parts.pop()) {
    					find();
    				} else {
    					resolve(null);
    				}
    			});
    		})();
    	});
    };
    
    module.exports.sync = function (filename, opts) {
    	opts = opts || {};
    
    	var parts = splitPath(opts.cwd);
    	var len = parts.length;
    
    	while (len--) {
    		var fp = join(parts, filename);
    
    		if (pathExists.sync(fp)) {
    			return fp;
    		}
    
    		parts.pop();
    	}
    
    	return null;
    };
    
  provide("find-up", module.exports);
}(global));

// pakmanager:object-assign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* eslint-disable no-unused-vars */
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    
    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}
    
    	return Object(val);
    }
    
    module.exports = Object.assign || function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;
    
    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);
    
    		for (var key in from) {
    			if (hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}
    
    		if (Object.getOwnPropertySymbols) {
    			symbols = Object.getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}
    
    	return to;
    };
    
  provide("object-assign", module.exports);
}(global));

// pakmanager:symbol
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* This Source Code Form is subject to the terms of the Mozilla Public
     * License, v. 2.0. If a copy of the MPL was not distributed with this
     * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    
    var crypto = require('crypto');
    
    var defineProperty = Object.defineProperty;
    function next() {
      return "@@symbol:" + crypto.randomBytes(8).toString('hex');
    }
    
    
    function Symbol(desc) {
      if (!(this instanceof Symbol)) {
        return new Symbol(desc);
      }
      var _symbol = this._symbol = next();
      defineProperty(this, '_desc', {
        value: desc,
        enumerable: false,
        writable: false,
        configurable: false
      });
      defineProperty(Object.prototype, _symbol, {
        set: function(value) {
          defineProperty(this, _symbol, {
            value: value,
            enumerable: false,
            writable: true
          });
        }
      });
    }
    
    Symbol.prototype.toString = function toString() {
      return this._symbol;
    };
    
    var globalSymbolRegistry = {};
    Symbol.for = function symbolFor(key) {
      key = String(key);
      return globalSymbolRegistry[key] || (globalSymbolRegistry[key] = Symbol(key));
    };
    
    Symbol.keyFor = function keyFor(sym) {
      if (!(sym instanceof Symbol)) {
        throw new TypeError("Symbol.keyFor requires a Symbol argument");
      }
      for (var key in globalSymbolRegistry) {
        if (globalSymbolRegistry[key] === sym) {
          return key;
        }
      }
      return undefined;
    };
    
    module.exports = this.Symbol || Symbol;
    
  provide("symbol", module.exports);
}(global));

// pakmanager:read-pkg
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var path = require('path');
    var loadJsonFile = require('load-json-file');
    var normalizePackageData = require('normalize-package-data');
    var pathType = require('path-type');
    
    module.exports = function (fp, opts) {
    	if (typeof fp !== 'string') {
    		opts = fp;
    		fp = '.';
    	}
    
    	opts = opts || {};
    
    	return pathType.dir(fp)
    		.then(function (isDir) {
    			if (isDir) {
    				fp = path.join(fp, 'package.json');
    			}
    
    			return loadJsonFile(fp);
    		})
    		.then(function (x) {
    			if (opts.normalize !== false) {
    				normalizePackageData(x);
    			}
    
    			return x;
    		});
    };
    
    module.exports.sync = function (fp, opts) {
    	if (typeof fp !== 'string') {
    		opts = fp;
    		fp = '.';
    	}
    
    	opts = opts || {};
    	fp = pathType.dirSync(fp) ? path.join(fp, 'package.json') : fp;
    
    	var x = loadJsonFile.sync(fp);
    
    	if (opts.normalize !== false) {
    		normalizePackageData(x);
    	}
    
    	return x;
    };
    
  provide("read-pkg", module.exports);
}(global));

// pakmanager:camelcase
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    function preserveCamelCase(str) {
    	var isLastCharLower = false;
    
    	for (var i = 0; i < str.length; i++) {
    		var c = str.charAt(i);
    
    		if (isLastCharLower && (/[a-zA-Z]/).test(c) && c.toUpperCase() === c) {
    			str = str.substr(0, i) + '-' + str.substr(i);
    			isLastCharLower = false;
    			i++;
    		} else {
    			isLastCharLower = (c.toLowerCase() === c);
    		}
    	}
    
    	return str;
    }
    
    module.exports = function () {
    	var str = [].map.call(arguments, function (str) {
    		return str.trim();
    	}).filter(function (str) {
    		return str.length;
    	}).join('-');
    
    	if (!str.length) {
    		return '';
    	}
    
    	if (str.length === 1) {
    		return str;
    	}
    
    	if (!(/[_.\- ]+/).test(str)) {
    		if (str === str.toUpperCase()) {
    			return str.toLowerCase();
    		}
    
    		if (str[0] !== str[0].toLowerCase()) {
    			return str[0].toLowerCase() + str.slice(1);
    		}
    
    		return str;
    	}
    
    	str = preserveCamelCase(str);
    
    	return str
    	.replace(/^[_.\- ]+/, '')
    	.toLowerCase()
    	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
    		return p1.toUpperCase();
    	});
    };
    
  provide("camelcase", module.exports);
}(global));

// pakmanager:lodash.assign
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.6 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var keys = require('lodash.keys'),
        rest = require('lodash.rest');
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    
    /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
    var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');
    
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        object[key] = value;
      }
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object) {
      return copyObjectWith(source, props, object);
    }
    
    /**
     * This function is like `copyObject` except that it accepts a function to
     * customize copied values.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObjectWith(source, props, object, customizer) {
      object || (object = {});
    
      var index = -1,
          length = props.length;
    
      while (++index < length) {
        var key = props[index];
    
        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : source[key];
    
        assignValue(object, key, newValue);
      }
      return object;
    }
    
    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return rest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;
    
        customizer = typeof customizer == 'function'
          ? (length--, customizer)
          : undefined;
    
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        return eq(object[index], value);
      }
      return false;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Assigns own enumerable properties of source objects to the destination
     * object. Source objects are applied from left to right. Subsequent sources
     * overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.c = 3;
     * }
     *
     * function Bar() {
     *   this.e = 5;
     * }
     *
     * Foo.prototype.d = 4;
     * Bar.prototype.f = 6;
     *
     * _.assign({ 'a': 1 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3, 'e': 5 }
     */
    var assign = createAssigner(function(object, source) {
      if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    
    module.exports = assign;
    
  provide("lodash.assign", module.exports);
}(global));

// pakmanager:warning
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2014-2015, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * LICENSE file in the root directory of this source tree. An additional grant
     * of patent rights can be found in the PATENTS file in the same directory.
     */
    
    'use strict';
    
    /**
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */
    
    var __DEV__ = process.env.NODE_ENV !== 'production';
    
    var warning = function() {};
    
    if (__DEV__) {
      warning = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === undefined) {
          throw new Error(
            '`warning(condition, format, ...args)` requires a warning ' +
            'message argument'
          );
        }
    
        if (format.length < 10 || (/^[s\W]*$/).test(format)) {
          throw new Error(
            'The warning format should be able to uniquely identify this ' +
            'warning. Please, use a more descriptive format than: ' + format
          );
        }
    
        if (!condition) {
          var argIndex = 0;
          var message = 'Warning: ' +
            format.replace(/%s/g, function() {
              return args[argIndex++];
            });
          if (typeof console !== 'undefined') {
            console.error(message);
          }
          try {
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
          } catch(x) {}
        }
      };
    }
    
    module.exports = warning;
    
  provide("warning", module.exports);
}(global));

// pakmanager:forwarded
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * forwarded
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     */
    
    module.exports = forwarded
    
    /**
     * Get all addresses in the request, using the `X-Forwarded-For` header.
     *
     * @param {Object} req
     * @api public
     */
    
    function forwarded(req) {
      if (!req) {
        throw new TypeError('argument req is required')
      }
    
      // simple header parsing
      var proxyAddrs = (req.headers['x-forwarded-for'] || '')
        .split(/ *, */)
        .filter(Boolean)
        .reverse()
      var socketAddr = req.connection.remoteAddress
      var addrs = [socketAddr].concat(proxyAddrs)
    
      // return all addresses
      return addrs
    }
    
  provide("forwarded", module.exports);
}(global));

// pakmanager:send
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * send
     * Copyright(c) 2012 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var createError = require('http-errors')
    var debug = require('debug')('send')
    var deprecate = require('depd')('send')
    var destroy = require('destroy')
    var escapeHtml = require('escape-html')
      , parseRange = require('range-parser')
      , Stream = require('stream')
      , mime = require('mime')
      , fresh = require('fresh')
      , path = require('path')
      , fs = require('fs')
      , normalize = path.normalize
      , join = path.join
    var etag = require('etag')
    var EventEmitter = require('events').EventEmitter;
    var ms = require('ms');
    var onFinished = require('on-finished')
    var statuses = require('statuses')
    
    /**
     * Variables.
     */
    var extname = path.extname
    var maxMaxAge = 60 * 60 * 24 * 365 * 1000; // 1 year
    var resolve = path.resolve
    var sep = path.sep
    var toString = Object.prototype.toString
    var upPathRegexp = /(?:^|[\\\/])\.\.(?:[\\\/]|$)/
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = send
    module.exports.mime = mime
    
    /**
     * Shim EventEmitter.listenerCount for node.js < 0.10
     */
    
    /* istanbul ignore next */
    var listenerCount = EventEmitter.listenerCount
      || function(emitter, type){ return emitter.listeners(type).length; };
    
    /**
     * Return a `SendStream` for `req` and `path`.
     *
     * @param {object} req
     * @param {string} path
     * @param {object} [options]
     * @return {SendStream}
     * @public
     */
    
    function send(req, path, options) {
      return new SendStream(req, path, options);
    }
    
    /**
     * Initialize a `SendStream` with the given `path`.
     *
     * @param {Request} req
     * @param {String} path
     * @param {object} [options]
     * @private
     */
    
    function SendStream(req, path, options) {
      var opts = options || {}
    
      this.options = opts
      this.path = path
      this.req = req
    
      this._etag = opts.etag !== undefined
        ? Boolean(opts.etag)
        : true
    
      this._dotfiles = opts.dotfiles !== undefined
        ? opts.dotfiles
        : 'ignore'
    
      if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"')
      }
    
      this._hidden = Boolean(opts.hidden)
    
      if (opts.hidden !== undefined) {
        deprecate('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead')
      }
    
      // legacy support
      if (opts.dotfiles === undefined) {
        this._dotfiles = undefined
      }
    
      this._extensions = opts.extensions !== undefined
        ? normalizeList(opts.extensions, 'extensions option')
        : []
    
      this._index = opts.index !== undefined
        ? normalizeList(opts.index, 'index option')
        : ['index.html']
    
      this._lastModified = opts.lastModified !== undefined
        ? Boolean(opts.lastModified)
        : true
    
      this._maxage = opts.maxAge || opts.maxage
      this._maxage = typeof this._maxage === 'string'
        ? ms(this._maxage)
        : Number(this._maxage)
      this._maxage = !isNaN(this._maxage)
        ? Math.min(Math.max(0, this._maxage), maxMaxAge)
        : 0
    
      this._root = opts.root
        ? resolve(opts.root)
        : null
    
      if (!this._root && opts.from) {
        this.from(opts.from)
      }
    }
    
    /**
     * Inherits from `Stream.prototype`.
     */
    
    SendStream.prototype.__proto__ = Stream.prototype;
    
    /**
     * Enable or disable etag generation.
     *
     * @param {Boolean} val
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.etag = deprecate.function(function etag(val) {
      val = Boolean(val);
      debug('etag %s', val);
      this._etag = val;
      return this;
    }, 'send.etag: pass etag as option');
    
    /**
     * Enable or disable "hidden" (dot) files.
     *
     * @param {Boolean} path
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.hidden = deprecate.function(function hidden(val) {
      val = Boolean(val);
      debug('hidden %s', val);
      this._hidden = val;
      this._dotfiles = undefined
      return this;
    }, 'send.hidden: use dotfiles option');
    
    /**
     * Set index `paths`, set to a falsy
     * value to disable index support.
     *
     * @param {String|Boolean|Array} paths
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.index = deprecate.function(function index(paths) {
      var index = !paths ? [] : normalizeList(paths, 'paths argument');
      debug('index %o', paths);
      this._index = index;
      return this;
    }, 'send.index: pass index as option');
    
    /**
     * Set root `path`.
     *
     * @param {String} path
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.root = function(path){
      path = String(path);
      this._root = resolve(path)
      return this;
    };
    
    SendStream.prototype.from = deprecate.function(SendStream.prototype.root,
      'send.from: pass root as option');
    
    SendStream.prototype.root = deprecate.function(SendStream.prototype.root,
      'send.root: pass root as option');
    
    /**
     * Set max-age to `maxAge`.
     *
     * @param {Number} maxAge
     * @return {SendStream}
     * @api public
     */
    
    SendStream.prototype.maxage = deprecate.function(function maxage(maxAge) {
      maxAge = typeof maxAge === 'string'
        ? ms(maxAge)
        : Number(maxAge);
      if (isNaN(maxAge)) maxAge = 0;
      if (Infinity == maxAge) maxAge = 60 * 60 * 24 * 365 * 1000;
      debug('max-age %d', maxAge);
      this._maxage = maxAge;
      return this;
    }, 'send.maxage: pass maxAge as option');
    
    /**
     * Emit error with `status`.
     *
     * @param {number} status
     * @param {Error} [error]
     * @private
     */
    
    SendStream.prototype.error = function error(status, error) {
      // emit if listeners instead of responding
      if (listenerCount(this, 'error') !== 0) {
        return this.emit('error', createError(error, status, {
          expose: false
        }))
      }
    
      var res = this.res
      var msg = statuses[status]
    
      // wipe all existing headers
      res._headers = null
    
      // send basic response
      res.statusCode = status
      res.setHeader('Content-Type', 'text/plain; charset=UTF-8')
      res.setHeader('Content-Length', Buffer.byteLength(msg))
      res.setHeader('X-Content-Type-Options', 'nosniff')
      res.end(msg)
    }
    
    /**
     * Check if the pathname ends with "/".
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.hasTrailingSlash = function(){
      return '/' == this.path[this.path.length - 1];
    };
    
    /**
     * Check if this is a conditional GET request.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isConditionalGET = function(){
      return this.req.headers['if-none-match']
        || this.req.headers['if-modified-since'];
    };
    
    /**
     * Strip content-* header fields.
     *
     * @private
     */
    
    SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
      var res = this.res
      var headers = Object.keys(res._headers || {})
    
      for (var i = 0; i < headers.length; i++) {
        var header = headers[i]
        if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
          res.removeHeader(header)
        }
      }
    }
    
    /**
     * Respond with 304 not modified.
     *
     * @api private
     */
    
    SendStream.prototype.notModified = function(){
      var res = this.res;
      debug('not modified');
      this.removeContentHeaderFields();
      res.statusCode = 304;
      res.end();
    };
    
    /**
     * Raise error that headers already sent.
     *
     * @api private
     */
    
    SendStream.prototype.headersAlreadySent = function headersAlreadySent(){
      var err = new Error('Can\'t set headers after they are sent.');
      debug('headers already sent');
      this.error(500, err);
    };
    
    /**
     * Check if the request is cacheable, aka
     * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isCachable = function(){
      var res = this.res;
      return (res.statusCode >= 200 && res.statusCode < 300) || 304 == res.statusCode;
    };
    
    /**
     * Handle stat() error.
     *
     * @param {Error} error
     * @private
     */
    
    SendStream.prototype.onStatError = function onStatError(error) {
      switch (error.code) {
        case 'ENAMETOOLONG':
        case 'ENOENT':
        case 'ENOTDIR':
          this.error(404, error)
          break
        default:
          this.error(500, error)
          break
      }
    }
    
    /**
     * Check if the cache is fresh.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isFresh = function(){
      return fresh(this.req.headers, this.res._headers);
    };
    
    /**
     * Check if the range is fresh.
     *
     * @return {Boolean}
     * @api private
     */
    
    SendStream.prototype.isRangeFresh = function isRangeFresh(){
      var ifRange = this.req.headers['if-range'];
    
      if (!ifRange) return true;
    
      return ~ifRange.indexOf('"')
        ? ~ifRange.indexOf(this.res._headers['etag'])
        : Date.parse(this.res._headers['last-modified']) <= Date.parse(ifRange);
    };
    
    /**
     * Redirect to path.
     *
     * @param {string} path
     * @private
     */
    
    SendStream.prototype.redirect = function redirect(path) {
      if (listenerCount(this, 'directory') !== 0) {
        this.emit('directory')
        return
      }
    
      if (this.hasTrailingSlash()) {
        this.error(403)
        return
      }
    
      var loc = path + '/'
      var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
      var res = this.res
    
      // redirect
      res.statusCode = 301
      res.setHeader('Content-Type', 'text/html; charset=UTF-8')
      res.setHeader('Content-Length', Buffer.byteLength(msg))
      res.setHeader('X-Content-Type-Options', 'nosniff')
      res.setHeader('Location', loc)
      res.end(msg)
    }
    
    /**
     * Pipe to `res.
     *
     * @param {Stream} res
     * @return {Stream} res
     * @api public
     */
    
    SendStream.prototype.pipe = function(res){
      var self = this
        , args = arguments
        , root = this._root;
    
      // references
      this.res = res;
    
      // decode the path
      var path = decode(this.path)
      if (path === -1) return this.error(400)
    
      // null byte(s)
      if (~path.indexOf('\0')) return this.error(400);
    
      var parts
      if (root !== null) {
        // malicious path
        if (upPathRegexp.test(normalize('.' + sep + path))) {
          debug('malicious path "%s"', path)
          return this.error(403)
        }
    
        // join / normalize from optional root dir
        path = normalize(join(root, path))
        root = normalize(root + sep)
    
        // explode path parts
        parts = path.substr(root.length).split(sep)
      } else {
        // ".." is malicious without "root"
        if (upPathRegexp.test(path)) {
          debug('malicious path "%s"', path)
          return this.error(403)
        }
    
        // explode path parts
        parts = normalize(path).split(sep)
    
        // resolve the path
        path = resolve(path)
      }
    
      // dotfile handling
      if (containsDotFile(parts)) {
        var access = this._dotfiles
    
        // legacy support
        if (access === undefined) {
          access = parts[parts.length - 1][0] === '.'
            ? (this._hidden ? 'allow' : 'ignore')
            : 'allow'
        }
    
        debug('%s dotfile "%s"', access, path)
        switch (access) {
          case 'allow':
            break
          case 'deny':
            return this.error(403)
          case 'ignore':
          default:
            return this.error(404)
        }
      }
    
      // index file support
      if (this._index.length && this.path[this.path.length - 1] === '/') {
        this.sendIndex(path);
        return res;
      }
    
      this.sendFile(path);
      return res;
    };
    
    /**
     * Transfer `path`.
     *
     * @param {String} path
     * @api public
     */
    
    SendStream.prototype.send = function(path, stat){
      var len = stat.size;
      var options = this.options
      var opts = {}
      var res = this.res;
      var req = this.req;
      var ranges = req.headers.range;
      var offset = options.start || 0;
    
      if (res._header) {
        // impossible to send now
        return this.headersAlreadySent();
      }
    
      debug('pipe "%s"', path)
    
      // set header fields
      this.setHeader(path, stat);
    
      // set content-type
      this.type(path);
    
      // conditional GET support
      if (this.isConditionalGET()
        && this.isCachable()
        && this.isFresh()) {
        return this.notModified();
      }
    
      // adjust len to start/end options
      len = Math.max(0, len - offset);
      if (options.end !== undefined) {
        var bytes = options.end - offset + 1;
        if (len > bytes) len = bytes;
      }
    
      // Range support
      if (ranges) {
        ranges = parseRange(len, ranges);
    
        // If-Range support
        if (!this.isRangeFresh()) {
          debug('range stale');
          ranges = -2;
        }
    
        // unsatisfiable
        if (-1 == ranges) {
          debug('range unsatisfiable');
          res.setHeader('Content-Range', 'bytes */' + stat.size);
          return this.error(416);
        }
    
        // valid (syntactically invalid/multiple ranges are treated as a regular response)
        if (-2 != ranges && ranges.length === 1) {
          debug('range %j', ranges);
    
          // Content-Range
          res.statusCode = 206;
          res.setHeader('Content-Range', 'bytes '
            + ranges[0].start
            + '-'
            + ranges[0].end
            + '/'
            + len);
    
          offset += ranges[0].start;
          len = ranges[0].end - ranges[0].start + 1;
        }
      }
    
      // clone options
      for (var prop in options) {
        opts[prop] = options[prop]
      }
    
      // set read options
      opts.start = offset
      opts.end = Math.max(offset, offset + len - 1)
    
      // content-length
      res.setHeader('Content-Length', len);
    
      // HEAD support
      if ('HEAD' == req.method) return res.end();
    
      this.stream(path, opts)
    };
    
    /**
     * Transfer file for `path`.
     *
     * @param {String} path
     * @api private
     */
    SendStream.prototype.sendFile = function sendFile(path) {
      var i = 0
      var self = this
    
      debug('stat "%s"', path);
      fs.stat(path, function onstat(err, stat) {
        if (err && err.code === 'ENOENT'
          && !extname(path)
          && path[path.length - 1] !== sep) {
          // not found, check extensions
          return next(err)
        }
        if (err) return self.onStatError(err)
        if (stat.isDirectory()) return self.redirect(self.path)
        self.emit('file', path, stat)
        self.send(path, stat)
      })
    
      function next(err) {
        if (self._extensions.length <= i) {
          return err
            ? self.onStatError(err)
            : self.error(404)
        }
    
        var p = path + '.' + self._extensions[i++]
    
        debug('stat "%s"', p)
        fs.stat(p, function (err, stat) {
          if (err) return next(err)
          if (stat.isDirectory()) return next()
          self.emit('file', p, stat)
          self.send(p, stat)
        })
      }
    }
    
    /**
     * Transfer index for `path`.
     *
     * @param {String} path
     * @api private
     */
    SendStream.prototype.sendIndex = function sendIndex(path){
      var i = -1;
      var self = this;
    
      function next(err){
        if (++i >= self._index.length) {
          if (err) return self.onStatError(err);
          return self.error(404);
        }
    
        var p = join(path, self._index[i]);
    
        debug('stat "%s"', p);
        fs.stat(p, function(err, stat){
          if (err) return next(err);
          if (stat.isDirectory()) return next();
          self.emit('file', p, stat);
          self.send(p, stat);
        });
      }
    
      next();
    };
    
    /**
     * Stream `path` to the response.
     *
     * @param {String} path
     * @param {Object} options
     * @api private
     */
    
    SendStream.prototype.stream = function(path, options){
      // TODO: this is all lame, refactor meeee
      var finished = false;
      var self = this;
      var res = this.res;
      var req = this.req;
    
      // pipe
      var stream = fs.createReadStream(path, options);
      this.emit('stream', stream);
      stream.pipe(res);
    
      // response finished, done with the fd
      onFinished(res, function onfinished(){
        finished = true;
        destroy(stream);
      });
    
      // error handling code-smell
      stream.on('error', function onerror(err){
        // request already finished
        if (finished) return;
    
        // clean up stream
        finished = true;
        destroy(stream);
    
        // error
        self.onStatError(err);
      });
    
      // end
      stream.on('end', function onend(){
        self.emit('end');
      });
    };
    
    /**
     * Set content-type based on `path`
     * if it hasn't been explicitly set.
     *
     * @param {String} path
     * @api private
     */
    
    SendStream.prototype.type = function type(path) {
      var res = this.res;
    
      if (res.getHeader('Content-Type')) return;
    
      var type = mime.lookup(path);
    
      if (!type) {
        debug('no content-type');
        return;
      }
    
      var charset = mime.charsets.lookup(type);
    
      debug('content-type %s', type);
      res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
    };
    
    /**
     * Set response header fields, most
     * fields may be pre-defined.
     *
     * @param {String} path
     * @param {Object} stat
     * @api private
     */
    
    SendStream.prototype.setHeader = function setHeader(path, stat){
      var res = this.res;
    
      this.emit('headers', res, path, stat);
    
      if (!res.getHeader('Accept-Ranges')) res.setHeader('Accept-Ranges', 'bytes');
      if (!res.getHeader('Cache-Control')) res.setHeader('Cache-Control', 'public, max-age=' + Math.floor(this._maxage / 1000));
    
      if (this._lastModified && !res.getHeader('Last-Modified')) {
        var modified = stat.mtime.toUTCString()
        debug('modified %s', modified)
        res.setHeader('Last-Modified', modified)
      }
    
      if (this._etag && !res.getHeader('ETag')) {
        var val = etag(stat)
        debug('etag %s', val)
        res.setHeader('ETag', val)
      }
    };
    
    /**
     * Determine if path parts contain a dotfile.
     *
     * @api private
     */
    
    function containsDotFile(parts) {
      for (var i = 0; i < parts.length; i++) {
        if (parts[i][0] === '.') {
          return true
        }
      }
    
      return false
    }
    
    /**
     * decodeURIComponent.
     *
     * Allows V8 to only deoptimize this fn instead of all
     * of send().
     *
     * @param {String} path
     * @api private
     */
    
    function decode(path) {
      try {
        return decodeURIComponent(path)
      } catch (err) {
        return -1
      }
    }
    
    /**
     * Normalize the index option into an array.
     *
     * @param {boolean|string|array} val
     * @param {string} name
     * @private
     */
    
    function normalizeList(val, name) {
      var list = [].concat(val || [])
    
      for (var i = 0; i < list.length; i++) {
        if (typeof list[i] !== 'string') {
          throw new TypeError(name + ' must be array of strings or false')
        }
      }
    
      return list
    }
    
  provide("send", module.exports);
}(global));

// pakmanager:original
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var parse = require('url-parse');
    
    /**
     * Transform an URL to a valid origin value.
     *
     * @param {String|Object} url URL to transform to it's origin.
     * @returns {String} The origin.
     * @api public
     */
    function origin(url) {
      if ('string' === typeof url) url = parse(url);
    
      //
      // 6.2.  ASCII Serialization of an Origin
      // http://tools.ietf.org/html/rfc6454#section-6.2
      //
      if (!url.protocol || !url.hostname) return 'null';
    
      //
      // 4. Origin of a URI
      // http://tools.ietf.org/html/rfc6454#section-4
      //
      // States that url.scheme, host should be converted to lower case. This also
      // makes it easier to match origins as everything is just lower case.
      //
      return (url.protocol +'//'+ url.host).toLowerCase();
    }
    
    /**
     * Check if the origins are the same.
     *
     * @param {String} a URL or origin of a.
     * @param {String} b URL or origin of b.
     * @returns {Boolean}
     * @api public
     */
    origin.same = function same(a, b) {
      return origin(a) === origin(b);
    };
    
    //
    // Expose the origin
    //
    module.exports = origin;
    
  provide("original", module.exports);
}(global));

// pakmanager:errno/custom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var prr = require('prr')
    
    function init (type, message, cause) {
      prr(this, {
          type    : type
        , name    : type
          // can be passed just a 'cause'
        , cause   : typeof message != 'string' ? message : cause
        , message : !!message && typeof message != 'string' ? message.message : message
    
      }, 'ewr')
    }
    
    // generic prototype, not intended to be actually used - helpful for `instanceof`
    function CustomError (message, cause) {
      Error.call(this)
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, arguments.callee)
      init.call(this, 'CustomError', message, cause)
    }
    
    CustomError.prototype = new Error()
    
    function createError (errno, type, proto) {
      var err = function (message, cause) {
        init.call(this, type, message, cause)
        //TODO: the specificity here is stupid, errno should be available everywhere
        if (type == 'FilesystemError') {
          this.code    = this.cause.code
          this.path    = this.cause.path
          this.errno   = this.cause.errno
          this.message =
            (errno.errno[this.cause.errno]
              ? errno.errno[this.cause.errno].description
              : this.cause.message)
            + (this.cause.path ? ' [' + this.cause.path + ']' : '')
        }
        Error.call(this)
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, arguments.callee)
      }
      err.prototype = !!proto ? new proto() : new CustomError()
      return err
    }
    
    module.exports = function (errno) {
      var ce = function (type, proto) {
        return createError(errno, type, proto)
      }
      return {
          CustomError     : CustomError
        , FilesystemError : ce('FilesystemError')
        , createError     : ce
      }
    }
    
  provide("errno/custom", module.exports);
}(global));

// pakmanager:errno
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var all = module.exports.all = [
      {
        errno: -2,
        code: 'ENOENT',
        description: 'no such file or directory'
      },
      {
        errno: -1,
        code: 'UNKNOWN',
        description: 'unknown error'
      },
      {
        errno: 0,
        code: 'OK',
        description: 'success'
      },
      {
        errno: 1,
        code: 'EOF',
        description: 'end of file'
      },
      {
        errno: 2,
        code: 'EADDRINFO',
        description: 'getaddrinfo error'
      },
      {
        errno: 3,
        code: 'EACCES',
        description: 'permission denied'
      },
      {
        errno: 4,
        code: 'EAGAIN',
        description: 'resource temporarily unavailable'
      },
      {
        errno: 5,
        code: 'EADDRINUSE',
        description: 'address already in use'
      },
      {
        errno: 6,
        code: 'EADDRNOTAVAIL',
        description: 'address not available'
      },
      {
        errno: 7,
        code: 'EAFNOSUPPORT',
        description: 'address family not supported'
      },
      {
        errno: 8,
        code: 'EALREADY',
        description: 'connection already in progress'
      },
      {
        errno: 9,
        code: 'EBADF',
        description: 'bad file descriptor'
      },
      {
        errno: 10,
        code: 'EBUSY',
        description: 'resource busy or locked'
      },
      {
        errno: 11,
        code: 'ECONNABORTED',
        description: 'software caused connection abort'
      },
      {
        errno: 12,
        code: 'ECONNREFUSED',
        description: 'connection refused'
      },
      {
        errno: 13,
        code: 'ECONNRESET',
        description: 'connection reset by peer'
      },
      {
        errno: 14,
        code: 'EDESTADDRREQ',
        description: 'destination address required'
      },
      {
        errno: 15,
        code: 'EFAULT',
        description: 'bad address in system call argument'
      },
      {
        errno: 16,
        code: 'EHOSTUNREACH',
        description: 'host is unreachable'
      },
      {
        errno: 17,
        code: 'EINTR',
        description: 'interrupted system call'
      },
      {
        errno: 18,
        code: 'EINVAL',
        description: 'invalid argument'
      },
      {
        errno: 19,
        code: 'EISCONN',
        description: 'socket is already connected'
      },
      {
        errno: 20,
        code: 'EMFILE',
        description: 'too many open files'
      },
      {
        errno: 21,
        code: 'EMSGSIZE',
        description: 'message too long'
      },
      {
        errno: 22,
        code: 'ENETDOWN',
        description: 'network is down'
      },
      {
        errno: 23,
        code: 'ENETUNREACH',
        description: 'network is unreachable'
      },
      {
        errno: 24,
        code: 'ENFILE',
        description: 'file table overflow'
      },
      {
        errno: 25,
        code: 'ENOBUFS',
        description: 'no buffer space available'
      },
      {
        errno: 26,
        code: 'ENOMEM',
        description: 'not enough memory'
      },
      {
        errno: 27,
        code: 'ENOTDIR',
        description: 'not a directory'
      },
      {
        errno: 28,
        code: 'EISDIR',
        description: 'illegal operation on a directory'
      },
      {
        errno: 29,
        code: 'ENONET',
        description: 'machine is not on the network'
      },
      {
        errno: 31,
        code: 'ENOTCONN',
        description: 'socket is not connected'
      },
      {
        errno: 32,
        code: 'ENOTSOCK',
        description: 'socket operation on non-socket'
      },
      {
        errno: 33,
        code: 'ENOTSUP',
        description: 'operation not supported on socket'
      },
      {
        errno: 34,
        code: 'ENOENT',
        description: 'no such file or directory'
      },
      {
        errno: 35,
        code: 'ENOSYS',
        description: 'function not implemented'
      },
      {
        errno: 36,
        code: 'EPIPE',
        description: 'broken pipe'
      },
      {
        errno: 37,
        code: 'EPROTO',
        description: 'protocol error'
      },
      {
        errno: 38,
        code: 'EPROTONOSUPPORT',
        description: 'protocol not supported'
      },
      {
        errno: 39,
        code: 'EPROTOTYPE',
        description: 'protocol wrong type for socket'
      },
      {
        errno: 40,
        code: 'ETIMEDOUT',
        description: 'connection timed out'
      },
      {
        errno: 41,
        code: 'ECHARSET',
        description: 'invalid Unicode character'
      },
      {
        errno: 42,
        code: 'EAIFAMNOSUPPORT',
        description: 'address family for hostname not supported'
      },
      {
        errno: 44,
        code: 'EAISERVICE',
        description: 'servname not supported for ai_socktype'
      },
      {
        errno: 45,
        code: 'EAISOCKTYPE',
        description: 'ai_socktype not supported'
      },
      {
        errno: 46,
        code: 'ESHUTDOWN',
        description: 'cannot send after transport endpoint shutdown'
      },
      {
        errno: 47,
        code: 'EEXIST',
        description: 'file already exists'
      },
      {
        errno: 48,
        code: 'ESRCH',
        description: 'no such process'
      },
      {
        errno: 49,
        code: 'ENAMETOOLONG',
        description: 'name too long'
      },
      {
        errno: 50,
        code: 'EPERM',
        description: 'operation not permitted'
      },
      {
        errno: 51,
        code: 'ELOOP',
        description: 'too many symbolic links encountered'
      },
      {
        errno: 52,
        code: 'EXDEV',
        description: 'cross-device link not permitted'
      },
      {
        errno: 53,
        code: 'ENOTEMPTY',
        description: 'directory not empty'
      },
      {
        errno: 54,
        code: 'ENOSPC',
        description: 'no space left on device'
      },
      {
        errno: 55,
        code: 'EIO',
        description: 'i/o error'
      },
      {
        errno: 56,
        code: 'EROFS',
        description: 'read-only file system'
      },
      {
        errno: 57,
        code: 'ENODEV',
        description: 'no such device'
      },
      {
        errno: 58,
        code: 'ESPIPE',
        description: 'invalid seek'
      },
      {
        errno: 59,
        code: 'ECANCELED',
        description: 'operation canceled'
      }
    ]
    
    module.exports.errno = {}
    module.exports.code = {}
    
    all.forEach(function (error) {
      module.exports.errno[error.errno] = error
      module.exports.code[error.code] = error
    })
    
    module.exports.custom =  require('errno/custom')(module.exports)
    module.exports.create = module.exports.custom.createError
    
  provide("errno", module.exports);
}(global));

// pakmanager:lodash.isstring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** `Object#toString` result references. */
    var stringTag = '[object String]';
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    module.exports = isString;
    
  provide("lodash.isstring", module.exports);
}(global));

// pakmanager:camelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function(obj) {
        if (typeof obj === 'string') return camelCase(obj);
        return walk(obj);
    };
    
    function walk (obj) {
        if (!obj || typeof obj !== 'object') return obj;
        if (isDate(obj) || isRegex(obj)) return obj;
        if (isArray(obj)) return map(obj, walk);
        return reduce(objectKeys(obj), function (acc, key) {
            var camel = camelCase(key);
            acc[camel] = walk(obj[key]);
            return acc;
        }, {});
    }
    
    function camelCase(str) {
        return str.replace(/[_.-](\w|$)/g, function (_,x) {
            return x.toUpperCase();
        });
    }
    
    var isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };
    
    var isDate = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    };
    
    var isRegex = function (obj) {
        return Object.prototype.toString.call(obj) === '[object RegExp]';
    };
    
    var has = Object.prototype.hasOwnProperty;
    var objectKeys = Object.keys || function (obj) {
        var keys = [];
        for (var key in obj) {
            if (has.call(obj, key)) keys.push(key);
        }
        return keys;
    };
    
    function map (xs, f) {
        if (xs.map) return xs.map(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
        }
        return res;
    }
    
    function reduce (xs, f, acc) {
        if (xs.reduce) return xs.reduce(f, acc);
        for (var i = 0; i < xs.length; i++) {
            acc = f(acc, xs[i], i);
        }
        return acc;
    }
    
  provide("camelize", module.exports);
}(global));

// pakmanager:content-security-policy-builder
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var dashify = require('dashify')
    
    module.exports = function (options) {
      var directives = options.directives
    
      var keysSeen = {}
    
      return Object.keys(directives).reduce(function (result, originalKey) {
        var directive = dashify(originalKey)
    
        if (keysSeen[directive]) {
          throw new Error(originalKey + ' is specified more than once')
        }
        keysSeen[directive] = true
    
        var value = directives[originalKey]
        if (Array.isArray(value)) {
          value = value.join(' ')
        }
    
        var combined
        if (value) {
          combined = directive + ' ' + value
        } else {
          combined = directive
        }
    
        result.push(combined)
    
        return result
      }, []).join('; ')
    }
    
  provide("content-security-policy-builder", module.exports);
}(global));

// pakmanager:lodash.isfunction
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 3.0.8 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    module.exports = isFunction;
    
  provide("lodash.isfunction", module.exports);
}(global));

// pakmanager:lodash.reduce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.2.0 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var baseEach = require('lodash._baseeach'),
        baseIteratee = require('lodash._baseiteratee'),
        baseReduce = require('lodash._basereduce');
    
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array.length;
    
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    
    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;
    
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    module.exports = reduce;
    
  provide("lodash.reduce", module.exports);
}(global));

// pakmanager:lodash.some
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.2.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var baseEach = require('lodash._baseeach'),
        baseIteratee = require('lodash._baseiteratee');
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;
    
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
     */
    function baseSome(collection, predicate) {
      var result;
    
      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        return eq(object[index], value);
      }
      return false;
    }
    
    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    module.exports = some;
    
  provide("lodash.some", module.exports);
}(global));

// pakmanager:bowser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
      * Bowser - a browser detector
      * https://github.com/ded/bowser
      * MIT License | (c) Dustin Diaz 2015
      */
    
    !function (name, definition) {
      if (typeof module != 'undefined' && module.exports) module.exports = definition()
      else if (typeof define == 'function' && define.amd) define(definition)
      else this[name] = definition()
    }('bowser', function () {
      /**
        * See useragents.js for examples of navigator.userAgent
        */
    
      var t = true
    
      function detect(ua) {
    
        function getFirstMatch(regex) {
          var match = ua.match(regex);
          return (match && match.length > 1 && match[1]) || '';
        }
    
        function getSecondMatch(regex) {
          var match = ua.match(regex);
          return (match && match.length > 1 && match[2]) || '';
        }
    
        var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
          , likeAndroid = /like android/i.test(ua)
          , android = !likeAndroid && /android/i.test(ua)
          , chromeBook = /CrOS/.test(ua)
          , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
          , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
          , tablet = /tablet/i.test(ua)
          , mobile = !tablet && /[^-]mobi/i.test(ua)
          , result
    
        if (/opera|opr/i.test(ua)) {
          result = {
            name: 'Opera'
          , opera: t
          , version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
          }
        }
        else if (/yabrowser/i.test(ua)) {
          result = {
            name: 'Yandex Browser'
          , yandexbrowser: t
          , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
          }
        }
        else if (/windows phone/i.test(ua)) {
          result = {
            name: 'Windows Phone'
          , windowsphone: t
          }
          if (edgeVersion) {
            result.msedge = t
            result.version = edgeVersion
          }
          else {
            result.msie = t
            result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
          }
        }
        else if (/msie|trident/i.test(ua)) {
          result = {
            name: 'Internet Explorer'
          , msie: t
          , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
          }
        } else if (chromeBook) {
          result = {
            name: 'Chrome'
          , chromeBook: t
          , chrome: t
          , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
          }
        } else if (/chrome.+? edge/i.test(ua)) {
          result = {
            name: 'Microsoft Edge'
          , msedge: t
          , version: edgeVersion
          }
        }
        else if (/chrome|crios|crmo/i.test(ua)) {
          result = {
            name: 'Chrome'
          , chrome: t
          , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
          }
        }
        else if (iosdevice) {
          result = {
            name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
          }
          // WTF: version is not part of user agent in web apps
          if (versionIdentifier) {
            result.version = versionIdentifier
          }
        }
        else if (/sailfish/i.test(ua)) {
          result = {
            name: 'Sailfish'
          , sailfish: t
          , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
          }
        }
        else if (/seamonkey\//i.test(ua)) {
          result = {
            name: 'SeaMonkey'
          , seamonkey: t
          , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
          }
        }
        else if (/firefox|iceweasel/i.test(ua)) {
          result = {
            name: 'Firefox'
          , firefox: t
          , version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
          }
          if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
            result.firefoxos = t
          }
        }
        else if (/silk/i.test(ua)) {
          result =  {
            name: 'Amazon Silk'
          , silk: t
          , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
          }
        }
        else if (android) {
          result = {
            name: 'Android'
          , version: versionIdentifier
          }
        }
        else if (/phantom/i.test(ua)) {
          result = {
            name: 'PhantomJS'
          , phantom: t
          , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
          }
        }
        else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
          result = {
            name: 'BlackBerry'
          , blackberry: t
          , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
          }
        }
        else if (/(web|hpw)os/i.test(ua)) {
          result = {
            name: 'WebOS'
          , webos: t
          , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
          };
          /touchpad\//i.test(ua) && (result.touchpad = t)
        }
        else if (/bada/i.test(ua)) {
          result = {
            name: 'Bada'
          , bada: t
          , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
          };
        }
        else if (/tizen/i.test(ua)) {
          result = {
            name: 'Tizen'
          , tizen: t
          , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
          };
        }
        else if (/safari/i.test(ua)) {
          result = {
            name: 'Safari'
          , safari: t
          , version: versionIdentifier
          }
        }
        else {
          result = {
            name: getFirstMatch(/^(.*)\/(.*) /),
            version: getSecondMatch(/^(.*)\/(.*) /)
         };
       }
    
        // set webkit or gecko flag for browsers based on these engines
        if (!result.msedge && /(apple)?webkit/i.test(ua)) {
          result.name = result.name || "Webkit"
          result.webkit = t
          if (!result.version && versionIdentifier) {
            result.version = versionIdentifier
          }
        } else if (!result.opera && /gecko\//i.test(ua)) {
          result.name = result.name || "Gecko"
          result.gecko = t
          result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
        }
    
        // set OS flags for platforms that have multiple browsers
        if (!result.msedge && (android || result.silk)) {
          result.android = t
        } else if (iosdevice) {
          result[iosdevice] = t
          result.ios = t
        }
    
        // OS version extraction
        var osVersion = '';
        if (result.windowsphone) {
          osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
        } else if (iosdevice) {
          osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
          osVersion = osVersion.replace(/[_\s]/g, '.');
        } else if (android) {
          osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
        } else if (result.webos) {
          osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
        } else if (result.blackberry) {
          osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
        } else if (result.bada) {
          osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
        } else if (result.tizen) {
          osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
        }
        if (osVersion) {
          result.osversion = osVersion;
        }
    
        // device type extraction
        var osMajorVersion = osVersion.split('.')[0];
        if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || result.silk) {
          result.tablet = t
        } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {
          result.mobile = t
        }
    
        // Graded Browser Support
        // http://developer.yahoo.com/yui/articles/gbs
        if (result.msedge ||
            (result.msie && result.version >= 10) ||
            (result.yandexbrowser && result.version >= 15) ||
            (result.chrome && result.version >= 20) ||
            (result.firefox && result.version >= 20.0) ||
            (result.safari && result.version >= 6) ||
            (result.opera && result.version >= 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
            (result.blackberry && result.version >= 10.1)
            ) {
          result.a = t;
        }
        else if ((result.msie && result.version < 10) ||
            (result.chrome && result.version < 20) ||
            (result.firefox && result.version < 20.0) ||
            (result.safari && result.version < 6) ||
            (result.opera && result.version < 10.0) ||
            (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
            ) {
          result.c = t
        } else result.x = t
    
        return result
      }
    
      var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')
    
      bowser.test = function (browserList) {
        for (var i = 0; i < browserList.length; ++i) {
          var browserItem = browserList[i];
          if (typeof browserItem=== 'string') {
            if (browserItem in bowser) {
              return true;
            }
          }
        }
        return false;
      }
    
      /*
       * Set our detect method to the main bowser object so we can
       * reuse it to test other user agents.
       * This is needed to implement future tests.
       */
      bowser._detect = detect;
    
      return bowser
    });
    
  provide("bowser", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:lodash._baseclone
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.5.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        weakMapTag = '[object WeakMap]';
    
    var arrayBufferTag = '[object ArrayBuffer]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    
    /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    
    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;
    
    /** Used to detect host constructors (Safari > 5). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
    cloneableTags[dateTag] = cloneableTags[float32Tag] =
    cloneableTags[float64Tag] = cloneableTags[int8Tag] =
    cloneableTags[int16Tag] = cloneableTags[int32Tag] =
    cloneableTags[mapTag] = cloneableTags[numberTag] =
    cloneableTags[objectTag] = cloneableTags[regexpTag] =
    cloneableTags[setTag] = cloneableTags[stringTag] =
    cloneableTags[symbolTag] = cloneableTags[uint8Tag] =
    cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =
    cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag] = false;
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = (freeModule && freeModule.exports === freeExports)
      ? freeExports
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * Adds the key-value `pair` to `map`.
     *
     * @private
     * @param {Object} map The map to modify.
     * @param {Array} pair The key-value pair to add.
     * @returns {Object} Returns `map`.
     */
    function addMapEntry(map, pair) {
      // Don't return `Map#set` because it doesn't return the map instance in IE 11.
      map.set(pair[0], pair[1]);
      return map;
    }
    
    /**
     * Adds `value` to `set`.
     *
     * @private
     * @param {Object} set The set to modify.
     * @param {*} value The value to add.
     * @returns {Object} Returns `set`.
     */
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;
    
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    
    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array.length;
    
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
    
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /**
     * Converts `map` to an array.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the converted array.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
    
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    
    /**
     * Converts `set` to an array.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the converted array.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
    
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    
    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;
    
    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );
    
    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined,
        Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        getPrototypeOf = Object.getPrototypeOf,
        getOwnPropertySymbols = Object.getOwnPropertySymbols,
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = Object.keys;
    
    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    
    /** Used to detect maps, sets, and weakmaps. */
    var mapCtorString = Map ? funcToString.call(Map) : '',
        setCtorString = Set ? funcToString.call(Set) : '',
        weakMapCtorString = WeakMap ? funcToString.call(WeakMap) : '';
    
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    
    /**
     * Creates an hash object.
     *
     * @private
     * @constructor
     * @returns {Object} Returns the new hash object.
     */
    function Hash() {}
    
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(hash, key) {
      return hashHas(hash, key) && delete hash[key];
    }
    
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(hash, key) {
      if (nativeCreate) {
        var result = hash[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
    }
    
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(hash, key) {
      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
    }
    
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function hashSet(hash, key, value) {
      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    }
    
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function MapCache(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapClear() {
      this.__data__ = {
        'hash': new Hash,
        'map': Map ? new Map : [],
        'string': new Hash
      };
    }
    
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapDelete(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
    }
    
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapGet(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.get(key) : assocGet(data.map, key);
    }
    
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.has(key) : assocHas(data.map, key);
    }
    
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache object.
     */
    function mapSet(key, value) {
      var data = this.__data__;
      if (isKeyable(key)) {
        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
      } else if (Map) {
        data.map.set(key, value);
      } else {
        assocSet(data.map, key, value);
      }
      return this;
    }
    
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function Stack(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = { 'array': [], 'map': null };
    }
    
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocDelete(array, key) : data.map['delete'](key);
    }
    
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocGet(array, key) : data.map.get(key);
    }
    
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocHas(array, key) : data.map.has(key);
    }
    
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache object.
     */
    function stackSet(key, value) {
      var data = this.__data__,
          array = data.array;
    
      if (array) {
        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
          assocSet(array, key, value);
        } else {
          data.array = null;
          data.map = new MapCache(array);
        }
      }
      var map = data.map;
      if (map) {
        map.set(key, value);
      }
      return this;
    }
    
    /**
     * Removes `key` and its value from the associative array.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function assocDelete(array, key) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = array.length - 1;
      if (index == lastIndex) {
        array.pop();
      } else {
        splice.call(array, index, 1);
      }
      return true;
    }
    
    /**
     * Gets the associative array value for `key`.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function assocGet(array, key) {
      var index = assocIndexOf(array, key);
      return index < 0 ? undefined : array[index][1];
    }
    
    /**
     * Checks if an associative array value for `key` exists.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function assocHas(array, key) {
      return assocIndexOf(array, key) > -1;
    }
    
    /**
     * Gets the index at which the first occurrence of `key` is found in `array`
     * of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    
    /**
     * Sets the associative array `key` to `value`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function assocSet(array, key, value) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        array.push([key, value]);
      } else {
        array[index][1] = value;
      }
    }
    
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        object[key] = value;
      }
    }
    
    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {boolean} [isFull] Specify a clone including symbols.
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;
    
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            result = baseAssign(result, value);
            return isFull ? copySymbols(value, result) : result;
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
    
      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
      });
      return (isFull && !isArr) ? copySymbols(value, result) : result;
    }
    
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    
    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iteratee functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();
    
    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
      // that are composed entirely of index properties, return `false` for
      // `hasOwnProperty` checks of them.
      return hasOwnProperty.call(object, key) ||
        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);
    }
    
    /**
     * The base implementation of `_.keys` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      return nativeKeys(Object(object));
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    
    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    
    /**
     * Creates a clone of `map`.
     *
     * @private
     * @param {Object} map The map to clone.
     * @returns {Object} Returns the cloned map.
     */
    function cloneMap(map) {
      return arrayReduce(mapToArray(map), addMapEntry, new map.constructor);
    }
    
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    
    /**
     * Creates a clone of `set`.
     *
     * @private
     * @param {Object} set The set to clone.
     * @returns {Object} Returns the cloned set.
     */
    function cloneSet(set) {
      return arrayReduce(setToArray(set), addSetEntry, new set.constructor);
    }
    
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    
    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
    
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object) {
      return copyObjectWith(source, props, object);
    }
    
    /**
     * This function is like `copyObject` except that it accepts a function to
     * customize copied values.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObjectWith(source, props, object, customizer) {
      object || (object = {});
    
      var index = -1,
          length = props.length;
    
      while (++index < length) {
        var key = props[index];
    
        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : source[key];
    
        assignValue(object, key, newValue);
      }
      return object;
    }
    
    /**
     * Copies own symbol properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    
    /**
     * Creates a base function for methods like `_.forIn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;
    
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }
    
    /**
     * Creates an array of the own symbol properties of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = getOwnPropertySymbols || function() {
      return [];
    };
    
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function getTag(value) {
      return objectToString.call(value);
    }
    
    // Fallback for IE 11 providing `toStringTag` values for maps, sets, and weakmaps.
    if ((Map && getTag(new Map) != mapTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = objectToString.call(value),
            Ctor = result == objectTag ? value.constructor : null,
            ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';
    
        if (ctorString) {
          switch (ctorString) {
            case mapCtorString: return mapTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }
    
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = array.constructor(length);
    
      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    
    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototypeOf(object))
        : {};
    }
    
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
    
        case boolTag:
        case dateTag:
          return new Ctor(+object);
    
        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);
    
        case mapTag:
          return cloneMap(object);
    
        case numberTag:
        case stringTag:
          return new Ctor(object);
    
        case regexpTag:
          return cloneRegExp(object);
    
        case setTag:
          return cloneSet(object);
    
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) &&
          (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return type == 'number' || type == 'boolean' ||
        (type == 'string' && value != '__proto__') || value == null;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = !Buffer ? constant(false) : function(value) {
      return value instanceof Buffer;
    };
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(funcToString.call(value));
      }
      return isObjectLike(value) &&
        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      var isProto = isPrototype(object);
      if (!(isProto || isArrayLike(object))) {
        return baseKeys(object);
      }
      var indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;
    
      for (var key in object) {
        if (baseHas(object, key) &&
            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
            !(isProto && key == 'constructor')) {
          result.push(key);
        }
      }
      return result;
    }
    
    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }
    
    // Avoid inheriting from `Object.prototype` when possible.
    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
    
    // Add functions to the `MapCache`.
    MapCache.prototype.clear = mapClear;
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;
    
    // Add functions to the `Stack` cache.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    
    module.exports = baseClone;
    
  provide("lodash._baseclone", module.exports);
}(global));

// pakmanager:lodash._stack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    
    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    
    /** Used to detect host constructors (Safari > 5). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    
    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        objectProto = Object.prototype;
    
    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );
    
    /** Built-in value references. */
    var splice = arrayProto.splice;
    
    /* Built-in method references that are verified to be native. */
    var Map = getNative(root, 'Map'),
        nativeCreate = getNative(Object, 'create');
    
    /**
     * Creates an hash object.
     *
     * @private
     * @constructor
     * @returns {Object} Returns the new hash object.
     */
    function Hash() {}
    
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(hash, key) {
      return hashHas(hash, key) && delete hash[key];
    }
    
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(hash, key) {
      if (nativeCreate) {
        var result = hash[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;
    }
    
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @param {Object} hash The hash to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(hash, key) {
      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);
    }
    
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function hashSet(hash, key, value) {
      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    }
    
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function MapCache(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapClear() {
      this.__data__ = {
        'hash': new Hash,
        'map': Map ? new Map : [],
        'string': new Hash
      };
    }
    
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapDelete(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map['delete'](key) : assocDelete(data.map, key);
    }
    
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapGet(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashGet(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.get(key) : assocGet(data.map, key);
    }
    
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      var data = this.__data__;
      if (isKeyable(key)) {
        return hashHas(typeof key == 'string' ? data.string : data.hash, key);
      }
      return Map ? data.map.has(key) : assocHas(data.map, key);
    }
    
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache object.
     */
    function mapSet(key, value) {
      var data = this.__data__;
      if (isKeyable(key)) {
        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);
      } else if (Map) {
        data.map.set(key, value);
      } else {
        assocSet(data.map, key, value);
      }
      return this;
    }
    
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function Stack(values) {
      var index = -1,
          length = values ? values.length : 0;
    
      this.clear();
      while (++index < length) {
        var entry = values[index];
        this.set(entry[0], entry[1]);
      }
    }
    
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = { 'array': [], 'map': null };
    }
    
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocDelete(array, key) : data.map['delete'](key);
    }
    
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocGet(array, key) : data.map.get(key);
    }
    
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      var data = this.__data__,
          array = data.array;
    
      return array ? assocHas(array, key) : data.map.has(key);
    }
    
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache object.
     */
    function stackSet(key, value) {
      var data = this.__data__,
          array = data.array;
    
      if (array) {
        if (array.length < (LARGE_ARRAY_SIZE - 1)) {
          assocSet(array, key, value);
        } else {
          data.array = null;
          data.map = new MapCache(array);
        }
      }
      var map = data.map;
      if (map) {
        map.set(key, value);
      }
      return this;
    }
    
    /**
     * Removes `key` and its value from the associative array.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function assocDelete(array, key) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = array.length - 1;
      if (index == lastIndex) {
        array.pop();
      } else {
        splice.call(array, index, 1);
      }
      return true;
    }
    
    /**
     * Gets the associative array value for `key`.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function assocGet(array, key) {
      var index = assocIndexOf(array, key);
      return index < 0 ? undefined : array[index][1];
    }
    
    /**
     * Checks if an associative array value for `key` exists.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function assocHas(array, key) {
      return assocIndexOf(array, key) > -1;
    }
    
    /**
     * Gets the index at which the first occurrence of `key` is found in `array`
     * of key-value pairs.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    
    /**
     * Sets the associative array `key` to `value`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     */
    function assocSet(array, key, value) {
      var index = assocIndexOf(array, key);
      if (index < 0) {
        array.push([key, value]);
      } else {
        array[index][1] = value;
      }
    }
    
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = object[key];
      return isNative(value) ? value : undefined;
    }
    
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return type == 'number' || type == 'boolean' ||
        (type == 'string' && value != '__proto__') || value == null;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (isFunction(value)) {
        return reIsNative.test(funcToString.call(value));
      }
      return isObjectLike(value) &&
        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
    }
    
    // Avoid inheriting from `Object.prototype` when possible.
    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;
    
    // Add functions to the `MapCache`.
    MapCache.prototype.clear = mapClear;
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;
    
    // Add functions to the `Stack` cache.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    
    module.exports = Stack;
    
  provide("lodash._stack", module.exports);
}(global));

// pakmanager:lodash.isplainobject
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** `Object#toString` result references. */
    var objectTag = '[object Object]';
    
    /**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */
    function isHostObject(value) {
      // Many host objects are `Object` objects that can coerce to strings
      // despite having improperly defined `toString` methods.
      var result = false;
      if (value != null && typeof value.toString != 'function') {
        try {
          result = !!(value + '');
        } catch (e) {}
      }
      return result;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to resolve the decompiled source of functions. */
    var funcToString = Function.prototype.toString;
    
    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var getPrototypeOf = Object.getPrototypeOf;
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) ||
          objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototypeOf(value);
      if (proto === null) {
        return true;
      }
      var Ctor = proto.constructor;
      return (typeof Ctor == 'function' &&
        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
    }
    
    module.exports = isPlainObject;
    
  provide("lodash.isplainobject", module.exports);
}(global));

// pakmanager:lodash.keysin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.1.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        stringTag = '[object String]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /** Used to determine if values are of the language type `Object`. */
    var objectTypes = {
      'function': true,
      'object': true
    };
    
    /** Detect free variable `exports`. */
    var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
      ? exports
      : undefined;
    
    /** Detect free variable `module`. */
    var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
      ? module
      : undefined;
    
    /** Detect free variable `global` from Node.js. */
    var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);
    
    /** Detect free variable `self`. */
    var freeSelf = checkGlobal(objectTypes[typeof self] && self);
    
    /** Detect free variable `window`. */
    var freeWindow = checkGlobal(objectTypes[typeof window] && window);
    
    /** Detect `this` as the global object. */
    var thisGlobal = checkGlobal(objectTypes[typeof this] && this);
    
    /**
     * Used as a reference to the global object.
     *
     * The `this` value is used if it's the global object to avoid Greasemonkey's
     * restricted `window` object, otherwise the `window` object is used.
     */
    var root = freeGlobal ||
      ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
        freeSelf || thisGlobal || Function('return this')();
    
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);
    
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    
    /**
     * Checks if `value` is a global object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {null|Object} Returns `value` if it's a global object, else `null`.
     */
    function checkGlobal(value) {
      return (value && value.Object === Object) ? value : null;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
      var data,
          result = [];
    
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var Reflect = root.Reflect,
        enumerate = Reflect ? Reflect.enumerate : undefined,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    
    /**
     * The base implementation of `_.keysIn` which doesn't skip the constructor
     * property of prototypes or treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      object = object == null ? object : Object(object);
    
      var result = [];
      for (var key in object) {
        result.push(key);
      }
      return result;
    }
    
    // Fallback for IE < 9 with es6-shim.
    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {
      baseKeysIn = function(object) {
        return iteratorToArray(enumerate(object));
      };
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Creates an array of index keys for `object` values of arrays,
     * `arguments` objects, and strings, otherwise `null` is returned.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array|null} Returns index keys, else `null`.
     */
    function indexKeys(object) {
      var length = object ? object.length : undefined;
      if (isLength(length) &&
          (isArray(object) || isString(object) || isArguments(object))) {
        return baseTimes(length, String);
      }
      return null;
    }
    
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    
      return value === proto;
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
    }
    
    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      var index = -1,
          isProto = isPrototype(object),
          props = baseKeysIn(object),
          propsLength = props.length,
          indexes = indexKeys(object),
          skipIndexes = !!indexes,
          result = indexes || [],
          length = result.length;
    
      while (++index < propsLength) {
        var key = props[index];
        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    
    module.exports = keysIn;
    
  provide("lodash.keysin", module.exports);
}(global));

// pakmanager:lodash.debounce
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.3 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    
    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;
    
    /** `Object#toString` result references. */
    var funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';
    
    /** Used to match leading and trailing whitespace. */
    var reTrim = /^\s+|\s+$/g;
    
    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    
    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;
    
    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;
    
    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;
    
    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = Date.now;
    
    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide an options object to indicate whether `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent calls
     * to the debounced function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it's invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          leading = false,
          maxWait = false,
          trailing = true;
    
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
    
      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        lastCalled = 0;
        args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;
      }
    
      function complete(isCalled, id) {
        if (id) {
          clearTimeout(id);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = undefined;
          }
        }
      }
    
      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          complete(trailingCall, maxTimeoutId);
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }
    
      function flush() {
        if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {
          result = func.apply(thisArg, args);
        }
        cancel();
        return result;
      }
    
      function maxDelayed() {
        complete(trailing, timeoutId);
      }
    
      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);
    
        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!lastCalled && !maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled);
    
          var isCalled = (remaining <= 0 || remaining > maxWait) &&
            (leading || maxTimeoutId);
    
          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = undefined;
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array constructors, and
      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3);
     * // => 3
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3');
     * // => 3
     */
    function toNumber(value) {
      if (isObject(value)) {
        var other = isFunction(value.valueOf) ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }
    
    module.exports = debounce;
    
  provide("lodash.debounce", module.exports);
}(global));

// pakmanager:assert
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
    //
    // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
    //
    // Originally from narwhal.js (http://narwhaljs.org)
    // Copyright (c) 2009 Thomas Robinson <280north.com>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the 'Software'), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
    // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // when used in node, this will actually load the util module we depend on
    // versus loading the builtin util module as happens otherwise
    // this is a bug in node module loading as far as I am concerned
    var util = require('util/');
    
    var pSlice = Array.prototype.slice;
    var hasOwn = Object.prototype.hasOwnProperty;
    
    // 1. The assert module provides functions that throw
    // AssertionError's when particular conditions are not met. The
    // assert module must conform to the following interface.
    
    var assert = module.exports = ok;
    
    // 2. The AssertionError is defined in assert.
    // new assert.AssertionError({ message: message,
    //                             actual: actual,
    //                             expected: expected })
    
    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;
      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }
      var stackStartFunction = options.stackStartFunction || fail;
    
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      }
      else {
        // non v8 browsers so we can have a stacktrace
        var err = new Error();
        if (err.stack) {
          var out = err.stack;
    
          // try to strip useless frames
          var fn_name = stackStartFunction.name;
          var idx = out.indexOf('\n' + fn_name);
          if (idx >= 0) {
            // once we have located the function frame
            // we need to strip out everything before it (and its line)
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }
    
          this.stack = out;
        }
      }
    };
    
    // assert.AssertionError instanceof Error
    util.inherits(assert.AssertionError, Error);
    
    function replacer(key, value) {
      if (util.isUndefined(value)) {
        return '' + value;
      }
      if (util.isNumber(value) && !isFinite(value)) {
        return value.toString();
      }
      if (util.isFunction(value) || util.isRegExp(value)) {
        return value.toString();
      }
      return value;
    }
    
    function truncate(s, n) {
      if (util.isString(s)) {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }
    
    function getMessage(self) {
      return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
             self.operator + ' ' +
             truncate(JSON.stringify(self.expected, replacer), 128);
    }
    
    // At present only the three keys mentioned above are used and
    // understood by the spec. Implementations or sub modules can pass
    // other keys to the AssertionError's constructor - they will be
    // ignored.
    
    // 3. All of the following functions must throw an AssertionError
    // when a corresponding condition is not met, with a message that
    // may be undefined if not provided.  All assertion methods provide
    // both the actual and expected values to the assertion error for
    // display purposes.
    
    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }
    
    // EXTENSION! allows for well behaved errors defined elsewhere.
    assert.fail = fail;
    
    // 4. Pure assertion tests whether a value is truthy, as determined
    // by !!guard.
    // assert.ok(guard, message_opt);
    // This statement is equivalent to assert.equal(true, !!guard,
    // message_opt);. To test strictly for the value true, use
    // assert.strictEqual(true, guard, message_opt);.
    
    function ok(value, message) {
      if (!value) fail(value, true, message, '==', assert.ok);
    }
    assert.ok = ok;
    
    // 5. The equality assertion tests shallow, coercive equality with
    // ==.
    // assert.equal(actual, expected, message_opt);
    
    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };
    
    // 6. The non-equality assertion tests for whether two objects are not equal
    // with != assert.notEqual(actual, expected, message_opt);
    
    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };
    
    // 7. The equivalence assertion tests a deep equality relation.
    // assert.deepEqual(actual, expected, message_opt);
    
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };
    
    function _deepEqual(actual, expected) {
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
    
      } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
        if (actual.length != expected.length) return false;
    
        for (var i = 0; i < actual.length; i++) {
          if (actual[i] !== expected[i]) return false;
        }
    
        return true;
    
      // 7.2. If the expected value is a Date object, the actual value is
      // equivalent if it is also a Date object that refers to the same time.
      } else if (util.isDate(actual) && util.isDate(expected)) {
        return actual.getTime() === expected.getTime();
    
      // 7.3 If the expected value is a RegExp object, the actual value is
      // equivalent if it is also a RegExp object with the same source and
      // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
      } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
        return actual.source === expected.source &&
               actual.global === expected.global &&
               actual.multiline === expected.multiline &&
               actual.lastIndex === expected.lastIndex &&
               actual.ignoreCase === expected.ignoreCase;
    
      // 7.4. Other pairs that do not both pass typeof value == 'object',
      // equivalence is determined by ==.
      } else if (!util.isObject(actual) && !util.isObject(expected)) {
        return actual == expected;
    
      // 7.5 For all other Object pairs, including Array objects, equivalence is
      // determined by having the same number of owned properties (as verified
      // with Object.prototype.hasOwnProperty.call), the same set of keys
      // (although not necessarily the same order), equivalent values for every
      // corresponding key, and an identical 'prototype' property. Note: this
      // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected);
      }
    }
    
    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }
    
    function objEquiv(a, b) {
      if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
        return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      // if one is a primitive, the other must be same
      if (util.isPrimitive(a) || util.isPrimitive(b)) {
        return a === b;
      }
      var aIsArgs = isArguments(a),
          bIsArgs = isArguments(b);
      if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
        return false;
      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b);
      }
      var ka = objectKeys(a),
          kb = objectKeys(b),
          key, i;
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length)
        return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i])
          return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key])) return false;
      }
      return true;
    }
    
    // 8. The non-equivalence assertion tests for any deep inequality.
    // assert.notDeepEqual(actual, expected, message_opt);
    
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };
    
    // 9. The strict equality assertion tests strict equality, as determined by ===.
    // assert.strictEqual(actual, expected, message_opt);
    
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };
    
    // 10. The strict non-equality assertion tests for strict inequality, as
    // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
    
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };
    
    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }
    
      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      } else if (actual instanceof expected) {
        return true;
      } else if (expected.call({}, actual) === true) {
        return true;
      }
    
      return false;
    }
    
    function _throws(shouldThrow, block, expected, message) {
      var actual;
    
      if (util.isString(expected)) {
        message = expected;
        expected = null;
      }
    
      try {
        block();
      } catch (e) {
        actual = e;
      }
    
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
                (message ? ' ' + message : '.');
    
      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }
    
      if (!shouldThrow && expectedException(actual, expected)) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }
    
      if ((shouldThrow && actual && expected &&
          !expectedException(actual, expected)) || (!shouldThrow && actual)) {
        throw actual;
      }
    }
    
    // 11. Expected to throw an error:
    // assert.throws(block, Error_opt, message_opt);
    
    assert.throws = function(block, /*optional*/error, /*optional*/message) {
      _throws.apply(this, [true].concat(pSlice.call(arguments)));
    };
    
    // EXTENSION! This is annoying to write outside this module.
    assert.doesNotThrow = function(block, /*optional*/message) {
      _throws.apply(this, [false].concat(pSlice.call(arguments)));
    };
    
    assert.ifError = function(err) { if (err) {throw err;}};
    
    var objectKeys = Object.keys || function (obj) {
      var keys = [];
      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }
      return keys;
    };
    
  provide("assert", module.exports);
}(global));

// pakmanager:browser-pack
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var JSONStream = require('JSONStream');
    var defined = require('defined');
    var through = require('through2');
    var umd = require('umd');
    
    var fs = require('fs');
    var path = require('path');
    
    var combineSourceMap = require('combine-source-map');
    
    var defaultPreludePath = path.join(__dirname, '_prelude.js');
    var defaultPrelude = fs.readFileSync(defaultPreludePath, 'utf8');
    
    function newlinesIn(src) {
      if (!src) return 0;
      var newlines = src.match(/\n/g);
    
      return newlines ? newlines.length : 0;
    }
    
    module.exports = function (opts) {
        if (!opts) opts = {};
        var parser = opts.raw ? through.obj() : JSONStream.parse([ true ]);
        var stream = through.obj(
            function (buf, enc, next) { parser.write(buf); next() },
            function () { parser.end() }
        );
        parser.pipe(through.obj(write, end));
        stream.standaloneModule = opts.standaloneModule;
        stream.hasExports = opts.hasExports;
        
        var first = true;
        var entries = [];
        var basedir = defined(opts.basedir, process.cwd());
        var prelude = opts.prelude || defaultPrelude;
        var preludePath = opts.preludePath ||
            path.relative(basedir, defaultPreludePath).replace(/\\/g, '/');
        
        var lineno = 1 + newlinesIn(prelude);
        var sourcemap;
        
        return stream;
        
        function write (row, enc, next) {
            if (first && opts.standalone) {
                var pre = umd.prelude(opts.standalone).trim();
                stream.push(Buffer(pre + 'return '));
            }
            else if (first && stream.hasExports) {
                var pre = opts.externalRequireName || 'require';
                stream.push(Buffer(pre + '='));
            }
            if (first) stream.push(Buffer(prelude + '({'));
            
            if (row.sourceFile && !row.nomap) {
                if (!sourcemap) {
                    sourcemap = combineSourceMap.create();
                    sourcemap.addFile(
                        { sourceFile: preludePath, source: prelude },
                        { line: 0 }
                    );
                }
                sourcemap.addFile(
                    { sourceFile: row.sourceFile, source: row.source },
                    { line: lineno }
                );
            }
            
            var wrappedSource = [
                (first ? '' : ','),
                JSON.stringify(row.id),
                ':[',
                'function(require,module,exports){\n',
                combineSourceMap.removeComments(row.source),
                '\n},',
                '{' + Object.keys(row.deps || {}).sort().map(function (key) {
                    return JSON.stringify(key) + ':'
                        + JSON.stringify(row.deps[key])
                    ;
                }).join(',') + '}',
                ']'
            ].join('');
    
            stream.push(Buffer(wrappedSource));
            lineno += newlinesIn(wrappedSource);
            
            first = false;
            if (row.entry && row.order !== undefined) {
                entries[row.order] = row.id;
            }
            else if (row.entry) entries.push(row.id);
            next();
        }
        
        function end () {
            if (first) stream.push(Buffer(prelude + '({'));
            entries = entries.filter(function (x) { return x !== undefined });
            
            stream.push(Buffer('},{},' + JSON.stringify(entries) + ')'));
    
            if (opts.standalone && !first) {
                stream.push(Buffer(
                    '(' + JSON.stringify(stream.standaloneModule) + ')'
                    + umd.postlude(opts.standalone)
                ));
            }
            
            if (sourcemap) {
                var comment = sourcemap.comment();
                if (opts.sourceMapPrefix) {
                    comment = comment.replace(
                        /^\/\/#/, function () { return opts.sourceMapPrefix }
                    )
                }
                stream.push(Buffer('\n' + comment + '\n'));
            }
            if (!sourcemap && !opts.standalone) stream.push(Buffer(';\n'));
    
            stream.push(null);
        }
    };
    
  provide("browser-pack", module.exports);
}(global));

// pakmanager:buffer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    'use strict'
    
    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    var isArray = require('isarray')
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    Buffer.poolSize = 8192 // not used by this implementation
    
    var rootParent = {}
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
      ? global.TYPED_ARRAY_SUPPORT
      : typedArraySupport()
    
    function typedArraySupport () {
      try {
        var arr = new Uint8Array(1)
        arr.foo = function () { return 42 }
        return arr.foo() === 42 && // typed array instances can be augmented
            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    }
    
    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    function Buffer (arg) {
      if (!(this instanceof Buffer)) {
        // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
        if (arguments.length > 1) return new Buffer(arg, arguments[1])
        return new Buffer(arg)
      }
    
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        this.length = 0
        this.parent = undefined
      }
    
      // Common case.
      if (typeof arg === 'number') {
        return fromNumber(this, arg)
      }
    
      // Slightly less common case.
      if (typeof arg === 'string') {
        return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
      }
    
      // Unusual.
      return fromObject(this, arg)
    }
    
    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype
      return arr
    }
    
    function fromNumber (that, length) {
      that = allocate(that, length < 0 ? 0 : checked(length) | 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < length; i++) {
          that[i] = 0
        }
      }
      return that
    }
    
    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
    
      // Assumption: byteLength() return value is always < kMaxLength.
      var length = byteLength(string, encoding) | 0
      that = allocate(that, length)
    
      that.write(string, encoding)
      return that
    }
    
    function fromObject (that, object) {
      if (Buffer.isBuffer(object)) return fromBuffer(that, object)
    
      if (isArray(object)) return fromArray(that, object)
    
      if (object == null) {
        throw new TypeError('must start with number, buffer, array or string')
      }
    
      if (typeof ArrayBuffer !== 'undefined') {
        if (object.buffer instanceof ArrayBuffer) {
          return fromTypedArray(that, object)
        }
        if (object instanceof ArrayBuffer) {
          return fromArrayBuffer(that, object)
        }
      }
    
      if (object.length) return fromArrayLike(that, object)
    
      return fromJsonObject(that, object)
    }
    
    function fromBuffer (that, buffer) {
      var length = checked(buffer.length) | 0
      that = allocate(that, length)
      buffer.copy(that, 0, 0, length)
      return that
    }
    
    function fromArray (that, array) {
      var length = checked(array.length) | 0
      that = allocate(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    // Duplicate of fromArray() to keep fromArray() monomorphic.
    function fromTypedArray (that, array) {
      var length = checked(array.length) | 0
      that = allocate(that, length)
      // Truncating the elements is probably not what people expect from typed
      // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
      // of the old Buffer constructor.
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    function fromArrayBuffer (that, array) {
      array.byteLength // this throws if `array` is not a valid ArrayBuffer
    
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(array)
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromTypedArray(that, new Uint8Array(array))
      }
      return that
    }
    
    function fromArrayLike (that, array) {
      var length = checked(array.length) | 0
      that = allocate(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    // Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
    // Returns a zero-length buffer for inputs that don't conform to the spec.
    function fromJsonObject (that, object) {
      var array
      var length = 0
    
      if (object.type === 'Buffer' && isArray(object.data)) {
        array = object.data
        length = checked(array.length) | 0
      }
      that = allocate(that, length)
    
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype
      Buffer.__proto__ = Uint8Array
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        })
      }
    } else {
      // pre-set for values that may exist in the future
      Buffer.prototype.length = undefined
      Buffer.prototype.parent = undefined
    }
    
    function allocate (that, length) {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length)
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        that.length = length
      }
    
      var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
      if (fromPool) that.parent = rootParent
    
      return that
    }
    
    function checked (length) {
      // Note: cannot use `length < kMaxLength` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (subject, encoding) {
      if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
    
      var buf = new Buffer(subject, encoding)
      delete buf.parent
      return buf
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return !!(b != null && b._isBuffer)
    }
    
    Buffer.compare = function compare (a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }
    
      if (a === b) return 0
    
      var x = a.length
      var y = b.length
    
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'raw':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
    
      if (list.length === 0) {
        return new Buffer(0)
      }
    
      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; i++) {
          length += list[i].length
        }
      }
    
      var buf = new Buffer(length)
      var pos = 0
      for (i = 0; i < list.length; i++) {
        var item = list[i]
        item.copy(buf, pos)
        pos += item.length
      }
      return buf
    }
    
    function byteLength (string, encoding) {
      if (typeof string !== 'string') string = '' + string
    
      var len = string.length
      if (len === 0) return 0
    
      // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'binary':
          // Deprecated
          case 'raw':
          case 'raws':
            return len
          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      var loweredCase = false
    
      start = start | 0
      end = end === undefined || end === Infinity ? this.length : end | 0
    
      if (!encoding) encoding = 'utf8'
      if (start < 0) start = 0
      if (end > this.length) end = this.length
      if (end <= start) return ''
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'binary':
            return binarySlice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true
    
    Buffer.prototype.toString = function toString () {
      var length = this.length | 0
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
        if (this.length > max) str += ' ... '
      }
      return '<Buffer ' + str + '>'
    }
    
    Buffer.prototype.compare = function compare (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      return Buffer.compare(this, b)
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
      if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
      else if (byteOffset < -0x80000000) byteOffset = -0x80000000
      byteOffset >>= 0
    
      if (this.length === 0) return -1
      if (byteOffset >= this.length) return -1
    
      // Negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
    
      if (typeof val === 'string') {
        if (val.length === 0) return -1 // special case: looking for empty string always fails
        return String.prototype.indexOf.call(this, val, byteOffset)
      }
      if (Buffer.isBuffer(val)) {
        return arrayIndexOf(this, val, byteOffset)
      }
      if (typeof val === 'number') {
        if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
          return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
        }
        return arrayIndexOf(this, [ val ], byteOffset)
      }
    
      function arrayIndexOf (arr, val, byteOffset) {
        var foundIndex = -1
        for (var i = 0; byteOffset + i < arr.length; i++) {
          if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
          } else {
            foundIndex = -1
          }
        }
        return -1
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      // must be an even number of digits
      var strLen = string.length
      if (strLen % 2 !== 0) throw new Error('Invalid hex string')
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; i++) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (isNaN(parsed)) throw new Error('Invalid hex string')
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function binaryWrite (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        var swap = encoding
        encoding = offset
        offset = length | 0
        length = swap
      }
    
      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
            return asciiWrite(this, string, offset, length)
    
          case 'binary':
            return binaryWrite(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []
    
      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1
    
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; i++) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function binarySlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; i++) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      var len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      var out = ''
      for (var i = start; i < end; i++) {
        out += toHex(buf[i])
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      var newBuf
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer(sliceLen, undefined)
        for (var i = 0; i < sliceLen; i++) {
          newBuf[i] = this[i + start]
        }
      }
    
      if (newBuf.length) newBuf.parent = this.parent || this
    
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('value is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('index out of range')
    }
    
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
    
      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
    
      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8
      }
    }
    
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
      }
    }
    
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = 0
      var mul = 1
      var sub = value < 0 ? 1 : 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = byteLength - 1
      var mul = 1
      var sub = value < 0 ? 1 : 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('index out of range')
      if (offset < 0) throw new RangeError('index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      var len = end - start
      var i
    
      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }
    
      return len
    }
    
    // fill(value, start=0, end=buffer.length)
    Buffer.prototype.fill = function fill (value, start, end) {
      if (!value) value = 0
      if (!start) start = 0
      if (!end) end = this.length
    
      if (end < start) throw new RangeError('end < start')
    
      // Fill 0 bytes; we're done
      if (end === start) return
      if (this.length === 0) return
    
      if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
      if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
    
      var i
      if (typeof value === 'number') {
        for (i = start; i < end; i++) {
          this[i] = value
        }
      } else {
        var bytes = utf8ToBytes(value.toString())
        var len = bytes.length
        for (i = start; i < end; i++) {
          this[i] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // HELPER FUNCTIONS
    // ================
    
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }
    
    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []
    
      for (var i = 0; i < length; i++) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; i++) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; i++) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; i++) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
  provide("buffer", module.exports);
}(global));

// pakmanager:console-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*global window, global*/
    var util = require("util")
    var assert = require("assert")
    var now = require("date-now")
    
    var slice = Array.prototype.slice
    var console
    var times = {}
    
    if (typeof global !== "undefined" && global.console) {
        console = global.console
    } else if (typeof window !== "undefined" && window.console) {
        console = window.console
    } else {
        console = {}
    }
    
    var functions = [
        [log, "log"],
        [info, "info"],
        [warn, "warn"],
        [error, "error"],
        [time, "time"],
        [timeEnd, "timeEnd"],
        [trace, "trace"],
        [dir, "dir"],
        [consoleAssert, "assert"]
    ]
    
    for (var i = 0; i < functions.length; i++) {
        var tuple = functions[i]
        var f = tuple[0]
        var name = tuple[1]
    
        if (!console[name]) {
            console[name] = f
        }
    }
    
    module.exports = console
    
    function log() {}
    
    function info() {
        console.log.apply(console, arguments)
    }
    
    function warn() {
        console.log.apply(console, arguments)
    }
    
    function error() {
        console.warn.apply(console, arguments)
    }
    
    function time(label) {
        times[label] = now()
    }
    
    function timeEnd(label) {
        var time = times[label]
        if (!time) {
            throw new Error("No such label: " + label)
        }
    
        var duration = now() - time
        console.log(label + ": " + duration + "ms")
    }
    
    function trace() {
        var err = new Error()
        err.name = "Trace"
        err.message = util.format.apply(null, arguments)
        console.error(err.stack)
    }
    
    function dir(object) {
        console.log(util.inspect(object) + "\n")
    }
    
    function consoleAssert(expression) {
        if (!expression) {
            var arr = slice.call(arguments, 1)
            assert.ok(false, util.format.apply(null, arr))
        }
    }
    
  provide("console-browserify", module.exports);
}(global));

// pakmanager:crypto-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
    exports.createHash = exports.Hash = require('create-hash')
    exports.createHmac = exports.Hmac = require('create-hmac')
    
    var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
    exports.getHashes = function () {
      return hashes
    }
    
    var p = require('pbkdf2')
    exports.pbkdf2 = p.pbkdf2
    exports.pbkdf2Sync = p.pbkdf2Sync
    
    var aes = require('browserify-cipher')
    ;[
      'Cipher',
      'createCipher',
      'Cipheriv',
      'createCipheriv',
      'Decipher',
      'createDecipher',
      'Decipheriv',
      'createDecipheriv',
      'getCiphers',
      'listCiphers'
    ].forEach(function (key) {
      exports[key] = aes[key]
    })
    
    var dh = require('diffie-hellman')
    ;[
      'DiffieHellmanGroup',
      'createDiffieHellmanGroup',
      'getDiffieHellman',
      'createDiffieHellman',
      'DiffieHellman'
    ].forEach(function (key) {
      exports[key] = dh[key]
    })
    
    var sign = require('browserify-sign')
    ;[
      'createSign',
      'Sign',
      'createVerify',
      'Verify'
    ].forEach(function (key) {
      exports[key] = sign[key]
    })
    
    exports.createECDH = require('create-ecdh')
    
    var publicEncrypt = require('public-encrypt')
    
    ;[
      'publicEncrypt',
      'privateEncrypt',
      'publicDecrypt',
      'privateDecrypt'
    ].forEach(function (key) {
      exports[key] = publicEncrypt[key]
    })
    
    // the least I can do is make error messages for the rest of the node.js/crypto api.
    ;[
      'createCredentials'
    ].forEach(function (name) {
      exports[name] = function () {
        throw new Error([
          'sorry, ' + name + ' is not implemented yet',
          'we accept pull requests',
          'https://github.com/crypto-browserify/crypto-browserify'
        ].join('\n'))
      }
    })
    
  provide("crypto-browserify", module.exports);
}(global));

// pakmanager:deps-sort
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var through = require('through2');
    var shasum = require('shasum');
    
    module.exports = function (opts) {
        if (!opts) opts = {};
        var rows = [];
        return through.obj(write, end);
        
        function write (row, enc, next) { rows.push(row); next() }
        
        function end () {
            var tr = this;
            rows.sort(cmp);
            sorter(rows, tr, opts);
        }
    };
    
    function sorter (rows, tr, opts) {
        var expose = opts.expose || {};
        if (Array.isArray(expose)) {
            expose = expose.reduce(function (acc, key) {
                acc[key] = true;
                return acc;
            }, {});
        }
        
        var hashes = {}, deduped = {};
        var sameDeps = depCmp();
        
        if (opts.dedupe) {
            rows.forEach(function (row) {
                var h = shasum(row.source);
                sameDeps.add(row, h);
                if (hashes[h]) {
                    hashes[h].push(row);
                } else {
                    hashes[h] = [row];
                }
            });
            Object.keys(hashes).forEach(function (h) {
                var rows = hashes[h];
                while (rows.length > 1) {
                    var row = rows.pop();
                    row.dedupe = rows[0].id;
                    row.sameDeps = sameDeps.cmp(rows[0].deps, row.deps);
                    deduped[row.id] = rows[0].id;
                }
            });
        }
        
        if (opts.index) {
            var index = {};
            var offset = 0;
            rows.forEach(function (row, ix) {
                if (has(expose, row.id)) {
                    row.index = row.id;
                    offset ++;
                    if (expose[row.id] !== true) {
                        index[expose[row.id]] = row.index;
                    }
                }
                else {
                    row.index = ix + 1 - offset;
                }
                index[row.id] = row.index;
            });
            rows.forEach(function (row) {
                row.indexDeps = {};
                Object.keys(row.deps).forEach(function (key) {
                    var id = row.deps[key];
                    row.indexDeps[key] = index[id];
                });
                if (row.dedupe) {
                    row.dedupeIndex = index[row.dedupe];
                }
                tr.push(row);
            });
        }
        else {
            rows.forEach(function (row) { tr.push(row) });
        }
        tr.push(null);
    }
    
    function cmp (a, b) {
        return a.id + a.hash < b.id + b.hash ? -1 : 1;
    }
    
    function has (obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }
    
    function depCmp () {
        var deps = {}, hashes = {};
        return { add: add, cmp: cmp }
        
        function add (row, hash) {
            deps[row.id] = row.deps;
            hashes[row.id] = hash;
        }
        function cmp (a, b, limit) {
            if (!a && !b) return true;
            if (!a || !b) return false;
            
            var keys = Object.keys(a);
            if (keys.length !== Object.keys(b).length) return false;
    
            for (var i = 0; i < keys.length; i++) {
                var k = keys[i], ka = a[k], kb = b[k];
                var ha = hashes[ka];
                var hb = hashes[kb];
                var da = deps[ka];
                var db = deps[kb];
    
                if (ka === kb) continue;
                if (ha !== hb || (!limit && !cmp(da, db, 1))) {
                    return false;
                }
            }
            return true;
        }
    }
    
  provide("deps-sort", module.exports);
}(global));

// pakmanager:domain-browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // This file should be ES5 compatible
    /* eslint prefer-spread:0, no-var:0, prefer-reflect:0, no-magic-numbers:0 */
    'use strict'
    module.exports = (function () {
    	// Import Events
    	var events = require('events')
    
    	// Export Domain
    	var domain = {}
    	domain.createDomain = domain.create = function () {
    		var d = new events.EventEmitter()
    
    		function emitError (e) {
    			d.emit('error', e)
    		}
    
    		d.add = function (emitter) {
    			emitter.on('error', emitError)
    		}
    		d.remove = function (emitter) {
    			emitter.removeListener('error', emitError)
    		}
    		d.bind = function (fn) {
    			return function () {
    				var args = Array.prototype.slice.call(arguments)
    				try {
    					fn.apply(null, args)
    				}
    				catch (err) {
    					emitError(err)
    				}
    			}
    		}
    		d.intercept = function (fn) {
    			return function (err) {
    				if ( err ) {
    					emitError(err)
    				}
    				else {
    					var args = Array.prototype.slice.call(arguments, 1)
    					try {
    						fn.apply(null, args)
    					}
    					catch (err) {
    						emitError(err)
    					}
    				}
    			}
    		}
    		d.run = function (fn) {
    			try {
    				fn()
    			}
    			catch (err) {
    				emitError(err)
    			}
    			return this
    		}
    		d.dispose = function () {
    			this.removeAllListeners()
    			return this
    		}
    		d.enter = d.exit = function () {
    			return this
    		}
    		return d
    	}
    	return domain
    }).call(this)
    
  provide("domain-browser", module.exports);
}(global));

// pakmanager:events
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    
    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    
    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;
    
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };
    
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
    
      if (!this._events)
        this._events = {};
    
      // If there is no 'error' event listener then throw.
      if (type === 'error') {
        if (!this._events.error ||
            (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er; // Unhandled 'error' event
          }
          throw TypeError('Uncaught, unspecified "error" event.');
        }
      }
    
      handler = this._events[type];
    
      if (isUndefined(handler))
        return false;
    
      if (isFunction(handler)) {
        switch (arguments.length) {
          // fast cases
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
    
      return true;
    };
    
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events)
        this._events = {};
    
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (this._events.newListener)
        this.emit('newListener', type,
                  isFunction(listener.listener) ?
                  listener.listener : listener);
    
      if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        // If we've already got an array, just append.
        this._events[type].push(listener);
      else
        // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener];
    
      // Check for listener leak
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
    
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          if (typeof console.trace === 'function') {
            // not supported in IE 10
            console.trace();
          }
        }
      }
    
      return this;
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      var fired = false;
    
      function g() {
        this.removeListener(type, g);
    
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
    
      g.listener = listener;
      this.on(type, g);
    
      return this;
    };
    
    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events || !this._events[type])
        return this;
    
      list = this._events[type];
      length = list.length;
      position = -1;
    
      if (list === listener ||
          (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
    
      } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
    
        if (position < 0)
          return this;
    
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
    
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      }
    
      return this;
    };
    
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
    
      if (!this._events)
        return this;
    
      // not listening for removeListener, no need to emit
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
    
      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }
    
      listeners = this._events[type];
    
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
    
      return this;
    };
    
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
    
        if (isFunction(evlistener))
          return 1;
        else if (evlistener)
          return evlistener.length;
      }
      return 0;
    };
    
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    
  provide("events", module.exports);
}(global));

// pakmanager:htmlescape
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Properly escape JSON for usage as an object literal inside of a `<script>` tag.
     * JS implementation of http://golang.org/pkg/encoding/json/#HTMLEscape
     * More info: http://timelessrepo.com/json-isnt-a-javascript-subset
     */
    
    'use strict';
    
    var ESCAPE_LOOKUP = {
      '&': '\\u0026',
      '>': '\\u003e',
      '<': '\\u003c',
      '\u2028': '\\u2028',
      '\u2029': '\\u2029'
    };
    
    var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    
    function escaper(match) {
      return ESCAPE_LOOKUP[match];
    }
    
    module.exports = function(obj) {
      return JSON.stringify(obj).replace(ESCAPE_REGEX, escaper);
    };
    
    /***/
    
    var TERMINATORS_LOOKUP = {
      '\u2028': '\\u2028',
      '\u2029': '\\u2029'
    };
    
    var TERMINATORS_REGEX = /[\u2028\u2029]/g;
    
    function sanitizer(match) {
      return TERMINATORS_LOOKUP[match];
    }
    
    module.exports.sanitize = function(str) {
      return str.replace(TERMINATORS_REGEX, sanitizer);
    };
    
  provide("htmlescape", module.exports);
}(global));

// pakmanager:stream-http
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var ClientRequest = require('./lib/request')
    var extend = require('xtend')
    var statusCodes = require('builtin-status-codes')
    var url = require('url')
    
    var http = exports
    
    http.request = function (opts, cb) {
    	if (typeof opts === 'string')
    		opts = url.parse(opts)
    	else
    		opts = extend(opts)
    
    	// Normally, the page is loaded from http or https, so not specifying a protocol
    	// will result in a (valid) protocol-relative url. However, this won't work if
    	// the protocol is something else, like 'file:'
    	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''
    
    	var protocol = opts.protocol || defaultProtocol
    	var host = opts.hostname || opts.host
    	var port = opts.port
    	var path = opts.path || '/'
    
    	// Necessary for IPv6 addresses
    	if (host && host.indexOf(':') !== -1)
    		host = '[' + host + ']'
    
    	// This may be a relative url. The browser should always be able to interpret it correctly.
    	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
    	opts.method = (opts.method || 'GET').toUpperCase()
    	opts.headers = opts.headers || {}
    
    	// Also valid opts.auth, opts.mode
    
    	var req = new ClientRequest(opts)
    	if (cb)
    		req.on('response', cb)
    	return req
    }
    
    http.get = function get (opts, cb) {
    	var req = http.request(opts, cb)
    	req.end()
    	return req
    }
    
    http.Agent = function () {}
    http.Agent.defaultMaxSockets = 4
    
    http.STATUS_CODES = statusCodes
    
    http.METHODS = [
    	'CHECKOUT',
    	'CONNECT',
    	'COPY',
    	'DELETE',
    	'GET',
    	'HEAD',
    	'LOCK',
    	'M-SEARCH',
    	'MERGE',
    	'MKACTIVITY',
    	'MKCOL',
    	'MOVE',
    	'NOTIFY',
    	'OPTIONS',
    	'PATCH',
    	'POST',
    	'PROPFIND',
    	'PROPPATCH',
    	'PURGE',
    	'PUT',
    	'REPORT',
    	'SEARCH',
    	'SUBSCRIBE',
    	'TRACE',
    	'UNLOCK',
    	'UNSUBSCRIBE'
    ]
  provide("stream-http", module.exports);
}(global));

// pakmanager:https-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var http = require('http');
    
    var https = module.exports;
    
    for (var key in http) {
        if (http.hasOwnProperty(key)) https[key] = http[key];
    };
    
    https.request = function (params, cb) {
        if (!params) params = {};
        params.scheme = 'https';
        params.protocol = 'https:';
        return http.request.call(this, params, cb);
    }
    
  provide("https-browserify", module.exports);
}(global));

// pakmanager:insert-module-globals
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parseScope = require('lexical-scope');
    var through = require('through2');
    var merge = require('xtend');
    
    var path = require('path');
    var processPath = require.resolve('process/browser.js');
    var isbufferPath = require.resolve('is-buffer')
    var combineSourceMap = require('combine-source-map');
    
    function getRelativeRequirePath(fullPath, fromPath) {
      var relpath = path.relative(path.dirname(fromPath), fullPath);
      // If fullPath is in the same directory as fromPath, relpath will
      // result in something like "index.js". require() needs "./" prepended
      // to these paths.
      if (path.dirname(relpath) === '.') {
        relpath = "./" + relpath;
      }
      // On Windows: Convert path separators to what require() expects
      if (path.sep === '\\') {
        relpath = relpath.replace(/\\/g, '/');
      }
      return relpath;
    }
    
    var defaultVars = {
        process: function (file) {
            var relpath = getRelativeRequirePath(processPath, file);
            return 'require(' + JSON.stringify(relpath) + ')';
        },
        global: function () {
            return 'typeof global !== "undefined" ? global : '
                + 'typeof self !== "undefined" ? self : '
                + 'typeof window !== "undefined" ? window : {}'
            ;
        },
        'Buffer.isBuffer': function (file) {
            var relpath = getRelativeRequirePath(isbufferPath, file);
            return 'require(' + JSON.stringify(relpath) + ')';
        },
        Buffer: function () {
            return 'require("buffer").Buffer';
        },
        __filename: function (file, basedir) {
            var filename = '/' + path.relative(basedir, file);
            return JSON.stringify(filename);
        },
        __dirname: function (file, basedir) {
            var dir = path.dirname('/' + path.relative(basedir, file));
            return JSON.stringify(dir);
        }
    };
    
    module.exports = function (file, opts) {
        if (/\.json$/i.test(file)) return through();
        if (!opts) opts = {};
        
        var basedir = opts.basedir || '/';
        var vars = merge(defaultVars, opts.vars);
        var varNames = Object.keys(vars).filter(function(name) {
            return typeof vars[name] === 'function';
        });
        
        var quick = RegExp(varNames.map(function (name) {
            return '\\b' + name + '\\b';
        }).join('|'));
        
        var chunks = [];
        
        return through(write, end);
        
        function write (chunk, enc, next) { chunks.push(chunk); next() }
        
        function end () {
            var self = this;
            var source = Buffer.isBuffer(chunks[0])
                ? Buffer.concat(chunks).toString('utf8')
                : chunks.join('')
            ;
            source = source
                .replace(/^\ufeff/, '')
                .replace(/^#![^\n]*\n/, '\n');
            
            if (opts.always !== true && !quick.test(source)) {
                this.push(source);
                this.push(null);
                return;
            }
            
            try {
                var scope = opts.always
                    ? { globals: { implicit: varNames } }
                    : parseScope('(function(){\n' + source + '\n})()')
                ;
            }
            catch (err) {
                var e = new SyntaxError(
                    (err.message || err) + ' while parsing ' + file
                );
                e.type = 'syntax';
                e.filename = file;
                return this.emit('error', e);
            }
            
            var globals = {};
            
            varNames.forEach(function (name) {
                if (!/\./.test(name)) return;
                var parts = name.split('.')
                var prop = (scope.globals.implicitProperties || {})[parts[0]]
                if (!prop || prop.length !== 1 || prop[0] !== parts[1]) return;
                var value = vars[name](file, basedir);
                if (!value) return;
                globals[parts[0]] = '{'
                    + JSON.stringify(parts[1]) + ':' + value + '}';
                self.emit('global', name);
            });
            varNames.forEach(function (name) {
                if (/\./.test(name)) return;
                if (globals[name]) return;
                if (scope.globals.implicit.indexOf(name) < 0) return;
                var value = vars[name](file, basedir);
                if (!value) return;
                globals[name] = value;
                self.emit('global', name);
            });
            
            this.push(closeOver(globals, source, file, opts));
            this.push(null);
        }
    };
    
    module.exports.vars = defaultVars;
    
    function closeOver (globals, src, file, opts) {
        var keys = Object.keys(globals);
        if (keys.length === 0) return src;
        var values = keys.map(function (key) { return globals[key] });
        
        var wrappedSource;
        if (keys.length <= 3) {
            wrappedSource = '(function (' + keys.join(',') + '){\n'
                + src + '\n}).call(this,' + values.join(',') + ')'
            ;
        }
        else {
          // necessary to make arguments[3..6] still work for workerify etc
          // a,b,c,arguments[3..6],d,e,f...
          var extra = [ '__argument0', '__argument1', '__argument2', '__argument3' ];
          var names = keys.slice(0,3).concat(extra).concat(keys.slice(3));
          values.splice(3, 0,
              'arguments[3]','arguments[4]',
              'arguments[5]','arguments[6]'
          );
          wrappedSource = '(function (' + names.join(',') + '){\n'
            + src + '\n}).call(this,' + values.join(',') + ')';
        }
    
        // Generate source maps if wanted. Including the right offset for
        // the wrapped source.
        if (!opts.debug) {
            return wrappedSource;
        }
        var sourceFile = path.relative(opts.basedir, file)
            .replace(/\\/g, '/');
        var sourceMap = combineSourceMap.create().addFile(
            { sourceFile: sourceFile, source: src},
            { line: 1 });
        return combineSourceMap.removeComments(wrappedSource) + "\n"
            + sourceMap.comment();
    }
    
  provide("insert-module-globals", module.exports);
}(global));

// pakmanager:labeled-stream-splicer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Splicer = require('stream-splicer');
    var inherits = require('inherits');
    var isarray = require('isarray');
    
    module.exports = Labeled;
    inherits(Labeled, Splicer);
    
    module.exports.obj = function (streams, opts) {
        if (!opts) opts = {};
        opts.objectMode = true;
        return new Labeled(streams, opts);
    };
    
    function Labeled (streams, opts) {
        if (!(this instanceof Labeled)) return new Labeled(streams, opts);
        Splicer.call(this, [], opts);
        
        var reps = [];
        for (var i = 0; i < streams.length; i++) {
            var s = streams[i];
            if (typeof s === 'string') continue;
            if (isarray(s)) {
                s = new Labeled(s, opts);
            }
            if (i >= 0 && typeof streams[i-1] === 'string') {
                s.label = streams[i-1];
            }
            reps.push(s);
        }
        if (typeof streams[i-1] === 'string') {
            reps.push(new Labeled([], opts));
        }
        this.splice.apply(this, [0,0].concat(reps));
    }
    
    Labeled.prototype.indexOf = function (stream) {
        if (typeof stream === 'string') {
            for (var i = 0; i < this._streams.length; i++) {
                if (this._streams[i].label === stream) return i;
            }
            return -1;
        }
        else {
            return Splicer.prototype.indexOf.call(this, stream);
        }
    };
    
    Labeled.prototype.get = function (key) {
        if (typeof key === 'string') {
            var ix = this.indexOf(key);
            if (ix < 0) return undefined;
            return this._streams[ix];
        }
        else return Splicer.prototype.get.call(this, key);
    };
    
    Labeled.prototype.splice = function (key) {
        var ix;
        if (typeof key === 'string') {
            ix = this.indexOf(key);
        }
        else ix = key;
        var args = [ ix ].concat([].slice.call(arguments, 1));
        return Splicer.prototype.splice.apply(this, args);
    };
    
  provide("labeled-stream-splicer", module.exports);
}(global));

// pakmanager:module-deps
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs');
    var path = require('path');
    
    var browserResolve = require('browser-resolve');
    var nodeResolve = require('resolve');
    var detective = require('detective');
    var through = require('through2');
    var concat = require('concat-stream');
    var parents = require('parents');
    var combine = require('stream-combiner2');
    var duplexer = require('duplexer2');
    var xtend = require('xtend');
    var defined = require('defined');
    
    var inherits = require('inherits');
    var Transform = require('readable-stream').Transform;
    
    module.exports = Deps;
    inherits(Deps, Transform);
    
    function Deps (opts) {
        var self = this;
        if (!(this instanceof Deps)) return new Deps(opts);
        Transform.call(this, { objectMode: true });
        
        if (!opts) opts = {};
        
        this.basedir = opts.basedir || process.cwd();
        this.cache = opts.cache;
        this.fileCache = opts.fileCache;
        this.pkgCache = opts.packageCache || {};
        this.pkgFileCache = {};
        this.pkgFileCachePending = {};
        this._emittedPkg = {};
        this.visited = {};
        this.walking = {};
        this.entries = [];
        this._input = [];
        
        this.paths = opts.paths || process.env.NODE_PATH || '';
        if (typeof this.paths === 'string') {
            var delimiter = path.delimiter || (process.platform === 'win32' ? ';' : ':');
            this.paths = this.paths.split(delimiter);
        }
        this.paths = this.paths
            .filter(Boolean)
            .map(function (p) {
                return path.resolve(self.basedir, p);
            });
        
        this.transforms = [].concat(opts.transform).filter(Boolean);
        this.globalTransforms = [].concat(opts.globalTransform).filter(Boolean);
        this.resolver = opts.resolve || browserResolve;
        this.options = xtend(opts);
        if (!this.options.modules) this.options.modules = {};
    
        // If the caller passes options.expose, store resolved pathnames for exposed
        // modules in it. If not, set it anyway so it's defined later.
        if (!this.options.expose) this.options.expose = {};
        this.pending = 0;
        this.inputPending = 0;
        
        var topfile = path.join(this.basedir, '__fake.js');
        this.top = {
            id: topfile,
            filename: topfile,
            paths: this.paths,
            basedir: this.basedir
        };
    }
    
    Deps.prototype._isTopLevel = function (file) {
        var isTopLevel = this.entries.some(function (main) {
            var m = path.relative(path.dirname(main), file);
            return m.split(/[\\\/]/).indexOf('node_modules') < 0;
        });
        if (!isTopLevel) {
            var m = path.relative(this.basedir, file);
            isTopLevel = m.split(/[\\\/]/).indexOf('node_modules') < 0;
        }
        return isTopLevel;
    };
    
    Deps.prototype._transform = function (row, enc, next) {
        var self = this;
        if (typeof row === 'string') {
            row = { file: row };
        }
        if (row.transform && row.global) {
            this.globalTransforms.push([ row.transform, row.options ]);
            return next();
        }
        else if (row.transform) {
            this.transforms.push([ row.transform, row.options ]);
            return next();
        }
        
        self.pending ++;
        var basedir = defined(row.basedir, self.basedir);
        
        if (row.entry !== false) {
            self.entries.push(path.resolve(basedir, row.file || row.id));
        }
        
        self.lookupPackage(row.file, function (err, pkg) {
            if (err && self.options.ignoreMissing) {
                self.emit('missing', row.file, self.top);
                self.pending --;
                return next();
            }
            if (err) return self.emit('error', err)
            self.pending --;
            self._input.push({ row: row, pkg: pkg });
            next();
        });
    };
    
    Deps.prototype._flush = function () {
        var self = this;
        var files = {};
        self._input.forEach(function (r) {
            var w = r.row, f = files[w.file || w.id];
            if (f) {
                f.row.entry = f.row.entry || w.entry;
                var ex = f.row.expose || w.expose;
                f.row.expose = ex;
                if (ex && f.row.file === f.row.id && w.file !== w.id) {
                    f.row.id = w.id;
                }
            }
            else files[w.file || w.id] = r;
        });
        
        Object.keys(files).forEach(function (key) {
            var r = files[key];
            var pkg = r.pkg || {};
            var dir = path.dirname(r.row.file);
            if (!pkg.__dirname) pkg.__dirname = dir;
            self.walk(r.row, xtend(self.top, {
                filename: path.join(dir, '_fake.js')
            }));
        });
        if (this.pending === 0) this.push(null);
        this._ended = true;
    };
    
    Deps.prototype.resolve = function (id, parent, cb) {
        var self = this;
        var opts = self.options;
        
        if (xhas(self.cache, parent.id, 'deps', id)
        && self.cache[parent.id].deps[id]) {
            var file = self.cache[parent.id].deps[id];
            var pkg = self.pkgCache[file];
            if (pkg) return cb(null, file, pkg);
            return self.lookupPackage(file, function (err, pkg) {
                cb(null, file, pkg);
            });
        }
        
        parent.packageFilter = function (p, x) {
            var pkgdir = path.dirname(x);
            if (opts.packageFilter) p = opts.packageFilter(p, x);
            p.__dirname = pkgdir;
    
            return p;
        };
        
        if (opts.extensions) parent.extensions = opts.extensions;
        if (opts.modules) parent.modules = opts.modules;
        
        self.resolver(id, parent, function onresolve (err, file, pkg, fakePath) {
            if (err) return cb(err);
            if (!file) return cb(new Error(
                'module not found: "' + id + '" from file '
                + parent.filename
            ));
            
            if (!pkg || !pkg.__dirname) {
                self.lookupPackage(file, function (err, p) {
                    if (err) return cb(err);
                    if (!p) p = {};
                    if (!p.__dirname) p.__dirname = path.dirname(file);
                    self.pkgCache[file] = p;
                    onresolve(err, file, opts.packageFilter
                        ? opts.packageFilter(p, p.__dirname) : p,
                        fakePath
                    );
                });
            }
            else cb(err, file, pkg, fakePath);
        });
    };
    
    Deps.prototype.readFile = function (file, id, pkg) {
        var self = this;
        if (xhas(this.fileCache, file)) {
            var tr = through();
            tr.push(this.fileCache[file]);
            tr.push(null);
            return tr;
        }
        var rs = fs.createReadStream(file, {
            encoding: 'utf8'
        });
        rs.on('error', function (err) { self.emit('error', err) });
        this.emit('file', file, id);
        return rs;
    };
    
    Deps.prototype.getTransforms = function (file, pkg, opts) {
        if (!opts) opts = {};
        var self = this;
        
        var isTopLevel;
        if (opts.builtin || opts.inNodeModules) isTopLevel = false;
        else isTopLevel = this._isTopLevel(file);
        
        var transforms = [].concat(isTopLevel ? this.transforms : [])
            .concat(getTransforms(pkg, {
                globalTransform: this.globalTransforms,
                transformKey: this.options.transformKey
            }))
        ;
        if (transforms.length === 0) return through();
        
        var pending = transforms.length;
        var streams = [];
        var input = through();
        var output = through();
        var dup = duplexer(input, output);
        
        for (var i = 0; i < transforms.length; i++) (function (i) {
            makeTransform(transforms[i], function (err, trs) {
                if (err) return self.emit('error', err)
                streams[i] = trs;
                if (-- pending === 0) done();
            });
        })(i);
        return dup;
        
        function done () {
            var middle = combine.apply(null, streams);
            middle.on('error', function (err) {
                err.message += ' while parsing file: ' + file;
                if (!err.filename) err.filename = file;
                self.emit('error', err);
            });
            input.pipe(middle).pipe(output);
        }
        
        function makeTransform (tr, cb) {
            var trOpts = {};
            if (Array.isArray(tr)) {
                trOpts = tr[1];
                tr = tr[0];
            }
            if (typeof tr === 'function') {
                var t = tr(file, trOpts);
                self.emit('transform', t, file);
                nextTick(cb, null, wrapTransform(t));
            }
            else {
                loadTransform(tr, trOpts, function (err, trs) {
                    if (err) return cb(err);
                    cb(null, wrapTransform(trs));
                });
            }
        }
        
        function loadTransform (id, trOpts, cb) {
            var params = { basedir: path.dirname(file) };
            nodeResolve(id, params, function nr (err, res, again) {
                if (err && again) return cb && cb(err);
                
                if (err) {
                    params.basedir = pkg.__dirname;
                    return nodeResolve(id, params, function (e, r) {
                        nr(e, r, true)
                    });
                }
                
                if (!res) return cb(new Error(
                    'cannot find transform module ' + tr
                    + ' while transforming ' + file
                ));
                
                var r = require(res);
                if (typeof r !== 'function') {
                    return cb(new Error(
                        'Unexpected ' + typeof r + ' exported by the '
                        + JSON.stringify(res) + ' package. '
                        + 'Expected a transform function.'
                    ));
                }
                
                var trs = r(file, trOpts);
                self.emit('transform', trs, file);
                cb(null, trs);
            });
        }
    };
    
    Deps.prototype.walk = function (id, parent, cb) {
        var self = this;
        var opts = self.options;
        this.pending ++;
        
        var rec = {};
        var input;
        if (typeof id === 'object') {
            rec = xtend(id);
            if (rec.entry === false) delete rec.entry;
            id = rec.file || rec.id;
            input = true;
            this.inputPending ++;
        }
        
        self.resolve(id, parent, function (err, file, pkg, fakePath) {
            // this is checked early because parent.modules is also modified
            // by this function.
            var builtin = has(parent.modules, id);
    
            if (rec.expose) {
                // Set options.expose to make the resolved pathname available to the
                // caller. They may or may not have requested it, but it's harmless
                // to set this if they didn't.
                self.options.expose[rec.expose] =
                    self.options.modules[rec.expose] = file;
            }
            if (pkg && !self._emittedPkg[pkg.__dirname]) {
                self._emittedPkg[pkg.__dirname] = true;
                self.emit('package', pkg);
            }
            
            if (opts.postFilter && !opts.postFilter(id, file, pkg)) {
                if (--self.pending === 0) self.push(null);
                if (input) --self.inputPending;
                return cb && cb(null, undefined);
            }
            if (err && rec.source) {
                file = rec.file;
                
                var ts = self.getTransforms(file, pkg);
                ts.pipe(concat(function (body) {
                    rec.source = body.toString('utf8');
                    fromSource(file, rec.source, pkg);
                }));
                return ts.end(rec.source);
            }
            if (err && self.options.ignoreMissing) {
                if (--self.pending === 0) self.push(null);
                if (input) --self.inputPending;
                self.emit('missing', id, parent);
                return cb && cb(null, undefined);
            }
            if (err) return self.emit('error', err);
            if (self.visited[file]) {
                if (-- self.pending === 0) self.push(null);
                if (input) --self.inputPending;
                return cb && cb(null, file);
            }
            self.visited[file] = true;
            
            if (rec.source) {
                var ts = self.getTransforms(file, pkg);
                ts.pipe(concat(function (body) {
                    rec.source = body.toString('utf8');
                    fromSource(file, rec.source, pkg);
                }));
                return ts.end(rec.source);
            }
            
            var c = self.cache && self.cache[file];
            if (c) return fromDeps(file, c.source, c.package, fakePath, Object.keys(c.deps));
            
            self.readFile(file, id, pkg)
                .pipe(self.getTransforms(fakePath || file, pkg, {
                    builtin: builtin,
                    inNodeModules: parent.inNodeModules
                }))
                .pipe(concat(function (body) {
                    fromSource(file, body.toString('utf8'), pkg, fakePath);
                }))
            ;
        });
    
        function fromSource (file, src, pkg, fakePath) {
            var deps = rec.noparse ? [] : self.parseDeps(file, src);
            if (deps) fromDeps(file, src, pkg, fakePath, deps);
        }
        
        function fromDeps (file, src, pkg, fakePath, deps) {
            var p = deps.length;
            var resolved = {};
            
            if (input) --self.inputPending;
            
            (function resolve () {
                if (self.inputPending > 0) return setTimeout(resolve);
                deps.forEach(function (id) {
                    if (opts.filter && !opts.filter(id)) {
                        resolved[id] = false;
                        if (--p === 0) done();
                        return;
                    }
                    var isTopLevel = self._isTopLevel(fakePath || file);
                    var current = {
                        id: file,
                        filename: file,
                        paths: self.paths,
                        package: pkg,
                        inNodeModules: parent.inNodeModules || !isTopLevel
                    };
                    self.walk(id, current, function (err, r) {
                        resolved[id] = r;
                        if (--p === 0) done();
                    });
                });
                if (deps.length === 0) done();
            })();
            
            function done () {
                if (!rec.id) rec.id = file;
                if (!rec.source) rec.source = src;
                if (!rec.deps) rec.deps = resolved;
                if (!rec.file) rec.file = file;
                
                if (self.entries.indexOf(file) >= 0) {
                    rec.entry = true;
                }
                self.push(rec);
                
                if (cb) cb(null, file);
                if (-- self.pending === 0) self.push(null);
            }
        }
    };
    
    Deps.prototype.parseDeps = function (file, src, cb) {
        if (this.options.noParse === true) return [];
        if (/\.json$/.test(file)) return [];
        
        if (Array.isArray(this.options.noParse)
        && this.options.noParse.indexOf(file) >= 0) {
            return [];
        }
        
        try { var deps = detective(src) }
        catch (ex) {
            var message = ex && ex.message ? ex.message : ex;
            this.emit('error', new Error(
                'Parsing file ' + file + ': ' + message
            ));
            return;
        }
        return deps;
    };
    
    Deps.prototype.lookupPackage = function (file, cb) {
        var self = this;
        
        var cached = this.pkgCache[file];
        if (cached) return nextTick(cb, null, cached);
        if (cached === false) return nextTick(cb, null, undefined);
        
        var dirs = parents(path.dirname(file));
        
        (function next () {
            if (dirs.length === 0) {
                self.pkgCache[file] = false;
                return cb(null, undefined);
            }
            var dir = dirs.shift();
            if (dir.split(/[\\\/]/).slice(-1)[0] === 'node_modules') {
                return cb(null, undefined);
            }
            
            var pkgfile = path.join(dir, 'package.json');
            
            var cached = self.pkgCache[pkgfile];
            if (cached) return nextTick(cb, null, cached);
            else if (cached === false) return next();
            
            var pcached = self.pkgFileCachePending[pkgfile];
            if (pcached) return pcached.push(onpkg);
            pcached = self.pkgFileCachePending[pkgfile] = [];
            
            fs.readFile(pkgfile, function (err, src) {
                if (err) return onpkg();
                try { var pkg = JSON.parse(src) }
                catch (err) {
                    return onpkg(new Error([
                        err + ' while parsing json file ' + pkgfile
                    ].join('')))
                }
                pkg.__dirname = dir;
                
                self.pkgCache[pkgfile] = pkg;
                self.pkgCache[file] = pkg;
                onpkg(null, pkg);
            });
            
            function onpkg (err, pkg) {
                if (self.pkgFileCachePending[pkgfile]) {
                    var fns = self.pkgFileCachePending[pkgfile];
                    delete self.pkgFileCachePending[pkgfile];
                    fns.forEach(function (f) { f(err, pkg) });
                }
                if (err) cb(err)
                else if (pkg) cb(null, pkg)
                else {
                    self.pkgCache[pkgfile] = false;
                    next();
                }
            }
        })();
    };
     
    function getTransforms (pkg, opts) {
        var trx = [];
        if (opts.transformKey) {
            var n = pkg;
            var keys = opts.transformKey;
            for (var i = 0; i < keys.length; i++) {
                if (n && typeof n === 'object') n = n[keys[i]];
                else break;
            }
            if (i === keys.length) {
                trx = [].concat(n).filter(Boolean);
            }
        }
        return trx.concat(opts.globalTransform || []);
    }
    
    function nextTick (cb) {
        var args = [].slice.call(arguments, 1);
        process.nextTick(function () { cb.apply(null, args) });
    }
    
    function xhas (obj) {
        if (!obj) return false;
        for (var i = 1; i < arguments.length; i++) {
            var key = arguments[i];
            if (!has(obj, key)) return false;
            obj = obj[key];
        }
        return true;
    }
    
    function has (obj, key) {
        return obj && Object.prototype.hasOwnProperty.call(obj, key);
    }
    
    function wrapTransform (tr) {
        if (typeof tr.read === 'function') return tr;
        var input = through(), output = through();
        input.pipe(tr).pipe(output);
        var wrapper = duplexer(input, output);
        tr.on('error', function (err) { wrapper.emit('error', err) });
        return wrapper;
    }
    
  provide("module-deps", module.exports);
}(global));

// pakmanager:os-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('os');
    
  provide("os-browserify", module.exports);
}(global));

// pakmanager:path-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
    
      return parts;
    }
    
    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var splitPath = function(filename) {
      return splitPathRe.exec(filename).slice(1);
    };
    
    // path.resolve([from ...], to)
    // posix version
    exports.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
    
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
    
        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
    
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
    
      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
    
      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
    
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    
    // path.normalize(path)
    // posix version
    exports.normalize = function(path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
    
      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isAbsolute).join('/');
    
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
    
      return (isAbsolute ? '/' : '') + path;
    };
    
    // posix version
    exports.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    
    // posix version
    exports.join = function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    
    
    // path.relative(from, to)
    // posix version
    exports.relative = function(from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
    
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
    
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
    
        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }
    
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
    
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
    
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
    
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
    
      return outputParts.join('/');
    };
    
    exports.sep = '/';
    exports.delimiter = ':';
    
    exports.dirname = function(path) {
      var result = splitPath(path),
          root = result[0],
          dir = result[1];
    
      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }
    
      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }
    
      return root + dir;
    };
    
    
    exports.basename = function(path, ext) {
      var f = splitPath(path)[2];
      // TODO: make this comparison case-insensitive on windows?
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    
    
    exports.extname = function(path) {
      return splitPath(path)[3];
    };
    
    function filter (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }
    
    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b'
        ? function (str, start, len) { return str.substr(start, len) }
        : function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;
    
  provide("path-browserify", module.exports);
}(global));

// pakmanager:querystring-es3/decode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    'use strict';
    
    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    
    module.exports = function(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};
    
      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }
    
      var regexp = /\+/g;
      qs = qs.split(sep);
    
      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }
    
      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
    
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;
    
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }
    
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
    
        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
    
      return obj;
    };
    
    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
  provide("querystring-es3/decode", module.exports);
}(global));

// pakmanager:querystring-es3/encode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    'use strict';
    
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;
    
        case 'boolean':
          return v ? 'true' : 'false';
    
        case 'number':
          return isFinite(v) ? v : '';
    
        default:
          return '';
      }
    };
    
    module.exports = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }
    
      if (typeof obj === 'object') {
        return map(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
    
      }
    
      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    };
    
    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    
    function map (xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }
    
    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };
    
  provide("querystring-es3/encode", module.exports);
}(global));

// pakmanager:querystring-es3
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    exports.decode = exports.parse =  require('querystring-es3/decode');
    exports.encode = exports.stringify =  require('querystring-es3/encode');
    
  provide("querystring-es3", module.exports);
}(global));

// pakmanager:read-only-stream
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Readable = require('readable-stream').Readable;
    
    module.exports = function (stream) {
        var opts = stream._readableState;
        if (typeof stream.read !== 'function') {
            stream = new Readable(opts).wrap(stream);
        }
        
        var ro = new Readable({ objectMode: opts && opts.objectMode });
        var waiting = false;
        
        stream.on('readable', function () {
            if (waiting) {
                waiting = false;
                ro._read();
            }
        });
        
        ro._read = function () {
            var buf, reads = 0;
            while ((buf = stream.read()) !== null) {
                ro.push(buf);
                reads ++;
            }
            if (reads === 0) waiting = true;
        };
        stream.once('end', function () { ro.push(null) });
        stream.on('error', function (err) { ro.emit('error', err) });
        return ro;
    };
    
  provide("read-only-stream", module.exports);
}(global));

// pakmanager:shell-quote
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var json = typeof JSON !== undefined ? JSON : require('jsonify');
    var map = require('array-map');
    var filter = require('array-filter');
    var reduce = require('array-reduce');
    
    exports.quote = function (xs) {
        return map(xs, function (s) {
            if (s && typeof s === 'object') {
                return s.op.replace(/(.)/g, '\\$1');
            }
            else if (/["\s]/.test(s) && !/'/.test(s)) {
                return "'" + s.replace(/(['\\])/g, '\\$1') + "'";
            }
            else if (/["'\s]/.test(s)) {
                return '"' + s.replace(/(["\\$`!])/g, '\\$1') + '"';
            }
            else {
                return String(s).replace(/([\\$`()!#&*|])/g, '\\$1');
            }
        }).join(' ');
    };
    
    var CONTROL = '(?:' + [
        '\\|\\|', '\\&\\&', ';;', '\\|\\&', '[&;()|<>]'
    ].join('|') + ')';
    var META = '|&;()<> \\t';
    var BAREWORD = '(\\\\[\'"' + META + ']|[^\\s\'"' + META + '])+';
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';
    
    var TOKEN = '';
    for (var i = 0; i < 4; i++) {
        TOKEN += (Math.pow(16,8)*Math.random()).toString(16);
    }
    
    exports.parse = function (s, env, opts) {
        var mapped = parse(s, env, opts);
        if (typeof env !== 'function') return mapped;
        return reduce(mapped, function (acc, s) {
            if (typeof s === 'object') return acc.concat(s);
            var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
            if (xs.length === 1) return acc.concat(xs[0]);
            return acc.concat(map(filter(xs, Boolean), function (x) {
                if (RegExp('^' + TOKEN).test(x)) {
                    return json.parse(x.split(TOKEN)[1]);
                }
                else return x;
            }));
        }, []);
    };
    
    function parse (s, env, opts) {
        var chunker = new RegExp([
            '(' + CONTROL + ')', // control chars
            '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'
        ].join('|'), 'g');
        var match = filter(s.match(chunker), Boolean);
    
        if (!match) return [];
        if (!env) env = {};
        if (!opts) opts = {};
        return map(match, function (s) {
            if (RegExp('^' + CONTROL + '$').test(s)) {
                return { op: s };
            }
    
            // Hand-written scanner/parser for Bash quoting rules:
            //
            //  1. inside single quotes, all characters are printed literally.
            //  2. inside double quotes, all characters are printed literally
            //     except variables prefixed by '$' and backslashes followed by
            //     either a double quote or another backslash.
            //  3. outside of any quotes, backslashes are treated as escape
            //     characters and not printed (unless they are themselves escaped)
            //  4. quote context can switch mid-token if there is no whitespace
            //     between the two quote contexts (e.g. all'one'"token" parses as
            //     "allonetoken")
            var SQ = "'";
            var DQ = '"';
            var DS = '$';
            var BS = opts.escape || '\\';
            var quote = false;
            var varname = false;
            var esc = false;
            var out = '';
            var isGlob = false;
    
            for (var i = 0, len = s.length; i < len; i++) {
                var c = s.charAt(i);
                isGlob = isGlob || (!quote && (c === '*' || c === '?'))
                if (esc) {
                    out += c;
                    esc = false;
                }
                else if (quote) {
                    if (c === quote) {
                        quote = false;
                    }
                    else if (quote == SQ) {
                        out += c;
                    }
                    else { // Double quote
                        if (c === BS) {
                            i += 1;
                            c = s.charAt(i);
                            if (c === DQ || c === BS || c === DS) {
                                out += c;
                            } else {
                                out += BS + c;
                            }
                        }
                        else if (c === DS) {
                            out += parseEnvVar();
                        }
                        else {
                            out += c
                        }
                    }
                }
                else if (c === DQ || c === SQ) {
                    quote = c
                }
                else if (RegExp('^' + CONTROL + '$').test(c)) {
                    return { op: s };
                }
                else if (c === BS) {
                    esc = true
                }
                else if (c === DS) {
                    out += parseEnvVar();
                }
                else out += c;
            }
    
            if (isGlob) return {op: 'glob', pattern: out};
    
            return out
    
            function parseEnvVar() {
                i += 1;
                var varend, varname;
                //debugger
                if (s.charAt(i) === '{') {
                    i += 1
                    if (s.charAt(i) === '}') {
                        throw new Error("Bad substitution: " + s.substr(i - 2, 3));
                    }
                    varend = s.indexOf('}', i);
                    if (varend < 0) {
                        throw new Error("Bad substitution: " + s.substr(i));
                    }
                    varname = s.substr(i, varend - i);
                    i = varend;
                }
                else if (/[*@#?$!_\-]/.test(s.charAt(i))) {
                    varname = s.charAt(i);
                    i += 1;
                }
                else {
                    varend = s.substr(i).match(/[^\w\d_]/);
                    if (!varend) {
                        varname = s.substr(i);
                        i = s.length;
                    } else {
                        varname = s.substr(i, varend.index)
                        i += varend.index - 1;
                    }
                }
                return getVar(null, '', varname);
            }
        });
    
        function getVar (_, pre, key) {
            var r = typeof env === 'function' ? env(key) : env[key];
            if (r === undefined) r = '';
    
            if (typeof r === 'object') {
                return pre + TOKEN + json.stringify(r) + TOKEN;
            }
            else return pre + r;
        }
    };
    
  provide("shell-quote", module.exports);
}(global));

// pakmanager:stream-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    module.exports = Stream;
    
    var EE = require('events').EventEmitter;
    var inherits = require('inherits');
    
    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/readable.js');
    Stream.Writable = require('readable-stream/writable.js');
    Stream.Duplex = require('readable-stream/duplex.js');
    Stream.Transform = require('readable-stream/transform.js');
    Stream.PassThrough = require('readable-stream/passthrough.js');
    
    // Backwards-compat with node 0.4.x
    Stream.Stream = Stream;
    
    
    
    // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.
    
    function Stream() {
      EE.call(this);
    }
    
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
    
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
    
      source.on('data', ondata);
    
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
    
      dest.on('drain', ondrain);
    
      // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }
    
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
    
        dest.end();
      }
    
    
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
    
        if (typeof dest.destroy === 'function') dest.destroy();
      }
    
      // don't leave dangling pipes when there are errors.
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }
    
      source.on('error', onerror);
      dest.on('error', onerror);
    
      // remove all the event listeners that were added.
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
    
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
    
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
    
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
    
        dest.removeListener('close', cleanup);
      }
    
      source.on('end', cleanup);
      source.on('close', cleanup);
    
      dest.on('close', cleanup);
    
      dest.emit('pipe', source);
    
      // Allow for unix-like usage: A.pipe(B).pipe(C)
      return dest;
    };
    
  provide("stream-browserify", module.exports);
}(global));

// pakmanager:syntax-error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var aparse = require('acorn').parse;
    function parse (src) {
        return aparse(src, {
            ecmaVersion: 6,
            allowHashBang: true
        });
    }
    
    module.exports = function (src, file) {
        if (typeof src !== 'string') src = String(src);
        
        try {
            eval('throw "STOP"; (function () { ' + src + '})()');
            return;
        }
        catch (err) {
            if (err === 'STOP') return undefined;
            if (err.constructor.name !== 'SyntaxError') throw err;
            return errorInfo(src, file);
        }
    };
    
    function errorInfo (src, file) {
        try { parse(src) }
        catch (err) {
            return new ParseError(err, src, file);
        }
        return undefined;
    }
    
    function ParseError (err, src, file) {
        SyntaxError.call(this);
        
        this.message = err.message.replace(/\s+\(\d+:\d+\)$/, '');
        
        this.line = err.loc.line;
        this.column = err.loc.column + 1;
        
        this.annotated = '\n'
            + (file || '(anonymous file)')
            + ':' + this.line
            + '\n'
            + src.split('\n')[this.line - 1]
            + '\n'
            + Array(this.column).join(' ') + '^'
            + '\n'
            + 'ParseError: ' + this.message
        ;
    }
    
    ParseError.prototype = Object.create(SyntaxError.prototype);
    
    ParseError.prototype.toString = function () {
        return this.annotated;
    };
    
    ParseError.prototype.inspect = function () {
        return this.annotated;
    };
    
  provide("syntax-error", module.exports);
}(global));

// pakmanager:timers-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var nextTick = require('process/browser.js').nextTick;
    var apply = Function.prototype.apply;
    var slice = Array.prototype.slice;
    var immediateIds = {};
    var nextImmediateId = 0;
    
    // DOM APIs, for completeness
    
    exports.setTimeout = function() {
      return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
    };
    exports.setInterval = function() {
      return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
    };
    exports.clearTimeout =
    exports.clearInterval = function(timeout) { timeout.close(); };
    
    function Timeout(id, clearFn) {
      this._id = id;
      this._clearFn = clearFn;
    }
    Timeout.prototype.unref = Timeout.prototype.ref = function() {};
    Timeout.prototype.close = function() {
      this._clearFn.call(window, this._id);
    };
    
    // Does not start the time, just sets up the members needed.
    exports.enroll = function(item, msecs) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = msecs;
    };
    
    exports.unenroll = function(item) {
      clearTimeout(item._idleTimeoutId);
      item._idleTimeout = -1;
    };
    
    exports._unrefActive = exports.active = function(item) {
      clearTimeout(item._idleTimeoutId);
    
      var msecs = item._idleTimeout;
      if (msecs >= 0) {
        item._idleTimeoutId = setTimeout(function onTimeout() {
          if (item._onTimeout)
            item._onTimeout();
        }, msecs);
      }
    };
    
    // That's not how node.js implements it but the exposed api is the same.
    exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
      var id = nextImmediateId++;
      var args = arguments.length < 2 ? false : slice.call(arguments, 1);
    
      immediateIds[id] = true;
    
      nextTick(function onNextTick() {
        if (immediateIds[id]) {
          // fn.call() is faster so we optimize for the common use-case
          // @see http://jsperf.com/call-apply-segu
          if (args) {
            fn.apply(null, args);
          } else {
            fn.call(null);
          }
          // Prevent ids from leaking
          exports.clearImmediate(id);
        }
      });
    
      return id;
    };
    
    exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
      delete immediateIds[id];
    };
  provide("timers-browserify", module.exports);
}(global));

// pakmanager:tty-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  exports.isatty = function () { return false; };
    
    function ReadStream() {
      throw new Error('tty.ReadStream is not implemented');
    }
    exports.ReadStream = ReadStream;
    
    function WriteStream() {
      throw new Error('tty.ReadStream is not implemented');
    }
    exports.WriteStream = WriteStream;
    
  provide("tty-browserify", module.exports);
}(global));

// pakmanager:url/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = {
      isString: function(arg) {
        return typeof(arg) === 'string';
      },
      isObject: function(arg) {
        return typeof(arg) === 'object' && arg !== null;
      },
      isNull: function(arg) {
        return arg === null;
      },
      isNullOrUndefined: function(arg) {
        return arg == null;
      }
    };
    
  provide("url/util", module.exports);
}(global));

// pakmanager:url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    'use strict';
    
    var punycode = require('punycode');
    var util =  require('url/util');
    
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    
    exports.Url = Url;
    
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    
    // Reference: RFC 3986, RFC 1808, RFC 2396
    
    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,
    
        // Special case for a simple path URL
        simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    
        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    
        // RFC 2396: characters not allowed for various reasons.
        unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    
        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ['\''].concat(unwise),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        },
        querystring = require('querystring');
    
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;
    
      var u = new Url;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
    
      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter =
              (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);
    
      var rest = url;
    
      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();
    
      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }
    
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
    
      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
    
      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {
    
        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c
    
        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.
    
        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
    
        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }
    
        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
    
        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;
    
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
    
        // pull out port.
        this.parseHost();
    
        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';
    
        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' &&
            this.hostname[this.hostname.length - 1] === ']';
    
        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }
    
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }
    
        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }
    
        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;
    
        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }
    
      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {
    
        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
    
    
      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] &&
          this.hostname && !this.pathname) {
        this.pathname = '/';
      }
    
      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }
    
      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };
    
    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }
    
    Url.prototype.format = function() {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }
    
      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';
    
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ?
            this.hostname :
            '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }
    
      if (this.query &&
          util.isObject(this.query) &&
          Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
    
      var search = this.search || (query && ('?' + query)) || '';
    
      if (protocol && protocol.substr(-1) !== ':') protocol += ':';
    
      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes ||
          (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }
    
      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;
    
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');
    
      return protocol + host + pathname + search + hash;
    };
    
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    
    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    
    Url.prototype.resolveObject = function(relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
    
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
    
      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;
    
      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }
    
      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }
    
        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
            result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }
    
        result.href = result.format();
        return result;
      }
    
      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }
    
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
    
      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
          isRelAbs = (
              relative.host ||
              relative.pathname && relative.pathname.charAt(0) === '/'
          ),
          mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname)),
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];
    
      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }
    
      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
                      relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
                          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ?
                           result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }
    
      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
    
      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
          (result.host || relative.host || srcPath.length > 1) &&
          (last === '.' || last === '..') || last === '');
    
      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }
    
      if (mustEndAbs && srcPath[0] !== '' &&
          (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }
    
      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }
    
      var isAbsolute = srcPath[0] === '' ||
          (srcPath[0] && srcPath[0].charAt(0) === '/');
    
      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
                                        srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                         result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
    
      mustEndAbs = mustEndAbs || (result.host && srcPath.length);
    
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }
    
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }
    
      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
                      (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };
    
  provide("url", module.exports);
}(global));

// pakmanager:vm-browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var indexOf = require('indexof');
    
    var Object_keys = function (obj) {
        if (Object.keys) return Object.keys(obj)
        else {
            var res = [];
            for (var key in obj) res.push(key)
            return res;
        }
    };
    
    var forEach = function (xs, fn) {
        if (xs.forEach) return xs.forEach(fn)
        else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };
    
    var defineProp = (function() {
        try {
            Object.defineProperty({}, '_', {});
            return function(obj, name, value) {
                Object.defineProperty(obj, name, {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value: value
                })
            };
        } catch(e) {
            return function(obj, name, value) {
                obj[name] = value;
            };
        }
    }());
    
    var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
    'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
    'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
    'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
    'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
    
    function Context() {}
    Context.prototype = {};
    
    var Script = exports.Script = function NodeScript (code) {
        if (!(this instanceof Script)) return new Script(code);
        this.code = code;
    };
    
    Script.prototype.runInContext = function (context) {
        if (!(context instanceof Context)) {
            throw new TypeError("needs a 'context' argument.");
        }
        
        var iframe = document.createElement('iframe');
        if (!iframe.style) iframe.style = {};
        iframe.style.display = 'none';
        
        document.body.appendChild(iframe);
        
        var win = iframe.contentWindow;
        var wEval = win.eval, wExecScript = win.execScript;
    
        if (!wEval && wExecScript) {
            // win.eval() magically appears when this is called in IE:
            wExecScript.call(win, 'null');
            wEval = win.eval;
        }
        
        forEach(Object_keys(context), function (key) {
            win[key] = context[key];
        });
        forEach(globals, function (key) {
            if (context[key]) {
                win[key] = context[key];
            }
        });
        
        var winKeys = Object_keys(win);
    
        var res = wEval.call(win, this.code);
        
        forEach(Object_keys(win), function (key) {
            // Avoid copying circular objects like `top` and `window` by only
            // updating existing context properties or new properties in the `win`
            // that was only introduced after the eval.
            if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
            }
        });
    
        forEach(globals, function (key) {
            if (!(key in context)) {
                defineProp(context, key, win[key]);
            }
        });
        
        document.body.removeChild(iframe);
        
        return res;
    };
    
    Script.prototype.runInThisContext = function () {
        return eval(this.code); // maybe...
    };
    
    Script.prototype.runInNewContext = function (context) {
        var ctx = Script.createContext(context);
        var res = this.runInContext(ctx);
    
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    
        return res;
    };
    
    forEach(Object_keys(Script.prototype), function (name) {
        exports[name] = Script[name] = function (code) {
            var s = Script(code);
            return s[name].apply(s, [].slice.call(arguments, 1));
        };
    });
    
    exports.createScript = function (code) {
        return exports.Script(code);
    };
    
    exports.createContext = Script.createContext = function (context) {
        var copy = new Context();
        if(typeof context === 'object') {
            forEach(Object_keys(context), function (key) {
                copy[key] = context[key];
            });
        }
        return copy;
    };
    
  provide("vm-browserify", module.exports);
}(global));

// pakmanager:assertion-error
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * assertion-error
     * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
     * MIT Licensed
     */
    
    /*!
     * Return a function that will copy properties from
     * one object to another excluding any originally
     * listed. Returned function will create a new `{}`.
     *
     * @param {String} excluded properties ...
     * @return {Function}
     */
    
    function exclude () {
      var excludes = [].slice.call(arguments);
    
      function excludeProps (res, obj) {
        Object.keys(obj).forEach(function (key) {
          if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
      }
    
      return function extendExclude () {
        var args = [].slice.call(arguments)
          , i = 0
          , res = {};
    
        for (; i < args.length; i++) {
          excludeProps(res, args[i]);
        }
    
        return res;
      };
    };
    
    /*!
     * Primary Exports
     */
    
    module.exports = AssertionError;
    
    /**
     * ### AssertionError
     *
     * An extension of the JavaScript `Error` constructor for
     * assertion and validation scenarios.
     *
     * @param {String} message
     * @param {Object} properties to include (optional)
     * @param {callee} start stack function (optional)
     */
    
    function AssertionError (message, _props, ssf) {
      var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
        , props = extend(_props || {});
    
      // default values
      this.message = message || 'Unspecified AssertionError';
      this.showDiff = false;
    
      // copy from properties
      for (var key in props) {
        this[key] = props[key];
      }
    
      // capture stack trace
      ssf = ssf || arguments.callee;
      if (ssf && Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
      } else {
        this.stack = new Error().stack;
      }
    }
    
    /*!
     * Inherit from Error.prototype
     */
    
    AssertionError.prototype = Object.create(Error.prototype);
    
    /*!
     * Statically set name
     */
    
    AssertionError.prototype.name = 'AssertionError';
    
    /*!
     * Ensure correct constructor
     */
    
    AssertionError.prototype.constructor = AssertionError;
    
    /**
     * Allow errors to be converted to JSON for static transfer.
     *
     * @param {Boolean} include stack (default: `true`)
     * @return {Object} object that can be `JSON.stringify`
     */
    
    AssertionError.prototype.toJSON = function (stack) {
      var extend = exclude('constructor', 'toJSON', 'stack')
        , props = extend({ name: this.name }, this);
    
      // include stack if exists and not turned off
      if (false !== stack && this.stack) {
        props.stack = this.stack;
      }
    
      return props;
    };
    
  provide("assertion-error", module.exports);
}(global));

// pakmanager:deep-eql
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./lib/eql');
    
  provide("deep-eql", module.exports);
}(global));

// pakmanager:batch
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    try {
      var EventEmitter = require('events').EventEmitter;
    } catch (err) {
      var Emitter = require('emitter');
    }
    
    /**
     * Noop.
     */
    
    function noop(){}
    
    /**
     * Expose `Batch`.
     */
    
    module.exports = Batch;
    
    /**
     * Create a new Batch.
     */
    
    function Batch() {
      if (!(this instanceof Batch)) return new Batch;
      this.fns = [];
      this.concurrency(Infinity);
      this.throws(true);
      for (var i = 0, len = arguments.length; i < len; ++i) {
        this.push(arguments[i]);
      }
    }
    
    /**
     * Inherit from `EventEmitter.prototype`.
     */
    
    if (EventEmitter) {
      Batch.prototype.__proto__ = EventEmitter.prototype;
    } else {
      Emitter(Batch.prototype);
    }
    
    /**
     * Set concurrency to `n`.
     *
     * @param {Number} n
     * @return {Batch}
     * @api public
     */
    
    Batch.prototype.concurrency = function(n){
      this.n = n;
      return this;
    };
    
    /**
     * Queue a function.
     *
     * @param {Function} fn
     * @return {Batch}
     * @api public
     */
    
    Batch.prototype.push = function(fn){
      this.fns.push(fn);
      return this;
    };
    
    /**
     * Set wether Batch will or will not throw up.
     *
     * @param  {Boolean} throws
     * @return {Batch}
     * @api public
     */
    Batch.prototype.throws = function(throws) {
      this.e = !!throws;
      return this;
    };
    
    /**
     * Execute all queued functions in parallel,
     * executing `cb(err, results)`.
     *
     * @param {Function} cb
     * @return {Batch}
     * @api public
     */
    
    Batch.prototype.end = function(cb){
      var self = this
        , total = this.fns.length
        , pending = total
        , results = []
        , errors = []
        , cb = cb || noop
        , fns = this.fns
        , max = this.n
        , throws = this.e
        , index = 0
        , done;
    
      // empty
      if (!fns.length) return cb(null, results);
    
      // process
      function next() {
        var i = index++;
        var fn = fns[i];
        if (!fn) return;
        var start = new Date;
    
        try {
          fn(callback);
        } catch (err) {
          callback(err);
        }
    
        function callback(err, res){
          if (done) return;
          if (err && throws) return done = true, cb(err);
          var complete = total - pending + 1;
          var end = new Date;
    
          results[i] = res;
          errors[i] = err;
    
          self.emit('progress', {
            index: i,
            value: res,
            error: err,
            pending: pending,
            total: total,
            complete: complete,
            percent: complete / total * 100 | 0,
            start: start,
            end: end,
            duration: end - start
          });
    
          if (--pending) next();
          else if(!throws) cb(errors, results);
          else cb(null, results);
        }
      }
    
      // concurrency
      for (var i = 0; i < fns.length; i++) {
        if (i == max) break;
        next();
      }
    
      return this;
    };
    
  provide("batch", module.exports);
}(global));

// pakmanager:body-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * body-parser
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var deprecate = require('depd')('body-parser')
    
    /**
     * Cache of loaded parsers.
     * @private
     */
    
    var parsers = Object.create(null)
    
    /**
     * @typedef Parsers
     * @type {function}
     * @property {function} json
     * @property {function} raw
     * @property {function} text
     * @property {function} urlencoded
     */
    
    /**
     * Module exports.
     * @type {Parsers}
     */
    
    exports = module.exports = deprecate.function(bodyParser,
      'bodyParser: use individual json/urlencoded middlewares')
    
    /**
     * JSON parser.
     * @public
     */
    
    Object.defineProperty(exports, 'json', {
      configurable: true,
      enumerable: true,
      get: createParserGetter('json')
    })
    
    /**
     * Raw parser.
     * @public
     */
    
    Object.defineProperty(exports, 'raw', {
      configurable: true,
      enumerable: true,
      get: createParserGetter('raw')
    })
    
    /**
     * Text parser.
     * @public
     */
    
    Object.defineProperty(exports, 'text', {
      configurable: true,
      enumerable: true,
      get: createParserGetter('text')
    })
    
    /**
     * URL-encoded parser.
     * @public
     */
    
    Object.defineProperty(exports, 'urlencoded', {
      configurable: true,
      enumerable: true,
      get: createParserGetter('urlencoded')
    })
    
    /**
     * Create a middleware to parse json and urlencoded bodies.
     *
     * @param {object} [options]
     * @return {function}
     * @deprecated
     * @public
     */
    
    function bodyParser(options){
      var opts = {}
    
      // exclude type option
      if (options) {
        for (var prop in options) {
          if ('type' !== prop) {
            opts[prop] = options[prop]
          }
        }
      }
    
      var _urlencoded = exports.urlencoded(opts)
      var _json = exports.json(opts)
    
      return function bodyParser(req, res, next) {
        _json(req, res, function(err){
          if (err) return next(err);
          _urlencoded(req, res, next);
        });
      }
    }
    
    /**
     * Create a getter for loading a parser.
     * @private
     */
    
    function createParserGetter(name) {
      return function get() {
        return loadParser(name)
      }
    }
    
    /**
     * Load a parser module.
     * @private
     */
    
    function loadParser(parserName) {
      var parser = parsers[parserName]
    
      if (parser !== undefined) {
        return parser
      }
    
      // this uses a switch for static require analysis
      switch (parserName) {
        case 'json':
          parser = require('./lib/types/json')
          break
        case 'raw':
          parser = require('./lib/types/raw')
          break
        case 'text':
          parser = require('./lib/types/text')
          break
        case 'urlencoded':
          parser = require('./lib/types/urlencoded')
          break
      }
    
      // store to prevent invoking require()
      return parsers[parserName] = parser
    }
    
  provide("body-parser", module.exports);
}(global));

// pakmanager:chokidar
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var EventEmitter = require('events').EventEmitter;
    var fs = require('fs');
    var sysPath = require('path');
    var asyncEach = require('async-each');
    var anymatch = require('anymatch');
    var globParent = require('glob-parent');
    var isGlob = require('is-glob');
    var isAbsolute = require('path-is-absolute');
    var inherits = require('inherits');
    
    var NodeFsHandler = require('./lib/nodefs-handler');
    var FsEventsHandler = require('./lib/fsevents-handler');
    
    var arrify = function(value) {
      if (value == null) return [];
      return Array.isArray(value) ? value : [value];
    };
    
    var flatten = function(list, result) {
      if (result == null) result = [];
      list.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    
    // Little isString util for use in Array#every.
    var isString = function(thing) {
      return typeof thing === 'string';
    };
    
    // Public: Main class.
    // Watches files & directories for changes.
    //
    // * _opts - object, chokidar options hash
    //
    // Emitted events:
    // `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
    //
    // Examples
    //
    //  var watcher = new FSWatcher()
    //    .add(directories)
    //    .on('add', function(path) {console.log('File', path, 'was added');})
    //    .on('change', function(path) {console.log('File', path, 'was changed');})
    //    .on('unlink', function(path) {console.log('File', path, 'was removed');})
    //    .on('all', function(event, path) {console.log(path, ' emitted ', event);})
    //
    function FSWatcher(_opts) {
      EventEmitter.call(this);
      var opts = {};
      // in case _opts that is passed in is a frozen object
      if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
      this._watched = Object.create(null);
      this._closers = Object.create(null);
      this._ignoredPaths = Object.create(null);
      Object.defineProperty(this, '_globIgnored', {
        get: function() { return Object.keys(this._ignoredPaths); }
      });
      this.closed = false;
      this._throttled = Object.create(null);
      this._symlinkPaths = Object.create(null);
    
      function undef(key) {
        return opts[key] === undefined;
      }
    
      // Set up default options.
      if (undef('persistent')) opts.persistent = true;
      if (undef('ignoreInitial')) opts.ignoreInitial = false;
      if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
      if (undef('interval')) opts.interval = 100;
      if (undef('binaryInterval')) opts.binaryInterval = 300;
      this.enableBinaryInterval = opts.binaryInterval !== opts.interval;
    
      // Enable fsevents on OS X when polling isn't explicitly enabled.
      if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;
    
      // If we can't use fsevents, ensure the options reflect it's disabled.
      if (!FsEventsHandler.canUse()) opts.useFsEvents = false;
    
      // Use polling on Mac if not using fsevents.
      // Other platforms use non-polling fs.watch.
      if (undef('usePolling') && !opts.useFsEvents) {
        opts.usePolling = process.platform === 'darwin';
      }
    
      // Editor atomic write normalization enabled by default with fs.watch
      if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
      if (opts.atomic) this._pendingUnlinks = Object.create(null);
    
      if (undef('followSymlinks')) opts.followSymlinks = true;
    
      if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;
      if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
      var awf = opts.awaitWriteFinish;
      if (awf) {
        if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
        if (!awf.pollInterval) awf.pollInterval = 100;
    
        this._pendingWrites = Object.create(null);
      }
      if (opts.ignored) opts.ignored = arrify(opts.ignored);
    
      this._isntIgnored = function(path, stat) {
        return !this._isIgnored(path, stat);
      }.bind(this);
    
      var readyCalls = 0;
      this._emitReady = function() {
        if (++readyCalls >= this._readyCount) {
          this._emitReady = Function.prototype;
          this._readyEmitted = true;
          // use process.nextTick to allow time for listener to be bound
          process.nextTick(this.emit.bind(this, 'ready'));
        }
      }.bind(this);
    
      this.options = opts;
    
      // You’re frozen when your heart’s not open.
      Object.freeze(opts);
    }
    
    inherits(FSWatcher, EventEmitter);
    
    // Common helpers
    // --------------
    
    // Private method: Normalize and emit events
    //
    // * event     - string, type of event
    // * path      - string, file or directory path
    // * val[1..3] - arguments to be passed with event
    //
    // Returns the error if defined, otherwise the value of the
    // FSWatcher instance's `closed` flag
    FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
      if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
      var args = [event, path];
      if (val3 !== undefined) args.push(val1, val2, val3);
      else if (val2 !== undefined) args.push(val1, val2);
      else if (val1 !== undefined) args.push(val1);
    
      var awf = this.options.awaitWriteFinish;
      if (awf && this._pendingWrites[path]) return this;
    
      if (this.options.atomic) {
        if (event === 'unlink') {
          this._pendingUnlinks[path] = args;
          setTimeout(function() {
            Object.keys(this._pendingUnlinks).forEach(function(path) {
              this.emit.apply(this, this._pendingUnlinks[path]);
              this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
              delete this._pendingUnlinks[path];
            }.bind(this));
          }.bind(this), 100);
          return this;
        } else if (event === 'add' && this._pendingUnlinks[path]) {
          event = args[0] = 'change';
          delete this._pendingUnlinks[path];
        }
      }
    
      var emitEvent = function() {
        this.emit.apply(this, args);
        if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
      }.bind(this);
    
      if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
        var awfEmit = function(err, stats) {
          if (err) {
            event = args[0] = 'error';
            args[1] = err;
            emitEvent();
          } else if (stats) {
            // if stats doesn't exist the file must have been deleted
            if (args.length > 2) {
              args[2] = stats;
            } else {
              args.push(stats);
            }
            emitEvent();
          }
        };
    
        this._awaitWriteFinish(path, awf.stabilityThreshold, awfEmit);
        return this;
      }
    
      if (event === 'change') {
        if (!this._throttle('change', path, 50)) return this;
      }
    
      if (
        this.options.alwaysStat && val1 === undefined &&
        (event === 'add' || event === 'addDir' || event === 'change')
      ) {
        fs.stat(path, function(error, stats) {
          // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
          if (error || !stats) return;
    
          args.push(stats);
          emitEvent();
        });
      } else {
        emitEvent();
      }
    
      return this;
    };
    
    // Private method: Common handler for errors
    //
    // * error  - object, Error instance
    //
    // Returns the error if defined, otherwise the value of the
    // FSWatcher instance's `closed` flag
    FSWatcher.prototype._handleError = function(error) {
      var code = error && error.code;
      var ipe = this.options.ignorePermissionErrors;
      if (error &&
        code !== 'ENOENT' &&
        code !== 'ENOTDIR' &&
        (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
      ) this.emit('error', error);
      return error || this.closed;
    };
    
    // Private method: Helper utility for throttling
    //
    // * action  - string, type of action being throttled
    // * path    - string, path being acted upon
    // * timeout - int, duration of time to suppress duplicate actions
    //
    // Returns throttle tracking object or false if action should be suppressed
    FSWatcher.prototype._throttle = function(action, path, timeout) {
      if (!(action in this._throttled)) {
        this._throttled[action] = Object.create(null);
      }
      var throttled = this._throttled[action];
      if (path in throttled) return false;
      function clear() {
        delete throttled[path];
        clearTimeout(timeoutObject);
      }
      var timeoutObject = setTimeout(clear, timeout);
      throttled[path] = {timeoutObject: timeoutObject, clear: clear};
      return throttled[path];
    };
    
    // Private method: Awaits write operation to finish
    //
    // * path    - string, path being acted upon
    // * threshold - int, time in milliseconds a file size must be fixed before
    //                    acknowledgeing write operation is finished
    // * awfEmit - function, to be called when ready for event to be emitted
    // Polls a newly created file for size variations. When files size does not
    // change for 'threshold' milliseconds calls callback.
    FSWatcher.prototype._awaitWriteFinish = function(path, threshold, awfEmit) {
      var timeoutHandler;
    
      var fullPath = path;
      if (this.options.cwd && !isAbsolute(path)) {
        fullPath = sysPath.join(this.options.cwd, path);
      }
    
      var now = new Date();
    
      var awaitWriteFinish = (function (prevStat) {
        fs.stat(fullPath, function(err, curStat) {
          if (err) {
            if (err.code !== 'ENOENT') awfEmit(err);
            return;
          }
    
          var now = new Date();
    
          if (prevStat && curStat.size != prevStat.size) {
            this._pendingWrites[path].lastChange = now;
          }
    
          if (now - this._pendingWrites[path].lastChange >= threshold) {
            delete this._pendingWrites[path];
            awfEmit(null, curStat);
          } else {
            timeoutHandler = setTimeout(
              awaitWriteFinish.bind(this, curStat),
              this.options.awaitWriteFinish.pollInterval
            );
          }
        }.bind(this));
      }.bind(this));
    
      if (!(path in this._pendingWrites)) {
        this._pendingWrites[path] = {
          lastChange: now,
          cancelWait: function() {
            delete this._pendingWrites[path];
            clearTimeout(timeoutHandler);
          }.bind(this)
        };
        timeoutHandler = setTimeout(
          awaitWriteFinish.bind(this),
          this.options.awaitWriteFinish.pollInterval
        );
      }
    };
    
    // Private method: Determines whether user has asked to ignore this path
    //
    // * path  - string, path to file or directory
    // * stats - object, result of fs.stat
    //
    // Returns boolean
    var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
    FSWatcher.prototype._isIgnored = function(path, stats) {
      if (this.options.atomic && dotRe.test(path)) return true;
    
      if (!this._userIgnored) {
        var cwd = this.options.cwd;
        var ignored = this.options.ignored;
        if (cwd && ignored) {
          ignored = ignored.map(function (path) {
            if (typeof path !== 'string') return path;
            return isAbsolute(path) ? path : sysPath.join(cwd, path);
          });
        }
        var paths = arrify(ignored)
          .filter(function(path) {
            return typeof path === 'string' && !isGlob(path);
          }).map(function(path) {
            return path + '/**';
          });
        this._userIgnored = anymatch(
          this._globIgnored.concat(ignored).concat(paths)
        );
      }
    
      return this._userIgnored([path, stats]);
    };
    
    // Private method: Provides a set of common helpers and properties relating to
    // symlink and glob handling
    //
    // * path - string, file, directory, or glob pattern being watched
    // * depth - int, at any depth > 0, this isn't a glob
    //
    // Returns object containing helpers for this path
    var replacerRe = /^\.[\/\\]/;
    FSWatcher.prototype._getWatchHelpers = function(path, depth) {
      path = path.replace(replacerRe, '');
      var watchPath = depth || !isGlob(path) ? path : globParent(path);
      var fullWatchPath = sysPath.resolve(watchPath);
      var hasGlob = watchPath !== path;
      var globFilter = hasGlob ? anymatch(path) : false;
      var follow = this.options.followSymlinks;
      var globSymlink = hasGlob && follow ? null : false;
    
      var checkGlobSymlink = function(entry) {
        // only need to resolve once
        // first entry should always have entry.parentDir === ''
        if (globSymlink == null) {
          globSymlink = entry.fullParentDir === fullWatchPath ? false : {
            realPath: entry.fullParentDir,
            linkPath: fullWatchPath
          };
        }
    
        if (globSymlink) {
          return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
        }
    
        return entry.fullPath;
      };
    
      var entryPath = function(entry) {
        return sysPath.join(watchPath,
          sysPath.relative(watchPath, checkGlobSymlink(entry))
        );
      };
    
      var filterPath = function(entry) {
        var resolvedPath = entryPath(entry);
        return (!hasGlob || globFilter(resolvedPath)) &&
          this._isntIgnored(resolvedPath, entry.stat) &&
          (this.options.ignorePermissionErrors ||
            this._hasReadPermissions(entry.stat));
      }.bind(this);
    
      var getDirParts = function(path) {
        if (!hasGlob) return false;
        var parts = sysPath.relative(watchPath, path).split(/[\/\\]/);
        return parts;
      };
    
      var dirParts = getDirParts(path);
      if (dirParts && dirParts.length > 1) dirParts.pop();
      var unmatchedGlob;
    
      var filterDir = function(entry) {
        if (hasGlob) {
          var entryParts = getDirParts(checkGlobSymlink(entry));
          var globstar = false;
          unmatchedGlob = !dirParts.every(function(part, i) {
            if (part === '**') globstar = true;
            return globstar || !entryParts[i] || anymatch(part, entryParts[i]);
          });
        }
        return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
      }.bind(this);
    
      return {
        followSymlinks: follow,
        statMethod: follow ? 'stat' : 'lstat',
        path: path,
        watchPath: watchPath,
        entryPath: entryPath,
        hasGlob: hasGlob,
        globFilter: globFilter,
        filterPath: filterPath,
        filterDir: filterDir
      };
    };
    
    // Directory helpers
    // -----------------
    
    // Private method: Provides directory tracking objects
    //
    // * directory - string, path of the directory
    //
    // Returns the directory's tracking object
    FSWatcher.prototype._getWatchedDir = function(directory) {
      var dir = sysPath.resolve(directory);
      var watcherRemove = this._remove.bind(this);
      if (!(dir in this._watched)) this._watched[dir] = {
        _items: Object.create(null),
        add: function(item) {
          if (item !== '.') this._items[item] = true;
        },
        remove: function(item) {
          delete this._items[item];
          if (!this.children().length) {
            fs.readdir(dir, function(err) {
              if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
            });
          }
        },
        has: function(item) {return item in this._items;},
        children: function() {return Object.keys(this._items);}
      };
      return this._watched[dir];
    };
    
    // File helpers
    // ------------
    
    // Private method: Check for read permissions
    // Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
    //
    // * stats - object, result of fs.stat
    //
    // Returns boolean
    FSWatcher.prototype._hasReadPermissions = function(stats) {
      return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
    };
    
    // Private method: Handles emitting unlink events for
    // files and directories, and via recursion, for
    // files and directories within directories that are unlinked
    //
    // * directory - string, directory within which the following item is located
    // * item      - string, base path of item/directory
    //
    // Returns nothing
    FSWatcher.prototype._remove = function(directory, item) {
      // if what is being deleted is a directory, get that directory's paths
      // for recursive deleting and cleaning of watched object
      // if it is not a directory, nestedDirectoryChildren will be empty array
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      var isDirectory = this._watched[path] || this._watched[fullPath];
    
      // prevent duplicate handling in case of arriving here nearly simultaneously
      // via multiple paths (such as _handleFile and _handleDir)
      if (!this._throttle('remove', path, 100)) return;
    
      // if the only watched file is removed, watch for its return
      var watchedDirs = Object.keys(this._watched);
      if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
        this.add(directory, item, true);
      }
    
      // This will create a new entry in the watched object in either case
      // so we got to do the directory check beforehand
      var nestedDirectoryChildren = this._getWatchedDir(path).children();
    
      // Recursively remove children directories / files.
      nestedDirectoryChildren.forEach(function(nestedItem) {
        this._remove(path, nestedItem);
      }, this);
    
      // Check if item was on the watched list and remove it
      var parent = this._getWatchedDir(directory);
      var wasTracked = parent.has(item);
      parent.remove(item);
    
      // If we wait for this file to be fully written, cancel the wait.
      if (this.options.awaitWriteFinish && this._pendingWrites[path]) {
        this._pendingWrites[path].cancelWait();
        return;
      }
    
      // The Entry will either be a directory that just got removed
      // or a bogus entry to a file, in either case we have to remove it
      delete this._watched[path];
      delete this._watched[fullPath];
      var eventName = isDirectory ? 'unlinkDir' : 'unlink';
      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
    
      // Avoid conflicts if we later create another file with the same name
      if (!this.options.useFsEvents) {
        this._closePath(path);
      }
    };
    
    FSWatcher.prototype._closePath = function(path) {
      if (!this._closers[path]) return;
      this._closers[path]();
      delete this._closers[path];
      this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
    }
    
    // Public method: Adds paths to be watched on an existing FSWatcher instance
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    // * _origAdd  - private boolean, for handling non-existent paths to be watched
    // * _internal - private boolean, indicates a non-user add
    
    // Returns an instance of FSWatcher for chaining.
    FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
      var cwd = this.options.cwd;
      this.closed = false;
      paths = flatten(arrify(paths));
    
      if (!paths.every(isString)) {
        throw new TypeError('Non-string provided as watch path: ' + paths);
      }
    
      if (cwd) paths = paths.map(function(path) {
        if (isAbsolute(path)) {
          return path;
        } else if (path[0] === '!') {
          return '!' + sysPath.join(cwd, path.substring(1));
        } else {
          return sysPath.join(cwd, path);
        }
      });
    
      // set aside negated glob strings
      paths = paths.filter(function(path) {
        if (path[0] === '!') {
          this._ignoredPaths[path.substring(1)] = true;
        } else {
          // if a path is being added that was previously ignored, stop ignoring it
          delete this._ignoredPaths[path];
          delete this._ignoredPaths[path + '/**'];
    
          // reset the cached userIgnored anymatch fn
          // to make ignoredPaths changes effective
          this._userIgnored = null;
    
          return true;
        }
      }, this);
    
      if (this.options.useFsEvents && FsEventsHandler.canUse()) {
        if (!this._readyCount) this._readyCount = paths.length;
        if (this.options.persistent) this._readyCount *= 2;
        paths.forEach(this._addToFsEvents, this);
      } else {
        if (!this._readyCount) this._readyCount = 0;
        this._readyCount += paths.length;
        asyncEach(paths, function(path, next) {
          this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
            if (res) this._emitReady();
            next(err, res);
          }.bind(this));
        }.bind(this), function(error, results) {
          results.forEach(function(item) {
            if (!item) return;
            this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          }, this);
        }.bind(this));
      }
    
      return this;
    };
    
    // Public method: Close watchers or start ignoring events from specified paths.
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    
    // Returns instance of FSWatcher for chaining.
    FSWatcher.prototype.unwatch = function(paths) {
      if (this.closed) return this;
      paths = flatten(arrify(paths));
    
      paths.forEach(function(path) {
        // convert to absolute path unless relative path already matches
        if (!isAbsolute(path) && !this._closers[path]) {
          if (this.options.cwd) path = sysPath.join(this.options.cwd, path);
          path = sysPath.resolve(path);
        }
    
        this._closePath(path);
    
        this._ignoredPaths[path] = true;
        if (path in this._watched) {
          this._ignoredPaths[path + '/**'] = true;
        }
    
        // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective
        this._userIgnored = null;
      }, this);
    
      return this;
    };
    
    // Public method: Close watchers and remove all listeners from watched paths.
    
    // Returns instance of FSWatcher for chaining.
    FSWatcher.prototype.close = function() {
      if (this.closed) return this;
    
      this.closed = true;
      Object.keys(this._closers).forEach(function(watchPath) {
        this._closers[watchPath]();
        delete this._closers[watchPath];
      }, this);
      this._watched = Object.create(null);
    
      this.removeAllListeners();
      return this;
    };
    
    // Public method: Expose list of watched paths
    
    // Returns object w/ dir paths as keys and arrays of contained paths as values.
    FSWatcher.prototype.getWatched = function() {
      var watchList = {};
      Object.keys(this._watched).forEach(function(dir) {
        var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
        watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();
      }.bind(this));
      return watchList;
    };
    
    // Attach watch handler prototype methods
    function importHandler(handler) {
      Object.keys(handler.prototype).forEach(function(method) {
        FSWatcher.prototype[method] = handler.prototype[method];
      });
    }
    importHandler(NodeFsHandler);
    if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);
    
    // Export FSWatcher class
    exports.FSWatcher = FSWatcher;
    
    // Public function: Instantiates watcher with paths to be tracked.
    
    // * paths     - string or array of strings, file/directory paths and/or globs
    // * options   - object, chokidar options
    
    // Returns an instance of FSWatcher for chaining.
    exports.watch = function(paths, options) {
      return new FSWatcher(options).add(paths);
    };
    
  provide("chokidar", module.exports);
}(global));

// pakmanager:colors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var colors =   require('colors');
    module['exports'] = colors;
    
    // Remark: By default, colors will add style properties to String.prototype
    //
    // If you don't wish to extend String.prototype you can do this instead and native String will not be touched
    //
    //   var colors = require('colors/safe);
    //   colors.red("foo")
    //
    //
    require('./extendStringPrototype')();
  provide("colors", module.exports);
}(global));

// pakmanager:connect
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * connect
     * Copyright(c) 2010 Sencha Inc.
     * Copyright(c) 2011 TJ Holowaychuk
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module dependencies.
     * @private
     */
    
    var debug = require('debug')('connect:dispatcher');
    var EventEmitter = require('events').EventEmitter;
    var finalhandler = require('finalhandler');
    var http = require('http');
    var merge = require('utils-merge');
    var parseUrl = require('parseurl');
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = createServer;
    
    /**
     * Module variables.
     * @private
     */
    
    var env = process.env.NODE_ENV || 'development';
    var proto = {};
    
    /* istanbul ignore next */
    var defer = typeof setImmediate === 'function'
      ? setImmediate
      : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
    
    /**
     * Create a new connect server.
     *
     * @return {function}
     * @public
     */
    
    function createServer() {
      function app(req, res, next){ app.handle(req, res, next); }
      merge(app, proto);
      merge(app, EventEmitter.prototype);
      app.route = '/';
      app.stack = [];
      return app;
    }
    
    /**
     * Utilize the given middleware `handle` to the given `route`,
     * defaulting to _/_. This "route" is the mount-point for the
     * middleware, when given a value other than _/_ the middleware
     * is only effective when that segment is present in the request's
     * pathname.
     *
     * For example if we were to mount a function at _/admin_, it would
     * be invoked on _/admin_, and _/admin/settings_, however it would
     * not be invoked for _/_, or _/posts_.
     *
     * @param {String|Function|Server} route, callback or server
     * @param {Function|Server} callback or server
     * @return {Server} for chaining
     * @public
     */
    
    proto.use = function use(route, fn) {
      var handle = fn;
      var path = route;
    
      // default route to '/'
      if (typeof route !== 'string') {
        handle = route;
        path = '/';
      }
    
      // wrap sub-apps
      if (typeof handle.handle === 'function') {
        var server = handle;
        server.route = path;
        handle = function (req, res, next) {
          server.handle(req, res, next);
        };
      }
    
      // wrap vanilla http.Servers
      if (handle instanceof http.Server) {
        handle = handle.listeners('request')[0];
      }
    
      // strip trailing slash
      if (path[path.length - 1] === '/') {
        path = path.slice(0, -1);
      }
    
      // add the middleware
      debug('use %s %s', path || '/', handle.name || 'anonymous');
      this.stack.push({ route: path, handle: handle });
    
      return this;
    };
    
    /**
     * Handle server requests, punting them down
     * the middleware stack.
     *
     * @private
     */
    
    proto.handle = function handle(req, res, out) {
      var index = 0;
      var protohost = getProtohost(req.url) || '';
      var removed = '';
      var slashAdded = false;
      var stack = this.stack;
    
      // final function handler
      var done = out || finalhandler(req, res, {
        env: env,
        onerror: logerror
      });
    
      // store the original URL
      req.originalUrl = req.originalUrl || req.url;
    
      function next(err) {
        if (slashAdded) {
          req.url = req.url.substr(1);
          slashAdded = false;
        }
    
        if (removed.length !== 0) {
          req.url = protohost + removed + req.url.substr(protohost.length);
          removed = '';
        }
    
        // next callback
        var layer = stack[index++];
    
        // all done
        if (!layer) {
          defer(done, err);
          return;
        }
    
        // route data
        var path = parseUrl(req).pathname || '/';
        var route = layer.route;
    
        // skip this layer if the route doesn't match
        if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
    
        // skip if route match does not border "/", ".", or end
        var c = path[route.length];
        if (c !== undefined && '/' !== c && '.' !== c) {
          return next(err);
        }
    
        // trim off the part of the url that matches the route
        if (route.length !== 0 && route !== '/') {
          removed = route;
          req.url = protohost + req.url.substr(protohost.length + removed.length);
    
          // ensure leading slash
          if (!protohost && req.url[0] !== '/') {
            req.url = '/' + req.url;
            slashAdded = true;
          }
        }
    
        // call the layer handle
        call(layer.handle, route, err, req, res, next);
      }
    
      next();
    };
    
    /**
     * Listen for connections.
     *
     * This method takes the same arguments
     * as node's `http.Server#listen()`.
     *
     * HTTP and HTTPS:
     *
     * If you run your application both as HTTP
     * and HTTPS you may wrap them individually,
     * since your Connect "server" is really just
     * a JavaScript `Function`.
     *
     *      var connect =  require('connect')
     *        , http = require('http')
     *        , https = require('https');
     *
     *      var app = connect();
     *
     *      http.createServer(app).listen(80);
     *      https.createServer(options, app).listen(443);
     *
     * @return {http.Server}
     * @api public
     */
    
    proto.listen = function listen() {
      var server = http.createServer(this);
      return server.listen.apply(server, arguments);
    };
    
    /**
     * Invoke a route handle.
     * @private
     */
    
    function call(handle, route, err, req, res, next) {
      var arity = handle.length;
      var error = err;
      var hasError = Boolean(err);
    
      debug('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);
    
      try {
        if (hasError && arity === 4) {
          // error-handling middleware
          handle(err, req, res, next);
          return;
        } else if (!hasError && arity < 4) {
          // request-handling middleware
          handle(req, res, next);
          return;
        }
      } catch (e) {
        // replace the error
        error = e;
      }
    
      // continue
      next(error);
    }
    
    /**
     * Log error using console.error.
     *
     * @param {Error} err
     * @private
     */
    
    function logerror(err) {
      if (env !== 'test') console.error(err.stack || err.toString());
    }
    
    /**
     * Get get protocol + host for a URL.
     *
     * @param {string} url
     * @private
     */
    
    function getProtohost(url) {
      if (url.length === 0 || url[0] === '/') {
        return undefined;
      }
    
      var searchIndex = url.indexOf('?');
      var pathLength = searchIndex !== -1
        ? searchIndex
        : url.length;
      var fqdnIndex = url.substr(0, pathLength).indexOf('://');
    
      return fqdnIndex !== -1
        ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))
        : undefined;
    }
    
  provide("connect", module.exports);
}(global));

// pakmanager:core-js/shim
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  require('./modules/es6.symbol');
    require('./modules/es6.object.create');
    require('./modules/es6.object.define-property');
    require('./modules/es6.object.define-properties');
    require('./modules/es6.object.get-own-property-descriptor');
    require('./modules/es6.object.get-prototype-of');
    require('./modules/es6.object.keys');
    require('./modules/es6.object.get-own-property-names');
    require('./modules/es6.object.freeze');
    require('./modules/es6.object.seal');
    require('./modules/es6.object.prevent-extensions');
    require('./modules/es6.object.is-frozen');
    require('./modules/es6.object.is-sealed');
    require('./modules/es6.object.is-extensible');
    require('./modules/es6.object.assign');
    require('./modules/es6.object.is');
    require('./modules/es6.object.set-prototype-of');
    require('./modules/es6.object.to-string');
    require('./modules/es6.function.bind');
    require('./modules/es6.function.name');
    require('./modules/es6.function.has-instance');
    require('./modules/es6.parse-int');
    require('./modules/es6.parse-float');
    require('./modules/es6.number.constructor');
    require('./modules/es6.number.to-fixed');
    require('./modules/es6.number.to-precision');
    require('./modules/es6.number.epsilon');
    require('./modules/es6.number.is-finite');
    require('./modules/es6.number.is-integer');
    require('./modules/es6.number.is-nan');
    require('./modules/es6.number.is-safe-integer');
    require('./modules/es6.number.max-safe-integer');
    require('./modules/es6.number.min-safe-integer');
    require('./modules/es6.number.parse-float');
    require('./modules/es6.number.parse-int');
    require('./modules/es6.math.acosh');
    require('./modules/es6.math.asinh');
    require('./modules/es6.math.atanh');
    require('./modules/es6.math.cbrt');
    require('./modules/es6.math.clz32');
    require('./modules/es6.math.cosh');
    require('./modules/es6.math.expm1');
    require('./modules/es6.math.fround');
    require('./modules/es6.math.hypot');
    require('./modules/es6.math.imul');
    require('./modules/es6.math.log10');
    require('./modules/es6.math.log1p');
    require('./modules/es6.math.log2');
    require('./modules/es6.math.sign');
    require('./modules/es6.math.sinh');
    require('./modules/es6.math.tanh');
    require('./modules/es6.math.trunc');
    require('./modules/es6.string.from-code-point');
    require('./modules/es6.string.raw');
    require('./modules/es6.string.trim');
    require('./modules/es6.string.iterator');
    require('./modules/es6.string.code-point-at');
    require('./modules/es6.string.ends-with');
    require('./modules/es6.string.includes');
    require('./modules/es6.string.repeat');
    require('./modules/es6.string.starts-with');
    require('./modules/es6.string.anchor');
    require('./modules/es6.string.big');
    require('./modules/es6.string.blink');
    require('./modules/es6.string.bold');
    require('./modules/es6.string.fixed');
    require('./modules/es6.string.fontcolor');
    require('./modules/es6.string.fontsize');
    require('./modules/es6.string.italics');
    require('./modules/es6.string.link');
    require('./modules/es6.string.small');
    require('./modules/es6.string.strike');
    require('./modules/es6.string.sub');
    require('./modules/es6.string.sup');
    require('./modules/es6.date.now');
    require('./modules/es6.date.to-json');
    require('./modules/es6.date.to-iso-string');
    require('./modules/es6.date.to-string');
    require('./modules/es6.date.to-primitive');
    require('./modules/es6.array.is-array');
    require('./modules/es6.array.from');
    require('./modules/es6.array.of');
    require('./modules/es6.array.join');
    require('./modules/es6.array.slice');
    require('./modules/es6.array.sort');
    require('./modules/es6.array.for-each');
    require('./modules/es6.array.map');
    require('./modules/es6.array.filter');
    require('./modules/es6.array.some');
    require('./modules/es6.array.every');
    require('./modules/es6.array.reduce');
    require('./modules/es6.array.reduce-right');
    require('./modules/es6.array.index-of');
    require('./modules/es6.array.last-index-of');
    require('./modules/es6.array.copy-within');
    require('./modules/es6.array.fill');
    require('./modules/es6.array.find');
    require('./modules/es6.array.find-index');
    require('./modules/es6.array.species');
    require('./modules/es6.array.iterator');
    require('./modules/es6.regexp.constructor');
    require('./modules/es6.regexp.to-string');
    require('./modules/es6.regexp.flags');
    require('./modules/es6.regexp.match');
    require('./modules/es6.regexp.replace');
    require('./modules/es6.regexp.search');
    require('./modules/es6.regexp.split');
    require('./modules/es6.promise');
    require('./modules/es6.map');
    require('./modules/es6.set');
    require('./modules/es6.weak-map');
    require('./modules/es6.weak-set');
    require('./modules/es6.typed.array-buffer');
    require('./modules/es6.typed.data-view');
    require('./modules/es6.typed.int8-array');
    require('./modules/es6.typed.uint8-array');
    require('./modules/es6.typed.uint8-clamped-array');
    require('./modules/es6.typed.int16-array');
    require('./modules/es6.typed.uint16-array');
    require('./modules/es6.typed.int32-array');
    require('./modules/es6.typed.uint32-array');
    require('./modules/es6.typed.float32-array');
    require('./modules/es6.typed.float64-array');
    require('./modules/es6.reflect.apply');
    require('./modules/es6.reflect.construct');
    require('./modules/es6.reflect.define-property');
    require('./modules/es6.reflect.delete-property');
    require('./modules/es6.reflect.enumerate');
    require('./modules/es6.reflect.get');
    require('./modules/es6.reflect.get-own-property-descriptor');
    require('./modules/es6.reflect.get-prototype-of');
    require('./modules/es6.reflect.has');
    require('./modules/es6.reflect.is-extensible');
    require('./modules/es6.reflect.own-keys');
    require('./modules/es6.reflect.prevent-extensions');
    require('./modules/es6.reflect.set');
    require('./modules/es6.reflect.set-prototype-of');
    require('./modules/es7.array.includes');
    require('./modules/es7.string.at');
    require('./modules/es7.string.pad-start');
    require('./modules/es7.string.pad-end');
    require('./modules/es7.string.trim-left');
    require('./modules/es7.string.trim-right');
    require('./modules/es7.string.match-all');
    require('./modules/es7.object.get-own-property-descriptors');
    require('./modules/es7.object.values');
    require('./modules/es7.object.entries');
    require('./modules/es7.object.define-getter');
    require('./modules/es7.object.define-setter');
    require('./modules/es7.object.lookup-getter');
    require('./modules/es7.object.lookup-setter');
    require('./modules/es7.map.to-json');
    require('./modules/es7.set.to-json');
    require('./modules/es7.system.global');
    require('./modules/es7.error.is-error');
    require('./modules/es7.math.iaddh');
    require('./modules/es7.math.isubh');
    require('./modules/es7.math.imulh');
    require('./modules/es7.math.umulh');
    require('./modules/es7.reflect.define-metadata');
    require('./modules/es7.reflect.delete-metadata');
    require('./modules/es7.reflect.get-metadata');
    require('./modules/es7.reflect.get-metadata-keys');
    require('./modules/es7.reflect.get-own-metadata');
    require('./modules/es7.reflect.get-own-metadata-keys');
    require('./modules/es7.reflect.has-metadata');
    require('./modules/es7.reflect.has-own-metadata');
    require('./modules/es7.reflect.metadata');
    require('./modules/web.timers');
    require('./modules/web.immediate');
    require('./modules/web.dom.iterable');
    module.exports = require('./modules/_core');
  provide("core-js/shim", module.exports);
}(global));

// pakmanager:core-js
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
   require('core-js/shim');
    require('./modules/core.dict');
    require('./modules/core.get-iterator-method');
    require('./modules/core.get-iterator');
    require('./modules/core.is-iterable');
    require('./modules/core.delay');
    require('./modules/core.function.part');
    require('./modules/core.object.is-object');
    require('./modules/core.object.classof');
    require('./modules/core.object.define');
    require('./modules/core.object.make');
    require('./modules/core.number.iterator');
    require('./modules/core.regexp.escape');
    require('./modules/core.string.escape-html');
    require('./modules/core.string.unescape-html');
    module.exports = require('./modules/_core');
  provide("core-js", module.exports);
}(global));

// pakmanager:dom-serialize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Module dependencies.
     */
    
    var extend = require('extend');
    var encode = require('ent/encode');
    var CustomEvent = require('custom-event');
    var voidElements = require('void-elements');
    
    /**
     * Module exports.
     */
    
    exports = module.exports = serialize;
    exports.serializeElement = serializeElement;
    exports.serializeAttribute = serializeAttribute;
    exports.serializeText = serializeText;
    exports.serializeComment = serializeComment;
    exports.serializeDocument = serializeDocument;
    exports.serializeDoctype = serializeDoctype;
    exports.serializeDocumentFragment = serializeDocumentFragment;
    exports.serializeNodeList = serializeNodeList;
    
    /**
     * Serializes any DOM node. Returns a string.
     *
     * @param {Node} node - DOM Node to serialize
     * @param {String} [context] - optional arbitrary "context" string to use (useful for event listeners)
     * @param {Function} [fn] - optional callback function to use in the "serialize" event for this call
     * @param {EventTarget} [eventTarget] - optional EventTarget instance to emit the "serialize" event on (defaults to `node`)
     * return {String}
     * @public
     */
    
    function serialize (node, context, fn, eventTarget) {
      if (!node) return '';
      if ('function' === typeof context) {
        fn = context;
        context = null;
      }
      if (!context) context = null;
    
      var rtn;
      var nodeType = node.nodeType;
    
      if (!nodeType && 'number' === typeof node.length) {
        // assume it's a NodeList or Array of Nodes
        rtn = exports.serializeNodeList(node, context, fn);
      } else {
    
        if ('function' === typeof fn) {
          // one-time "serialize" event listener
          node.addEventListener('serialize', fn, false);
        }
    
        // emit a custom "serialize" event on `node`, in case there
        // are event listeners for custom serialization of this node
        var e = new CustomEvent('serialize', {
          bubbles: true,
          cancelable: true,
          detail: {
            serialize: null,
            context: context
          }
        });
    
        e.serializeTarget = node;
    
        var target = eventTarget || node;
        var cancelled = !target.dispatchEvent(e);
    
        // `e.detail.serialize` can be set to a:
        //   String - returned directly
        //   Node   - goes through serializer logic instead of `node`
        //   Anything else - get Stringified first, and then returned directly
        var s = e.detail.serialize;
        if (s != null) {
          if ('string' === typeof s) {
            rtn = s;
          } else if ('number' === typeof s.nodeType) {
            // make it go through the serialization logic
            rtn = serialize(s, context, null, target);
          } else {
            rtn = String(s);
          }
        } else if (!cancelled) {
          // default serialization logic
          switch (nodeType) {
            case 1 /* element */:
              rtn = exports.serializeElement(node, context, eventTarget);
              break;
            case 2 /* attribute */:
              rtn = exports.serializeAttribute(node);
              break;
            case 3 /* text */:
              rtn = exports.serializeText(node);
              break;
            case 8 /* comment */:
              rtn = exports.serializeComment(node);
              break;
            case 9 /* document */:
              rtn = exports.serializeDocument(node, context, eventTarget);
              break;
            case 10 /* doctype */:
              rtn = exports.serializeDoctype(node);
              break;
            case 11 /* document fragment */:
              rtn = exports.serializeDocumentFragment(node, context, eventTarget);
              break;
          }
        }
    
        if ('function' === typeof fn) {
          node.removeEventListener('serialize', fn, false);
        }
      }
    
      return rtn || '';
    }
    
    /**
     * Serialize an Attribute node.
     */
    
    function serializeAttribute (node, opts) {
      return node.name + '="' + encode(node.value, extend({
        named: true
      }, opts)) + '"';
    }
    
    /**
     * Serialize a DOM element.
     */
    
    function serializeElement (node, context, eventTarget) {
      var c, i, l;
      var name = node.nodeName.toLowerCase();
    
      // opening tag
      var r = '<' + name;
    
      // attributes
      for (i = 0, c = node.attributes, l = c.length; i < l; i++) {
        r += ' ' + exports.serializeAttribute(c[i]);
      }
    
      r += '>';
    
      // child nodes
      r += exports.serializeNodeList(node.childNodes, context, null, eventTarget);
    
      // closing tag, only for non-void elements
      if (!voidElements[name]) {
        r += '</' + name + '>';
      }
    
      return r;
    }
    
    /**
     * Serialize a text node.
     */
    
    function serializeText (node, opts) {
      return encode(node.nodeValue, extend({
        named: true,
        special: { '<': true, '>': true, '&': true }
      }, opts));
    }
    
    /**
     * Serialize a comment node.
     */
    
    function serializeComment (node) {
      return '<!--' + node.nodeValue + '-->';
    }
    
    /**
     * Serialize a Document node.
     */
    
    function serializeDocument (node, context, eventTarget) {
      return exports.serializeNodeList(node.childNodes, context, null, eventTarget);
    }
    
    /**
     * Serialize a DOCTYPE node.
     * See: http://stackoverflow.com/a/10162353
     */
    
    function serializeDoctype (node) {
      var r = '<!DOCTYPE ' + node.name;
    
      if (node.publicId) {
        r += ' PUBLIC "' + node.publicId + '"';
      }
    
      if (!node.publicId && node.systemId) {
        r += ' SYSTEM';
      }
    
      if (node.systemId) {
        r += ' "' + node.systemId + '"';
      }
    
      r += '>';
      return r;
    }
    
    /**
     * Serialize a DocumentFragment instance.
     */
    
    function serializeDocumentFragment (node, context, eventTarget) {
      return exports.serializeNodeList(node.childNodes, context, null, eventTarget);
    }
    
    /**
     * Serialize a NodeList/Array of nodes.
     */
    
    function serializeNodeList (list, context, fn, eventTarget) {
      var r = '';
      for (var i = 0, l = list.length; i < l; i++) {
        r += serialize(list[i], context, fn, eventTarget);
      }
      return r;
    }
    
  provide("dom-serialize", module.exports);
}(global));

// pakmanager:expand-braces
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * expand-braces <https://github.com/jonschlinkert/expand-braces>
     *
     * Copyright (c) 2014 Jon Schlinkert, contributors.
     * Licensed under the MIT license.
     */
    
    'use strict';
    
    var braces = require('braces');
    var uniq = require('array-unique');
    var slice = require('array-slice');
    
    module.exports = function expand(array) {
      var args = slice(arguments);
      var fn;
    
      if (typeof args[args.length - 1] === 'function') {
        fn = args.pop();
      }
    
      var len = args.length;
      var arr = [];
      var i = 0;
    
      while (i < len) {
        var current = args[i++];
        if (Array.isArray(current)) {
          var clen = current.length;
          var j = 0;
          while (j < clen) {
            arr.push.apply(arr, braces(current[j++], fn));
          }
        } else {
          arr.push.apply(arr, braces(current, fn));
        }
      }
    
      return uniq(arr);
    };
    
  provide("expand-braces", module.exports);
}(global));

// pakmanager:http-proxy
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Caron dimonio, con occhi di bragia
     * loro accennando, tutte le raccoglie;
     * batte col remo qualunque s’adagia 
     *
     * Charon the demon, with the eyes of glede,
     * Beckoning to them, collects them all together,
     * Beats with his oar whoever lags behind
     *          
     *          Dante - The Divine Comedy (Canto III)
     */
    
    module.exports = require('./lib/http-proxy');
  provide("http-proxy", module.exports);
}(global));

// pakmanager:isbinaryfile
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs');
    var path = require("path");
    var MAX_BYTES = 512;
    
    module.exports = function(bytes, size, cb) {
      // Only two args
      if (cb === undefined) {
        var file = bytes;
        cb = size;
    
        fs.stat(file, function(err, stat) {
          if (err || !stat.isFile()) return cb(err, false);
    
          fs.open(file, 'r', function(r_err, descriptor){
              if (r_err) return cb(r_err);
              bytes = new Buffer(MAX_BYTES);
              // Read the file with no encoding for raw buffer access.
              fs.read(descriptor, bytes, 0, bytes.length, 0, function(err, size, bytes){
                fs.close(descriptor, function(c_err){
                    if (c_err) return cb(c_err, false);
                    return cb(null, isBinaryCheck(bytes, size));
                });
              });
          });
        });
      }
      else
        return cb(null, isBinaryCheck(bytes, size));
    };
    
    function isBinaryCheck(bytes, size) {
      if (size === 0)
        return false;
    
      var suspicious_bytes = 0;
      var total_bytes = Math.min(size, MAX_BYTES);
    
      // UTF-8 BOM
      if (size >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {
        return false;
      }
    
      // UTF-32 BOM
      if (size >= 4 && bytes[0] === 0x00 && bytes[1] === 0x00 && bytes[2] == 0xFE && bytes[3] == 0xFF) {
        return false;
      }
    
      // UTF-32 LE BOM
      if (size >= 4 && bytes[0] == 0xFF && bytes[1] == 0xFE && bytes[2] === 0x00 && bytes[3] === 0x00) {
        return false;
      }
    
      // GB BOM
      if (size >= 4 && bytes[0] == 0x84 && bytes[1] == 0x31 && bytes[2] == 0x95 && bytes[3] == 0x33) {
        return false;
      }
    
      // PDF
      if (total_bytes >= 4 && bytes[0] == 0x25 && bytes[1] == 0x50 && bytes[2] == 0x44 && bytes[3] ==  0x46) {
        return true;
      }
    
      // UTF-16 BE BOM
      if (size >= 2 && bytes[0] == 0xFE && bytes[1] == 0xFF) {
        return false;
      }
    
      // UTF-16 LE BOM
      if (size >= 2 && bytes[0] == 0xFF && bytes[1] == 0xFE) {
        return false;
      }
    
      for (var i = 0; i < total_bytes; i++) {
        if (bytes[i] === 0) { // NULL byte--it's binary!
          return true;
        }
        else if ((bytes[i] < 7 || bytes[i] > 14) && (bytes[i] < 32 || bytes[i] > 127)) {
          // UTF-8 detection
          if (bytes[i] > 193 && bytes[i] < 224 && i + 1 < total_bytes) {
              i++;
              if (bytes[i] > 127 && bytes[i] < 192) {
                continue;
              }
          }
          else if (bytes[i] > 223 && bytes[i] < 240 && i + 2 < total_bytes) {
              i++;
              if (bytes[i] > 127 && bytes[i] < 192 && bytes[i + 1] > 127 && bytes[i + 1] < 192) {
                i++;
                continue;
              }
          }
          suspicious_bytes++;
          // Read at least 32 bytes before making a decision
          if (i > 32 && (suspicious_bytes * 100) / total_bytes > 10) {
            return true;
          }
        }
      }
    
      if ((suspicious_bytes * 100) / total_bytes > 10) {
        return true;
      }
    
      return false;
    }
    
    module.exports.sync = function(bytes, size) {
      // Only one arg
      if (size === undefined) {
        var file = bytes;
        try {
          if(!fs.statSync(file).isFile()) return false;
        } catch (err) {
          // otherwise continue on
        }
        var descriptor = fs.openSync(file, 'r');
        try {
          // Read the file with no encoding for raw buffer access.
          bytes = new Buffer(MAX_BYTES);
          size = fs.readSync(descriptor, bytes, 0, bytes.length, 0);
        } finally {
          fs.closeSync(descriptor);
        }
        return isBinaryCheck(bytes, size);
      }
      else
        return isBinaryCheck(bytes, size);
    }
    
  provide("isbinaryfile", module.exports);
}(global));

// pakmanager:optimist
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    var minimist = require('minimist');
    var wordwrap = require('wordwrap');
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
             require('optimist')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
             require('optimist').argv
        to get a parsed version of process.argv.
    */
    
    var inst = Argv(process.argv.slice(2));
    Object.keys(inst).forEach(function (key) {
        Argv[key] = typeof inst[key] == 'function'
            ? inst[key].bind(inst)
            : inst[key];
    });
    
    var exports = module.exports = Argv;
    function Argv (processArgs, cwd) {
        var self = {};
        if (!cwd) cwd = process.cwd();
        
        self.$0 = process.argv
            .slice(0,2)
            .map(function (x) {
                var b = rebase(cwd, x);
                return x.match(/^\//) && b.length < x.length
                    ? b : x
            })
            .join(' ')
        ;
        
        if (process.env._ != undefined && process.argv[1] == process.env._) {
            self.$0 = process.env._.replace(
                path.dirname(process.execPath) + '/', ''
            );
        }
        
        var options = {
            boolean: [],
            string: [],
            alias: {},
            default: []
        };
        
        self.boolean = function (bools) {
            options.boolean.push.apply(options.boolean, [].concat(bools));
            return self;
        };
        
        self.string = function (strings) {
            options.string.push.apply(options.string, [].concat(strings));
            return self;
        };
        
        self.default = function (key, value) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.default(k, key[k]);
                });
            }
            else {
                options.default[key] = value;
            }
            return self;
        };
        
        self.alias = function (x, y) {
            if (typeof x === 'object') {
                Object.keys(x).forEach(function (key) {
                    self.alias(key, x[key]);
                });
            }
            else {
                options.alias[x] = (options.alias[x] || []).concat(y);
            }
            return self;
        };
        
        var demanded = {};
        self.demand = function (keys) {
            if (typeof keys == 'number') {
                if (!demanded._) demanded._ = 0;
                demanded._ += keys;
            }
            else if (Array.isArray(keys)) {
                keys.forEach(function (key) {
                    self.demand(key);
                });
            }
            else {
                demanded[keys] = true;
            }
            
            return self;
        };
        
        var usage;
        self.usage = function (msg, opts) {
            if (!opts && typeof msg === 'object') {
                opts = msg;
                msg = null;
            }
            
            usage = msg;
            
            if (opts) self.options(opts);
            
            return self;
        };
        
        function fail (msg) {
            self.showHelp();
            if (msg) console.error(msg);
            process.exit(1);
        }
        
        var checks = [];
        self.check = function (f) {
            checks.push(f);
            return self;
        };
        
        var descriptions = {};
        self.describe = function (key, desc) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.describe(k, key[k]);
                });
            }
            else {
                descriptions[key] = desc;
            }
            return self;
        };
        
        self.parse = function (args) {
            return parseArgs(args);
        };
        
        self.option = self.options = function (key, opt) {
            if (typeof key === 'object') {
                Object.keys(key).forEach(function (k) {
                    self.options(k, key[k]);
                });
            }
            else {
                if (opt.alias) self.alias(key, opt.alias);
                if (opt.demand) self.demand(key);
                if (typeof opt.default !== 'undefined') {
                    self.default(key, opt.default);
                }
                
                if (opt.boolean || opt.type === 'boolean') {
                    self.boolean(key);
                }
                if (opt.string || opt.type === 'string') {
                    self.string(key);
                }
                
                var desc = opt.describe || opt.description || opt.desc;
                if (desc) {
                    self.describe(key, desc);
                }
            }
            
            return self;
        };
        
        var wrap = null;
        self.wrap = function (cols) {
            wrap = cols;
            return self;
        };
        
        self.showHelp = function (fn) {
            if (!fn) fn = console.error;
            fn(self.help());
        };
        
        self.help = function () {
            var keys = Object.keys(
                Object.keys(descriptions)
                .concat(Object.keys(demanded))
                .concat(Object.keys(options.default))
                .reduce(function (acc, key) {
                    if (key !== '_') acc[key] = true;
                    return acc;
                }, {})
            );
            
            var help = keys.length ? [ 'Options:' ] : [];
            
            if (usage) {
                help.unshift(usage.replace(/\$0/g, self.$0), '');
            }
            
            var switches = keys.reduce(function (acc, key) {
                acc[key] = [ key ].concat(options.alias[key] || [])
                    .map(function (sw) {
                        return (sw.length > 1 ? '--' : '-') + sw
                    })
                    .join(', ')
                ;
                return acc;
            }, {});
            
            var switchlen = longest(Object.keys(switches).map(function (s) {
                return switches[s] || '';
            }));
            
            var desclen = longest(Object.keys(descriptions).map(function (d) { 
                return descriptions[d] || '';
            }));
            
            keys.forEach(function (key) {
                var kswitch = switches[key];
                var desc = descriptions[key] || '';
                
                if (wrap) {
                    desc = wordwrap(switchlen + 4, wrap)(desc)
                        .slice(switchlen + 4)
                    ;
                }
                
                var spadding = new Array(
                    Math.max(switchlen - kswitch.length + 3, 0)
                ).join(' ');
                
                var dpadding = new Array(
                    Math.max(desclen - desc.length + 1, 0)
                ).join(' ');
                
                var type = null;
                
                if (options.boolean[key]) type = '[boolean]';
                if (options.string[key]) type = '[string]';
                
                if (!wrap && dpadding.length > 0) {
                    desc += dpadding;
                }
                
                var prelude = '  ' + kswitch + spadding;
                var extra = [
                    type,
                    demanded[key]
                        ? '[required]'
                        : null
                    ,
                    options.default[key] !== undefined
                        ? '[default: ' + JSON.stringify(options.default[key]) + ']'
                        : null
                    ,
                ].filter(Boolean).join('  ');
                
                var body = [ desc, extra ].filter(Boolean).join('  ');
                
                if (wrap) {
                    var dlines = desc.split('\n');
                    var dlen = dlines.slice(-1)[0].length
                        + (dlines.length === 1 ? prelude.length : 0)
                    
                    body = desc + (dlen + extra.length > wrap - 2
                        ? '\n'
                            + new Array(wrap - extra.length + 1).join(' ')
                            + extra
                        : new Array(wrap - extra.length - dlen + 1).join(' ')
                            + extra
                    );
                }
                
                help.push(prelude + body);
            });
            
            help.push('');
            return help.join('\n');
        };
        
        Object.defineProperty(self, 'argv', {
            get : function () { return parseArgs(processArgs) },
            enumerable : true,
        });
        
        function parseArgs (args) {
            var argv = minimist(args, options);
            argv.$0 = self.$0;
            
            if (demanded._ && argv._.length < demanded._) {
                fail('Not enough non-option arguments: got '
                    + argv._.length + ', need at least ' + demanded._
                );
            }
            
            var missing = [];
            Object.keys(demanded).forEach(function (key) {
                if (!argv[key]) missing.push(key);
            });
            
            if (missing.length) {
                fail('Missing required arguments: ' + missing.join(', '));
            }
            
            checks.forEach(function (f) {
                try {
                    if (f(argv) === false) {
                        fail('Argument check failed: ' + f.toString());
                    }
                }
                catch (err) {
                    fail(err)
                }
            });
            
            return argv;
        }
        
        function longest (xs) {
            return Math.max.apply(
                null,
                xs.map(function (x) { return x.length })
            );
        }
        
        return self;
    };
    
    // rebase an absolute path to a relative one with respect to a base directory
    // exported for tests
    exports.rebase = rebase;
    function rebase (base, dir) {
        var ds = path.normalize(dir).split('/').slice(1);
        var bs = path.normalize(base).split('/').slice(1);
        
        for (var i = 0; ds[i] && ds[i] == bs[i]; i++);
        ds.splice(0, i); bs.splice(0, i);
        
        var p = path.normalize(
            bs.map(function () { return '..' }).concat(ds).join('/')
        ).replace(/\/$/,'').replace(/^$/, '.');
        return p.match(/^[.\/]/) ? p : './' + p;
    };
    
  provide("optimist", module.exports);
}(global));

// pakmanager:useragent
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /**
     * This is where all the magic comes from, specially crafted for `useragent`.
     */
    var regexps = require('./lib/regexps');
    
    /**
     * Reduce references by storing the lookups.
     */
    // OperatingSystem parsers:
    var osparsers = regexps.os
      , osparserslength = osparsers.length;
    
    // UserAgent parsers:
    var agentparsers = regexps.browser
      , agentparserslength = agentparsers.length;
    
    // Device parsers:
    var deviceparsers = regexps.device
      , deviceparserslength = deviceparsers.length;
    
    /**
     * The representation of a parsed user agent.
     *
     * @constructor
     * @param {String} family The name of the browser
     * @param {String} major Major version of the browser
     * @param {String} minor Minor version of the browser
     * @param {String} patch Patch version of the browser
     * @param {String} source The actual user agent string
     * @api public
     */
    function Agent(family, major, minor, patch, source) {
      this.family = family || 'Other';
      this.major = major || '0';
      this.minor = minor || '0';
      this.patch = patch || '0';
      this.source = source || '';
    }
    
    /**
     * OnDemand parsing of the Operating System.
     *
     * @type {OperatingSystem}
     * @api public
     */
    Object.defineProperty(Agent.prototype, 'os', {
      get: function lazyparse() {
        var userAgent = this.source
          , length = osparserslength
          , parsers = osparsers
          , i = 0
          , parser
          , res;
    
        for (; i < length; i++) {
          if (res = parsers[i][0].exec(userAgent)) {
            parser = parsers[i];
    
            if (parser[1]) res[1] = parser[1].replace('$1', res[1]);
            break;
          }
        }
    
        return Object.defineProperty(this, 'os', {
            value: !parser || !res
              ? new OperatingSystem()
              : new OperatingSystem(
                    res[1]
                  , parser[2] || res[2]
                  , parser[3] || res[3]
                  , parser[4] || res[4]
                )
        }).os;
      },
    
      /**
       * Bypass the OnDemand parsing and set an OperatingSystem instance.
       *
       * @param {OperatingSystem} os
       * @api public
       */
      set: function set(os) {
        if (!(os instanceof OperatingSystem)) return false;
    
        return Object.defineProperty(this, 'os', {
          value: os
        }).os;
      }
    });
    
    /**
     * OnDemand parsing of the Device type.
     *
     * @type {Device}
     * @api public
     */
    Object.defineProperty(Agent.prototype, 'device', {
      get: function lazyparse() {
        var userAgent = this.source
          , length = deviceparserslength
          , parsers = deviceparsers
          , i = 0
          , parser
          , res;
    
        for (; i < length; i++) {
          if (res = parsers[i][0].exec(userAgent)) {
            parser = parsers[i];
    
            if (parser[1]) res[1] = parser[1].replace('$1', res[1]);
            break;
          }
        }
    
        return Object.defineProperty(this, 'device', {
            value: !parser || !res
              ? new Device()
              : new Device(
                    res[1]
                  , parser[2] || res[2]
                  , parser[3] || res[3]
                  , parser[4] || res[4]
                )
        }).device;
      },
    
      /**
       * Bypass the OnDemand parsing and set an Device instance.
       *
       * @param {Device} device
       * @api public
       */
      set: function set(device) {
        if (!(device instanceof Device)) return false;
    
        return Object.defineProperty(this, 'device', {
          value: device
        }).device;
      }
    });
    /*** Generates a string output of the parsed user agent.
     *
     * @returns {String}
     * @api public
     */
    Agent.prototype.toAgent = function toAgent() {
      var output = this.family
        , version = this.toVersion();
    
      if (version) output += ' '+ version;
      return output;
    };
    
    /**
     * Generates a string output of the parser user agent and operating system.
     *
     * @returns {String}  "UserAgent 0.0.0 / OS"
     * @api public
     */
    Agent.prototype.toString = function toString() {
      var agent = this.toAgent()
        , os = this.os !== 'Other' ? this.os : false;
    
      return agent + (os ? ' / ' + os : '');
    };
    
    /**
     * Outputs a compiled veersion number of the user agent.
     *
     * @returns {String}
     * @api public
     */
    Agent.prototype.toVersion = function toVersion() {
      var version = '';
    
      if (this.major) {
        version += this.major;
    
        if (this.minor) {
         version += '.' + this.minor;
    
         // Special case here, the patch can also be Alpha, Beta etc so we need
         // to check if it's a string or not.
         if (this.patch) {
          version += (isNaN(+this.patch) ? ' ' : '.') + this.patch;
         }
        }
      }
    
      return version;
    };
    
    /**
     * Outputs a JSON string of the Agent.
     *
     * @returns {String}
     * @api public
     */
    Agent.prototype.toJSON = function toJSON() {
      return {
          family: this.family
        , major: this.major
        , minor: this.minor
        , patch: this.patch
        , device: this.device
        , os: this.os
      };
    };
    
    /**
     * The representation of a parsed Operating System.
     *
     * @constructor
     * @param {String} family The name of the os
     * @param {String} major Major version of the os
     * @param {String} minor Minor version of the os
     * @param {String} patch Patch version of the os
     * @api public
     */
    function OperatingSystem(family, major, minor, patch) {
      this.family = family || 'Other';
      this.major = major || '0';
      this.minor = minor || '0';
      this.patch = patch || '0';
    }
    
    /**
     * Generates a stringified version of the Operating System.
     *
     * @returns {String} "Operating System 0.0.0"
     * @api public
     */
    OperatingSystem.prototype.toString = function toString() {
      var output = this.family
        , version = this.toVersion();
    
      if (version) output += ' '+ version;
      return output;
    };
    
    /**
     * Generates the version of the Operating System.
     *
     * @returns {String}
     * @api public
     */
    OperatingSystem.prototype.toVersion = function toVersion() {
      var version = '';
    
      if (this.major) {
        version += this.major;
    
        if (this.minor) {
         version += '.' + this.minor;
    
         // Special case here, the patch can also be Alpha, Beta etc so we need
         // to check if it's a string or not.
         if (this.patch) {
          version += (isNaN(+this.patch) ? ' ' : '.') + this.patch;
         }
        }
      }
    
      return version;
    };
    
    /**
     * Outputs a JSON string of the OS, values are defaulted to undefined so they
     * are not outputed in the stringify.
     *
     * @returns {String}
     * @api public
     */
    OperatingSystem.prototype.toJSON = function toJSON(){
      return {
          family: this.family
        , major: this.major || undefined
        , minor: this.minor || undefined
        , patch: this.patch || undefined
      };
    };
    
    /**
     * The representation of a parsed Device.
     *
     * @constructor
     * @param {String} family The name of the device
     * @param {String} major Major version of the device
     * @param {String} minor Minor version of the device
     * @param {String} patch Patch version of the device
     * @api public
     */
    function Device(family, major, minor, patch) {
      this.family = family || 'Other';
      this.major = major || '0';
      this.minor = minor || '0';
      this.patch = patch || '0';
    }
    
    /**
     * Generates a stringified version of the Device.
     *
     * @returns {String} "Device 0.0.0"
     * @api public
     */
    Device.prototype.toString = function toString() {
      var output = this.family
        , version = this.toVersion();
    
      if (version) output += ' '+ version;
      return output;
    };
    
    /**
     * Generates the version of the Device.
     *
     * @returns {String}
     * @api public
     */
    Device.prototype.toVersion = function toVersion() {
      var version = '';
    
      if (this.major) {
        version += this.major;
    
        if (this.minor) {
         version += '.' + this.minor;
    
         // Special case here, the patch can also be Alpha, Beta etc so we need
         // to check if it's a string or not.
         if (this.patch) {
          version += (isNaN(+this.patch) ? ' ' : '.') + this.patch;
         }
        }
      }
    
      return version;
    };
    
    /**
     * Outputs a JSON string of the Device, values are defaulted to undefined so they
     * are not outputed in the stringify.
     *
     * @returns {String}
     * @api public
     */
    Device.prototype.toJSON = function toJSON() {
      return {
          family: this.family
        , major: this.major || undefined
        , minor: this.minor || undefined
        , patch: this.patch || undefined
      };
    };
    
    /**
     * Small nifty thick that allows us to download a fresh set regexs from t3h
     * Int3rNetz when we want to. We will be using the compiled version by default
     * but users can opt-in for updates.
     *
     * @param {Boolean} refresh Refresh the dataset from the remote
     * @api public
     */
    module.exports = function updater() {
      try {
        require('./lib/update').update(function updating(err, results) {
          if (err) {
            console.log('[useragent] Failed to update the parsed due to an error:');
            console.log('[useragent] '+ (err.message ? err.message : err));
            return;
          }
    
          regexps = results;
    
          // OperatingSystem parsers:
          osparsers = regexps.os;
          osparserslength = osparsers.length;
    
          // UserAgent parsers:
          agentparsers = regexps.browser;
          agentparserslength = agentparsers.length;
    
          // Device parsers:
          deviceparsers = regexps.device;
          deviceparserslength = deviceparsers.length;
        });
      } catch (e) {
        console.error('[useragent] If you want to use automatic updating, please add:');
        console.error('[useragent]   - request (npm install request --save)');
        console.error('[useragent]   - yamlparser (npm install yamlparser --save)');
        console.error('[useragent] To your own package.json');
      }
    };
    
    // Override the exports with our newly set module.exports
    exports = module.exports;
    
    /**
     * Nao that we have setup all the different classes and configured it we can
     * actually start assembling and exposing everything.
     */
    exports.Device = Device;
    exports.OperatingSystem = OperatingSystem;
    exports.Agent = Agent;
    
    /**
     * Parses the user agent string with the generated parsers from the
     * ua-parser project on google code.
     *
     * @param {String} userAgent The user agent string
     * @param {String} jsAgent Optional UA from js to detect chrome frame
     * @returns {Agent}
     * @api public
     */
    exports.parse = function parse(userAgent, jsAgent) {
      if (!userAgent) return new Agent();
    
      var length = agentparserslength
        , parsers = agentparsers
        , i = 0
        , parser
        , res;
    
      for (; i < length; i++) {
        if (res = parsers[i][0].exec(userAgent)) {
          parser = parsers[i];
    
          if (parser[1]) res[1] = parser[1].replace('$1', res[1]);
          if (!jsAgent) return new Agent(
              res[1]
            , parser[2] || res[2]
            , parser[3] || res[3]
            , parser[4] || res[4]
            , userAgent
          );
    
          break;
        }
      }
    
      // Return early if we didn't find an match, but might still be able to parse
      // the os and device, so make sure we supply it with the source
      if (!parser || !res) return new Agent('', '', '', '', userAgent);
    
      // Detect Chrome Frame, but make sure it's enabled! So we need to check for
      // the Chrome/ so we know that it's actually using Chrome under the hood.
      if (jsAgent && ~jsAgent.indexOf('Chrome/') && ~userAgent.indexOf('chromeframe')) {
        res[1] = 'Chrome Frame (IE '+ res[1] +'.'+ res[2] +')';
    
        // Run the JavaScripted userAgent string through the parser again so we can
        // update the version numbers;
        parser = parse(jsAgent);
        parser[2] = parser.major;
        parser[3] = parser.minor;
        parser[4] = parser.patch;
      }
    
      return new Agent(
          res[1]
        , parser[2] || res[2]
        , parser[3] || res[3]
        , parser[4] || res[4]
        , userAgent
      );
    };
    
    /**
     * If you are doing a lot of lookups you might want to cache the results of the
     * parsed user agent string instead, in memory.
     *
     * @TODO We probably want to create 2 dictionary's here 1 for the Agent
     * instances and one for the userAgent instance mapping so we can re-use simular
     * Agent instance and lower our memory consumption.
     *
     * @param {String} userAgent The user agent string
     * @param {String} jsAgent Optional UA from js to detect chrome frame
     * @api public
     */
    var LRU = require('lru-cache')(5000);
    exports.lookup = function lookup(userAgent, jsAgent) {
      var key = (userAgent || '')+(jsAgent || '')
        , cached = LRU.get(key);
    
      if (cached) return cached;
      LRU.set(key, (cached = exports.parse(userAgent, jsAgent)));
    
      return cached;
    };
    
    /**
     * Does a more inaccurate but more common check for useragents identification.
     * The version detection is from the jQuery.com library and is licensed under
     * MIT.
     *
     * @param {String} useragent The user agent
     * @returns {Object} matches
     * @api public
     */
    exports.is = function is(useragent) {
      var ua = (useragent || '').toLowerCase()
        , details = {
            chrome: false
          , firefox: false
          , ie: false
          , mobile_safari: false
          , mozilla: false
          , opera: false
          , safari: false
          , webkit: false
          , android: false
          , version: (ua.match(exports.is.versionRE) || [0, "0"])[1]
        };
    
      if (~ua.indexOf('webkit')) {
        details.webkit = true;
    
        if (~ua.indexOf('android')){
          details.android = true;
        }
    
        if (~ua.indexOf('chrome')) {
          details.chrome = true;
        } else if (~ua.indexOf('safari')) {
          details.safari = true;
    
          if (~ua.indexOf('mobile') && ~ua.indexOf('apple')) {
            details.mobile_safari = true;
          }
        }
      } else if (~ua.indexOf('opera')) {
        details.opera = true;
      } else if (~ua.indexOf('trident') || ~ua.indexOf('msie')) {
        details.ie = true;
      } else if (~ua.indexOf('mozilla') && !~ua.indexOf('compatible')) {
        details.mozilla = true;
    
        if (~ua.indexOf('firefox')) details.firefox = true;
      }
    
    
      return details;
    };
    
    /**
     * Parses out the version numbers.
     *
     * @type {RegExp}
     * @api private
     */
    exports.is.versionRE = /.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/;
    
    /**
     * Transform a JSON object back to a valid userAgent string
     *
     * @param {Object} details
     * @returns {Agent}
     */
    exports.fromJSON = function fromJSON(details) {
      if (typeof details === 'string') details = JSON.parse(details);
    
      var agent = new Agent(details.family, details.major, details.minor, details.patch)
        , os = details.os;
    
      // The device family was added in v2.0
      if ('device' in details) {
        agent.device = new Device(details.device.family);
      } else {
        agent.device = new Device();
      }
    
      if ('os' in details && os) {
        // In v1.1.0 we only parsed out the Operating System name, not the full
        // version which we added in v2.0. To provide backwards compatible we should
        // we should set the details.os as family
        if (typeof os === 'string') {
          agent.os = new OperatingSystem(os);
        } else {
          agent.os = new OperatingSystem(os.family, os.major, os.minor, os.patch);
        }
      }
    
      return agent;
    };
    
    /**
     * Library version.
     *
     * @type {String}
     * @api public
     */
    exports.version = require('./package.json').version;
    
  provide("useragent", module.exports);
}(global));

// pakmanager:fs-access
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var fs = require('fs');
    var nullCheck = require('null-check');
    
    var access = module.exports = function (pth, mode, cb) {
    	if (typeof pth !== 'string') {
    		throw new TypeError('path must be a string');
    	}
    
    	if (typeof mode === 'function') {
    		cb = mode;
    		mode = access.F_OK;
    	} else if (typeof cb !== 'function') {
    		throw new TypeError('callback must be a function');
    	}
    
    	if (!nullCheck(pth, cb)) {
    		return;
    	}
    
    	mode = mode | 0;
    
    	if (mode === access.F_OK) {
    		fs.stat(pth, cb);
    	}
    };
    
    access.sync = function (pth, mode) {
    	nullCheck(pth);
    
    	mode = mode === undefined ? access.F_OK : mode | 0;
    
    	if (mode === access.F_OK) {
    		fs.statSync(pth);
    	}
    };
    
    access.F_OK = 0;
    access.R_OK = 4;
    access.W_OK = 2;
    access.X_OK = 1;
    
  provide("fs-access", module.exports);
}(global));

// pakmanager:which
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = which
    which.sync = whichSync
    
    var isWindows = process.platform === 'win32' ||
        process.env.OSTYPE === 'cygwin' ||
        process.env.OSTYPE === 'msys'
    
    var path = require('path')
    var COLON = isWindows ? ';' : ':'
    var isexe = require('isexe')
    var fs = require('fs')
    var isAbsolute = require('is-absolute')
    
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON
      var pathEnv = opt.path || process.env.Path || process.env.PATH || ''
      var pathExt = ['']
    
      pathEnv = pathEnv.split(colon)
    
      var pathExtExe = ''
      if (isWindows) {
        pathEnv.unshift(process.cwd())
        pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')
        pathExt = pathExtExe.split(colon)
    
    
        // Always test the cmd itself first.  isexe will check to make sure
        // it's found in the pathExt set.
        if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
          pathExt.unshift('')
      }
    
      // If it's absolute, then we don't bother searching the pathenv.
      // just check the file itself, and that's it.
      if (isAbsolute(cmd))
        pathEnv = ['']
    
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      }
    }
    
    function which (cmd, opt, cb) {
      if (typeof opt === 'function') {
        cb = opt
        opt = {}
      }
    
      var info = getPathInfo(cmd, opt)
      var pathEnv = info.env
      var pathExt = info.ext
      var pathExtExe = info.extExe
      var found = []
    
      ;(function F (i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found)
          else
            return cb(new Error('not found: '+cmd))
        }
    
        var pathPart = pathEnv[i]
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1)
    
        var p = path.resolve(pathPart, cmd)
        ;(function E (ii, ll) {
          if (ii === ll) return F(i + 1, l)
          var ext = pathExt[ii]
          isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext)
              else
                return cb(null, p + ext)
            }
            return E(ii + 1, ll)
          })
        })(0, pathExt.length)
      })(0, pathEnv.length)
    }
    
    function whichSync (cmd, opt) {
      opt = opt || {}
    
      var info = getPathInfo(cmd, opt)
      var pathEnv = info.env
      var pathExt = info.ext
      var pathExtExe = info.extExe
      var found = []
    
      for (var i = 0, l = pathEnv.length; i < l; i ++) {
        var pathPart = pathEnv[i]
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1)
    
        var p = path.join(pathPart, cmd)
        for (var j = 0, ll = pathExt.length; j < ll; j ++) {
          var cur = p + pathExt[j]
          var is
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe })
            if (is) {
              if (opt.all)
                found.push(cur)
              else
                return cur
            }
          } catch (ex) {}
        }
      }
    
      if (opt.all && found.length)
        return found
    
      throw new Error('not found: '+cmd)
    }
    
  provide("which", module.exports);
}(global));

// pakmanager:saucelabs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = process.env.SAUCELABS_COV ?
      require('./lib-cov/SauceLabs') :
      require('./lib/SauceLabs');
    
  provide("saucelabs", module.exports);
}(global));

// pakmanager:cliui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var stringWidth = require('string-width')
    var stripAnsi = require('strip-ansi')
    var wrap = require('wrap-ansi')
    var align = {
      right: alignRight,
      center: alignCenter
    }
    var top = 0
    var right = 1
    var bottom = 2
    var left = 3
    
    function UI (opts) {
      this.width = opts.width
      this.wrap = opts.wrap
      this.rows = []
    }
    
    UI.prototype.span = function () {
      var cols = this.div.apply(this, arguments)
      cols.span = true
    }
    
    UI.prototype.div = function () {
      if (arguments.length === 0) this.div('')
      if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
        return this._applyLayoutDSL(arguments[0])
      }
    
      var cols = []
    
      for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
        if (typeof arg === 'string') cols.push(this._colFromString(arg))
        else cols.push(arg)
      }
    
      this.rows.push(cols)
      return cols
    }
    
    UI.prototype._shouldApplyLayoutDSL = function () {
      return arguments.length === 1 && typeof arguments[0] === 'string' &&
        /[\t\n]/.test(arguments[0])
    }
    
    UI.prototype._applyLayoutDSL = function (str) {
      var _this = this
      var rows = str.split('\n')
      var leftColumnWidth = 0
    
      // simple heuristic for layout, make sure the
      // second column lines up along the left-hand.
      // don't allow the first column to take up more
      // than 50% of the screen.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
          leftColumnWidth = Math.min(
            Math.floor(_this.width * 0.5),
            stringWidth(columns[0])
          )
        }
      })
    
      // generate a table:
      //  replacing ' ' with padding calculations.
      //  using the algorithmically generated width.
      rows.forEach(function (row) {
        var columns = row.split('\t')
        _this.div.apply(_this, columns.map(function (r, i) {
          return {
            text: r.trim(),
            padding: _this._measurePadding(r),
            width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
          }
        }))
      })
    
      return this.rows[this.rows.length - 1]
    }
    
    UI.prototype._colFromString = function (str) {
      return {
        text: str,
        padding: this._measurePadding(str)
      }
    }
    
    UI.prototype._measurePadding = function (str) {
      // measure padding without ansi escape codes
      var noAnsi = stripAnsi(str)
      return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length]
    }
    
    UI.prototype.toString = function () {
      var _this = this
      var lines = []
    
      _this.rows.forEach(function (row, i) {
        _this.rowToString(row, lines)
      })
    
      // don't display any lines with the
      // hidden flag set.
      lines = lines.filter(function (line) {
        return !line.hidden
      })
    
      return lines.map(function (line) {
        return line.text
      }).join('\n')
    }
    
    UI.prototype.rowToString = function (row, lines) {
      var _this = this
      var padding
      var rrows = this._rasterize(row)
      var str = ''
      var ts
      var width
      var wrapWidth
    
      rrows.forEach(function (rrow, r) {
        str = ''
        rrow.forEach(function (col, c) {
          ts = '' // temporary string used during alignment/padding.
          width = row[c].width // the width with padding.
          wrapWidth = _this._negatePadding(row[c]) // the width without padding.
    
          ts += col
    
          for (var i = 0; i < wrapWidth - stringWidth(col); i++) {
            ts += ' '
          }
    
          // align the string within its column.
          if (row[c].align && row[c].align !== 'left' && _this.wrap) {
            ts = align[row[c].align](ts, wrapWidth)
            if (stringWidth(ts) < wrapWidth) ts += new Array(width - stringWidth(ts)).join(' ')
          }
    
          // apply border and padding to string.
          padding = row[c].padding || [0, 0, 0, 0]
          if (padding[left]) str += new Array(padding[left] + 1).join(' ')
          str += addBorder(row[c], ts, '| ')
          str += ts
          str += addBorder(row[c], ts, ' |')
          if (padding[right]) str += new Array(padding[right] + 1).join(' ')
    
          // if prior row is span, try to render the
          // current row on the prior line.
          if (r === 0 && lines.length > 0) {
            str = _this._renderInline(str, lines[lines.length - 1])
          }
        })
    
        // remove trailing whitespace.
        lines.push({
          text: str.replace(/ +$/, ''),
          span: row.span
        })
      })
    
      return lines
    }
    
    function addBorder (col, ts, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts)) return ''
        else if (ts.trim().length) return style
        else return '  '
      }
      return ''
    }
    
    // if the full 'source' can render in
    // the target line, do so.
    UI.prototype._renderInline = function (source, previousLine) {
      var leadingWhitespace = source.match(/^ */)[0].length
      var target = previousLine.text
      var targetTextWidth = stringWidth(target.trimRight())
    
      if (!previousLine.span) return source
    
      // if we're not applying wrapping logic,
      // just always append to the span.
      if (!this.wrap) {
        previousLine.hidden = true
        return target + source
      }
    
      if (leadingWhitespace < targetTextWidth) return source
    
      previousLine.hidden = true
    
      return target.trimRight() + new Array(leadingWhitespace - targetTextWidth + 1).join(' ') + source.trimLeft()
    }
    
    UI.prototype._rasterize = function (row) {
      var _this = this
      var i
      var rrow
      var rrows = []
      var widths = this._columnWidths(row)
      var wrapped
    
      // word wrap all columns, and create
      // a data-structure that is easy to rasterize.
      row.forEach(function (col, c) {
        // leave room for left and right padding.
        col.width = widths[c]
        if (_this.wrap) wrapped = wrap(col.text, _this._negatePadding(col), {hard: true}).split('\n')
        else wrapped = col.text.split('\n')
    
        if (col.border) {
          wrapped.unshift('.' + new Array(_this._negatePadding(col) + 3).join('-') + '.')
          wrapped.push("'" + new Array(_this._negatePadding(col) + 3).join('-') + "'")
        }
    
        // add top and bottom padding.
        if (col.padding) {
          for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
          for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
        }
    
        wrapped.forEach(function (str, r) {
          if (!rrows[r]) rrows.push([])
    
          rrow = rrows[r]
    
          for (var i = 0; i < c; i++) {
            if (rrow[i] === undefined) rrow.push('')
          }
          rrow.push(str)
        })
      })
    
      return rrows
    }
    
    UI.prototype._negatePadding = function (col) {
      var wrapWidth = col.width
      if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
      if (col.border) wrapWidth -= 4
      return wrapWidth
    }
    
    UI.prototype._columnWidths = function (row) {
      var _this = this
      var widths = []
      var unset = row.length
      var unsetWidth
      var remainingWidth = this.width
    
      // column widths can be set in config.
      row.forEach(function (col, i) {
        if (col.width) {
          unset--
          widths[i] = col.width
          remainingWidth -= col.width
        } else {
          widths[i] = undefined
        }
      })
    
      // any unset widths should be calculated.
      if (unset) unsetWidth = Math.floor(remainingWidth / unset)
      widths.forEach(function (w, i) {
        if (!_this.wrap) widths[i] = row[i].width || stringWidth(row[i].text)
        else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
      })
    
      return widths
    }
    
    // calculates the minimum width of
    // a column, based on padding preferences.
    function _minWidth (col) {
      var padding = col.padding || []
      var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)
      if (col.border) minWidth += 4
      return minWidth
    }
    
    function alignRight (str, width) {
      str = str.trim()
      var padding = ''
      var strWidth = stringWidth(str)
    
      if (strWidth < width) {
        padding = new Array(width - strWidth + 1).join(' ')
      }
    
      return padding + str
    }
    
    function alignCenter (str, width) {
      str = str.trim()
      var padding = ''
      var strWidth = stringWidth(str.trim())
    
      if (strWidth < width) {
        padding = new Array(parseInt((width - strWidth) / 2, 10) + 1).join(' ')
      }
    
      return padding + str
    }
    
    module.exports = function (opts) {
      opts = opts || {}
    
      return new UI({
        width: (opts || {}).width || 80,
        wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
      })
    }
    
  provide("cliui", module.exports);
}(global));

// pakmanager:decamelize
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    module.exports = function (str, sep) {
    	if (typeof str !== 'string') {
    		throw new TypeError('Expected a string');
    	}
    
    	sep = typeof sep === 'undefined' ? '_' : sep;
    
    	return str
    		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
    		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
    		.toLowerCase();
    };
    
  provide("decamelize", module.exports);
}(global));

// pakmanager:os-locale
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var childProcess = require('child_process');
    var execFileSync = childProcess.execFileSync;
    var lcid = require('lcid');
    var defaultOpts = {spawn: true};
    var cache;
    
    function fallback() {
    	cache = 'en_US';
    	return cache;
    }
    
    function getEnvLocale(env) {
    	env = env || process.env;
    	var ret = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;
    	cache = getLocale(ret);
    	return ret;
    }
    
    function parseLocale(x) {
    	var env = x.split('\n').reduce(function (env, def) {
    		def = def.split('=');
    		env[def[0]] = def[1];
    		return env;
    	}, {});
    	return getEnvLocale(env);
    }
    
    function getLocale(str) {
    	return (str && str.replace(/[.:].*/, '')) || fallback();
    }
    
    module.exports = function (opts, cb) {
    	if (typeof opts === 'function') {
    		cb = opts;
    		opts = defaultOpts;
    	} else {
    		opts = opts || defaultOpts;
    	}
    
    	if (cache || getEnvLocale() || opts.spawn === false) {
    		setImmediate(cb, null, cache);
    		return;
    	}
    
    	var getAppleLocale = function () {
    		childProcess.execFile('defaults', ['read', '-g', 'AppleLocale'], function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			cache = stdout.trim() || fallback();
    			cb(null, cache);
    		});
    	};
    
    	if (process.platform === 'win32') {
    		childProcess.execFile('wmic', ['os', 'get', 'locale'], function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
    			cache = lcid.from(lcidCode) || fallback();
    			cb(null, cache);
    		});
    	} else {
    		childProcess.execFile('locale', function (err, stdout) {
    			if (err) {
    				fallback();
    				return;
    			}
    
    			var res = parseLocale(stdout);
    
    			if (!res && process.platform === 'darwin') {
    				getAppleLocale();
    				return;
    			}
    
    			cache = getLocale(res);
    			cb(null, cache);
    		});
    	}
    };
    
    module.exports.sync = function (opts) {
    	opts = opts || defaultOpts;
    
    	if (cache || getEnvLocale() || !execFileSync || opts.spawn === false) {
    		return cache;
    	}
    
    	if (process.platform === 'win32') {
    		var stdout;
    
    		try {
    			stdout = execFileSync('wmic', ['os', 'get', 'locale'], {encoding: 'utf8'});
    		} catch (err) {
    			return fallback();
    		}
    
    		var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
    		cache = lcid.from(lcidCode) || fallback();
    		return cache;
    	}
    
    	var res;
    
    	try {
    		res = parseLocale(execFileSync('locale', {encoding: 'utf8'}));
    	} catch (err) {}
    
    	if (!res && process.platform === 'darwin') {
    		try {
    			cache = execFileSync('defaults', ['read', '-g', 'AppleLocale'], {encoding: 'utf8'}).trim() || fallback();
    			return cache;
    		} catch (err) {
    			return fallback();
    		}
    	}
    
    	cache = getLocale(res);
    	return cache;
    };
    
  provide("os-locale", module.exports);
}(global));

// pakmanager:pkg-conf
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var findUp = require('find-up');
    var loadJsonFile = require('load-json-file');
    var objectAssign = require('object-assign');
    var Symbol = require('symbol');
    var fpSymbol = Symbol('package.json filepath');
    
    function addFp(x, fp) {
    	x[fpSymbol] = fp;
    	return x;
    }
    
    module.exports = function (namespace, opts) {
    	// legacy
    	if (typeof opts === 'string') {
    		opts = {cwd: opts};
    	}
    
    	opts = opts || {};
    
    	return findUp('package.json', {cwd: opts.cwd})
    		.then(function (fp) {
    			if (!namespace) {
    				throw new TypeError('Expected a namespace');
    			}
    
    			if (!fp) {
    				return addFp(opts.defaults || {}, fp);
    			}
    
    			return loadJsonFile(fp).then(function (pkg) {
    				return addFp(objectAssign({}, opts.defaults, pkg[namespace]), fp);
    			});
    		});
    };
    
    module.exports.sync = function (namespace, opts) {
    	if (!namespace) {
    		throw new TypeError('Expected a namespace');
    	}
    
    	// legacy
    	if (typeof opts === 'string') {
    		opts = {cwd: opts};
    	}
    
    	opts = opts || {};
    
    	var fp = findUp.sync('package.json', {cwd: opts.cwd});
    
    	if (!fp) {
    		return addFp(opts.defaults || {}, fp);
    	}
    
    	var pkg = loadJsonFile.sync(fp);
    
    	return addFp(objectAssign({}, opts.defaults, pkg[namespace]), fp);
    };
    
    module.exports.filepath = function (conf) {
    	return conf[fpSymbol];
    };
    
  provide("pkg-conf", module.exports);
}(global));

// pakmanager:read-pkg-up
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var findUp = require('find-up');
    var readPkg = require('read-pkg');
    
    module.exports = function (opts) {
    	return findUp('package.json', opts).then(function (fp) {
    		if (!fp) {
    			return {};
    		}
    
    		return readPkg(fp, opts).then(function (pkg) {
    			return {
    				pkg: pkg,
    				path: fp
    			};
    		});
    	});
    };
    
    module.exports.sync = function (opts) {
    	var fp = findUp.sync('package.json', opts);
    
    	if (!fp) {
    		return {};
    	}
    
    	return {
    		pkg: readPkg.sync(fp, opts),
    		path: fp
    	};
    };
    
  provide("read-pkg-up", module.exports);
}(global));

// pakmanager:require-main-filename
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function (_require) {
      _require = _require || require
      var main = _require.main
      if (main && isIISNode(main)) return handleIISNode(main)
      else return main ? main.filename : process.cwd()
    }
    
    function isIISNode (main) {
      return /\\iisnode\\/.test(main.filename)
    }
    
    function handleIISNode (main) {
      if (!main.children.length) {
        return main.filename
      } else {
        return main.children[0].filename
      }
    }
    
  provide("require-main-filename", module.exports);
}(global));

// pakmanager:window-size
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    /*!
     * window-size <https://github.com/jonschlinkert/window-size>
     *
     * Copyright (c) 2014-2015 Jon Schlinkert
     * Licensed under the MIT license.
     */
    
    var tty = require('tty');
    
    module.exports = (function () {
      var width;
      var height;
    
      if (tty.isatty(1) && tty.isatty(2)) {
        if (process.stdout.getWindowSize) {
          width = process.stdout.getWindowSize(1)[0];
          height = process.stdout.getWindowSize(1)[1];
        } else if (tty.getWindowSize) {
          width = tty.getWindowSize()[1];
          height = tty.getWindowSize()[0];
        } else if (process.stdout.columns && process.stdout.rows) {
          height = process.stdout.rows;
          width = process.stdout.columns;
        }
      } else {
        Error('window-size could not get size with tty or process.stdout.');
      }
    
      return {height: height, width: width};
    })();
    
  provide("window-size", module.exports);
}(global));

// pakmanager:y18n
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fs = require('fs')
    var path = require('path')
    var util = require('util')
    
    function Y18N (opts) {
      // configurable options.
      opts = opts || {}
      this.directory = opts.directory || './locales'
      this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true
      this.locale = opts.locale || 'en'
      this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true
    
      // internal stuff.
      this.cache = {}
      this.writeQueue = []
    }
    
    Y18N.prototype.__ = function () {
      var args = Array.prototype.slice.call(arguments)
      var str = args.shift()
      var cb = function () {} // start with noop.
    
      if (typeof args[args.length - 1] === 'function') cb = args.pop()
      cb = cb || function () {} // noop.
    
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      // we've observed a new string, update the language file.
      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str
    
        // include the current directory and locale,
        // since these values could change before the
        // write is performed.
        this._enqueueWrite([this.directory, this.locale, cb])
      } else {
        cb()
      }
    
      return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))
    }
    
    Y18N.prototype._enqueueWrite = function (work) {
      this.writeQueue.push(work)
      if (this.writeQueue.length === 1) this._processWriteQueue()
    }
    
    Y18N.prototype._processWriteQueue = function () {
      var _this = this
      var work = this.writeQueue[0]
    
      // destructure the enqueued work.
      var directory = work[0]
      var locale = work[1]
      var cb = work[2]
    
      var languageFile = this._resolveLocaleFile(directory, locale)
      var serializedLocale = JSON.stringify(this.cache[locale], null, 2)
    
      fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
        _this.writeQueue.shift()
        if (_this.writeQueue.length > 0) _this._processWriteQueue()
        cb(err)
      })
    }
    
    Y18N.prototype._readLocaleFile = function () {
      var localeLookup = {}
      var languageFile = this._resolveLocaleFile(this.directory, this.locale)
    
      try {
        localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = 'syntax error in ' + languageFile
        }
    
        if (err.code === 'ENOENT') localeLookup = {}
        else throw err
      }
    
      this.cache[this.locale] = localeLookup
    }
    
    Y18N.prototype._resolveLocaleFile = function (directory, locale) {
      var file = path.resolve(directory, './', locale + '.json')
      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
        // attempt fallback to language only
        var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')
        if (this._fileExistsSync(languageFile)) file = languageFile
      }
      return file
    }
    
    // this only exists because fs.existsSync() "will be deprecated"
    // see https://nodejs.org/api/fs.html#fs_fs_existssync_path
    Y18N.prototype._fileExistsSync = function (file) {
      try {
        return fs.statSync(file).isFile()
      } catch (err) {
        return false
      }
    }
    
    Y18N.prototype.__n = function () {
      var args = Array.prototype.slice.call(arguments)
      var singular = args.shift()
      var plural = args.shift()
      var quantity = args.shift()
    
      var cb = function () {} // start with noop.
      if (typeof args[args.length - 1] === 'function') cb = args.pop()
    
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      var str = quantity === 1 ? singular : plural
      if (this.cache[this.locale][singular]) {
        str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']
      }
    
      // we've observed a new string, update the language file.
      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        }
    
        // include the current directory and locale,
        // since these values could change before the
        // write is performed.
        this._enqueueWrite([this.directory, this.locale, cb])
      } else {
        cb()
      }
    
      // if a %d placeholder is provided, add quantity
      // to the arguments expanded by util.format.
      var values = [str]
      if (~str.indexOf('%d')) values.push(quantity)
    
      return util.format.apply(util, values.concat(args))
    }
    
    Y18N.prototype.setLocale = function (locale) {
      this.locale = locale
    }
    
    Y18N.prototype.getLocale = function () {
      return this.locale
    }
    
    Y18N.prototype.updateLocale = function (obj) {
      if (!this.cache[this.locale]) this._readLocaleFile()
    
      for (var key in obj) {
        this.cache[this.locale][key] = obj[key]
      }
    }
    
    module.exports = function (opts) {
      var y18n = new Y18N(opts)
    
      // bind all functions to y18n, so that
      // they can be used in isolation.
      for (var key in y18n) {
        if (typeof y18n[key] === 'function') {
          y18n[key] = y18n[key].bind(y18n)
        }
      }
    
      return y18n
    }
    
  provide("y18n", module.exports);
}(global));

// pakmanager:yargs-parser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var assign = require('lodash.assign')
    var camelCase = require('camelcase')
    var path = require('path')
    var tokenizeArgString = require('./lib/tokenize-arg-string')
    var util = require('util')
    
    function parse (args, opts) {
      if (!opts) opts = {}
      // allow a string argument to be passed in rather
      // than an argv array.
      args = tokenizeArgString(args)
      // aliases might have transitive relationships, normalize this.
      var aliases = combineAliases(opts.alias || {})
      var configuration = assign({}, {
        'short-option-groups': true,
        'camel-case-expansion': true,
        'dot-notation': true,
        'parse-numbers': true,
        'boolean-negation': true
      }, opts.configuration)
      var defaults = opts.default || {}
      var envPrefix = opts.envPrefix
      var newAliases = {}
      // allow a i18n handler to be passed in, default to a fake one (util.format).
      var __ = opts.__ || function (str) {
        return util.format.apply(util, Array.prototype.slice.call(arguments))
      }
      var error = null
      var flags = {
        aliases: {},
        arrays: {},
        bools: {},
        strings: {},
        numbers: {},
        counts: {},
        normalize: {},
        configs: {},
        defaulted: {},
        nargs: {}
      }
    
      ;[].concat(opts.array).filter(Boolean).forEach(function (key) {
        flags.arrays[key] = true
      })
    
      ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {
        flags.bools[key] = true
      })
    
      ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true
      })
    
      ;[].concat(opts.number).filter(Boolean).forEach(function (key) {
        flags.numbers[key] = true
      })
    
      ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
        flags.counts[key] = true
      })
    
      ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
        flags.normalize[key] = true
      })
    
      Object.keys(opts.narg || {}).forEach(function (k) {
        flags.nargs[k] = opts.narg[k]
      })
    
      if (Array.isArray(opts.config) || typeof opts.config === 'string') {
        ;[].concat(opts.config).filter(Boolean).forEach(function (key) {
          flags.configs[key] = true
        })
      } else {
        Object.keys(opts.config || {}).forEach(function (k) {
          flags.configs[k] = opts.config[k]
        })
      }
    
      // create a lookup table that takes into account all
      // combinations of aliases: {f: ['foo'], foo: ['f']}
      extendAliases(opts.key, aliases, opts.default, flags.arrays)
    
      // apply default values to all aliases.
      Object.keys(defaults).forEach(function (key) {
        (flags.aliases[key] || []).forEach(function (alias) {
          defaults[alias] = defaults[key]
        })
      })
    
      var argv = { _: [] }
    
      Object.keys(flags.bools).forEach(function (key) {
        setArg(key, !(key in defaults) ? false : defaults[key])
        setDefaulted(key)
      })
    
      var notFlags = []
      if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--') + 1)
        args = args.slice(0, args.indexOf('--'))
      }
    
      for (var i = 0; i < args.length; i++) {
        var arg = args[i]
        var broken
        var key
        var letters
        var m
        var next
        var value
    
        // -- seperated by =
        if (arg.match(/^--.+=/) || (
          !configuration['short-option-groups'] && arg.match(/^-.+=/)
        )) {
          // Using [\s\S] instead of . because js doesn't support the
          // 'dotall' regex modifier. See:
          // http://stackoverflow.com/a/1068308/13216
          m = arg.match(/^--?([^=]+)=([\s\S]*)$/)
    
          // nargs format = '--f=monkey washing cat'
          if (checkAllAliases(m[1], flags.nargs)) {
            args.splice(i + 1, m[1], m[2])
            i = eatNargs(i, m[1], args)
          // arrays format = '--f=a b c'
          } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, m[1], m[2])
            i = eatArray(i, m[1], args)
          } else {
            setArg(m[1], m[2])
          }
        } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {
          key = arg.match(/^--no-(.+)/)[1]
          setArg(key, false)
    
        // -- seperated by space.
        } else if (arg.match(/^--.+/) || (
          !configuration['short-option-groups'] && arg.match(/^-.+/)
        )) {
          key = arg.match(/^--?(.+)/)[1]
    
          // nargs format = '--foo a b c'
          if (checkAllAliases(key, flags.nargs)) {
            i = eatNargs(i, key, args)
          // array format = '--foo a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            i = eatArray(i, key, args)
          } else {
            next = args[i + 1]
    
            if (next !== undefined && !next.match(/^-/) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)) {
              setArg(key, next)
              i++
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next)
              i++
            } else {
              setArg(key, defaultForType(guessType(key, flags)))
            }
          }
    
        // dot-notation flag seperated by '='.
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/)
          setArg(m[1], m[2])
    
        // dot-notation flag seperated by space.
        } else if (arg.match(/^-.\..+/)) {
          next = args[i + 1]
          key = arg.match(/^-(.\..+)/)[1]
    
          if (next !== undefined && !next.match(/^-/) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, next)
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        } else if (arg.match(/^-[^-]+/)) {
          letters = arg.slice(1, -1).split('')
          broken = false
    
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2)
    
            if (letters[j + 1] && letters[j + 1] === '=') {
              value = arg.slice(j + 3)
              key = letters[j]
    
              // nargs format = '-f=monkey washing cat'
              if (checkAllAliases(letters[j], flags.nargs)) {
                args.splice(i + 1, 0, value)
                i = eatNargs(i, key, args)
              // array format = '-f=a b c'
              } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
                args.splice(i + 1, 0, value)
                i = eatArray(i, key, args)
              } else {
                setArg(key, value)
              }
    
              broken = true
              break
            }
    
            if (next === '-') {
              setArg(letters[j], next)
              continue
            }
    
            if (/[A-Za-z]/.test(letters[j]) &&
              /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next)
              broken = true
              break
            }
    
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2))
              broken = true
              break
            } else {
              setArg(letters[j], defaultForType(guessType(letters[j], flags)))
            }
          }
    
          key = arg.slice(-1)[0]
    
          if (!broken && key !== '-') {
            // nargs format = '-f a b c'
            if (checkAllAliases(key, flags.nargs)) {
              i = eatNargs(i, key, args)
            // array format = '-f a b c'
            } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
              i = eatArray(i, key, args)
            } else {
              if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
                !checkAllAliases(key, flags.bools) &&
                !checkAllAliases(key, flags.counts)) {
                setArg(key, args[i + 1])
                i++
              } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
                setArg(key, args[i + 1])
                i++
              } else {
                setArg(key, defaultForType(guessType(key, flags)))
              }
            }
          }
        } else {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          )
        }
      }
    
      // order of precedence:
      // 1. command line arg
      // 2. value from config file
      // 3. value from env var
      // 4. configured default value
      applyEnvVars(argv, true) // special case: check env vars that point to config file
      setConfig(argv)
      applyEnvVars(argv, false)
      applyDefaultsAndAliases(argv, flags.aliases, defaults)
    
      Object.keys(flags.counts).forEach(function (key) {
        setArg(key, defaults[key])
      })
    
      notFlags.forEach(function (key) {
        argv._.push(key)
      })
    
      // how many arguments should we consume, based
      // on the nargs option?
      function eatNargs (i, key, args) {
        var toEat = checkAllAliases(key, flags.nargs)
    
        if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))
    
        for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
          setArg(key, args[ii])
        }
    
        return (i + toEat)
      }
    
      // if an option is an array, eat all non-hyphenated arguments
      // following it... YUM!
      // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
      function eatArray (i, key, args) {
        var start = i + 1
        for (var ii = i + 1; ii < args.length; ii++) {
          if (/^-/.test(args[ii])) {
            if (ii === start) {
              setArg(key, defaultForType('array'))
            }
            break
          }
          i = ii
          setArg(key, args[ii])
        }
    
        return i
      }
    
      function setArg (key, val) {
        unsetDefaulted(key)
    
        // handle parsing boolean arguments --foo=true --bar false.
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === 'string') val = val === 'true'
        }
    
        if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {
          var c = camelCase(key)
          flags.aliases[key] = [c]
          newAliases[c] = true
        }
    
        var value = val
        if (!checkAllAliases(key, flags.strings)) {
          if (isNumber(val)) value = Number(val)
          if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN
        }
    
        if (checkAllAliases(key, flags.counts)) {
          value = increment
        }
    
        var splitKey = key.split('.')
        setKey(argv, splitKey, value)
    
        // alias references an inner-value within
        // a dot-notation object. see #279.
        if (~key.indexOf('.') && flags.aliases[key]) {
          flags.aliases[key].forEach(function (x) {
            x = x.split('.')
            setKey(argv, x, value)
          })
        }
    
        ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {
          x = x.split('.')
    
          // handle populating dot notation for both
          // the key and its aliases.
          if (splitKey.length > 1) {
            var a = [].concat(splitKey)
            a.shift() // nuke the old key.
            x = x.concat(a)
          }
    
          setKey(argv, x, value)
        })
    
        var keys = [key].concat(flags.aliases[key] || [])
        for (var i = 0, l = keys.length; i < l; i++) {
          if (flags.normalize[keys[i]]) {
            keys.forEach(function (key) {
              argv.__defineSetter__(key, function (v) {
                val = path.normalize(v)
              })
    
              argv.__defineGetter__(key, function () {
                return typeof val === 'string' ? path.normalize(val) : val
              })
            })
            break
          }
        }
      }
    
      // set args from config.json file, this should be
      // applied last so that defaults can be applied.
      function setConfig (argv) {
        var configLookup = {}
    
        // expand defaults/aliases, in-case any happen to reference
        // the config.json file.
        applyDefaultsAndAliases(configLookup, flags.aliases, defaults)
    
        Object.keys(flags.configs).forEach(function (configKey) {
          var configPath = argv[configKey] || configLookup[configKey]
          if (configPath) {
            try {
              var config = null
              var resolvedConfigPath = path.resolve(process.cwd(), configPath)
    
              if (typeof flags.configs[configKey] === 'function') {
                try {
                  config = flags.configs[configKey](resolvedConfigPath)
                } catch (e) {
                  config = e
                }
                if (config instanceof Error) {
                  error = config
                  return
                }
              } else {
                config = require(resolvedConfigPath)
              }
    
              Object.keys(config).forEach(function (key) {
                // setting arguments via CLI takes precedence over
                // values within the config file.
                if (argv[key] === undefined || (flags.defaulted[key])) {
                  delete argv[key]
                  setArg(key, config[key])
                }
              })
            } catch (ex) {
              if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
            }
          }
        })
      }
    
      function applyEnvVars (argv, configOnly) {
        if (typeof envPrefix === 'undefined') return
    
        var prefix = typeof envPrefix === 'string' ? envPrefix : ''
        Object.keys(process.env).forEach(function (envVar) {
          if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
            var key = camelCase(envVar.substring(prefix.length))
            if (((configOnly && flags.configs[key]) || !configOnly) && (!(key in argv) || flags.defaulted[key])) {
              setArg(key, process.env[envVar])
            }
          }
        })
      }
    
      function applyDefaultsAndAliases (obj, aliases, defaults) {
        Object.keys(defaults).forEach(function (key) {
          if (!hasKey(obj, key.split('.'))) {
            setKey(obj, key.split('.'), defaults[key])
    
            ;(aliases[key] || []).forEach(function (x) {
              if (hasKey(obj, x.split('.'))) return
              setKey(obj, x.split('.'), defaults[key])
            })
          }
        })
      }
    
      function hasKey (obj, keys) {
        var o = obj
    
        if (!configuration['dot-notation']) keys = [keys.join('.')]
    
        keys.slice(0, -1).forEach(function (key) {
          o = (o[key] || {})
        })
    
        var key = keys[keys.length - 1]
    
        if (typeof o !== 'object') return false
        else return key in o
      }
    
      function setKey (obj, keys, value) {
        var o = obj
    
        if (!configuration['dot-notation']) keys = [keys.join('.')]
    
        keys.slice(0, -1).forEach(function (key) {
          if (o[key] === undefined) o[key] = {}
          o = o[key]
        })
    
        var key = keys[keys.length - 1]
    
        if (value === increment) {
          o[key] = increment(o[key])
        } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
          o[key] = Array.isArray(value) ? value : [value]
        } else if (o[key] === undefined || typeof o[key] === 'boolean') {
          o[key] = value
        } else if (Array.isArray(o[key])) {
          o[key].push(value)
        } else {
          o[key] = [ o[key], value ]
        }
      }
    
      // extend the aliases list with inferred aliases.
      function extendAliases () {
        Array.prototype.slice.call(arguments).forEach(function (obj) {
          Object.keys(obj || {}).forEach(function (key) {
            // short-circuit if we've already added a key
            // to the aliases array, for example it might
            // exist in both 'opts.default' and 'opts.key'.
            if (flags.aliases[key]) return
    
            flags.aliases[key] = [].concat(aliases[key] || [])
            // For "--option-name", also set argv.optionName
            flags.aliases[key].concat(key).forEach(function (x) {
              if (/-/.test(x) && configuration['camel-case-expansion']) {
                var c = camelCase(x)
                flags.aliases[key].push(c)
                newAliases[c] = true
              }
            })
            flags.aliases[key].forEach(function (x) {
              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {
                return x !== y
              }))
            })
          })
        })
      }
    
      // check if a flag is set for any of a key's aliases.
      function checkAllAliases (key, flag) {
        var isSet = false
        var toCheck = [].concat(flags.aliases[key] || [], key)
    
        toCheck.forEach(function (key) {
          if (flag[key]) isSet = flag[key]
        })
    
        return isSet
      }
    
      function setDefaulted (key) {
        [].concat(flags.aliases[key] || [], key).forEach(function (k) {
          flags.defaulted[k] = true
        })
      }
    
      function unsetDefaulted (key) {
        [].concat(flags.aliases[key] || [], key).forEach(function (k) {
          delete flags.defaulted[k]
        })
      }
    
      // return a default value, given the type of a flag.,
      // e.g., key of type 'string' will default to '', rather than 'true'.
      function defaultForType (type) {
        var def = {
          boolean: true,
          string: '',
          number: undefined,
          array: []
        }
    
        return def[type]
      }
    
      // given a flag, enforce a default type.
      function guessType (key, flags) {
        var type = 'boolean'
    
        if (flags.strings && flags.strings[key]) type = 'string'
        else if (flags.numbers && flags.numbers[key]) type = 'number'
        else if (flags.arrays && flags.arrays[key]) type = 'array'
    
        return type
      }
    
      function isNumber (x) {
        if (!configuration['parse-numbers']) return false
        if (typeof x === 'number') return true
        if (/^0x[0-9a-f]+$/i.test(x)) return true
        return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
      }
    
      function isUndefined (num) {
        return num === undefined
      }
    
      return {
        argv: argv,
        error: error,
        aliases: flags.aliases,
        newAliases: newAliases,
        configuration: configuration
      }
    }
    
    // if any aliases reference each other, we should
    // merge them together.
    function combineAliases (aliases) {
      var aliasArrays = []
      var change = true
      var combined = {}
    
      // turn alias lookup hash {key: ['alias1', 'alias2']} into
      // a simple array ['key', 'alias1', 'alias2']
      Object.keys(aliases).forEach(function (key) {
        aliasArrays.push(
          [].concat(aliases[key], key)
        )
      })
    
      // combine arrays until zero changes are
      // made in an iteration.
      while (change) {
        change = false
        for (var i = 0; i < aliasArrays.length; i++) {
          for (var ii = i + 1; ii < aliasArrays.length; ii++) {
            var intersect = aliasArrays[i].filter(function (v) {
              return aliasArrays[ii].indexOf(v) !== -1
            })
    
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])
              aliasArrays.splice(ii, 1)
              change = true
              break
            }
          }
        }
      }
    
      // map arrays back to the hash-lookup (de-dupe while
      // we're at it).
      aliasArrays.forEach(function (aliasArray) {
        aliasArray = aliasArray.filter(function (v, i, self) {
          return self.indexOf(v) === i
        })
        combined[aliasArray.pop()] = aliasArray
      })
    
      return combined
    }
    
    function increment (orig) {
      return orig !== undefined ? orig + 1 : 0
    }
    
    function Parser (args, opts) {
      var result = parse(args.slice(), opts)
    
      return result.argv
    }
    
    // parse arguments and return detailed
    // meta information, aliases, etc.
    Parser.detailed = function (args, opts) {
      return parse(args.slice(), opts)
    }
    
    module.exports = Parser
    
  provide("yargs-parser", module.exports);
}(global));

// pakmanager:classnames
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
      Copyright (c) 2016 Jed Watson.
      Licensed under the MIT License (MIT), see
      http://jedwatson.github.io/classnames
    */
    /* global define */
    
    (function () {
    	'use strict';
    
    	var hasOwn = {}.hasOwnProperty;
    
    	function classNames () {
    		var classes = [];
    
    		for (var i = 0; i < arguments.length; i++) {
    			var arg = arguments[i];
    			if (!arg) continue;
    
    			var argType = typeof arg;
    
    			if (argType === 'string' || argType === 'number') {
    				classes.push(arg);
    			} else if (Array.isArray(arg)) {
    				classes.push(classNames.apply(null, arg));
    			} else if (argType === 'object') {
    				for (var key in arg) {
    					if (hasOwn.call(arg, key) && arg[key]) {
    						classes.push(key);
    					}
    				}
    			}
    		}
    
    		return classes.join(' ');
    	}
    
    	if (typeof module !== 'undefined' && module.exports) {
    		module.exports = classNames;
    	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
    		// register as 'classnames', consistent with npm package name
    		define('classnames', [], function () {
    			return classNames;
    		});
    	} else {
    		window.classNames = classNames;
    	}
    }());
    
  provide("classnames", module.exports);
}(global));

// pakmanager:dom-helpers/ownerDocument
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  "use strict";
    
    exports.__esModule = true;
    exports["default"] = ownerDocument;
    
    function ownerDocument(node) {
      return node && node.ownerDocument || document;
    }
    
    module.exports = exports["default"];
  provide("dom-helpers/ownerDocument", module.exports);
}(global));

// pakmanager:dom-helpers/style
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var camelize = require('../util/camelizeStyle'),
        hyphenate = require('../util/hyphenateStyle'),
        _getComputedStyle = require('./getComputedStyle'),
        removeStyle = require('./removeStyle');
    
    var has = Object.prototype.hasOwnProperty;
    
    module.exports = function style(node, property, value) {
      var css = '',
          props = property;
    
      if (typeof property === 'string') {
    
        if (value === undefined) return node.style[camelize(property)] || _getComputedStyle(node).getPropertyValue(hyphenate(property));else (props = {})[property] = value;
      }
    
      for (var key in props) if (has.call(props, key)) {
        !props[key] && props[key] !== 0 ? removeStyle(node, hyphenate(key)) : css += hyphenate(key) + ':' + props[key] + ';';
      }
    
      node.style.cssText += ';' + css;
    };
  provide("dom-helpers/style", module.exports);
}(global));

// pakmanager:dom-helpers/events
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    var on = require('./on'),
        off = require('./off'),
        filter = require('./filter');
    
    module.exports = { on: on, off: off, filter: filter };
  provide("dom-helpers/events", module.exports);
}(global));

// pakmanager:dom-helpers/query
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    module.exports = {
    
      matches: require('./matches'),
    
      height: require('./height'),
    
      width: require('./width'),
    
      offset: require('./offset'),
    
      offsetParent: require('./offsetParent'),
    
      position: require('./position'),
    
      contains: require('./contains'),
    
      scrollParent: require('./scrollParent'),
    
      scrollTop: require('./scrollTop'),
    
      querySelectorAll: require('./querySelectorAll'),
    
      closest: require('./closest')
    };
  provide("dom-helpers/query", module.exports);
}(global));

// pakmanager:dom-helpers/activeElement
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var babelHelpers = require('./util/babelHelpers.js');
    
    exports.__esModule = true;
    
    /**
     * document.activeElement
     */
    exports['default'] = activeElement;
    
    var _ownerDocument =  require('dom-helpers/ownerDocument');
    
    var _ownerDocument2 = babelHelpers.interopRequireDefault(_ownerDocument);
    
    function activeElement() {
      var doc = arguments[0] === undefined ? document : arguments[0];
    
      try {
        return doc.activeElement;
      } catch (e) {}
    }
    
    module.exports = exports['default'];
  provide("dom-helpers/activeElement", module.exports);
}(global));

// pakmanager:dom-helpers/ownerWindow
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var babelHelpers = require('./util/babelHelpers.js');
    
    exports.__esModule = true;
    exports['default'] = ownerWindow;
    
    var _ownerDocument =  require('dom-helpers/ownerDocument');
    
    var _ownerDocument2 = babelHelpers.interopRequireDefault(_ownerDocument);
    
    function ownerWindow(node) {
      var doc = (0, _ownerDocument2['default'])(node);
      return doc && doc.defaultView || doc.parentWindow;
    }
    
    module.exports = exports['default'];
  provide("dom-helpers/ownerWindow", module.exports);
}(global));

// pakmanager:dom-helpers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var babelHelpers = require('./util/babelHelpers.js');
    
    var style =  require('dom-helpers/style'),
        events =  require('dom-helpers/events'),
        query =  require('dom-helpers/query'),
        activeElement =  require('dom-helpers/activeElement'),
        ownerDocument =  require('dom-helpers/ownerDocument'),
        ownerWindow =  require('dom-helpers/ownerWindow');
    
    module.exports = babelHelpers._extends({}, style, events, query, {
    
      activeElement: activeElement,
      ownerDocument: ownerDocument,
      ownerWindow: ownerWindow,
    
      requestAnimationFrame: require('./util/requestAnimationFrame')
    });
  provide("dom-helpers", module.exports);
}(global));

// pakmanager:invariant
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013-2015, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * LICENSE file in the root directory of this source tree. An additional grant
     * of patent rights can be found in the PATENTS file in the same directory.
     */
    
    'use strict';
    
    /**
     * Use invariant() to assert state which your program assumes to be true.
     *
     * Provide sprintf-style format (only %s is supported) and arguments
     * to provide information about what broke and what you were
     * expecting.
     *
     * The invariant message will be stripped in production, but the invariant
     * will remain to ensure logic does not differ in production.
     */
    
    var NODE_ENV = process.env.NODE_ENV;
    
    var invariant = function(condition, format, a, b, c, d, e, f) {
      if (NODE_ENV !== 'production') {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      }
    
      if (!condition) {
        var error;
        if (format === undefined) {
          error = new Error(
            'Minified exception occurred; use the non-minified dev environment ' +
            'for the full error message and additional helpful warnings.'
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() { return args[argIndex++]; })
          );
          error.name = 'Invariant Violation';
        }
    
        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
      }
    };
    
    module.exports = invariant;
    
  provide("invariant", module.exports);
}(global));

// pakmanager:compressible
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * compressible
     * Copyright(c) 2013 Jonathan Ong
     * Copyright(c) 2014 Jeremiah Senkpiel
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var db = require('mime-db')
    
    /**
     * Module variables.
     * @private
     */
    
    var compressibleTypeRegExp = /^text\/|\+json$|\+text$|\+xml$/i
    var extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = compressible
    
    /**
     * Checks if a type is compressible.
     *
     * @param {string} type
     * @return {Boolean} compressible
     * @public
     */
    
    function compressible(type) {
      if (!type || typeof type !== 'string') {
        return false
      }
    
      // strip parameters
      var match = extractTypeRegExp.exec(type)
      var mime = match && match[1].toLowerCase()
      var data = db[mime]
    
      if ((data && data.compressible) || compressibleTypeRegExp.test(mime)) {
        return true
      }
    
      return data
        ? data.compressible
        : undefined
    }
    
  provide("compressible", module.exports);
}(global));

// pakmanager:on-headers
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * on-headers
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Reference to Array slice.
     */
    
    var slice = Array.prototype.slice
    
    /**
     * Execute a listener when a response is about to write headers.
     *
     * @param {Object} res
     * @return {Function} listener
     * @api public
     */
    
    module.exports = function onHeaders(res, listener) {
      if (!res) {
        throw new TypeError('argument res is required')
      }
    
      if (typeof listener !== 'function') {
        throw new TypeError('argument listener must be a function')
      }
    
      res.writeHead = createWriteHead(res.writeHead, listener)
    }
    
    function createWriteHead(prevWriteHead, listener) {
      var fired = false;
    
      // return function with core name and argument list
      return function writeHead(statusCode) {
        // set headers from arguments
        var args = setWriteHeadHeaders.apply(this, arguments);
    
        // fire listener
        if (!fired) {
          fired = true
          listener.call(this)
    
          // pass-along an updated status code
          if (typeof args[0] === 'number' && this.statusCode !== args[0]) {
            args[0] = this.statusCode
            args.length = 1
          }
        }
    
        prevWriteHead.apply(this, args);
      }
    }
    
    function setWriteHeadHeaders(statusCode) {
      var length = arguments.length
      var headerIndex = length > 1 && typeof arguments[1] === 'string'
        ? 2
        : 1
    
      var headers = length >= headerIndex + 1
        ? arguments[headerIndex]
        : undefined
    
      this.statusCode = statusCode
    
      // the following block is from node.js core
      if (Array.isArray(headers)) {
        // handle array case
        for (var i = 0, len = headers.length; i < len; ++i) {
          this.setHeader(headers[i][0], headers[i][1])
        }
      } else if (headers) {
        // handle object case
        var keys = Object.keys(headers)
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i]
          if (k) this.setHeader(k, headers[k])
        }
      }
    
      // copy leading arguments
      var args = new Array(Math.min(length, headerIndex))
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i]
      }
    
      return args
    }
    
  provide("on-headers", module.exports);
}(global));

// pakmanager:vary
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * vary
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module exports.
     */
    
    module.exports = vary;
    module.exports.append = append;
    
    /**
     * RegExp to match field-name in RFC 7230 sec 3.2
     *
     * field-name    = token
     * token         = 1*tchar
     * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
     *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
     *               / DIGIT / ALPHA
     *               ; any VCHAR, except delimiters
     */
    
    var fieldNameRegExp = /^[!#$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+$/
    
    /**
     * Append a field to a vary header.
     *
     * @param {String} header
     * @param {String|Array} field
     * @return {String}
     * @api public
     */
    
    function append(header, field) {
      if (typeof header !== 'string') {
        throw new TypeError('header argument is required');
      }
    
      if (!field) {
        throw new TypeError('field argument is required');
      }
    
      // get fields array
      var fields = !Array.isArray(field)
        ? parse(String(field))
        : field;
    
      // assert on invalid field names
      for (var i = 0; i < fields.length; i++) {
        if (!fieldNameRegExp.test(fields[i])) {
          throw new TypeError('field argument contains an invalid header name');
        }
      }
    
      // existing, unspecified vary
      if (header === '*') {
        return header;
      }
    
      // enumerate current values
      var val = header;
      var vals = parse(header.toLowerCase());
    
      // unspecified vary
      if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
        return '*';
      }
    
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
    
        // append value (case-preserving)
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val
            ? val + ', ' + fields[i]
            : fields[i];
        }
      }
    
      return val;
    }
    
    /**
     * Parse a vary header into an array.
     *
     * @param {String} header
     * @return {Array}
     * @api private
     */
    
    function parse(header) {
      return header.trim().split(/ *, */);
    }
    
    /**
     * Mark that a request is varied on a header field.
     *
     * @param {Object} res
     * @param {String|Array} field
     * @api public
     */
    
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        // quack quack
        throw new TypeError('res argument is required');
      }
    
      // get existing header
      var val = res.getHeader('Vary') || ''
      var header = Array.isArray(val)
        ? val.join(', ')
        : String(val);
    
      // set new header
      if ((val = append(header, field))) {
        res.setHeader('Vary', val);
      }
    }
    
  provide("vary", module.exports);
}(global));

// pakmanager:array-flatten
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict'
    
    /**
     * Expose `arrayFlatten`.
     */
    module.exports = flatten
    module.exports.from = flattenFrom
    module.exports.depth = flattenDepth
    module.exports.fromDepth = flattenFromDepth
    
    /**
     * Flatten an array.
     *
     * @param  {Array} array
     * @return {Array}
     */
    function flatten (array) {
      if (!Array.isArray(array)) {
        throw new TypeError('Expected value to be an array')
      }
    
      return flattenFrom(array)
    }
    
    /**
     * Flatten an array-like structure.
     *
     * @param  {Array} array
     * @return {Array}
     */
    function flattenFrom (array) {
      return flattenDown(array, [], Infinity)
    }
    
    /**
     * Flatten an array-like structure with depth.
     *
     * @param  {Array}  array
     * @param  {number} depth
     * @return {Array}
     */
    function flattenDepth (array, depth) {
      if (!Array.isArray(array)) {
        throw new TypeError('Expected value to be an array')
      }
    
      return flattenFromDepth(array, depth)
    }
    
    /**
     * Flatten an array-like structure with depth.
     *
     * @param  {Array}  array
     * @param  {number} depth
     * @return {Array}
     */
    function flattenFromDepth (array, depth) {
      if (typeof depth !== 'number') {
        throw new TypeError('Expected the depth to be a number')
      }
    
      return flattenDownDepth(array, [], depth)
    }
    
    /**
     * Flatten an array indefinitely.
     *
     * @param  {Array} array
     * @param  {Array} result
     * @return {Array}
     */
    function flattenDown (array, result) {
      for (var i = 0; i < array.length; i++) {
        var value = array[i]
    
        if (Array.isArray(value)) {
          flattenDown(value, result)
        } else {
          result.push(value)
        }
      }
    
      return result
    }
    
    /**
     * Flatten an array with depth.
     *
     * @param  {Array}  array
     * @param  {Array}  result
     * @param  {number} depth
     * @return {Array}
     */
    function flattenDownDepth (array, result, depth) {
      depth--
    
      for (var i = 0; i < array.length; i++) {
        var value = array[i]
    
        if (depth > -1 && Array.isArray(value)) {
          flattenDownDepth(value, result, depth)
        } else {
          result.push(value)
        }
      }
    
      return result
    }
    
  provide("array-flatten", module.exports);
}(global));

// pakmanager:content-disposition
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * content-disposition
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     */
    
    module.exports = contentDisposition
    module.exports.parse = parse
    
    /**
     * Module dependencies.
     */
    
    var basename = require('path').basename
    
    /**
     * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
     */
    
    var encodeUriAttrCharRegExp = /[\x00-\x20"'\(\)*,\/:;<=>?@\[\\\]\{\}\x7f]/g
    
    /**
     * RegExp to match percent encoding escape.
     */
    
    var hexEscapeRegExp = /%[0-9A-Fa-f]{2}/
    var hexEscapeReplaceRegExp = /%([0-9A-Fa-f]{2})/g
    
    /**
     * RegExp to match non-latin1 characters.
     */
    
    var nonLatin1RegExp = /[^\x20-\x7e\xa0-\xff]/g
    
    /**
     * RegExp to match quoted-pair in RFC 2616
     *
     * quoted-pair = "\" CHAR
     * CHAR        = <any US-ASCII character (octets 0 - 127)>
     */
    
    var qescRegExp = /\\([\u0000-\u007f])/g;
    
    /**
     * RegExp to match chars that must be quoted-pair in RFC 2616
     */
    
    var quoteRegExp = /([\\"])/g
    
    /**
     * RegExp for various RFC 2616 grammar
     *
     * parameter     = token "=" ( token | quoted-string )
     * token         = 1*<any CHAR except CTLs or separators>
     * separators    = "(" | ")" | "<" | ">" | "@"
     *               | "," | ";" | ":" | "\" | <">
     *               | "/" | "[" | "]" | "?" | "="
     *               | "{" | "}" | SP | HT
     * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
     * qdtext        = <any TEXT except <">>
     * quoted-pair   = "\" CHAR
     * CHAR          = <any US-ASCII character (octets 0 - 127)>
     * TEXT          = <any OCTET except CTLs, but including LWS>
     * LWS           = [CRLF] 1*( SP | HT )
     * CRLF          = CR LF
     * CR            = <US-ASCII CR, carriage return (13)>
     * LF            = <US-ASCII LF, linefeed (10)>
     * SP            = <US-ASCII SP, space (32)>
     * HT            = <US-ASCII HT, horizontal-tab (9)>
     * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
     * OCTET         = <any 8-bit sequence of data>
     */
    
    var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g
    var textRegExp = /^[\x20-\x7e\x80-\xff]+$/
    var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/
    
    /**
     * RegExp for various RFC 5987 grammar
     *
     * ext-value     = charset  "'" [ language ] "'" value-chars
     * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
     * mime-charset  = 1*mime-charsetc
     * mime-charsetc = ALPHA / DIGIT
     *               / "!" / "#" / "$" / "%" / "&"
     *               / "+" / "-" / "^" / "_" / "`"
     *               / "{" / "}" / "~"
     * language      = ( 2*3ALPHA [ extlang ] )
     *               / 4ALPHA
     *               / 5*8ALPHA
     * extlang       = *3( "-" 3ALPHA )
     * value-chars   = *( pct-encoded / attr-char )
     * pct-encoded   = "%" HEXDIG HEXDIG
     * attr-char     = ALPHA / DIGIT
     *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
     *               / "^" / "_" / "`" / "|" / "~"
     */
    
    var extValueRegExp = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+\-\.^_`|~])+)$/
    
    /**
     * RegExp for various RFC 6266 grammar
     *
     * disposition-type = "inline" | "attachment" | disp-ext-type
     * disp-ext-type    = token
     * disposition-parm = filename-parm | disp-ext-parm
     * filename-parm    = "filename" "=" value
     *                  | "filename*" "=" ext-value
     * disp-ext-parm    = token "=" value
     *                  | ext-token "=" ext-value
     * ext-token        = <the characters in token, followed by "*">
     */
    
    var dispositionTypeRegExp = /^([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *(?:$|;)/
    
    /**
     * Create an attachment Content-Disposition header.
     *
     * @param {string} [filename]
     * @param {object} [options]
     * @param {string} [options.type=attachment]
     * @param {string|boolean} [options.fallback=true]
     * @return {string}
     * @api public
     */
    
    function contentDisposition(filename, options) {
      var opts = options || {}
    
      // get type
      var type = opts.type || 'attachment'
    
      // get parameters
      var params = createparams(filename, opts.fallback)
    
      // format into string
      return format(new ContentDisposition(type, params))
    }
    
    /**
     * Create parameters object from filename and fallback.
     *
     * @param {string} [filename]
     * @param {string|boolean} [fallback=true]
     * @return {object}
     * @api private
     */
    
    function createparams(filename, fallback) {
      if (filename === undefined) {
        return
      }
    
      var params = {}
    
      if (typeof filename !== 'string') {
        throw new TypeError('filename must be a string')
      }
    
      // fallback defaults to true
      if (fallback === undefined) {
        fallback = true
      }
    
      if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
        throw new TypeError('fallback must be a string or boolean')
      }
    
      if (typeof fallback === 'string' && nonLatin1RegExp.test(fallback)) {
        throw new TypeError('fallback must be ISO-8859-1 string')
      }
    
      // restrict to file base name
      var name = basename(filename)
    
      // determine if name is suitable for quoted string
      var isQuotedString = textRegExp.test(name)
    
      // generate fallback name
      var fallbackName = typeof fallback !== 'string'
        ? fallback && getlatin1(name)
        : basename(fallback)
      var hasFallback = typeof fallbackName === 'string' && fallbackName !== name
    
      // set extended filename parameter
      if (hasFallback || !isQuotedString || hexEscapeRegExp.test(name)) {
        params['filename*'] = name
      }
    
      // set filename parameter
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback
          ? fallbackName
          : name
      }
    
      return params
    }
    
    /**
     * Format object to Content-Disposition header.
     *
     * @param {object} obj
     * @param {string} obj.type
     * @param {object} [obj.parameters]
     * @return {string}
     * @api private
     */
    
    function format(obj) {
      var parameters = obj.parameters
      var type = obj.type
    
      if (!type || typeof type !== 'string' || !tokenRegExp.test(type)) {
        throw new TypeError('invalid type')
      }
    
      // start with normalized type
      var string = String(type).toLowerCase()
    
      // append parameters
      if (parameters && typeof parameters === 'object') {
        var param
        var params = Object.keys(parameters).sort()
    
        for (var i = 0; i < params.length; i++) {
          param = params[i]
    
          var val = param.substr(-1) === '*'
            ? ustring(parameters[param])
            : qstring(parameters[param])
    
          string += '; ' + param + '=' + val
        }
      }
    
      return string
    }
    
    /**
     * Decode a RFC 6987 field value (gracefully).
     *
     * @param {string} str
     * @return {string}
     * @api private
     */
    
    function decodefield(str) {
      var match = extValueRegExp.exec(str)
    
      if (!match) {
        throw new TypeError('invalid extended field value')
      }
    
      var charset = match[1].toLowerCase()
      var encoded = match[2]
      var value
    
      // to binary string
      var binary = encoded.replace(hexEscapeReplaceRegExp, pdecode)
    
      switch (charset) {
        case 'iso-8859-1':
          value = getlatin1(binary)
          break
        case 'utf-8':
          value = new Buffer(binary, 'binary').toString('utf8')
          break
        default:
          throw new TypeError('unsupported charset in extended field')
      }
    
      return value
    }
    
    /**
     * Get ISO-8859-1 version of string.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function getlatin1(val) {
      // simple Unicode -> ISO-8859-1 transformation
      return String(val).replace(nonLatin1RegExp, '?')
    }
    
    /**
     * Parse Content-Disposition header string.
     *
     * @param {string} string
     * @return {object}
     * @api private
     */
    
    function parse(string) {
      if (!string || typeof string !== 'string') {
        throw new TypeError('argument string is required')
      }
    
      var match = dispositionTypeRegExp.exec(string)
    
      if (!match) {
        throw new TypeError('invalid type format')
      }
    
      // normalize type
      var index = match[0].length
      var type = match[1].toLowerCase()
    
      var key
      var names = []
      var params = {}
      var value
    
      // calculate index to start at
      index = paramRegExp.lastIndex = match[0].substr(-1) === ';'
        ? index - 1
        : index
    
      // match parameters
      while (match = paramRegExp.exec(string)) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }
    
        index += match[0].length
        key = match[1].toLowerCase()
        value = match[2]
    
        if (names.indexOf(key) !== -1) {
          throw new TypeError('invalid duplicate parameter')
        }
    
        names.push(key)
    
        if (key.indexOf('*') + 1 === key.length) {
          // decode extended value
          key = key.slice(0, -1)
          value = decodefield(value)
    
          // overwrite existing value
          params[key] = value
          continue
        }
    
        if (typeof params[key] === 'string') {
          continue
        }
    
        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(qescRegExp, '$1')
        }
    
        params[key] = value
      }
    
      if (index !== -1 && index !== string.length) {
        throw new TypeError('invalid parameter format')
      }
    
      return new ContentDisposition(type, params)
    }
    
    /**
     * Percent decode a single character.
     *
     * @param {string} str
     * @param {string} hex
     * @return {string}
     * @api private
     */
    
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16))
    }
    
    /**
     * Percent encode a single character.
     *
     * @param {string} char
     * @return {string}
     * @api private
     */
    
    function pencode(char) {
      var hex = String(char)
        .charCodeAt(0)
        .toString(16)
        .toUpperCase()
      return hex.length === 1
        ? '%0' + hex
        : '%' + hex
    }
    
    /**
     * Quote a string for HTTP.
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function qstring(val) {
      var str = String(val)
    
      return '"' + str.replace(quoteRegExp, '\\$1') + '"'
    }
    
    /**
     * Encode a Unicode string for HTTP (RFC 5987).
     *
     * @param {string} val
     * @return {string}
     * @api private
     */
    
    function ustring(val) {
      var str = String(val)
    
      // percent encode as UTF-8
      var encoded = encodeURIComponent(str)
        .replace(encodeUriAttrCharRegExp, pencode)
    
      return 'UTF-8\'\'' + encoded
    }
    
    /**
     * Class for parsed Content-Disposition header for v8 optimization
     */
    
    function ContentDisposition(type, parameters) {
      this.type = type
      this.parameters = parameters
    }
    
  provide("content-disposition", module.exports);
}(global));

// pakmanager:cookie
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * cookie
     * Copyright(c) 2012-2014 Roman Shtylman
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    /**
     * Module exports.
     * @public
     */
    
    exports.parse = parse;
    exports.serialize = serialize;
    
    /**
     * Module variables.
     * @private
     */
    
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    
    /**
     * RegExp to match field-content in RFC 7230 sec 3.2
     *
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     * field-vchar   = VCHAR / obs-text
     * obs-text      = %x80-FF
     */
    
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    
    /**
     * Parse a cookie header.
     *
     * Parse the given cookie header string into an object
     * The object has the various cookies as keys(names) => values
     *
     * @param {string} str
     * @param {object} [options]
     * @return {object}
     * @public
     */
    
    function parse(str, options) {
      if (typeof str !== 'string') {
        throw new TypeError('argument str must be a string');
      }
    
      var obj = {}
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
    
      pairs.forEach(function(pair) {
        var eq_idx = pair.indexOf('=')
    
        // skip things that don't look like key=value
        if (eq_idx < 0) {
          return;
        }
    
        var key = pair.substr(0, eq_idx).trim()
        var val = pair.substr(++eq_idx, pair.length).trim();
    
        // quoted values
        if ('"' == val[0]) {
          val = val.slice(1, -1);
        }
    
        // only assign once
        if (undefined == obj[key]) {
          obj[key] = tryDecode(val, dec);
        }
      });
    
      return obj;
    }
    
    /**
     * Serialize data into a cookie header.
     *
     * Serialize the a name value pair into a cookie string suitable for
     * http headers. An optional options object specified cookie parameters.
     *
     * serialize('foo', 'bar', { httpOnly: true })
     *   => "foo=bar; httpOnly"
     *
     * @param {string} name
     * @param {string} val
     * @param {object} [options]
     * @return {string}
     * @public
     */
    
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
    
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError('argument name is invalid');
      }
    
      var value = enc(val);
    
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError('argument val is invalid');
      }
    
      var pairs = [name + '=' + value];
    
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
        pairs.push('Max-Age=' + Math.floor(maxAge));
      }
    
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError('option domain is invalid');
        }
    
        pairs.push('Domain=' + opt.domain);
      }
    
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError('option path is invalid');
        }
    
        pairs.push('Path=' + opt.path);
      }
    
      if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString());
      if (opt.httpOnly) pairs.push('HttpOnly');
      if (opt.secure) pairs.push('Secure');
      if (opt.firstPartyOnly) pairs.push('First-Party-Only');
    
      return pairs.join('; ');
    }
    
    /**
     * Try decoding a string using a decoding function.
     *
     * @param {string} str
     * @param {function} decode
     * @private
     */
    
    function tryDecode(str, decode) {
      try {
        return decode(str);
      } catch (e) {
        return str;
      }
    }
    
  provide("cookie", module.exports);
}(global));

// pakmanager:cookie-signature
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Module dependencies.
     */
    
    var crypto = require('crypto');
    
    /**
     * Sign the given `val` with `secret`.
     *
     * @param {String} val
     * @param {String} secret
     * @return {String}
     * @api private
     */
    
    exports.sign = function(val, secret){
      if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
      if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
      return val + '.' + crypto
        .createHmac('sha256', secret)
        .update(val)
        .digest('base64')
        .replace(/\=+$/, '');
    };
    
    /**
     * Unsign and decode the given `val` with `secret`,
     * returning `false` if the signature is invalid.
     *
     * @param {String} val
     * @param {String} secret
     * @return {String|Boolean}
     * @api private
     */
    
    exports.unsign = function(val, secret){
      if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
      if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
      var str = val.slice(0, val.lastIndexOf('.'))
        , mac = exports.sign(str, secret);
      
      return sha1(mac) == sha1(val) ? str : false;
    };
    
    /**
     * Private
     */
    
    function sha1(str){
      return crypto.createHash('sha1').update(str).digest('hex');
    }
    
  provide("cookie-signature", module.exports);
}(global));

// pakmanager:merge-descriptors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * merge-descriptors
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = merge
    
    /**
     * Module variables.
     * @private
     */
    
    var hasOwnProperty = Object.prototype.hasOwnProperty
    
    /**
     * Merge the property descriptors of `src` into `dest`
     *
     * @param {object} dest Object to add descriptors to
     * @param {object} src Object to clone descriptors from
     * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
     * @returns {object} Reference to dest
     * @public
     */
    
    function merge(dest, src, redefine) {
      if (!dest) {
        throw new TypeError('argument dest is required')
      }
    
      if (!src) {
        throw new TypeError('argument src is required')
      }
    
      if (redefine === undefined) {
        // Default to true
        redefine = true
      }
    
      Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
        if (!redefine && hasOwnProperty.call(dest, name)) {
          // Skip desriptor
          return
        }
    
        // Copy descriptor
        var descriptor = Object.getOwnPropertyDescriptor(src, name)
        Object.defineProperty(dest, name, descriptor)
      })
    
      return dest
    }
    
  provide("merge-descriptors", module.exports);
}(global));

// pakmanager:methods
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * methods
     * Copyright(c) 2013-2014 TJ Holowaychuk
     * Copyright(c) 2015-2016 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module dependencies.
     * @private
     */
    
    var http = require('http');
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = getCurrentNodeMethods() || getBasicNodeMethods();
    
    /**
     * Get the current Node.js methods.
     * @private
     */
    
    function getCurrentNodeMethods() {
      return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
        return method.toLowerCase();
      });
    }
    
    /**
     * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
     * @private
     */
    
    function getBasicNodeMethods() {
      return [
        'get',
        'post',
        'put',
        'head',
        'delete',
        'options',
        'trace',
        'copy',
        'lock',
        'mkcol',
        'move',
        'purge',
        'propfind',
        'proppatch',
        'unlock',
        'report',
        'mkactivity',
        'checkout',
        'merge',
        'm-search',
        'notify',
        'subscribe',
        'unsubscribe',
        'patch',
        'search',
        'connect'
      ];
    }
    
  provide("methods", module.exports);
}(global));

// pakmanager:path-to-regexp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isarray = require('isarray')
    
    /**
     * Expose `pathToRegexp`.
     */
    module.exports = pathToRegexp
    module.exports.parse = parse
    module.exports.compile = compile
    module.exports.tokensToFunction = tokensToFunction
    module.exports.tokensToRegExp = tokensToRegExp
    
    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
      // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
      // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
      '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
    ].join('|'), 'g')
    
    /**
     * Parse a string for the raw tokens.
     *
     * @param  {String} str
     * @return {Array}
     */
    function parse (str) {
      var tokens = []
      var key = 0
      var index = 0
      var path = ''
      var res
    
      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m = res[0]
        var escaped = res[1]
        var offset = res.index
        path += str.slice(index, offset)
        index = offset + m.length
    
        // Ignore already escaped sequences.
        if (escaped) {
          path += escaped[1]
          continue
        }
    
        // Push the current path onto the tokens.
        if (path) {
          tokens.push(path)
          path = ''
        }
    
        var prefix = res[2]
        var name = res[3]
        var capture = res[4]
        var group = res[5]
        var suffix = res[6]
        var asterisk = res[7]
    
        var repeat = suffix === '+' || suffix === '*'
        var optional = suffix === '?' || suffix === '*'
        var delimiter = prefix || '/'
        var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')
    
        tokens.push({
          name: name || key++,
          prefix: prefix || '',
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: escapeGroup(pattern)
        })
      }
    
      // Match any characters still remaining.
      if (index < str.length) {
        path += str.substr(index)
      }
    
      // If the path exists, push it onto the end.
      if (path) {
        tokens.push(path)
      }
    
      return tokens
    }
    
    /**
     * Compile a string to a template function for the path.
     *
     * @param  {String}   str
     * @return {Function}
     */
    function compile (str) {
      return tokensToFunction(parse(str))
    }
    
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction (tokens) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length)
    
      // Compile all the patterns before compilation.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^' + tokens[i].pattern + '$')
        }
      }
    
      return function (obj) {
        var path = ''
        var data = obj || {}
    
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i]
    
          if (typeof token === 'string') {
            path += token
    
            continue
          }
    
          var value = data[token.name]
          var segment
    
          if (value == null) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to be defined')
            }
          }
    
          if (isarray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
            }
    
            if (value.length === 0) {
              if (token.optional) {
                continue
              } else {
                throw new TypeError('Expected "' + token.name + '" to not be empty')
              }
            }
    
            for (var j = 0; j < value.length; j++) {
              segment = encodeURIComponent(value[j])
    
              if (!matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
              }
    
              path += (j === 0 ? token.prefix : token.delimiter) + segment
            }
    
            continue
          }
    
          segment = encodeURIComponent(value)
    
          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }
    
          path += token.prefix + segment
        }
    
        return path
      }
    }
    
    /**
     * Escape a regular expression string.
     *
     * @param  {String} str
     * @return {String}
     */
    function escapeString (str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
    }
    
    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1')
    }
    
    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys) {
      re.keys = keys
      return re
    }
    
    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i'
    }
    
    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g)
    
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          })
        }
      }
    
      return attachKeys(path, keys)
    }
    
    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options) {
      var parts = []
    
      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source)
      }
    
      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
    
      return attachKeys(regexp, keys)
    }
    
    /**
     * Create a path regexp from string input.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function stringToRegexp (path, keys, options) {
      var tokens = parse(path)
      var re = tokensToRegExp(tokens, options)
    
      // Attach keys back to the regexp.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] !== 'string') {
          keys.push(tokens[i])
        }
      }
    
      return attachKeys(re, keys)
    }
    
    /**
     * Expose a function for taking tokens and returning a RegExp.
     *
     * @param  {Array}  tokens
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function tokensToRegExp (tokens, options) {
      options = options || {}
    
      var strict = options.strict
      var end = options.end !== false
      var route = ''
      var lastToken = tokens[tokens.length - 1]
      var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken)
    
      // Iterate over the tokens and create our regexp string.
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i]
    
        if (typeof token === 'string') {
          route += escapeString(token)
        } else {
          var prefix = escapeString(token.prefix)
          var capture = token.pattern
    
          if (token.repeat) {
            capture += '(?:' + prefix + capture + ')*'
          }
    
          if (token.optional) {
            if (prefix) {
              capture = '(?:' + prefix + '(' + capture + '))?'
            } else {
              capture = '(' + capture + ')?'
            }
          } else {
            capture = prefix + '(' + capture + ')'
          }
    
          route += capture
        }
      }
    
      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?'
      }
    
      if (end) {
        route += '$'
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)'
      }
    
      return new RegExp('^' + route, flags(options))
    }
    
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options) {
      keys = keys || []
    
      if (!isarray(keys)) {
        options = keys
        keys = []
      } else if (!options) {
        options = {}
      }
    
      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options)
      }
    
      if (isarray(path)) {
        return arrayToRegexp(path, keys, options)
      }
    
      return stringToRegexp(path, keys, options)
    }
    
  provide("path-to-regexp", module.exports);
}(global));

// pakmanager:proxy-addr
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * proxy-addr
     * Copyright(c) 2014 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module exports.
     */
    
    module.exports = proxyaddr;
    module.exports.all = alladdrs;
    module.exports.compile = compile;
    
    /**
     * Module dependencies.
     */
    
    var forwarded = require('forwarded');
    var ipaddr = require('ipaddr.js');
    
    /**
     * Variables.
     */
    
    var digitre = /^[0-9]+$/;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    
    /**
     * Pre-defined IP ranges.
     */
    
    var ipranges = {
      linklocal: ['169.254.0.0/16', 'fe80::/10'],
      loopback: ['127.0.0.1/8', '::1/128'],
      uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']
    };
    
    /**
     * Get all addresses in the request, optionally stopping
     * at the first untrusted.
     *
     * @param {Object} request
     * @param {Function|Array|String} [trust]
     * @api public
     */
    
    function alladdrs(req, trust) {
      // get addresses
      var addrs = forwarded(req);
    
      if (!trust) {
        // Return all addresses
        return addrs;
      }
    
      if (typeof trust !== 'function') {
        trust = compile(trust);
      }
    
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i)) continue;
    
        addrs.length = i + 1;
      }
    
      return addrs;
    }
    
    /**
     * Compile argument into trust function.
     *
     * @param {Array|String} val
     * @api private
     */
    
    function compile(val) {
      if (!val) {
        throw new TypeError('argument is required');
      }
    
      var trust = typeof val === 'string'
        ? [val]
        : val;
    
      if (!Array.isArray(trust)) {
        throw new TypeError('unsupported trust argument');
      }
    
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
    
        if (!ipranges.hasOwnProperty(val)) {
          continue;
        }
    
        // Splice in pre-defined range
        val = ipranges[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
    
      return compileTrust(compileRangeSubnets(trust));
    }
    
    /**
     * Compile `arr` elements into range subnets.
     *
     * @param {Array} arr
     * @api private
     */
    
    function compileRangeSubnets(arr) {
      var rangeSubnets = new Array(arr.length);
    
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
    
      return rangeSubnets;
    }
    
    /**
     * Compile range subnet array into trust function.
     *
     * @param {Array} rangeSubnets
     * @api private
     */
    
    function compileTrust(rangeSubnets) {
      // Return optimized function based on length
      var len = rangeSubnets.length;
      return len === 0
        ? trustNone
        : len === 1
        ? trustSingle(rangeSubnets[0])
        : trustMulti(rangeSubnets);
    }
    
    /**
     * Parse IP notation string into range subnet.
     *
     * @param {String} note
     * @api private
     */
    
    function parseipNotation(note) {
      var ip;
      var kind;
      var max;
      var pos = note.lastIndexOf('/');
      var range;
    
      ip = pos !== -1
        ? note.substring(0, pos)
        : note;
    
      if (!isip(ip)) {
        throw new TypeError('invalid IP address: ' + ip);
      }
    
      ip = parseip(ip);
    
      kind = ip.kind();
      max = kind === 'ipv6'
        ? 128
        : 32;
    
      range = pos !== -1
        ? note.substring(pos + 1, note.length)
        : max;
    
      if (typeof range !== 'number') {
        range = digitre.test(range)
          ? parseInt(range, 10)
          : isip(range)
          ? parseNetmask(range)
          : 0;
      }
    
      if (ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
        // Store as IPv4
        ip = ip.toIPv4Address();
        range = range <= max
          ? range - 96
          : range;
      }
    
      if (range <= 0 || range > max) {
        throw new TypeError('invalid range on address: ' + note);
      }
    
      return [ip, range];
    }
    
    /**
     * Parse netmask string into CIDR range.
     *
     * @param {String} note
     * @api private
     */
    
    function parseNetmask(netmask) {
      var ip = parseip(netmask);
      var parts;
      var size;
    
      switch (ip.kind()) {
        case 'ipv4':
          parts = ip.octets;
          size = 8;
          break;
        case 'ipv6':
          parts = ip.parts;
          size = 16;
          break;
      }
    
      var max = Math.pow(2, size) - 1;
      var part;
      var range = 0;
    
      for (var i = 0; i < parts.length; i++) {
        part = parts[i] & max;
    
        if (part === max) {
          range += size;
          continue;
        }
    
        while (part) {
          part = (part << 1) & max;
          range += 1;
        }
    
        break;
      }
    
      return range;
    }
    
    /**
     * Determine address of proxied request.
     *
     * @param {Object} request
     * @param {Function|Array|String} trust
     * @api public
     */
    
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError('req argument is required');
      }
    
      if (!trust) {
        throw new TypeError('trust argument is required');
      }
    
      var addrs = alladdrs(req, trust);
      var addr = addrs[addrs.length - 1];
    
      return addr;
    }
    
    /**
     * Static trust function to trust nothing.
     *
     * @api private
     */
    
    function trustNone() {
      return false;
    }
    
    /**
     * Compile trust function for multiple subnets.
     *
     * @param {Array} subnets
     * @api private
     */
    
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr)) return false;
    
        var ip = parseip(addr);
        var ipv4;
        var kind = ip.kind();
        var subnet;
        var subnetip;
        var subnetkind;
        var subnetrange;
        var trusted;
    
        for (var i = 0; i < subnets.length; i++) {
          subnet = subnets[i];
          subnetip = subnet[0];
          subnetkind = subnetip.kind();
          subnetrange = subnet[1];
          trusted = ip;
    
          if (kind !== subnetkind) {
            if (kind !== 'ipv6' || subnetkind !== 'ipv4' || !ip.isIPv4MappedAddress()) {
              continue;
            }
    
            // Store addr as IPv4
            ipv4 = ipv4 || ip.toIPv4Address();
            trusted = ipv4;
          }
    
          if (trusted.match(subnetip, subnetrange)) return true;
        }
    
        return false;
      };
    }
    
    /**
     * Compile trust function for single subnet.
     *
     * @param {Object} subnet
     * @api private
     */
    
    function trustSingle(subnet) {
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetisipv4 = subnetkind === 'ipv4';
      var subnetrange = subnet[1];
    
      return function trust(addr) {
        if (!isip(addr)) return false;
    
        var ip = parseip(addr);
        var kind = ip.kind();
    
        return kind === subnetkind
          ? ip.match(subnetip, subnetrange)
          : subnetisipv4 && kind === 'ipv6' && ip.isIPv4MappedAddress()
          ? ip.toIPv4Address().match(subnetip, subnetrange)
          : false;
      };
    }
    
  provide("proxy-addr", module.exports);
}(global));

// pakmanager:serve-static
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * serve-static
     * Copyright(c) 2010 Sencha Inc.
     * Copyright(c) 2011 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var escapeHtml = require('escape-html')
    var parseUrl = require('parseurl')
    var resolve = require('path').resolve
    var send = require('send')
    var url = require('url')
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = serveStatic
    module.exports.mime = send.mime
    
    /**
     * @param {string} root
     * @param {object} [options]
     * @return {function}
     * @public
     */
    
    function serveStatic(root, options) {
      if (!root) {
        throw new TypeError('root path required')
      }
    
      if (typeof root !== 'string') {
        throw new TypeError('root path must be a string')
      }
    
      // copy options object
      var opts = Object.create(options || null)
    
      // fall-though
      var fallthrough = opts.fallthrough !== false
    
      // default redirect
      var redirect = opts.redirect !== false
    
      // headers listener
      var setHeaders = opts.setHeaders
    
      if (setHeaders && typeof setHeaders !== 'function') {
        throw new TypeError('option setHeaders must be function')
      }
    
      // setup options for send
      opts.maxage = opts.maxage || opts.maxAge || 0
      opts.root = resolve(root)
    
      // construct directory listener
      var onDirectory = redirect
        ? createRedirectDirectoryListener()
        : createNotFoundDirectoryListener()
    
      return function serveStatic(req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
          if (fallthrough) {
            return next()
          }
    
          // method not allowed
          res.statusCode = 405
          res.setHeader('Allow', 'GET, HEAD')
          res.setHeader('Content-Length', '0')
          res.end()
          return
        }
    
        var forwardError = !fallthrough
        var originalUrl = parseUrl.original(req)
        var path = parseUrl(req).pathname
    
        // make sure redirect occurs at mount
        if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {
          path = ''
        }
    
        // create send stream
        var stream = send(req, path, opts)
    
        // add directory handler
        stream.on('directory', onDirectory)
    
        // add headers listener
        if (setHeaders) {
          stream.on('headers', setHeaders)
        }
    
        // add file listener for fallthrough
        if (fallthrough) {
          stream.on('file', function onFile() {
            // once file is determined, always forward error
            forwardError = true
          })
        }
    
        // forward errors
        stream.on('error', function error(err) {
          if (forwardError || !(err.statusCode < 500)) {
            next(err)
            return
          }
    
          next()
        })
    
        // pipe
        stream.pipe(res)
      }
    }
    
    /**
     * Collapse all leading slashes into a single slash
     * @private
     */
    function collapseLeadingSlashes(str) {
      for (var i = 0; i < str.length; i++) {
        if (str[i] !== '/') {
          break
        }
      }
    
      return i > 1
        ? '/' + str.substr(i)
        : str
    }
    
    /**
     * Create a directory listener that just 404s.
     * @private
     */
    
    function createNotFoundDirectoryListener() {
      return function notFound() {
        this.error(404)
      }
    }
    
    /**
     * Create a directory listener that performs a redirect.
     * @private
     */
    
    function createRedirectDirectoryListener() {
      return function redirect() {
        if (this.hasTrailingSlash()) {
          this.error(404)
          return
        }
    
        // get original URL
        var originalUrl = parseUrl.original(this.req)
    
        // append trailing slash
        originalUrl.path = null
        originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')
    
        // reformat the URL
        var loc = url.format(originalUrl)
        var msg = 'Redirecting to <a href="' + escapeHtml(loc) + '">' + escapeHtml(loc) + '</a>\n'
        var res = this.res
    
        // send redirect response
        res.statusCode = 303
        res.setHeader('Content-Type', 'text/html; charset=UTF-8')
        res.setHeader('Content-Length', Buffer.byteLength(msg))
        res.setHeader('X-Content-Type-Options', 'nosniff')
        res.setHeader('Location', loc)
        res.end(msg)
      }
    }
    
  provide("serve-static", module.exports);
}(global));

// pakmanager:dont-sniff-mimetype
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function nosniff () {
      return function nosniff (req, res, next) {
        res.setHeader('X-Content-Type-Options', 'nosniff')
        next()
      }
    }
    
  provide("dont-sniff-mimetype", module.exports);
}(global));

// pakmanager:frameguard
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var isString = require('lodash.isstring')
    
    function isObject (value) {
      return !!value && typeof value === 'object'
    }
    
    module.exports = function frameguard (action, domain) {
      var directive
    
      // This converts String objects.
      if (isString(action)) {
        action = action.valueOf()
      }
    
      if (isObject(action)) {
        domain = action.domain
        action = action.action
      }
    
      if (action === undefined) {
        directive = 'SAMEORIGIN'
      } else if (isString(action)) {
        directive = action.toUpperCase()
      }
    
      if (directive === 'ALLOWFROM') {
        directive = 'ALLOW-FROM'
      } else if (directive === 'SAME-ORIGIN') {
        directive = 'SAMEORIGIN'
      }
    
      if (['DENY', 'ALLOW-FROM', 'SAMEORIGIN'].indexOf(directive) === -1) {
        throw new Error('X-Frame must be undefined, "DENY", "ALLOW-FROM", or "SAMEORIGIN"')
      }
    
      if (directive === 'ALLOW-FROM') {
        if (!isString(domain)) {
          throw new Error('X-Frame: ALLOW-FROM requires a second parameter')
        }
        directive = 'ALLOW-FROM ' + domain
      }
    
      return function frameguard (req, res, next) {
        res.setHeader('X-Frame-Options', directive)
        next()
      }
    }
    
  provide("frameguard", module.exports);
}(global));

// pakmanager:helmet-crossdomain
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var parse = require('url').parse;
    
    var data = '<?xml version="1.0"?>' +
      '<!DOCTYPE cross-domain-policy SYSTEM "http://www.adobe.com/xml/dtds/cross-domain-policy.dtd">' +
      '<cross-domain-policy>' +
      '<site-control permitted-cross-domain-policies="none"/>' +
      '</cross-domain-policy>';
    
    module.exports = function crossdomain(options) {
    
      options = options || {};
      var caseSensitive = options.caseSensitive;
    
      return function crossdomain(req, res, next) {
    
        var pathname = parse(req.url).pathname;
    
        var uri;
        if (caseSensitive) {
          uri = pathname;
        } else {
          uri = pathname.toLowerCase();
        }
    
        if ('/crossdomain.xml' === uri) {
          res.writeHead(200, {
            'Content-Type': 'text/x-cross-domain-policy'
          });
          res.end(data);
        } else {
          next();
        }
    
      };
    
    };
    
  provide("helmet-crossdomain", module.exports);
}(global));

// pakmanager:helmet-csp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var camelize = require('camelize')
    var cspBuilder = require('content-security-policy-builder')
    var platform = require('platform')
    var containsFunction = require('./lib/contains-function')
    var getHeaderKeysForBrowser = require('./lib/get-header-keys-for-browser')
    var transformDirectivesForBrowser = require('./lib/transform-directives-for-browser')
    var parseDynamicDirectives = require('./lib/parse-dynamic-directives')
    var ALL_HEADERS = require('./lib/all-headers')
    
    module.exports = function csp (options) {
      options = options || {}
    
      var originalDirectives = camelize(options.directives || {})
      var directivesAreDynamic = containsFunction(originalDirectives)
      var shouldBrowserSniff = options.browserSniff !== false
    
      if (options.reportOnly && !originalDirectives.reportUri) {
        throw new Error('Please remove reportOnly or add a report-uri.')
      }
    
      if (shouldBrowserSniff) {
        return function csp (req, res, next) {
          var userAgent = req.headers['user-agent']
    
          var browser
          if (userAgent) {
            browser = platform.parse(userAgent)
          } else {
            browser = {}
          }
    
          var headerKeys
          if (options.setAllHeaders || !userAgent) {
            headerKeys = ALL_HEADERS
          } else {
            headerKeys = getHeaderKeysForBrowser(browser, options)
          }
    
          if (headerKeys.length === 0) {
            next()
            return
          }
    
          var directives = transformDirectivesForBrowser(browser, originalDirectives)
    
          if (directivesAreDynamic) {
            directives = parseDynamicDirectives(directives, [req, res])
          }
    
          var policyString = cspBuilder({ directives: directives })
    
          headerKeys.forEach(function (headerKey) {
            if (options.reportOnly) {
              headerKey += '-Report-Only'
            }
            res.setHeader(headerKey, policyString)
          })
    
          next()
        }
      } else {
        var headerKeys
        if (options.setAllHeaders) {
          headerKeys = ALL_HEADERS
        } else {
          headerKeys = ['Content-Security-Policy']
        }
    
        if (options.reportOnly) {
          headerKeys = headerKeys.map(function (headerKey) {
            return headerKey + '-Report-Only'
          })
        }
    
        return function csp (req, res, next) {
          var directives = parseDynamicDirectives(originalDirectives, [req, res])
          var policyString = cspBuilder({ directives: directives })
    
          headerKeys.forEach(function (headerKey) {
            res.setHeader(headerKey, policyString)
          })
          next()
        }
      }
    }
    
  provide("helmet-csp", module.exports);
}(global));

// pakmanager:hide-powered-by
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function hidePoweredBy (options) {
      var setTo = (options || {}).setTo
    
      if (setTo) {
        return function hidePoweredBy (req, res, next) {
          res.setHeader('X-Powered-By', setTo)
          next()
        }
      } else {
        return function hidePoweredBy (req, res, next) {
          res.removeHeader('X-Powered-By')
          next()
        }
      }
    }
    
  provide("hide-powered-by", module.exports);
}(global));

// pakmanager:hpkp
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var badArgumentsError = new Error('hpkp must be called with a maxAge and at least two SHA-256s (one actually used and another kept as a backup).')
    
    module.exports = function hpkp (passedOptions) {
      var options = parseOptions(passedOptions)
      var headerKey = getHeaderKey(options)
      var headerValue = getHeaderValue(options)
    
      return function hpkp (req, res, next) {
        var setHeader = true
        var setIf = options.setIf
    
        if (setIf) {
          setHeader = setIf(req, res)
        }
    
        if (setHeader) {
          res.setHeader(headerKey, headerValue)
        }
    
        next()
      }
    }
    
    function parseOptions (options) {
      if (!options) { throw badArgumentsError }
    
      if (options.maxage && options.maxAge) { throw badArgumentsError }
    
      var maxAge = options.maxAge
      var sha256s = options.sha256s
      var setIf = options.setIf
    
      if (!maxAge || maxAge <= 0) { throw badArgumentsError }
      if (!sha256s || sha256s.length < 2) { throw badArgumentsError }
      if (setIf && (typeof setIf !== 'function')) {
        throw new TypeError('setIf must be a function.')
      }
    
      if (options.reportOnly && !options.reportUri) { throw badArgumentsError }
    
      return {
        maxAge: maxAge,
        sha256s: sha256s,
        includeSubdomains: options.includeSubdomains,
        reportUri: options.reportUri,
        reportOnly: options.reportOnly,
        setIf: setIf
      }
    }
    
    function getHeaderKey (options) {
      var header = 'Public-Key-Pins'
      if (options.reportOnly) {
        header += '-Report-Only'
      }
      return header
    }
    
    function getHeaderValue (options) {
      var result = options.sha256s.map(function (sha) {
        return 'pin-sha256="' + sha + '"'
      })
      result.push('max-age=' + Math.round(options.maxAge / 1000))
      if (options.includeSubdomains) {
        result.push('includeSubdomains')
      }
      if (options.reportUri) {
        result.push('report-uri="' + options.reportUri + '"')
      }
      return result.join('; ')
    }
    
  provide("hpkp", module.exports);
}(global));

// pakmanager:hsts
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var util = require('core-util-is')
    
    var oneDay = 86400000
    
    module.exports = function hsts (options) {
      options = options || {}
    
      var maxAgeMS = options.maxAge != null ? options.maxAge : oneDay
      var force = options.force
      var setIf = options.setIf
    
      if (options.maxage != null) {
        throw new Error('Did you mean to pass "maxAge" instead of "maxage"?')
      }
      if (!util.isObject(options)) {
        throw new Error('HSTS must be passed an object or undefined.')
      }
      if (arguments.length > 1) {
        throw new Error('HSTS passed the wrong number of arguments.')
      }
    
      if (!util.isNumber(maxAgeMS)) {
        throw new TypeError('HSTS must be passed a numeric maxAge parameter.')
      }
      if (maxAgeMS < 0) {
        throw new RangeError('HSTS maxAge must be nonnegative.')
      }
      if (setIf && !util.isFunction(setIf)) {
        throw new TypeError('setIf must be a function.')
      }
      if (setIf && force) {
        throw new Error('setIf and force cannot both be specified.')
      }
    
      var maxAge = Math.round(maxAgeMS / 1000)
      var header = 'max-age=' + maxAge
      if (options.includeSubDomains || options.includeSubdomains) {
        header += '; includeSubDomains'
      }
      if (options.preload) {
        header += '; preload'
      }
    
      return function hsts (req, res, next) {
        var setHeader
        if (setIf) {
          setHeader = setIf(req, res)
        } else {
          setHeader = force || req.secure
        }
    
        if (setHeader) {
          res.setHeader('Strict-Transport-Security', header)
        }
    
        next()
      }
    }
    
  provide("hsts", module.exports);
}(global));

// pakmanager:ienoopen
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function ienoopen () {
      return function ienoopen (req, res, next) {
        res.setHeader('X-Download-Options', 'noopen')
        next()
      }
    }
    
  provide("ienoopen", module.exports);
}(global));

// pakmanager:nocache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function nocache (options) {
      var noEtag = (options || {}).noEtag
    
      return function nocache (req, res, next) {
        res.setHeader('Surrogate-Control', 'no-store')
        res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate')
        res.setHeader('Pragma', 'no-cache')
        res.setHeader('Expires', '0')
        if (noEtag) {
          res.removeHeader('ETag')
        }
        next()
      }
    }
    
  provide("nocache", module.exports);
}(global));

// pakmanager:x-xss-protection
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = function xXssProtection (options) {
      if (options && options.setOnOldIE) {
        return function xXssProtection (req, res, next) {
          res.setHeader('X-XSS-Protection', '1; mode=block')
          next()
        }
      } else {
        return function xXssProtection (req, res, next) {
          var matches = /msie\s*(\d+)/i.exec(req.headers['user-agent'])
    
          var value
          if (!matches || (parseFloat(matches[1]) >= 9)) {
            value = '1; mode=block'
          } else {
            value = '0'
          }
    
          res.setHeader('X-XSS-Protection', value)
          next()
        }
      }
    }
    
  provide("x-xss-protection", module.exports);
}(global));

// pakmanager:lodash.flowright
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 3.2.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modern modularize exports="npm" -o ./`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    
    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return function() {
        var length = arguments.length,
            index = fromRight ? length : -1,
            leftIndex = 0,
            funcs = Array(length);
    
        while ((fromRight ? index-- : ++index < length)) {
          var func = funcs[leftIndex++] = arguments[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
        }
        return function() {
          var index = 0,
              result = length ? funcs[index].apply(this, arguments) : arguments[0];
    
          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      };
    }
    
    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, _.add);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);
    
    module.exports = flowRight;
    
  provide("lodash.flowright", module.exports);
}(global));

// pakmanager:lodash.merge
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.3.2 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var Stack = require('lodash._stack'),
        baseClone = require('lodash._baseclone'),
        isPlainObject = require('lodash.isplainobject'),
        keysIn = require('lodash.keysin'),
        rest = require('lodash.rest');
    
    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    
    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    
    var arrayBufferTag = '[object ArrayBuffer]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dateTag] = typedArrayTags[errorTag] =
    typedArrayTags[funcTag] = typedArrayTags[mapTag] =
    typedArrayTags[numberTag] = typedArrayTags[objectTag] =
    typedArrayTags[regexpTag] = typedArrayTags[setTag] =
    typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;
    
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }
    
    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    
    /**
     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;
    
    /** Built-in value references. */
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    
    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (typeof key == 'number' && value === undefined && !(key in object))) {
        object[key] = value;
      }
    }
    
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        object[key] = value;
      }
    }
    
    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      var props = (isArray(source) || isTypedArray(source))
        ? undefined
        : keysIn(source);
    
      arrayEach(props || source, function(srcValue, key) {
        if (props) {
          key = srcValue;
          srcValue = source[key];
        }
        if (isObject(srcValue)) {
          stack || (stack = new Stack);
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
            : undefined;
    
          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      });
    }
    
    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = object[key],
          srcValue = source[key],
          stacked = stack.get(srcValue);
    
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;
    
      var isCommon = newValue === undefined;
    
      if (isCommon) {
        newValue = srcValue;
        if (isArray(srcValue) || isTypedArray(srcValue)) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else {
            isCommon = false;
            newValue = baseClone(srcValue, !customizer);
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
            isCommon = false;
            newValue = baseClone(srcValue, !customizer);
          }
          else {
            newValue = objValue;
          }
        }
        else {
          isCommon = false;
        }
      }
      stack.set(srcValue, newValue);
    
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      }
      stack['delete'](srcValue);
      assignMergeValue(object, key, newValue);
    }
    
    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }
    
    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
    
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    
    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object) {
      return copyObjectWith(source, props, object);
    }
    
    /**
     * This function is like `copyObject` except that it accepts a function to
     * customize copied values.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property names to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObjectWith(source, props, object, customizer) {
      object || (object = {});
    
      var index = -1,
          length = props.length;
    
      while (++index < length) {
        var key = props[index];
    
        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : source[key];
    
        assignValue(object, key, newValue);
      }
      return object;
    }
    
    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return rest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;
    
        customizer = typeof customizer == 'function'
          ? (length--, customizer)
          : undefined;
    
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    
    /**
     * Gets the "length" property value of `object`.
     *
     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
     * that affects Safari on at least iOS 8.1-8.3 ARM64.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {*} Returns the "length" value.
     */
    var getLength = baseProperty('length');
    
    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)) {
        return eq(object[index], value);
      }
      return false;
    }
    
    /**
     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }
    
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }
    
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @type {Function}
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;
    
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(getLength(value)) && !isFunction(value);
    }
    
    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8 which returns 'object' for typed array and weak map constructors,
      // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }
    
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }
    
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    
    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    
    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable properties of source objects into the destination
     * object. Source properties that resolve to `undefined` are skipped if a
     * destination value exists. Array and plain object properties are merged
     * recursively.Other objects and value types are overridden by assignment.
     * Source objects are applied from left to right. Subsequent sources
     * overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    
    module.exports = merge;
    
  provide("lodash.merge", module.exports);
}(global));

// pakmanager:lodash.throttle
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * lodash 4.0.1 (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    var debounce = require('lodash.debounce');
    
    /** Used as the `TypeError` message for "Functions" methods. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    
    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide an options object to indicate whether
     * `func` should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;
    
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }
    
    /**
     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }
    
    module.exports = throttle;
    
  provide("lodash.throttle", module.exports);
}(global));

// pakmanager:react-addons-create-fragment
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('react/lib/ReactFragment').create;
  provide("react-addons-create-fragment", module.exports);
}(global));

// pakmanager:react-addons-pure-render-mixin
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('react/lib/ReactComponentWithPureRenderMixin');
  provide("react-addons-pure-render-mixin", module.exports);
}(global));

// pakmanager:react-addons-transition-group
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('react/lib/ReactTransitionGroup');
  provide("react-addons-transition-group", module.exports);
}(global));

// pakmanager:react-addons-update
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('react/lib/update');
  provide("react-addons-update", module.exports);
}(global));

// pakmanager:browserify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var mdeps = require('module-deps');
    var depsSort = require('deps-sort');
    var bpack = require('browser-pack');
    var insertGlobals = require('insert-module-globals');
    var syntaxError = require('syntax-error');
    
    var builtins = require('./lib/builtins.js');
    
    var splicer = require('labeled-stream-splicer');
    var through = require('through2');
    var concat = require('concat-stream');
    
    var inherits = require('inherits');
    var EventEmitter = require('events').EventEmitter;
    var xtend = require('xtend');
    var isarray = require('isarray');
    var defined = require('defined');
    var has = require('has');
    var sanitize = require('htmlescape').sanitize;
    var shasum = require('shasum');
    
    var bresolve = require('browser-resolve');
    var resolve = require('resolve');
    
    var readonly = require('read-only-stream');
    
    module.exports = Browserify;
    inherits(Browserify, EventEmitter);
    
    var fs = require('fs');
    var path = require('path');
    var paths = {
        empty: path.join(__dirname, 'lib/_empty.js')
    };
    
    function Browserify (files, opts) {
        var self = this;
        if (!(this instanceof Browserify)) return new Browserify(files, opts);
        if (!opts) opts = {};
        
        if (typeof files === 'string' || isarray(files) || isStream(files)) {
            opts = xtend(opts, { entries: [].concat(opts.entries || [], files) });
        }
        else opts = xtend(files, opts);
        
        self._options = opts;
        if (opts.noparse) opts.noParse = opts.noparse;
        
        if (opts.basedir !== undefined && typeof opts.basedir !== 'string') {
            throw new Error('opts.basedir must be either undefined or a string.');
        }
        
        self._external = [];
        self._exclude = [];
        self._ignore = [];
        self._expose = {};
        self._hashes = {};
        self._pending = 0;
        self._transformOrder = 0;
        self._transformPending = 0;
        self._transforms = [];
        self._entryOrder = 0;
        self._ticked = false;
        self._bresolve = opts.browserField === false
            ? function (id, opts, cb) {
                if (!opts.basedir) opts.basedir = path.dirname(opts.filename)
                resolve(id, opts, cb)
            }
            : bresolve
        ;
        self._syntaxCache = {};
    
        var ignoreTransform = [].concat(opts.ignoreTransform).filter(Boolean);
        self._filterTransform = function (tr) {
            if (Array.isArray(tr)) {
                return ignoreTransform.indexOf(tr[0]) === -1;
            }
            return ignoreTransform.indexOf(tr) === -1;
        };
    
        self.pipeline = self._createPipeline(opts);
        
        [].concat(opts.transform).filter(Boolean).filter(self._filterTransform)
        .forEach(function (tr) {
            self.transform(tr);
        });
        
        [].concat(opts.entries).filter(Boolean).forEach(function (file) {
            self.add(file, { basedir: opts.basedir });
        });
        
        [].concat(opts.require).filter(Boolean).forEach(function (file) {
            self.require(file, { basedir: opts.basedir });
        });
        
        [].concat(opts.plugin).filter(Boolean).forEach(function (p) {
            self.plugin(p, { basedir: opts.basedir });
        });
    }
    
    Browserify.prototype.require = function (file, opts) {
        var self = this;
        if (isarray(file)) {
            file.forEach(function (x) {
                if (typeof x === 'object') {
                    self.require(x.file, xtend(opts, x));
                }
                else self.require(x, opts);
            });
            return this;
        }
        
        if (!opts) opts = {};
        var basedir = defined(opts.basedir, self._options.basedir, process.cwd());
        var expose = opts.expose;
        if (file === expose && /^[\.]/.test(expose)) {
            expose = '/' + path.relative(basedir, expose);
            expose = expose.replace(/\\/g, '/');
        }
        if (expose === undefined && this._options.exposeAll) {
            expose = true;
        }
        if (expose === true) {
            expose = '/' + path.relative(basedir, file);
            expose = expose.replace(/\\/g, '/');
        }
        
        if (isStream(file)) {
            self._pending ++;
            var order = self._entryOrder ++;
            file.pipe(concat(function (buf) {
                var filename = opts.file || file.file || path.join(
                    basedir,
                    '_stream_' + order + '.js'
                );
                var id = file.id || expose || filename;
                if (expose || opts.entry === false) {
                    self._expose[id] = filename;
                }
                if (!opts.entry && self._options.exports === undefined) {
                    self._bpack.hasExports = true;
                }
                var rec = {
                    source: buf.toString('utf8'),
                    entry: defined(opts.entry, false),
                    file: filename,
                    id: id
                };
                if (rec.entry) rec.order = order;
                if (rec.transform === false) rec.transform = false;
                self.pipeline.write(rec);
                
                if (-- self._pending === 0) self.emit('_ready');
            }));
            return this;
        }
        
        var row;
        if (typeof file === 'object') {
            row = xtend(file, opts);
        }
        else if (!opts.entry && isExternalModule(file)) {
            // external module or builtin
            row = xtend(opts, { id: expose || file, file: file });
        }
        else {
            row = xtend(opts, { file: path.resolve(basedir, file) });
        }
        
        if (!row.id) {
            row.id = expose || row.file;
        }
        if (expose || !row.entry) {
            // Make this available to mdeps so that it can assign the value when it
            // resolves the pathname.
            row.expose = row.id;
        }
        
        if (opts.external) return self.external(file, opts);
        if (row.entry === undefined) row.entry = false;
        
        if (!row.entry && self._options.exports === undefined) {
            self._bpack.hasExports = true;
        }
        
        if (row.entry) row.order = self._entryOrder ++;
        
        if (opts.transform === false) row.transform = false;
        self.pipeline.write(row);
        return self;
    };
    
    Browserify.prototype.add = function (file, opts) {
        var self = this;
        if (!opts) opts = {};
        if (isarray(file)) {
            file.forEach(function (x) { self.add(x, opts) });
            return this;
        }
        return this.require(file, xtend({ entry: true, expose: false }, opts));
    };
    
    Browserify.prototype.external = function (file, opts) {
        var self = this;
        if (isarray(file)) {
            file.forEach(function (f) {
                if (typeof f === 'object') {
                    self.external(f, xtend(opts, f));
                }
                else self.external(f, opts)
            });
            return this;
        }
        if (file && typeof file === 'object' && typeof file.bundle === 'function') {
            var b = file;
            self._pending ++;
    
            var bdeps = {};
            var blabels = {};
    
            b.on('label', function (prev, id) {
                self._external.push(id);
    
                if (prev !== id) {
                    blabels[prev] = id;
                    self._external.push(prev);
                }
            });
    
            b.pipeline.get('deps').push(through.obj(function (row, enc, next) {
                bdeps = xtend(bdeps, row.deps);
                this.push(row);
                next();
            }));
    
            self.on('dep', function (row) {
                Object.keys(row.deps).forEach(function (key) {
                    var prev = bdeps[key];
                    if (prev) {
                        var id = blabels[prev];
                        if (id) {
                            row.indexDeps[key] = id;
                        }
                    }
                });
            });
    
            b.pipeline.get('label').once('end', function () {
                if (-- self._pending === 0) self.emit('_ready');
            });
            return this;
        }
        
        if (!opts) opts = {};
        var basedir = defined(opts.basedir, process.cwd());
        this._external.push(file);
        this._external.push('/' + path.relative(basedir, file));
        return this;
    };
    
    Browserify.prototype.exclude = function (file, opts) {
        if (!opts) opts = {};
        var basedir = defined(opts.basedir, process.cwd());
        this._exclude.push(file);
        this._exclude.push('/' + path.relative(basedir, file));
        return this;
    };
    
    Browserify.prototype.ignore = function (file, opts) {
        if (!opts) opts = {};
        var basedir = defined(opts.basedir, process.cwd());
    
        // Handle relative paths
        if (file[0] === '.') {
            this._ignore.push(path.resolve(basedir, file));
        }
        else {
            this._ignore.push(file);
        }
        return this;
    };
    
    Browserify.prototype.transform = function (tr, opts) {
        var self = this;
        if (typeof opts === 'function' || typeof opts === 'string') {
            tr = [ opts, tr ];
        }
        if (isarray(tr)) {
            opts = tr[1];
            tr = tr[0];
        }
        
        //if the bundler is ignoring this transform
        if (typeof tr === 'string' && !self._filterTransform(tr)) {
            return this;
        }
    
        function resolved () {
          self._transforms[order] = rec;
          -- self._pending;
          if (-- self._transformPending === 0) {
              self._transforms.forEach(function (transform) {
                self.pipeline.write(transform);
              });
    
              if (self._pending === 0) {
                self.emit('_ready');
              }
          }
        }
        
        if (!opts) opts = {};
        opts._flags = '_flags' in opts ? opts._flags : self._options;
        
        var basedir = defined(opts.basedir, this._options.basedir, process.cwd());
        var order = self._transformOrder ++;
        self._pending ++;
        self._transformPending ++;
    
        var rec = {
            transform: tr,
            options: opts,
            global: opts.global
        };
    
        if (typeof tr === 'string') {
            var topts = {
                basedir: basedir,
                paths: (self._options.paths || []).map(function (p) {
                    return path.resolve(basedir, p);
                })
            };
            resolve(tr, topts, function (err, res) {
                if (err) return self.emit('error', err);
                rec.transform = res;
                resolved();
            });
        }
        else process.nextTick(resolved);
        return this;
    };
    
    Browserify.prototype.plugin = function (p, opts) {
        if (isarray(p)) {
            opts = p[1];
            p = p[0];
        }
        if (!opts) opts = {};
        var basedir = defined(opts.basedir, this._options.basedir, process.cwd());
        if (typeof p === 'function') {
            p(this, opts);
        }
        else {
            var pfile = resolve.sync(String(p), { basedir: basedir })
            var f = require(pfile);
            if (typeof f !== 'function') {
                throw new Error('plugin ' + p + ' should export a function');
            }
            f(this, opts);
        }
        return this;
    };
    
    Browserify.prototype._createPipeline = function (opts) {
        var self = this;
        if (!opts) opts = {};
        this._mdeps = this._createDeps(opts);
        this._mdeps.on('file', function (file, id) {
            pipeline.emit('file', file, id);
            self.emit('file', file, id);
        });
        this._mdeps.on('package', function (pkg) {
            pipeline.emit('package', pkg);
            self.emit('package', pkg);
        });
        this._mdeps.on('transform', function (tr, file) {
            pipeline.emit('transform', tr, file);
            self.emit('transform', tr, file);
        });
        
        var dopts = {
            index: !opts.fullPaths && !opts.exposeAll,
            dedupe: true,
            expose: this._expose
        };
        this._bpack = bpack(xtend(opts, { raw: true }));
        
        var pipeline = splicer.obj([
            'record', [ this._recorder() ],
            'deps', [ this._mdeps ],
            'json', [ this._json() ],
            'unbom', [ this._unbom() ],
            'unshebang', [ this._unshebang() ],
            'syntax', [ this._syntax() ],
            'sort', [ depsSort(dopts) ],
            'dedupe', [ this._dedupe() ],
            'label', [ this._label(opts) ],
            'emit-deps', [ this._emitDeps() ],
            'debug', [ this._debug(opts) ],
            'pack', [ this._bpack ],
            'wrap', []
        ]);
        if (opts.exposeAll) {
            var basedir = defined(opts.basedir, process.cwd());
            pipeline.get('deps').push(through.obj(function (row, enc, next) {
                if (self._external.indexOf(row.id) >= 0) return next();
                if (self._external.indexOf(row.file) >= 0) return next();
                
                if (isAbsolutePath(row.id)) {
                    row.id = '/' + path.relative(basedir, row.file);
                }
                Object.keys(row.deps || {}).forEach(function (key) {
                    row.deps[key] = '/' + path.relative(basedir, row.deps[key]);
                });
                this.push(row);
                next();
            }));
        }
        return pipeline;
    };
    
    Browserify.prototype._createDeps = function (opts) {
        var self = this;
        var mopts = xtend(opts);
        var basedir = defined(opts.basedir, process.cwd());
    
        // Let mdeps populate these values since it will be resolving file paths
        // anyway.
        mopts.expose = this._expose;
        mopts.extensions = [ '.js', '.json' ].concat(mopts.extensions || []);
        self._extensions = mopts.extensions;
    
        mopts.transform = [];
        mopts.transformKey = [ 'browserify', 'transform' ];
        mopts.postFilter = function (id, file, pkg) {
            if (opts.postFilter && !opts.postFilter(id, file, pkg)) return false;
            if (self._external.indexOf(file) >= 0) return false;
            if (self._exclude.indexOf(file) >= 0) return false;
    
            //filter transforms on module dependencies
            if (pkg && pkg.browserify && pkg.browserify.transform) {
                //In edge cases it may be a string
                pkg.browserify.transform = [].concat(pkg.browserify.transform)
                        .filter(Boolean)
                        .filter(self._filterTransform);
            }
            return true;
        };
        mopts.filter = function (id) {
            if (opts.filter && !opts.filter(id)) return false;
            if (self._external.indexOf(id) >= 0) return false;
            if (self._exclude.indexOf(id) >= 0) return false;
            if (opts.bundleExternal === false && isExternalModule(id)) {
                return false;
            }
            return true;
        };
        mopts.resolve = function (id, parent, cb) {
            if (self._ignore.indexOf(id) >= 0) return cb(null, paths.empty, {});
            
            self._bresolve(id, parent, function (err, file, pkg) {
                if (file && self._ignore.indexOf(file) >= 0) {
                    return cb(null, paths.empty, {});
                }
                if (file && self._ignore.length) {
                    var nm = file.split('/node_modules/')[1];
                    if (nm) {
                        nm = nm.split('/')[0];
                        if (self._ignore.indexOf(nm) >= 0) {
                            return cb(null, paths.empty, {});
                        }
                    }
                }
                
                if (file) {
                    var ex = '/' + path.relative(basedir, file);
                    if (self._external.indexOf(ex) >= 0) {
                        return cb(null, ex);
                    }
                    if (self._exclude.indexOf(ex) >= 0) {
                        return cb(null, ex);
                    }
                    if (self._ignore.indexOf(ex) >= 0) {
                        return cb(null, paths.empty, {});
                    }
                }
                if (err) cb(err, file, pkg)
                else if (file) fs.realpath(file, function (err, res) {
                    cb(err, res, pkg, file);
                });
                else cb(err, null, pkg)
            });
        };
        
        if (opts.builtins === false) {
            mopts.modules = {};
            self._exclude.push.apply(self._exclude, Object.keys(builtins));
        }
        else if (opts.builtins && isarray(opts.builtins)) {
            mopts.modules = {};
            opts.builtins.forEach(function (key) {
                mopts.modules[key] = builtins[key];
            });
        }
        else if (opts.builtins && typeof opts.builtins === 'object') {
            mopts.modules = opts.builtins;
        }
        else mopts.modules = xtend(builtins);
        
        Object.keys(builtins).forEach(function (key) {
            if (!has(mopts.modules, key)) self._exclude.push(key);
        });
        
        mopts.globalTransform = [];
        if (!this._bundled) {
            this.once('bundle', function () {
                self.pipeline.write({
                    transform: globalTr,
                    global: true,
                    options: {}
                });
            });
        }
        
        var no = [].concat(opts.noParse).filter(Boolean);
        var absno = no.filter(function(x) {
            return typeof x === 'string';
        }).map(function (x) {
            return path.resolve(basedir, x);
        });
        
        function globalTr (file) {
            if (opts.detectGlobals === false) return through();
            
            if (opts.noParse === true) return through();
            if (no.indexOf(file) >= 0) return through();
            if (absno.indexOf(file) >= 0) return through();
            
            var parts = file.split('/node_modules/');
            for (var i = 0; i < no.length; i++) {
                if (typeof no[i] === 'function' && no[i](file)) {
                    return through();
                }
                else if (no[i] === parts[parts.length-1].split('/')[0]) {
                    return through();
                }
                else if (no[i] === parts[parts.length-1]) {
                    return through();
                }
            }
            
            var vars = xtend({
                process: function () { return "require('_process')" },
            }, opts.insertGlobalVars);
            
            if (opts.bundleExternal === false) {
                vars.process = undefined;
                vars.buffer = undefined;
            }
            
            return insertGlobals(file, xtend(opts, {
                debug: opts.debug,
                always: opts.insertGlobals,
                basedir: opts.commondir === false
                    ? '/'
                    : opts.basedir || process.cwd()
                ,
                vars: vars
            }));
        }
        return mdeps(mopts);
    };
    
    Browserify.prototype._recorder = function (opts) {
        var self = this;
        var ended = false;
        this._recorded = [];
        
        if (!this._ticked) {
            process.nextTick(function () {
                self._ticked = true;
                self._recorded.forEach(function (row) {
                    stream.push(row);
                });
                if (ended) stream.push(null);
            });
        }
        
        var stream = through.obj(write, end);
        return stream;
        
        function write (row, enc, next) {
            self._recorded.push(row);
            if (self._ticked) this.push(row);
            next();
        }
        function end () {
            ended = true;
            if (self._ticked) this.push(null);
        }
    };
    
    Browserify.prototype._json = function () {
        return through.obj(function (row, enc, next) {
            if (/\.json$/.test(row.file)) {
                row.source = 'module.exports=' + sanitize(row.source);
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._unbom = function () {
        return through.obj(function (row, enc, next) {
            if (/^\ufeff/.test(row.source)) {
                row.source = row.source.replace(/^\ufeff/, '');
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._unshebang = function () {
        return through.obj(function (row, enc, next) {
            if (/^#!/.test(row.source)) {
                row.source = row.source.replace(/^#![^\n]*\n/, '');
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._syntax = function () {
        var self = this;
        return through.obj(function (row, enc, next) {
            var h = shasum(row.source);
            if (typeof self._syntaxCache[h] === 'undefined') {
                var err = syntaxError(row.source, row.file || row.id);
                if (err) return this.emit('error', err);
                self._syntaxCache[h] = true;
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._dedupe = function () {
        return through.obj(function (row, enc, next) {
            if (!row.dedupeIndex && row.dedupe) {
                row.source = 'arguments[4]['
                    + JSON.stringify(row.dedupe)
                    + '][0].apply(exports,arguments)'
                ;
                row.nomap = true;
            }
            else if (row.dedupeIndex) {
                row.source = 'arguments[4]['
                    + JSON.stringify(row.dedupeIndex)
                    + '][0].apply(exports,arguments)'
                ;
                row.nomap = true;
            }
            if (row.dedupeIndex && row.indexDeps) {
                row.indexDeps.dup = row.dedupeIndex;
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._label = function (opts) {
        var self = this;
        var basedir = defined(opts.basedir, process.cwd());
        
        return through.obj(function (row, enc, next) {
            var prev = row.id;
    
            if (self._external.indexOf(row.id) >= 0) return next();
            if (self._external.indexOf('/' + path.relative(basedir, row.id)) >= 0) {
                return next();
            }
            if (self._external.indexOf(row.file) >= 0) return next();
            
            if (row.index) row.id = row.index;
            
            self.emit('label', prev, row.id);
            if (row.indexDeps) row.deps = row.indexDeps || {};
            
            Object.keys(row.deps).forEach(function (key) {
                if (self._expose[key]) {
                    row.deps[key] = key;
                    return;
                }
    
                var afile = path.resolve(path.dirname(row.file), key);
                var rfile = '/' + path.relative(basedir, afile);
                if (self._external.indexOf(rfile) >= 0) {
                    row.deps[key] = rfile;
                }
                if (self._external.indexOf(afile) >= 0) {
                    row.deps[key] = rfile;
                }
                if (self._external.indexOf(key) >= 0) {
                    row.deps[key] = key;
                    return;
                }
                
                for (var i = 0; i < self._extensions.length; i++) {
                    var ex = self._extensions[i];
                    if (self._external.indexOf(rfile + ex) >= 0) {
                        row.deps[key] = rfile + ex;
                        break;
                    }
                }
            });
            
            if (row.entry || row.expose) {
                self._bpack.standaloneModule = row.id;
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype._emitDeps = function () {
        var self = this;
        return through.obj(function (row, enc, next) {
            self.emit('dep', row);
            this.push(row);
            next();
        })
    };
    
    Browserify.prototype._debug = function (opts) {
        var basedir = defined(opts.basedir, process.cwd());
        return through.obj(function (row, enc, next) {
            if (opts.debug) {
                row.sourceRoot = 'file://localhost';
                row.sourceFile = path.relative(basedir, row.file)
                    .replace(/\\/g, '/');
            }
            this.push(row);
            next();
        });
    };
    
    Browserify.prototype.reset = function (opts) {
        if (!opts) opts = {};
        var hadExports = this._bpack.hasExports;
        this.pipeline = this._createPipeline(xtend(opts, this._options));
        this._bpack.hasExports = hadExports;
        this._entryOrder = 0;
        this._bundled = false;
        this.emit('reset');
    };
    
    Browserify.prototype.bundle = function (cb) {
        var self = this;
        if (cb && typeof cb === 'object') {
            throw new Error(
                'bundle() no longer accepts option arguments.\n'
                + 'Move all option arguments to the browserify() constructor.'
            );
        }
        if (this._bundled) {
            var recorded = this._recorded;
            this.reset();
            recorded.forEach(function (x) {
                self.pipeline.write(x);
            });
        }
        var output = readonly(this.pipeline);
        if (cb) {
            output.on('error', cb);
            output.pipe(concat(function (body) {
                cb(null, body);
            }));
        }
    
        function ready () {
            self.emit('bundle', output);
            self.pipeline.end();
        }
    
        if (this._pending === 0) ready();
        else this.once('_ready', ready);
    
        this._bundled = true;
        return output;
    };
    
    function isStream (s) { return s && typeof s.pipe === 'function' }
    function isAbsolutePath (file) {
        var regexp = process.platform === 'win32' ?
            /^\w:/ :
            /^\//;
        return regexp.test(file);
    }
    function isExternalModule (file) {
        var regexp = process.platform === 'win32' ?
            /^(\.|\w:)/ :
            /^[\/.]/;
        return !regexp.test(file);
    }
    
  provide("browserify", module.exports);
}(global));

// pakmanager:chai
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./lib/chai');
    
  provide("chai", module.exports);
}(global));

// pakmanager:karma-chai
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var path = require('path');
    
    var pattern = function(file) {
      return {pattern: file, included: true, served: true, watched: false};
    };
    
    var framework = function(files) {
      files.unshift(pattern(path.join(__dirname, 'adapter.js')));
      files.unshift(pattern(path.resolve(require.resolve('chai'), '../chai.js')));
    };
    
    framework.$inject = ['config.files'];
    module.exports = {'framework:chai': ['factory', framework]};
  provide("karma-chai", module.exports);
}(global));

// pakmanager:karma-chrome-launcher
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var fsAccess = require('fs-access')
    var path = require('path')
    var which = require('which')
    
    function isJSFlags (flag) {
      return flag.indexOf('--js-flags=') === 0
    }
    
    function sanitizeJSFlags (flag) {
      var test = /--js-flags=(['"])/.exec(flag)
      if (!test) {
        return flag
      }
      var escapeChar = test[1]
      var endExp = new RegExp(escapeChar + '$')
      var startExp = new RegExp('--js-flags=' + escapeChar)
      return flag.replace(startExp, '--js-flags=').replace(endExp, '')
    }
    
    var ChromeBrowser = function (baseBrowserDecorator, args) {
      baseBrowserDecorator(this)
    
      var flags = args.flags || []
      var userDataDir = args.chromeDataDir || this._tempDir
    
      this._getOptions = function (url) {
        // Chrome CLI options
        // http://peter.sh/experiments/chromium-command-line-switches/
        flags.forEach(function (flag, i) {
          if (isJSFlags(flag)) {
            flags[i] = sanitizeJSFlags(flag)
          }
        })
    
        return [
          '--user-data-dir=' + userDataDir,
          '--no-default-browser-check',
          '--no-first-run',
          '--disable-default-apps',
          '--disable-popup-blocking',
          '--disable-translate',
          '--disable-background-timer-throttling'
        ].concat(flags, [url])
      }
    }
    
    // Return location of chrome.exe file for a given Chrome directory (available: "Chrome", "Chrome SxS").
    function getChromeExe (chromeDirName) {
      // Only run these checks on win32
      if (process.platform !== 'win32') {
        return null
      }
      var windowsChromeDirectory, i, prefix
      var suffix = '\\Google\\' + chromeDirName + '\\Application\\chrome.exe'
      var prefixes = [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env['PROGRAMFILES(X86)']]
    
      for (i = 0; i < prefixes.length; i++) {
        prefix = prefixes[i]
        try {
          windowsChromeDirectory = path.join(prefix, suffix)
          fsAccess.sync(windowsChromeDirectory)
          return windowsChromeDirectory
        } catch (e) {}
      }
    
      return windowsChromeDirectory
    }
    
    function getBin (commands) {
      // Don't run these checks on win32
      if (process.platform !== 'linux') {
        return null
      }
      var bin, i
      for (i = 0; i < commands.length; i++) {
        try {
          if (which.sync(commands[i])) {
            bin = commands[i]
            break
          }
        } catch (e) {}
      }
      return bin
    }
    
    function getChromeDarwin (defaultPath) {
      if (process.platform !== 'darwin') {
        return null
      }
    
      try {
        var homePath = path.join(process.env.HOME, defaultPath)
        fsAccess.sync(homePath)
        return homePath
      } catch (e) {
        return defaultPath
      }
    }
    
    ChromeBrowser.prototype = {
      name: 'Chrome',
    
      DEFAULT_CMD: {
        // Try chromium-browser before chromium to avoid conflict with the legacy
        // chromium-bsu package previously known as 'chromium' in Debian and Ubuntu.
        linux: getBin(['chromium-browser', 'chromium', 'google-chrome', 'google-chrome-stable']),
        darwin: getChromeDarwin('/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'),
        win32: getChromeExe('Chrome')
      },
      ENV_CMD: 'CHROME_BIN'
    }
    
    ChromeBrowser.$inject = ['baseBrowserDecorator', 'args']
    
    function canaryGetOptions (url, args, parent) {
      // disable crankshaft optimizations, as it causes lot of memory leaks (as of Chrome 23.0)
      var flags = args.flags || []
      var augmentedFlags
      var customFlags = '--nocrankshaft --noopt'
    
      flags.forEach(function (flag) {
        if (isJSFlags(flag)) {
          augmentedFlags = sanitizeJSFlags(flag) + ' ' + customFlags
        }
      })
    
      return parent.call(this, url).concat([augmentedFlags || '--js-flags=' + customFlags])
    }
    
    var ChromeCanaryBrowser = function (baseBrowserDecorator, args) {
      ChromeBrowser.apply(this, arguments)
    
      var parentOptions = this._getOptions
      this._getOptions = function (url) {
        return canaryGetOptions.call(this, url, args, parentOptions)
      }
    }
    
    ChromeCanaryBrowser.prototype = {
      name: 'ChromeCanary',
    
      DEFAULT_CMD: {
        linux: getBin(['google-chrome-canary', 'google-chrome-unstable']),
        darwin: getChromeDarwin('/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary'),
        win32: getChromeExe('Chrome SxS')
      },
      ENV_CMD: 'CHROME_CANARY_BIN'
    }
    
    ChromeCanaryBrowser.$inject = ['baseBrowserDecorator', 'args']
    
    var DartiumBrowser = function () {
      ChromeBrowser.apply(this, arguments)
    
      var checkedFlag = '--checked'
      var dartFlags = process.env.DART_FLAGS || ''
      var flags = dartFlags.split(' ')
      if (flags.indexOf(checkedFlag) === -1) {
        flags.push(checkedFlag)
        process.env.DART_FLAGS = flags.join(' ')
      }
    }
    
    DartiumBrowser.prototype = {
      name: 'Dartium',
      DEFAULT_CMD: {},
      ENV_CMD: 'DARTIUM_BIN'
    }
    
    DartiumBrowser.$inject = ['baseBrowserDecorator', 'args']
    
    // PUBLISH DI MODULE
    module.exports = {
      'launcher:Chrome': ['type', ChromeBrowser],
      'launcher:ChromeCanary': ['type', ChromeCanaryBrowser],
      'launcher:Dartium': ['type', DartiumBrowser]
    }
    
    module.exports.test = {
      isJSFlags: isJSFlags,
      sanitizeJSFlags: sanitizeJSFlags,
      canaryGetOptions: canaryGetOptions
    }
    
  provide("karma-chrome-launcher", module.exports);
}(global));

// pakmanager:karma-sauce-launcher
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var SauceConnect = require('./lib/sauce_connect')
    var SauceLauncher = require('./lib/sauce_launcher')
    var SauceReporter = require('./lib/sauce_reporter')
    
    // PUBLISH DI MODULE
    module.exports = {
      'sauceConnect': ['type', SauceConnect],
      'launcher:SauceLabs': ['type', SauceLauncher],
      'reporter:saucelabs': ['type', SauceReporter],
    
      // We keep a mapping from Karma launch IDs to Sauce job IDs here, to report the pass/fail results.
      // We also keep the Sauce credentials here - theoretically different credentials can be used for
      // different browsers in the same session.
      'sauce:jobMapping': ['value', {}]
    }
    
  provide("karma-sauce-launcher", module.exports);
}(global));

// pakmanager:secure-keys
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    var crypto = require('crypto');
    
    var json = {
      stringify: function (obj, replacer, spacing) {
        return JSON.stringify(obj, replacer || null, spacing || 2)
      },
      parse: JSON.parse
    };
    
    module.exports = Secure;
    /**
     * @constructor
     * Simple Object used to serialize and deserialize
     */
    function Secure(opts) {
      opts = opts || {};
      this.secret = typeof opts !== 'string'
        ? opts.secret
        : opts;
    
      this.format = opts.format || json;
      this.alg = opts.alg || 'aes-256-ctr';
    
      if (!this.secret) throw new Error('Secret is a required option');
    }
    
    Secure.prototype.encrypt = function encrypt(data, callback) {
      var self = this;
    
      return Object.keys(data).reduce(function (acc, key) {
        var value = self.format.stringify(data[key]);
        acc[key] = {
          alg: self.alg,
          value: cipherConvert(value, {
            alg: self.alg,
            secret: self.secret,
            encs: { input: 'utf8', output: 'hex' }
          })
        };
    
        return acc;
      }, {});
    
     };
    
    Secure.prototype.decrypt = function decrypt(data, callback) {
      var self = this;
    
      return Object.keys(data).reduce(function (acc, key) {
        var decrypted = cipherConvert(data[key].value, {
          alg: data[key].alg || self.alg,
          secret: self.secret,
          encs: { input: 'hex', output: 'utf8' }
        });
    
        acc[key] = self.format.parse(decrypted);
        return acc;
      }, {});
    
     };
    
    //
    // ### function cipherConvert (contents, opts)
    // Returns the result of the cipher operation
    // on the contents contents.
    //
    function cipherConvert(contents, opts) {
      var encs = opts.encs;
      var cipher = crypto.createCipher(opts.alg, opts.secret);
      return cipher.update(contents, encs.input, encs.output)
        + cipher.final(encs.output);
    }
    
  provide("secure-keys", module.exports);
}(global));

// pakmanager:yargs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // classic singleton yargs API, to use yargs
    // without running as a singleton do:
    // require('yargs/yargs')(process.argv.slice(2))
    var yargs =   require('yargs')
    
    Argv(process.argv.slice(2))
    
    var exports = module.exports = Argv
    
    function Argv (processArgs, cwd) {
      var argv = yargs(processArgs, cwd, require)
      singletonify(argv)
      return argv
    }
    
    exports.rebase = yargs.rebase
    
    /*  Hack an instance of Argv with process.argv into Argv
        so people can do
         require('yargs')(['--beeble=1','-z','zizzle']).argv
        to parse a list of args and
         require('yargs').argv
        to get a parsed version of process.argv.
    */
    function singletonify (inst) {
      Object.keys(inst).forEach(function (key) {
        if (key === 'argv') {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key))
        } else {
          Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]
        }
      })
    }
    
  provide("yargs", module.exports);
}(global));

// pakmanager:keycode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Source: http://jsfiddle.net/vWx8V/
    // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes
    
    /**
     * Conenience method returns corresponding value for given keyName or keyCode.
     *
     * @param {Mixed} keyCode {Number} or keyName {String}
     * @return {Mixed}
     * @api public
     */
    
    exports = module.exports = function(searchInput) {
      // Keyboard Events
      if (searchInput && 'object' === typeof searchInput) {
        var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode
        if (hasKeyCode) searchInput = hasKeyCode
      }
    
      // Numbers
      if ('number' === typeof searchInput) return names[searchInput]
    
      // Everything else (cast to string)
      var search = String(searchInput)
    
      // check codes
      var foundNamedKey = codes[search.toLowerCase()]
      if (foundNamedKey) return foundNamedKey
    
      // check aliases
      var foundNamedKey = aliases[search.toLowerCase()]
      if (foundNamedKey) return foundNamedKey
    
      // weird character?
      if (search.length === 1) return search.charCodeAt(0)
    
      return undefined
    }
    
    /**
     * Get by name
     *
     *   exports.code['enter'] // => 13
     */
    
    var codes = exports.code = exports.codes = {
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause/break': 19,
      'caps lock': 20,
      'esc': 27,
      'space': 32,
      'page up': 33,
      'page down': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      'command': 91,
      'right click': 93,
      'numpad *': 106,
      'numpad +': 107,
      'numpad -': 109,
      'numpad .': 110,
      'numpad /': 111,
      'num lock': 144,
      'scroll lock': 145,
      'my computer': 182,
      'my calculator': 183,
      ';': 186,
      '=': 187,
      ',': 188,
      '-': 189,
      '.': 190,
      '/': 191,
      '`': 192,
      '[': 219,
      '\\': 220,
      ']': 221,
      "'": 222
    }
    
    // Helper aliases
    
    var aliases = exports.aliases = {
      'windows': 91,
      '⇧': 16,
      '⌥': 18,
      '⌃': 17,
      '⌘': 91,
      'ctl': 17,
      'control': 17,
      'option': 18,
      'pause': 19,
      'break': 19,
      'caps': 20,
      'return': 13,
      'escape': 27,
      'spc': 32,
      'pgup': 33,
      'pgdn': 33,
      'ins': 45,
      'del': 46,
      'cmd': 91
    }
    
    
    /*!
     * Programatically add the following
     */
    
    // lower case chars
    for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32
    
    // numbers
    for (var i = 48; i < 58; i++) codes[i - 48] = i
    
    // function keys
    for (i = 1; i < 13; i++) codes['f'+i] = i + 111
    
    // numpad keys
    for (i = 0; i < 10; i++) codes['numpad '+i] = i + 96
    
    /**
     * Get by code
     *
     *   exports.name[13] // => 'Enter'
     */
    
    var names = exports.names = exports.title = {} // title for backward compat
    
    // Create reverse mapping
    for (i in codes) names[codes[i]] = i
    
    // Add aliases
    for (var alias in aliases) {
      codes[alias] = aliases[alias]
    }
    
  provide("keycode", module.exports);
}(global));

// pakmanager:lodash-compat
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * @license
     * lodash 3.10.2 (Custom Build) <https://lodash.com/>
     * Build: `lodash compat -d -o ./index.js`
     * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     * Available under MIT license <https://lodash.com/license>
     */
    ;(function() {
    
      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined;
    
      /** Used as the semantic version number. */
      var VERSION = '3.10.2';
    
      /** Used to compose bitmasks for wrapper metadata. */
      var BIND_FLAG = 1,
          BIND_KEY_FLAG = 2,
          CURRY_BOUND_FLAG = 4,
          CURRY_FLAG = 8,
          CURRY_RIGHT_FLAG = 16,
          PARTIAL_FLAG = 32,
          PARTIAL_RIGHT_FLAG = 64,
          ARY_FLAG = 128,
          REARG_FLAG = 256;
    
      /** Used as default options for `_.trunc`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';
    
      /** Used to detect when a function becomes hot. */
      var HOT_COUNT = 150,
          HOT_SPAN = 16;
    
      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;
    
      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2;
    
      /** Used as the `TypeError` message for "Functions" methods. */
      var FUNC_ERROR_TEXT = 'Expected a function';
    
      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';
    
      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
    
      var arrayBufferTag = '[object ArrayBuffer]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
    
      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    
      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
          reUnescapedHtml = /[&<>"'`]/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    
      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;
    
      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    
      /**
       * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
       * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
       */
      var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
          reHasRegExpChars = RegExp(reRegExpChars.source);
    
      /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
      var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
    
      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;
    
      /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    
      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;
    
      /** Used to detect hexadecimal string values. */
      var reHasHexPrefix = /^0[xX]/;
    
      /** Used to detect host constructors (Safari > 5). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
    
      /** Used to detect unsigned integer values. */
      var reIsUint = /^\d+$/;
    
      /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
      var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    
      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;
    
      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    
      /** Used to match words to create compound words. */
      var reWords = (function() {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
            lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
    
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
      }());
    
      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
        'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
        'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
      ];
    
      /** Used to fix the JScript `[[DontEnum]]` bug. */
      var shadowProps = [
        'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
        'toLocaleString', 'toString', 'valueOf'
      ];
    
      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;
    
      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dateTag] = typedArrayTags[errorTag] =
      typedArrayTags[funcTag] = typedArrayTags[mapTag] =
      typedArrayTags[numberTag] = typedArrayTags[objectTag] =
      typedArrayTags[regexpTag] = typedArrayTags[setTag] =
      typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    
      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
      cloneableTags[dateTag] = cloneableTags[float32Tag] =
      cloneableTags[float64Tag] = cloneableTags[int8Tag] =
      cloneableTags[int16Tag] = cloneableTags[int32Tag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[stringTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[mapTag] = cloneableTags[setTag] =
      cloneableTags[weakMapTag] = false;
    
      /** Used to map latin-1 supplementary letters to basic latin letters. */
      var deburredLetters = {
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss'
      };
    
      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '`': '&#96;'
      };
    
      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
        '&#96;': '`'
      };
    
      /** Used to determine if values are of the language type `Object`. */
      var objectTypes = {
        'function': true,
        'object': true
      };
    
      /** Used to escape characters for inclusion in compiled regexes. */
      var regexpEscapes = {
        '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
        '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
        'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
        'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
        'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
      };
    
      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };
    
      /** Detect free variable `exports`. */
      var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    
      /** Detect free variable `module`. */
      var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    
      /** Detect free variable `global` from Node.js. */
      var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    
      /** Detect free variable `self`. */
      var freeSelf = objectTypes[typeof self] && self && self.Object && self;
    
      /** Detect free variable `window`. */
      var freeWindow = objectTypes[typeof window] && window && window.Object && window;
    
      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    
      /**
       * Used as a reference to the global object.
       *
       * The `this` value is used if it's the global object to avoid Greasemonkey's
       * restricted `window` object, otherwise the `window` object is used.
       */
      var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * The base implementation of `compareAscending` which compares values and
       * sorts them in ascending order without guaranteeing a stable sort.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function baseCompareAscending(value, other) {
        if (value !== other) {
          var valIsNull = value === null,
              valIsUndef = value === undefined,
              valIsReflexive = value === value;
    
          var othIsNull = other === null,
              othIsUndef = other === undefined,
              othIsReflexive = other === other;
    
          if ((value > other && !othIsNull) || !valIsReflexive ||
              (valIsNull && !othIsUndef && othIsReflexive) ||
              (valIsUndef && othIsReflexive)) {
            return 1;
          }
          if ((value < other && !valIsNull) || !othIsReflexive ||
              (othIsNull && !valIsUndef && valIsReflexive) ||
              (othIsUndef && valIsReflexive)) {
            return -1;
          }
        }
        return 0;
      }
    
      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;
    
        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.indexOf` without support for binary searches.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
          return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1,
            length = array.length;
    
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * The base implementation of `_.isFunction` without support for environments
       * with incorrect `typeof` results.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
       */
      function baseIsFunction(value) {
        // Avoid a Chakra JIT bug in compatibility modes of IE 11.
        // See https://github.com/jashkenas/underscore/issues/1621 for more details.
        return typeof value == 'function' || false;
      }
    
      /**
       * Converts `value` to a string if it's not one. An empty string is returned
       * for `null` or `undefined` values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        return value == null ? '' : (value + '');
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the first character not found in `chars`.
       */
      function charsLeftIndex(string, chars) {
        var index = -1,
            length = string.length;
    
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last character
       * of `string` that is not found in `chars`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @param {string} chars The characters to find.
       * @returns {number} Returns the index of the last character not found in `chars`.
       */
      function charsRightIndex(string, chars) {
        var index = string.length;
    
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
        return index;
      }
    
      /**
       * Used by `_.sortBy` to compare transformed elements of a collection and stable
       * sort them in ascending order.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
      }
    
      /**
       * Used by `_.sortByOrder` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
       * a value is sorted in ascending order if its corresponding order is "asc", and
       * descending if "desc".
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;
    
        while (++index < length) {
          var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * ((order === 'asc' || order === true) ? 1 : -1);
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index;
      }
    
      /**
       * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      function deburrLetter(letter) {
        return deburredLetters[letter];
      }
    
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
      }
    
      /**
       * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @param {string} leadingChar The capture group for a leading character.
       * @param {string} whitespaceChar The capture group for a whitespace character.
       * @returns {string} Returns the escaped character.
       */
      function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
        if (leadingChar) {
          chr = regexpEscapes[chr];
        } else if (whitespaceChar) {
          chr = stringEscapes[chr];
        }
        return '\\' + chr;
      }
    
      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
    
      /**
       * Gets the index at which the first occurrence of `NaN` is found in `array`.
       *
       * @private
       * @param {Array} array The array to search.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched `NaN`, else `-1`.
       */
      function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 0 : -1);
    
        while ((fromRight ? index-- : ++index < length)) {
          var other = array[index];
          if (other !== other) {
            return index;
          }
        }
        return -1;
      }
    
      /**
       * Checks if `value` is a host object in IE < 9.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
       */
      var isHostObject = (function() {
        try {
          Object({ 'toString': 0 } + '');
        } catch(e) {
          return function() { return false; };
        }
        return function(value) {
          // IE < 9 presents many host objects as `Object` objects that can coerce
          // to strings despite having improperly defined `toString` methods.
          return typeof value.toString != 'function' && typeof (value + '') == 'string';
        };
      }());
    
      /**
       * Checks if `value` is object-like.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       */
      function isObjectLike(value) {
        return !!value && typeof value == 'object';
      }
    
      /**
       * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
       * character code is whitespace.
       *
       * @private
       * @param {number} charCode The character code to inspect.
       * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
       */
      function isSpace(charCode) {
        return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
          (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
      }
    
      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          if (array[index] === placeholder) {
            array[index] = PLACEHOLDER;
            result[++resIndex] = index;
          }
        }
        return result;
      }
    
      /**
       * An implementation of `_.uniq` optimized for sorted arrays without support
       * for callback shorthands and `this` binding.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The function invoked per iteration.
       * @returns {Array} Returns the new duplicate free array.
       */
      function sortedUniq(array, iteratee) {
        var seen,
            index = -1,
            length = array.length,
            resIndex = -1,
            result = [];
    
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value, index, array) : value;
    
          if (!index || seen !== computed) {
            seen = computed;
            result[++resIndex] = value;
          }
        }
        return result;
      }
    
      /**
       * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the first non-whitespace character.
       */
      function trimmedLeftIndex(string) {
        var index = -1,
            length = string.length;
    
        while (++index < length && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedRightIndex(string) {
        var index = string.length;
    
        while (index-- && isSpace(string.charCodeAt(index))) {}
        return index;
      }
    
      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
      }
    
      /*--------------------------------------------------------------------------*/
    
      /**
       * Create a new pristine `lodash` function using the given `context` object.
       *
       * @static
       * @memberOf _
       * @category Utility
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // using `context` to mock `Date#getTime` use in `_.now`
       * var mock = _.runInContext({
       *   'Date': function() {
       *     return { 'getTime': getTimeMock };
       *   }
       * });
       *
       * // or creating a suped-up `defer` in Node.js
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      function runInContext(context) {
        // Avoid issues with some ES3 environments that attempt to use values, named
        // after built-in constructors like `Object`, for the creation of literals.
        // ES5 clears this up by stating that literals must use built-in constructors.
        // See https://es5.github.io/#x11.1.5 for more details.
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    
        /** Native constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Number = context.Number,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;
    
        /** Used for native method references. */
        var arrayProto = Array.prototype,
            errorProto = Error.prototype,
            objectProto = Object.prototype,
            stringProto = String.prototype;
    
        /** Used to resolve the decompiled source of functions. */
        var fnToString = Function.prototype.toString;
    
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
    
        /** Used to generate unique IDs. */
        var idCounter = 0;
    
        /**
         * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
         * of values.
         */
        var objToString = objectProto.toString;
    
        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;
    
        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );
    
        /** Native method references. */
        var ArrayBuffer = context.ArrayBuffer,
            clearTimeout = context.clearTimeout,
            parseFloat = context.parseFloat,
            pow = Math.pow,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            Set = getNative(context, 'Set'),
            setTimeout = context.setTimeout,
            splice = arrayProto.splice,
            Uint8Array = context.Uint8Array,
            WeakMap = getNative(context, 'WeakMap');
    
        /* Native method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeCreate = getNative(Object, 'create'),
            nativeFloor = Math.floor,
            nativeIsArray = getNative(Array, 'isArray'),
            nativeIsFinite = context.isFinite,
            nativeKeys = getNative(Object, 'keys'),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = getNative(Date, 'now'),
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random;
    
        /** Used as references for `-Infinity` and `Infinity`. */
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
            POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
    
        /** Used as references for the maximum length and index of an array. */
        var MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    
        /**
         * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
         * of an array-like value.
         */
        var MAX_SAFE_INTEGER = 9007199254740991;
    
        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;
    
        /** Used to lookup unminified function names. */
        var realNames = {};
    
        /** Used to lookup a type array constructors by `toStringTag`. */
        var ctorByTag = {};
        ctorByTag[float32Tag] = context.Float32Array;
        ctorByTag[float64Tag] = context.Float64Array;
        ctorByTag[int8Tag] = context.Int8Array;
        ctorByTag[int16Tag] = context.Int16Array;
        ctorByTag[int32Tag] = context.Int32Array;
        ctorByTag[uint8Tag] = Uint8Array;
        ctorByTag[uint8ClampedTag] = context.Uint8ClampedArray;
        ctorByTag[uint16Tag] = context.Uint16Array;
        ctorByTag[uint32Tag] = context.Uint32Array;
    
        /** Used to avoid iterating over non-enumerable properties in IE < 9. */
        var nonEnumProps = {};
        nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
        nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
        nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
        nonEnumProps[objectTag] = { 'constructor': true };
    
        arrayEach(shadowProps, function(key) {
          for (var tag in nonEnumProps) {
            if (hasOwnProperty.call(nonEnumProps, tag)) {
              var props = nonEnumProps[tag];
              props[key] = hasOwnProperty.call(props, key);
            }
          }
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object which wraps `value` to enable implicit chaining.
         * Methods that operate on and return arrays, collections, and functions can
         * be chained together. Methods that retrieve a single value or may return a
         * primitive value will automatically end the chain returning the unwrapped
         * value. Explicit chaining may be enabled using `_.chain`. The execution of
         * chained methods is lazy, that is, execution is deferred until `_#value`
         * is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
         * fusion is an optimization strategy which merge iteratee calls; this can help
         * to avoid the creation of intermediate data structures and greatly reduce the
         * number of iteratee executions.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
         * `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
         * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
         * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
         * and `where`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
         * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
         * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
         * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
         * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
         * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
         * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
         * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
         * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
         * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
         * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
         * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
         * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
         * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
         * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
         * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
         * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
         * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
         * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
         * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
         * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
         * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
         * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
         * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
         * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
         * `unescape`, `uniqueId`, `value`, and `words`
         *
         * The wrapper method `sample` will return a wrapped value when `n` is provided,
         * otherwise an unwrapped value is returned.
         *
         * @name _
         * @constructor
         * @category Chain
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(total, n) {
         *   return total + n;
         * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(n) {
         *   return n * n;
         * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
    
        /**
         * The function whose prototype all chaining wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }
    
        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
         * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
         */
        function LodashWrapper(value, chainAll, actions) {
          this.__wrapped__ = value;
          this.__actions__ = actions || [];
          this.__chain__ = !!chainAll;
        }
    
        /**
         * An object environment feature flags.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        var support = lodash.support = {};
    
        (function(x) {
          var Ctor = function() { this.x = x; },
              object = { '0': x, 'length': x },
              props = [];
    
          Ctor.prototype = { 'valueOf': x, 'y': x };
          for (var key in new Ctor) { props.push(key); }
    
          /**
           * Detect if `name` or `message` properties of `Error.prototype` are
           * enumerable by default (IE < 9, Safari < 5.1).
           *
           * @memberOf _.support
           * @type boolean
           */
          support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
            propertyIsEnumerable.call(errorProto, 'name');
    
          /**
           * Detect if `prototype` properties are enumerable by default.
           *
           * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
           * (if the prototype or a property on the prototype has been set)
           * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
           * property to `true`.
           *
           * @memberOf _.support
           * @type boolean
           */
          support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');
    
          /**
           * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
           *
           * In IE < 9 an object's own properties, shadowing non-enumerable ones,
           * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
           *
           * @memberOf _.support
           * @type boolean
           */
          support.nonEnumShadows = !/valueOf/.test(props);
    
          /**
           * Detect if own properties are iterated after inherited properties (IE < 9).
           *
           * @memberOf _.support
           * @type boolean
           */
          support.ownLast = props[0] != 'x';
    
          /**
           * Detect if `Array#shift` and `Array#splice` augment array-like objects
           * correctly.
           *
           * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array
           * `shift()` and `splice()` functions that fail to remove the last element,
           * `value[0]`, of array-like objects even though the "length" property is
           * set to `0`. The `shift()` method is buggy in compatibility modes of IE 8,
           * while `splice()` is buggy regardless of mode in IE < 9.
           *
           * @memberOf _.support
           * @type boolean
           */
          support.spliceObjects = (splice.call(object, 0, 1), !object[0]);
    
          /**
           * Detect lack of support for accessing string characters by index.
           *
           * IE < 8 can't access characters by index. IE 8 can only access characters
           * by index on string literals, not string objects.
           *
           * @memberOf _.support
           * @type boolean
           */
          support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
        }(1, 0));
    
        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB). Change the following template settings to use
         * alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        lodash.templateSettings = {
    
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'escape': reEscape,
    
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'evaluate': reEvaluate,
    
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'interpolate': reInterpolate,
    
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type string
           */
          'variable': '',
    
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type Object
           */
          'imports': {
    
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type Function
             */
            '_': lodash
          }
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = POSITIVE_INFINITY;
          this.__views__ = [];
        }
    
        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = arrayCopy(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = arrayCopy(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = arrayCopy(this.__views__);
          return result;
        }
    
        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }
    
        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
    
          if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];
    
          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
    
            var iterIndex = -1,
                value = array[index];
    
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
    
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a cache object to store key/value pairs.
         *
         * @private
         * @static
         * @name Cache
         * @memberOf _.memoize
         */
        function MapCache() {
          this.__data__ = {};
        }
    
        /**
         * Removes `key` and its value from the cache.
         *
         * @private
         * @name delete
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
         */
        function mapDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
    
        /**
         * Gets the cached value for `key`.
         *
         * @private
         * @name get
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the cached value.
         */
        function mapGet(key) {
          return key == '__proto__' ? undefined : this.__data__[key];
        }
    
        /**
         * Checks if a cached value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapHas(key) {
          return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
    
        /**
         * Sets `value` to `key` of the cache.
         *
         * @private
         * @name set
         * @memberOf _.memoize.Cache
         * @param {string} key The key of the value to cache.
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache object.
         */
        function mapSet(key, value) {
          if (key != '__proto__') {
            this.__data__[key] = value;
          }
          return this;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         *
         * Creates a cache object to store unique values.
         *
         * @private
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var length = values ? values.length : 0;
    
          this.data = { 'hash': nativeCreate(null), 'set': new Set };
          while (length--) {
            this.push(values[length]);
          }
        }
    
        /**
         * Checks if `value` is in `cache` mimicking the return signature of
         * `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache to search.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var data = cache.data,
              result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];
    
          return result ? 0 : -1;
        }
    
        /**
         * Adds `value` to the cache.
         *
         * @private
         * @name push
         * @memberOf SetCache
         * @param {*} value The value to cache.
         */
        function cachePush(value) {
          var data = this.data;
          if (typeof value == 'string' || isObject(value)) {
            data.set.add(value);
          } else {
            data.hash[value] = true;
          }
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a new array joining `array` with `other`.
         *
         * @private
         * @param {Array} array The array to join.
         * @param {Array} other The other array to join.
         * @returns {Array} Returns the new concatenated array.
         */
        function arrayConcat(array, other) {
          var index = -1,
              length = array.length,
              othIndex = -1,
              othLength = other.length,
              result = Array(length + othLength);
    
          while (++index < length) {
            result[index] = array[index];
          }
          while (++othIndex < othLength) {
            result[index++] = other[othIndex];
          }
          return result;
        }
    
        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function arrayCopy(source, array) {
          var index = -1,
              length = source.length;
    
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEach` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEachRight(array, iteratee) {
          var length = array.length;
    
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }
    
        /**
         * A specialized version of `_.every` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
         * with one argument: (value).
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function arrayExtremum(array, iteratee, comparator, exValue) {
          var index = -1,
              length = array.length,
              computed = exValue,
              result = computed;
    
          while (++index < length) {
            var value = array[index],
                current = +iteratee(value);
    
            if (comparator(current, computed)) {
              computed = current;
              result = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.filter` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
              length = array.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.map` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
              length = array.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
    
        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
              length = values.length,
              offset = array.length;
    
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
    
        /**
         * A specialized version of `_.reduce` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the first element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
          var index = -1,
              length = array.length;
    
          if (initFromArray && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initFromArray] Specify using the last element of `array`
         *  as the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
          var length = array.length;
          if (initFromArray && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }
    
        /**
         * A specialized version of `_.some` for arrays without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
    
        /**
         * A specialized version of `_.sum` for arrays without support for callback
         * shorthands and `this` binding..
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function arraySum(array, iteratee) {
          var length = array.length,
              result = 0;
    
          while (length--) {
            result += +iteratee(array[length]) || 0;
          }
          return result;
        }
    
        /**
         * Used by `_.defaults` to customize its `_.assign` use.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : objectValue;
        }
    
        /**
         * Used by `_.template` to customize its `_.assign` use.
         *
         * **Note:** This function is like `assignDefaults` except that it ignores
         * inherited property values when checking if a property is `undefined`.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @param {string} key The key associated with the object and source values.
         * @param {Object} object The destination object.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
          return (objectValue === undefined || !hasOwnProperty.call(object, key))
            ? sourceValue
            : objectValue;
        }
    
        /**
         * A specialized version of `_.assign` for customizing assigned values without
         * support for argument juggling, multiple sources, and `this` binding `customizer`
         * functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         */
        function assignWith(object, source, customizer) {
          var index = -1,
              props = keys(source),
              length = props.length;
    
          while (++index < length) {
            var key = props[index],
                value = object[key],
                result = customizer(value, source[key], key, object, source);
    
            if ((result === result ? (result !== value) : (value === value)) ||
                (value === undefined && !(key in object))) {
              object[key] = result;
            }
          }
          return object;
        }
    
        /**
         * The base implementation of `_.assign` without support for argument juggling,
         * multiple sources, and `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return source == null
            ? object
            : baseCopy(source, keys(source), object);
        }
    
        /**
         * The base implementation of `_.at` without support for string collections
         * and individual key arguments.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {number[]|string[]} props The property names or indexes of elements to pick.
         * @returns {Array} Returns the new array of picked elements.
         */
        function baseAt(collection, props) {
          var index = -1,
              isNil = collection == null,
              isArr = !isNil && isArrayLike(collection),
              length = isArr ? collection.length : 0,
              propsLength = props.length,
              result = Array(propsLength);
    
          while(++index < propsLength) {
            var key = props[index];
            if (isArr) {
              result[index] = isIndex(key, length) ? collection[key] : undefined;
            } else {
              result[index] = isNil ? undefined : collection[key];
            }
          }
          return result;
        }
    
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property names to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @returns {Object} Returns `object`.
         */
        function baseCopy(source, props, object) {
          object || (object = {});
    
          var index = -1,
              length = props.length;
    
          while (++index < length) {
            var key = props[index];
            object[key] = source[key];
          }
          return object;
        }
    
        /**
         * The base implementation of `_.callback` which supports specifying the
         * number of arguments to provide to `func`.
         *
         * @private
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function baseCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (type == 'function') {
            return thisArg === undefined
              ? func
              : bindCallback(func, thisArg, argCount);
          }
          if (func == null) {
            return identity;
          }
          if (type == 'object') {
            return baseMatches(func);
          }
          return thisArg === undefined
            ? property(func)
            : baseMatchesProperty(func, thisArg);
        }
    
        /**
         * The base implementation of `_.clone` without support for argument juggling
         * and `this` binding `customizer` functions.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The object `value` belongs to.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates clones with source counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
          var result;
          if (customizer) {
            result = object ? customizer(value, key, object) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return arrayCopy(value, result);
            }
          } else {
            var tag = objToString.call(value),
                isFunc = tag == funcTag;
    
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              if (isHostObject(value)) {
                return object ? value : {};
              }
              result = initCloneObject(isFunc ? {} : value);
              if (!isDeep) {
                return baseAssign(result, value);
              }
            } else {
              return cloneableTags[tag]
                ? initCloneByTag(value, tag, isDeep)
                : (object ? value : {});
            }
          }
          // Check for circular references and return its corresponding clone.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == value) {
              return stackB[length];
            }
          }
          // Add the source value to the stack of traversed objects and associate it with its clone.
          stackA.push(value);
          stackB.push(result);
    
          // Recursively populate clone (susceptible to call stack limits).
          (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
            result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(prototype) {
            if (isObject(prototype)) {
              object.prototype = prototype;
              var result = new object;
              object.prototype = undefined;
            }
            return result || {};
          };
        }());
    
        /**
         * The base implementation of `_.delay` and `_.defer` which accepts an index
         * of where to slice the arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Object} args The arguments provide to `func`.
         * @returns {number} Returns the timer id.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }
    
        /**
         * The base implementation of `_.difference` which accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values) {
          var length = array ? array.length : 0,
              result = [];
    
          if (!length) {
            return result;
          }
          var index = -1,
              indexOf = getIndexOf(),
              isCommon = indexOf === baseIndexOf,
              cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
              valuesLength = values.length;
    
          if (cache) {
            indexOf = cacheIndexOf;
            isCommon = false;
            values = cache;
          }
          outer:
          while (++index < length) {
            var value = array[index];
    
            if (isCommon && value === value) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === value) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (indexOf(values, value, 0) < 0) {
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.forEach` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);
    
        /**
         * The base implementation of `_.forEachRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object|string} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);
    
        /**
         * The base implementation of `_.every` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }
    
        /**
         * Gets the extremum value of `collection` invoking `iteratee` for each value
         * in `collection` to generate the criterion by which the value is ranked.
         * The `iteratee` is invoked with three arguments: (value, index|key, collection).
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(collection, iteratee, comparator, exValue) {
          var computed = exValue,
              result = computed;
    
          baseEach(collection, function(value, index, collection) {
            var current = +iteratee(value, index, collection);
            if (comparator(current, computed) || (current === exValue && current === result)) {
              computed = current;
              result = value;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end >>> 0);
          start >>>= 0;
    
          while (start < length) {
            array[start++] = value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.filter` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
         * without support for callback shorthands and `this` binding, which iterates
         * over `collection` using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @param {boolean} [retKey] Specify returning the key of the found element
         *  instead of the element itself.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFind(collection, predicate, eachFunc, retKey) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = retKey ? key : value;
              return false;
            }
          });
          return result;
        }
    
        /**
         * The base implementation of `_.flatten` with added support for restricting
         * flattening and specifying the start index.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, isDeep, isStrict, result) {
          result || (result = []);
    
          var index = -1,
              length = array.length;
    
          while (++index < length) {
            var value = array[index];
            if (isObjectLike(value) && isArrayLike(value) &&
                (isStrict || isArray(value) || isArguments(value))) {
              if (isDeep) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, isDeep, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `baseForIn` and `baseForOwn` which iterates
         * over `object` properties returned by `keysFunc` invoking `iteratee` for
         * each property. Iteratee functions may exit iteration early by explicitly
         * returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();
    
        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);
    
        /**
         * The base implementation of `_.forIn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForIn(object, iteratee) {
          return baseFor(object, iteratee, keysIn);
        }
    
        /**
         * The base implementation of `_.forOwn` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return baseFor(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.forOwnRight` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return baseForRight(object, iteratee, keys);
        }
    
        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from those provided.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the new array of filtered property names.
         */
        function baseFunctions(object, props) {
          var index = -1,
              length = props.length,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var key = props[index];
            if (isFunction(object[key])) {
              result[++resIndex] = key;
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `get` without support for string paths
         * and default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path of the property to get.
         * @param {string} [pathKey] The key representation of path.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path, pathKey) {
          if (object == null) {
            return;
          }
          object = toObject(object);
          if (pathKey !== undefined && pathKey in object) {
            path = [pathKey];
          }
          var index = 0,
              length = path.length;
    
          while (object != null && index < length) {
            object = toObject(object)[path[index++]];
          }
          return (index && index == length) ? object : undefined;
        }
    
        /**
         * The base implementation of `_.isEqual` without support for `this` binding
         * `customizer` functions.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
    
        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `value` objects.
         * @param {Array} [stackB=[]] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = arrayTag,
              othTag = arrayTag;
    
          if (!objIsArr) {
            objTag = objToString.call(object);
            if (objTag == argsTag) {
              objTag = objectTag;
            } else if (objTag != objectTag) {
              objIsArr = isTypedArray(object);
            }
          }
          if (!othIsArr) {
            othTag = objToString.call(other);
            if (othTag == argsTag) {
              othTag = objectTag;
            } else if (othTag != objectTag) {
              othIsArr = isTypedArray(other);
            }
          }
          var objIsObj = objTag == objectTag && !isHostObject(object),
              othIsObj = othTag == objectTag && !isHostObject(other),
              isSameTag = objTag == othTag;
    
          if (isSameTag && !(objIsArr || objIsObj)) {
            return equalByTag(object, other, objTag);
          }
          if (!isLoose) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
    
            if (objIsWrapped || othIsWrapped) {
              return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
            }
          }
          if (!isSameTag) {
            return false;
          }
          // Assume cyclic values are equal.
          // For more information on detecting circular references see https://es5.github.io/#JO.
          stackA || (stackA = []);
          stackB || (stackB = []);
    
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == object) {
              return stackB[length] == other;
            }
          }
          // Add `object` and `other` to the stack of traversed objects.
          stackA.push(object);
          stackB.push(other);
    
          var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
    
          stackA.pop();
          stackB.pop();
    
          return result;
        }
    
        /**
         * The base implementation of `_.isMatch` without support for callback
         * shorthands and `this` binding.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} matchData The propery names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparing objects.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
    
          if (object == null) {
            return !length;
          }
          object = toObject(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];
    
            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              var result = customizer ? customizer(objValue, srcValue, key) : undefined;
              if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
                return false;
              }
            }
          }
          return true;
        }
    
        /**
         * The base implementation of `_.map` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }
    
        /**
         * The base implementation of `_.matches` which does not clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            var key = matchData[0][0],
                value = matchData[0][1];
    
            return function(object) {
              if (object == null) {
                return false;
              }
              object = toObject(object);
              return object[key] === value && (value !== undefined || (key in object));
            };
          }
          return function(object) {
            return baseIsMatch(object, matchData);
          };
        }
    
        /**
         * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to compare.
         * @returns {Function} Returns the new function.
         */
        function baseMatchesProperty(path, srcValue) {
          var isArr = isArray(path),
              isCommon = isKey(path) && isStrictComparable(srcValue),
              pathKey = (path + '');
    
          path = toPath(path);
          return function(object) {
            if (object == null) {
              return false;
            }
            var key = pathKey;
            object = toObject(object);
            if ((isArr || !isCommon) && !(key in object)) {
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              if (object == null) {
                return false;
              }
              key = last(path);
              object = toObject(object);
            }
            return object[key] === srcValue
              ? (srcValue !== undefined || (key in object))
              : baseIsEqual(srcValue, object[key], undefined, true);
          };
        }
    
        /**
         * The base implementation of `_.merge` without support for argument juggling,
         * multiple sources, and `this` binding `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {Object} Returns `object`.
         */
        function baseMerge(object, source, customizer, stackA, stackB) {
          if (!isObject(object)) {
            return object;
          }
          var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
              props = isSrcArr ? undefined : keys(source);
    
          arrayEach(props || source, function(srcValue, key) {
            if (props) {
              key = srcValue;
              srcValue = source[key];
            }
            if (isObjectLike(srcValue)) {
              stackA || (stackA = []);
              stackB || (stackB = []);
              baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
            }
            else {
              var value = object[key],
                  result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
                  isCommon = result === undefined;
    
              if (isCommon) {
                result = srcValue;
              }
              if ((result !== undefined || (isSrcArr && !(key in object))) &&
                  (isCommon || (result === result ? (result !== value) : (value === value)))) {
                object[key] = result;
              }
            }
          });
          return object;
        }
    
        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Array} [stackA=[]] Tracks traversed source objects.
         * @param {Array} [stackB=[]] Associates values with source counterparts.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
          var length = stackA.length,
              srcValue = source[key];
    
          while (length--) {
            if (stackA[length] == srcValue) {
              object[key] = stackB[length];
              return;
            }
          }
          var value = object[key],
              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
              isCommon = result === undefined;
    
          if (isCommon) {
            result = srcValue;
            if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
              result = isArray(value)
                ? value
                : (isArrayLike(value) ? arrayCopy(value) : []);
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              result = isArguments(value)
                ? toPlainObject(value)
                : (isPlainObject(value) ? value : {});
            }
            else {
              isCommon = false;
            }
          }
          // Add the source value to the stack of traversed objects and associate
          // it with its merged value.
          stackA.push(srcValue);
          stackB.push(result);
    
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
          } else if (result === result ? (result !== value) : (value === value)) {
            object[key] = result;
          }
        }
    
        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new function.
         */
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined : toObject(object)[key];
          };
        }
    
        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         */
        function basePropertyDeep(path) {
          var pathKey = (path + '');
          path = toPath(path);
          return function(object) {
            return baseGet(object, path, pathKey);
          };
        }
    
        /**
         * The base implementation of `_.pullAt` without support for individual
         * index arguments and capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0;
          while (length--) {
            var index = indexes[length];
            if (index != previous && isIndex(index)) {
              var previous = index;
              splice.call(array, index, 1);
            }
          }
          return array;
        }
    
        /**
         * The base implementation of `_.random` without support for argument juggling
         * and returning floating-point numbers.
         *
         * @private
         * @param {number} min The minimum possible value.
         * @param {number} max The maximum possible value.
         * @returns {number} Returns the random number.
         */
        function baseRandom(min, max) {
          return min + nativeFloor(nativeRandom() * (max - min + 1));
        }
    
        /**
         * The base implementation of `_.reduce` and `_.reduceRight` without support
         * for callback shorthands and `this` binding, which iterates over `collection`
         * using the provided `eachFunc`.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initFromCollection Specify using the first or last element
         *  of `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initFromCollection
              ? (initFromCollection = false, value)
              : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
    
        /**
         * The base implementation of `setData` without support for hot loop detection.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
    
        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;
    
          start = start == null ? 0 : (+start || 0);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined || end > length) ? length : (+end || 0);
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;
    
          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.some` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;
    
          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }
    
        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define
         * the sort order of `array` and replaces criteria objects with their
         * corresponding values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length;
    
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }
    
        /**
         * The base implementation of `_.sortByOrder` without param guards.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseSortByOrder(collection, iteratees, orders) {
          var callback = getCallback(),
              index = -1;
    
          iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });
    
          var result = baseMap(collection, function(value) {
            var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });
    
          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
    
        /**
         * The base implementation of `_.sum` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function baseSum(collection, iteratee) {
          var result = 0;
          baseEach(collection, function(value, index, collection) {
            result += +iteratee(value, index, collection) || 0;
          });
          return result;
        }
    
        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * and `this` binding.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The function invoked per iteration.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array.length,
              isCommon = indexOf === baseIndexOf,
              isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
              seen = isLarge ? createCache() : null,
              result = [];
    
          if (seen) {
            indexOf = cacheIndexOf;
            isCommon = false;
          } else {
            isLarge = false;
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value, index, array) : value;
    
            if (isCommon && value === value) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (indexOf(seen, computed, 0) < 0) {
              if (iteratee || isLarge) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
    
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
          var index = -1,
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
    
        /**
         * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
         * and `_.takeWhile` without support for callback shorthands and `this` binding.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;
    
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }
    
        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to peform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          var index = -1,
              length = actions.length;
    
          while (++index < length) {
            var action = actions[index];
            result = action.func.apply(action.thisArg, arrayPush([result], action.args));
          }
          return result;
        }
    
        /**
         * Performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndex(array, value, retHighest) {
          var low = 0,
              high = array ? array.length : low;
    
          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];
    
              if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return binaryIndexBy(array, value, identity, retHighest);
        }
    
        /**
         * This function is like `binaryIndex` except that it invokes `iteratee` for
         * `value` and each element of `array` to compute their sort ranking. The
         * iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function binaryIndexBy(array, value, iteratee, retHighest) {
          value = iteratee(value);
    
          var low = 0,
              high = array ? array.length : 0,
              valIsNaN = value !== value,
              valIsNull = value === null,
              valIsUndef = value === undefined;
    
          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                isDef = computed !== undefined,
                isReflexive = computed === computed;
    
            if (valIsNaN) {
              var setLow = isReflexive || retHighest;
            } else if (valIsNull) {
              setLow = isReflexive && isDef && (retHighest || computed != null);
            } else if (valIsUndef) {
              setLow = isReflexive && (retHighest || isDef);
            } else if (computed == null) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
    
        /**
         * A specialized version of `baseCallback` which only supports `this` binding
         * and specifying the number of arguments to provide to `func`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {number} [argCount] The number of arguments to provide to `func`.
         * @returns {Function} Returns the callback.
         */
        function bindCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          if (thisArg === undefined) {
            return func;
          }
          switch (argCount) {
            case 1: return function(value) {
              return func.call(thisArg, value);
            };
            case 3: return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
            case 5: return function(value, other, key, object, source) {
              return func.call(thisArg, value, other, key, object, source);
            };
          }
          return function() {
            return func.apply(thisArg, arguments);
          };
        }
    
        /**
         * Creates a clone of the given array buffer.
         *
         * @private
         * @param {ArrayBuffer} buffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function bufferClone(buffer) {
          var result = new ArrayBuffer(buffer.byteLength),
              view = new Uint8Array(result);
    
          view.set(new Uint8Array(buffer));
          return result;
        }
    
        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders) {
          var holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              leftIndex = -1,
              leftLength = partials.length,
              result = Array(leftLength + argsLength);
    
          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
          while (argsLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array|Object} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders) {
          var holdersIndex = -1,
              holdersLength = holders.length,
              argsIndex = -1,
              argsLength = nativeMax(args.length - holdersLength, 0),
              rightIndex = -1,
              rightLength = partials.length,
              result = Array(argsLength + rightLength);
    
          while (++argsIndex < argsLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
          return result;
        }
    
        /**
         * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
         *
         * @private
         * @param {Function} setter The function to set keys and values of the accumulator object.
         * @param {Function} [initializer] The function to initialize the accumulator object.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee, thisArg) {
            var result = initializer ? initializer() : {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
    
              while (++index < length) {
                var value = collection[index];
                setter(result, value, iteratee(value, index, collection), collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                setter(result, value, iteratee(value, key, collection), collection);
              });
            }
            return result;
          };
        }
    
        /**
         * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return restParam(function(object, sources) {
            var index = -1,
                length = object == null ? 0 : sources.length,
                customizer = length > 2 ? sources[length - 2] : undefined,
                guard = length > 2 ? sources[2] : undefined,
                thisArg = length > 1 ? sources[length - 1] : undefined;
    
            if (typeof customizer == 'function') {
              customizer = bindCallback(customizer, thisArg, 5);
              length -= 2;
            } else {
              customizer = typeof thisArg == 'function' ? thisArg : undefined;
              length -= (customizer ? 1 : 0);
            }
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, customizer);
              }
            }
            return object;
          });
        }
    
        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
              return eachFunc(collection, iteratee);
            }
            var index = fromRight ? length : -1,
                iterable = toObject(collection);
    
            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
    
        /**
         * Creates a base function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var iterable = toObject(object),
                props = keysFunc(object),
                length = props.length,
                index = fromRight ? length : -1;
    
            while ((fromRight ? index-- : ++index < length)) {
              var key = props[index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to bind.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new bound function.
         */
        function createBindWrapper(func, thisArg) {
          var Ctor = createCtorWrapper(func);
    
          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(thisArg, arguments);
          }
          return wrapper;
        }
    
        /**
         * Creates a `Set` cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [values] The values to cache.
         * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
         */
        function createCache(values) {
          return (nativeCreate && Set) ? new SetCache(values) : null;
        }
    
        /**
         * Creates a function that produces compound words out of the words in a
         * given string.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            var index = -1,
                array = words(deburr(string)),
                length = array.length,
                result = '';
    
            while (++index < length) {
              result = callback(result, array[index], index);
            }
            return result;
          };
        }
    
        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtorWrapper(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors.
            // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);
    
            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }
    
        /**
         * Creates a `_.curry` or `_.curryRight` function.
         *
         * @private
         * @param {boolean} flag The curry bit flag.
         * @returns {Function} Returns the new curry function.
         */
        function createCurry(flag) {
          function curryFunc(func, arity, guard) {
            if (guard && isIterateeCall(func, arity, guard)) {
              arity = undefined;
            }
            var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryFunc.placeholder;
            return result;
          }
          return curryFunc;
        }
    
        /**
         * Creates a `_.defaults` or `_.defaultsDeep` function.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Function} Returns the new defaults function.
         */
        function createDefaults(assigner, customizer) {
          return restParam(function(args) {
            var object = args[0];
            if (object == null) {
              return object;
            }
            args.push(customizer);
            return assigner.apply(undefined, args);
          });
        }
    
        /**
         * Creates a `_.max` or `_.min` function.
         *
         * @private
         * @param {Function} comparator The function used to compare values.
         * @param {*} exValue The initial extremum value.
         * @returns {Function} Returns the new extremum function.
         */
        function createExtremum(comparator, exValue) {
          return function(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
              iteratee = undefined;
            }
            iteratee = getCallback(iteratee, thisArg, 3);
            if (iteratee.length == 1) {
              collection = isArray(collection) ? collection : toIterable(collection);
              var result = arrayExtremum(collection, iteratee, comparator, exValue);
              if (!(collection.length && result === exValue)) {
                return result;
              }
            }
            return baseExtremum(collection, iteratee, comparator, exValue);
          };
        }
    
        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFind(eachFunc, fromRight) {
          return function(collection, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            if (isArray(collection)) {
              var index = baseFindIndex(collection, predicate, fromRight);
              return index > -1 ? collection[index] : undefined;
            }
            return baseFind(collection, predicate, eachFunc);
          };
        }
    
        /**
         * Creates a `_.findIndex` or `_.findLastIndex` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new find function.
         */
        function createFindIndex(fromRight) {
          return function(array, predicate, thisArg) {
            if (!(array && array.length)) {
              return -1;
            }
            predicate = getCallback(predicate, thisArg, 3);
            return baseFindIndex(array, predicate, fromRight);
          };
        }
    
        /**
         * Creates a `_.findKey` or `_.findLastKey` function.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new find function.
         */
        function createFindKey(objectFunc) {
          return function(object, predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 3);
            return baseFind(object, predicate, objectFunc, true);
          };
        }
    
        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return function() {
            var wrapper,
                length = arguments.length,
                index = fromRight ? length : -1,
                leftIndex = 0,
                funcs = Array(length);
    
            while ((fromRight ? index-- : ++index < length)) {
              var func = funcs[leftIndex++] = arguments[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
                wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? -1 : length;
            while (++index < length) {
              func = funcs[index];
    
              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
    
              if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];
    
              if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
    
              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          };
        }
    
        /**
         * Creates a function for `_.forEach` or `_.forEachRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createForEach(arrayFunc, eachFunc) {
          return function(collection, iteratee, thisArg) {
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee)
              : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
          };
        }
    
        /**
         * Creates a function for `_.forIn` or `_.forInRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForIn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee, keysIn);
          };
        }
    
        /**
         * Creates a function for `_.forOwn` or `_.forOwnRight`.
         *
         * @private
         * @param {Function} objectFunc The function to iterate over an object.
         * @returns {Function} Returns the new each function.
         */
        function createForOwn(objectFunc) {
          return function(object, iteratee, thisArg) {
            if (typeof iteratee != 'function' || thisArg !== undefined) {
              iteratee = bindCallback(iteratee, thisArg, 3);
            }
            return objectFunc(object, iteratee);
          };
        }
    
        /**
         * Creates a function for `_.mapKeys` or `_.mapValues`.
         *
         * @private
         * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
         * @returns {Function} Returns the new map function.
         */
        function createObjectMapper(isMapKeys) {
          return function(object, iteratee, thisArg) {
            var result = {};
            iteratee = getCallback(iteratee, thisArg, 3);
    
            baseForOwn(object, function(value, key, object) {
              var mapped = iteratee(value, key, object);
              key = isMapKeys ? mapped : key;
              value = isMapKeys ? value : mapped;
              result[key] = value;
            });
            return result;
          };
        }
    
        /**
         * Creates a function for `_.padLeft` or `_.padRight`.
         *
         * @private
         * @param {boolean} [fromRight] Specify padding from the right.
         * @returns {Function} Returns the new pad function.
         */
        function createPadDir(fromRight) {
          return function(string, length, chars) {
            string = baseToString(string);
            return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
          };
        }
    
        /**
         * Creates a `_.partial` or `_.partialRight` function.
         *
         * @private
         * @param {boolean} flag The partial bit flag.
         * @returns {Function} Returns the new partial function.
         */
        function createPartial(flag) {
          var partialFunc = restParam(function(func, partials) {
            var holders = replaceHolders(partials, partialFunc.placeholder);
            return createWrapper(func, flag, undefined, partials, holders);
          });
          return partialFunc;
        }
    
        /**
         * Creates a function for `_.reduce` or `_.reduceRight`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over an array.
         * @param {Function} eachFunc The function to iterate over a collection.
         * @returns {Function} Returns the new each function.
         */
        function createReduce(arrayFunc, eachFunc) {
          return function(collection, iteratee, accumulator, thisArg) {
            var initFromArray = arguments.length < 3;
            return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
              ? arrayFunc(collection, iteratee, accumulator, initFromArray)
              : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
          };
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with optional `this`
         * binding of, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & ARY_FLAG,
              isBind = bitmask & BIND_FLAG,
              isBindKey = bitmask & BIND_KEY_FLAG,
              isCurry = bitmask & CURRY_FLAG,
              isCurryBound = bitmask & CURRY_BOUND_FLAG,
              isCurryRight = bitmask & CURRY_RIGHT_FLAG,
              Ctor = isBindKey ? undefined : createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it to other functions.
            var length = arguments.length,
                index = length,
                args = Array(length);
    
            while (index--) {
              args[index] = arguments[index];
            }
            if (partials) {
              args = composeArgs(args, partials, holders);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight);
            }
            if (isCurry || isCurryRight) {
              var placeholder = wrapper.placeholder,
                  argsHolders = replaceHolders(args, placeholder);
    
              length -= argsHolders.length;
              if (length < arity) {
                var newArgPos = argPos ? arrayCopy(argPos) : undefined,
                    newArity = nativeMax(arity - length, 0),
                    newsHolders = isCurry ? argsHolders : undefined,
                    newHoldersRight = isCurry ? undefined : argsHolders,
                    newPartials = isCurry ? args : undefined,
                    newPartialsRight = isCurry ? undefined : args;
    
                bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
                bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
    
                if (!isCurryBound) {
                  bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                }
                var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
                    result = createHybridWrapper.apply(undefined, newData);
    
                if (isLaziable(func)) {
                  setData(result, newData);
                }
                result.placeholder = placeholder;
                return result;
              }
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
    
            if (argPos) {
              args = reorder(args, argPos);
            }
            if (isAry && ary < args.length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtorWrapper(func);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
    
        /**
         * Creates the padding required for `string` based on the given `length`.
         * The `chars` string is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {string} string The string to create padding for.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the pad for `string`.
         */
        function createPadding(string, length, chars) {
          var strLength = string.length;
          length = +length;
    
          if (strLength >= length || !nativeIsFinite(length)) {
            return '';
          }
          var padLength = length - strLength;
          chars = chars == null ? ' ' : (chars + '');
          return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
        }
    
        /**
         * Creates a function that wraps `func` and invokes it with the optional `this`
         * binding of `thisArg` and the `partials` prepended to those provided to
         * the wrapper.
         *
         * @private
         * @param {Function} func The function to partially apply arguments to.
         * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to the new function.
         * @returns {Function} Returns the new bound function.
         */
        function createPartialWrapper(func, bitmask, thisArg, partials) {
          var isBind = bitmask & BIND_FLAG,
              Ctor = createCtorWrapper(func);
    
          function wrapper() {
            // Avoid `arguments` object use disqualifying optimizations by
            // converting it to an array before providing it `func`.
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength);
    
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, args);
          }
          return wrapper;
        }
    
        /**
         * Creates a `_.ceil`, `_.floor`, or `_.round` function.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            precision = precision === undefined ? 0 : (+precision || 0);
            if (precision) {
              precision = pow(10, precision);
              return func(number * precision) / precision;
            }
            return func(number);
          };
        }
    
        /**
         * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
         *
         * @private
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {Function} Returns the new index function.
         */
        function createSortedIndex(retHighest) {
          return function(array, value, iteratee, thisArg) {
            var callback = getCallback(iteratee);
            return (iteratee == null && callback === baseCallback)
              ? binaryIndex(array, value, retHighest)
              : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
          };
        }
    
        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of flags.
         *  The bitmask may be composed of the following flags:
         *     1 - `_.bind`
         *     2 - `_.bindKey`
         *     4 - `_.curry` or `_.curryRight` of a bound function
         *     8 - `_.curry`
         *    16 - `_.curryRight`
         *    32 - `_.partial`
         *    64 - `_.partialRight`
         *   128 - `_.rearg`
         *   256 - `_.ary`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          length -= (holders ? holders.length : 0);
          if (bitmask & PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;
    
            partials = holders = undefined;
          }
          var data = isBindKey ? undefined : getData(func),
              newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
    
          if (data) {
            mergeData(newData, data);
            bitmask = newData[1];
            arity = newData[9];
          }
          newData[9] = arity == null
            ? (isBindKey ? 0 : func.length)
            : (nativeMax(arity - length, 0) || 0);
    
          if (bitmask == BIND_FLAG) {
            var result = createBindWrapper(newData[0], newData[2]);
          } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
            result = createPartialWrapper.apply(undefined, newData);
          } else {
            result = createHybridWrapper.apply(undefined, newData);
          }
          var setter = data ? baseSetData : setData;
          return setter(result, newData);
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing arrays.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var index = -1,
              arrLength = array.length,
              othLength = other.length;
    
          if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
            return false;
          }
          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index],
                result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
    
            if (result !== undefined) {
              if (result) {
                continue;
              }
              return false;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (isLoose) {
              if (!arraySome(other, function(othValue) {
                    return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                  })) {
                return false;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag) {
          switch (tag) {
            case boolTag:
            case dateTag:
              // Coerce dates and booleans to numbers, dates to milliseconds and booleans
              // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
              return +object == +other;
    
            case errorTag:
              return object.name == other.name && object.message == other.message;
    
            case numberTag:
              // Treat `NaN` vs. `NaN` as equal.
              return (object != +object)
                ? other != +other
                : object == +other;
    
            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings primitives and string
              // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
              return object == (other + '');
          }
          return false;
        }
    
        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Function} [customizer] The function to customize comparing values.
         * @param {boolean} [isLoose] Specify performing partial comparisons.
         * @param {Array} [stackA] Tracks traversed `value` objects.
         * @param {Array} [stackB] Tracks traversed `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
          var objProps = keys(object),
              objLength = objProps.length,
              othProps = keys(other),
              othLength = othProps.length;
    
          if (objLength != othLength && !isLoose) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var skipCtor = isLoose;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key],
                result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
    
            // Recursively compare objects (susceptible to call stack limits).
            if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
              return false;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (!skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;
    
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              return false;
            }
          }
          return true;
        }
    
        /**
         * Gets the appropriate "callback" function. If the `_.callback` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseCallback` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function} Returns the chosen function or its result.
         */
        function getCallback(func, thisArg, argCount) {
          var result = lodash.callback || callback;
          result = result === callback ? baseCallback : result;
          return argCount ? result(func, thisArg, argCount) : result;
        }
    
        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
    
        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = array ? array.length : 0;
    
          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }
    
        /**
         * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
         * customized this function returns the custom method, otherwise it returns
         * the `baseIndexOf` function. If arguments are provided the chosen function
         * is invoked with them and its result is returned.
         *
         * @private
         * @returns {Function|number} Returns the chosen function or its result.
         */
        function getIndexOf(collection, target, fromIndex) {
          var result = lodash.indexOf || indexOf;
          result = result === indexOf ? baseIndexOf : result;
          return collection ? result(collection, target, fromIndex) : result;
        }
    
        /**
         * Gets the "length" property value of `object`.
         *
         * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
         * that affects Safari on at least iOS 8.1-8.3 ARM64.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {*} Returns the "length" value.
         */
        var getLength = baseProperty('length');
    
        /**
         * Gets the propery names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = pairs(object),
              length = result.length;
    
          while (length--) {
            result[length][2] = isStrictComparable(result[length][1]);
          }
          return result;
        }
    
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = object == null ? undefined : object[key];
          return isNative(value) ? value : undefined;
        }
    
        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;
    
          while (++index < length) {
            var data = transforms[index],
                size = data.size;
    
            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }
    
        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);
    
          // Add array properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
    
        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          var Ctor = object.constructor;
          if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
            Ctor = Object;
          }
          return new Ctor;
        }
    
        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return bufferClone(object);
    
            case boolTag:
            case dateTag:
              return new Ctor(+object);
    
            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.
              if (Ctor instanceof Ctor) {
                Ctor = ctorByTag[tag];
              }
              var buffer = object.buffer;
              return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
    
            case numberTag:
            case stringTag:
              return new Ctor(object);
    
            case regexpTag:
              var result = new Ctor(object.source, reFlags.exec(object));
              result.lastIndex = object.lastIndex;
          }
          return result;
        }
    
        /**
         * Invokes the method at `path` on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function invokePath(object, path, args) {
          if (object != null && !isKey(path, object)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            path = last(path);
          }
          var func = object == null ? object : object[path];
          return func == null ? undefined : func.apply(object, args);
        }
    
        /**
         * Checks if `value` is array-like.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         */
        function isArrayLike(value) {
          return value != null && isLength(getLength(value));
        }
    
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return value > -1 && value % 1 == 0 && value < length;
        }
    
        /**
         * Checks if the provided arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)) {
            var other = object[index];
            return value === value ? (value === other) : (other !== other);
          }
          return false;
        }
    
        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          var type = typeof value;
          if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
            return true;
          }
          if (isArray(value)) {
            return false;
          }
          var result = !reIsDeepProp.test(value);
          return result || (object != null && value in toObject(object));
        }
    
        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];
    
          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
    
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
    
        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
    
        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers required to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
         * augment function arguments, making the order in which they are executed important,
         * preventing the merging of metadata. However, we make an exception for a safe
         * common case where curried functions have `_.ary` and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < ARY_FLAG;
    
          var isCombo =
            (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
            (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
            (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);
    
          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = arrayCopy(value);
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;
    
          return data;
        }
    
        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use.
         *
         * @private
         * @param {*} objectValue The destination object property value.
         * @param {*} sourceValue The source object property value.
         * @returns {*} Returns the value to assign to the destination object.
         */
        function mergeDefaults(objectValue, sourceValue) {
          return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties specified
         * by `props`.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} props The property names to pick.
         * @returns {Object} Returns the new object.
         */
        function pickByArray(object, props) {
          object = toObject(object);
    
          var index = -1,
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
    
        /**
         * A specialized version of `_.pick` which picks `object` properties `predicate`
         * returns truthy for.
         *
         * @private
         * @param {Object} object The source object.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Object} Returns the new object.
         */
        function pickByCallback(object, predicate) {
          var result = {};
          baseForIn(object, function(value, key, object) {
            if (predicate(value, key, object)) {
              result[key] = value;
            }
          });
          return result;
        }
    
        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = arrayCopy(array);
    
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }
    
        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity function
         * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = (function() {
          var count = 0,
              lastCalled = 0;
    
          return function(key, value) {
            var stamp = now(),
                remaining = HOT_SPAN - (stamp - lastCalled);
    
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return key;
              }
            } else {
              count = 0;
            }
            return baseSetData(key, value);
          };
        }());
    
        /**
         * A fallback implementation of `Object.keys` which creates an array of the
         * own enumerable property names of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function shimKeys(object) {
          var props = keysIn(object),
              propsLength = props.length,
              length = propsLength && object.length;
    
          var allowIndexes = !!length && isLength(length) &&
            (isArray(object) || isArguments(object) || isString(object));
    
          var index = -1,
              result = [];
    
          while (++index < propsLength) {
            var key = props[index];
            if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
              result.push(key);
            }
          }
          return result;
        }
    
        /**
         * Converts `value` to an array-like object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array|Object} Returns the array-like object.
         */
        function toIterable(value) {
          if (value == null) {
            return [];
          }
          if (!isArrayLike(value)) {
            return values(value);
          }
          if (lodash.support.unindexedChars && isString(value)) {
            return value.split('');
          }
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to an object if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Object} Returns the object.
         */
        function toObject(value) {
          if (lodash.support.unindexedChars && isString(value)) {
            var index = -1,
                length = value.length,
                result = Object(value);
    
            while (++index < length) {
              result[index] = value.charAt(index);
            }
            return result;
          }
          return isObject(value) ? value : Object(value);
        }
    
        /**
         * Converts `value` to property path array if it's not one.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {Array} Returns the property path array.
         */
        function toPath(value) {
          if (isArray(value)) {
            return value;
          }
          var result = [];
          baseToString(value).replace(rePropName, function(match, number, quote, string) {
            result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        }
    
        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          return wrapper instanceof LazyWrapper
            ? wrapper.clone()
            : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `collection` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new array containing chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size == null) {
            size = 1;
          } else {
            size = nativeMax(nativeFloor(size) || 1, 1);
          }
          var index = 0,
              length = array ? array.length : 0,
              resIndex = -1,
              result = Array(nativeCeil(length / size));
    
          while (index < length) {
            result[++resIndex] = baseSlice(array, index, (index += size));
          }
          return result;
        }
    
        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              resIndex = -1,
              result = [];
    
          while (++index < length) {
            var value = array[index];
            if (value) {
              result[++resIndex] = value;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of unique `array` values not included in the other
         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The arrays of values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.difference([1, 2, 3], [4, 2]);
         * // => [1, 3]
         */
        var difference = restParam(function(array, values) {
          return (isObjectLike(array) && isArrayLike(array))
            ? baseDifference(array, baseFlatten(values, false, true))
            : [];
        });
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that match the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [1]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
         * // => ['barney']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropRightWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.dropWhile(users, 'active', false), 'user');
         * // => ['pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.dropWhile(users, 'active'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
            : [];
        }
    
        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8], '*', 1, 2);
         * // => [4, '*', 8]
         */
        function fill(array, value, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
    
        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(chr) {
         *   return chr.user == 'barney';
         * });
         * // => 0
         *
         * // using the `_.matches` callback shorthand
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findIndex(users, 'active', false);
         * // => 0
         *
         * // using the `_.property` callback shorthand
         * _.findIndex(users, 'active');
         * // => 2
         */
        var findIndex = createFindIndex();
    
        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(chr) {
         *   return chr.user == 'pebbles';
         * });
         * // => 2
         *
         * // using the `_.matches` callback shorthand
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastIndex(users, 'active', false);
         * // => 2
         *
         * // using the `_.property` callback shorthand
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        var findLastIndex = createFindIndex(true);
    
        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias head
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.first([1, 2, 3]);
         * // => 1
         *
         * _.first([]);
         * // => undefined
         */
        function first(array) {
          return array ? array[0] : undefined;
        }
    
        /**
         * Flattens a nested array. If `isDeep` is `true` the array is recursively
         * flattened, otherwise it's only flattened a single level.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {boolean} [isDeep] Specify a deep flatten.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, 3, [4]]]);
         * // => [1, 2, 3, [4]]
         *
         * // using `isDeep`
         * _.flatten([1, [2, 3, [4]]], true);
         * // => [1, 2, 3, 4]
         */
        function flatten(array, isDeep, guard) {
          var length = array ? array.length : 0;
          if (guard && isIterateeCall(array, isDeep, guard)) {
            isDeep = false;
          }
          return length ? baseFlatten(array, isDeep) : [];
        }
    
        /**
         * Recursively flattens a nested array.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to recursively flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, 3, [4]]]);
         * // => [1, 2, 3, 4]
         */
        function flattenDeep(array) {
          var length = array ? array.length : 0;
          return length ? baseFlatten(array, true) : [];
        }
    
        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the offset
         * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
         * performs a faster binary search.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=0] The index to search from or `true`
         *  to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // using `fromIndex`
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         *
         * // performing a binary search
         * _.indexOf([1, 1, 2, 2], 2, true);
         * // => 2
         */
        function indexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          if (typeof fromIndex == 'number') {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
          } else if (fromIndex) {
            var index = binaryIndex(array, value);
            if (index < length &&
                (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
              return index;
            }
            return -1;
          }
          return baseIndexOf(array, value, fromIndex || 0);
        }
    
        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          return dropRight(array, 1);
        }
    
        /**
         * Creates an array of unique values that are included in all of the provided
         * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of shared values.
         * @example
         * _.intersection([1, 2], [4, 2], [2, 1]);
         * // => [2]
         */
        var intersection = restParam(function(arrays) {
          var othLength = arrays.length,
              othIndex = othLength,
              caches = Array(length),
              indexOf = getIndexOf(),
              isCommon = indexOf === baseIndexOf,
              result = [];
    
          while (othIndex--) {
            var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
            caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
          }
          var array = arrays[0],
              index = -1,
              length = array ? array.length : 0,
              seen = caches[0];
    
          outer:
          while (++index < length) {
            value = array[index];
            if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
              var othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(value);
              }
              result.push(value);
            }
          }
          return result;
        });
    
        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array ? array.length : 0;
          return length ? array[length - 1] : undefined;
        }
    
        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=array.length-1] The index to search from
         *  or `true` to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // using `fromIndex`
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         *
         * // performing a binary search
         * _.lastIndexOf([1, 1, 2, 2], 2, true);
         * // => 3
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array ? array.length : 0;
          if (!length) {
            return -1;
          }
          var index = length;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
          } else if (fromIndex) {
            index = binaryIndex(array, value, true) - 1;
            var other = array[index];
            if (value === value ? (value === other) : (other !== other)) {
              return index;
            }
            return -1;
          }
          if (value !== value) {
            return indexOfNaN(array, index, true);
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
    
        /**
         * Removes all provided values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3, 1, 2, 3];
         *
         * _.pull(array, 2, 3);
         * console.log(array);
         * // => [1, 1]
         */
        function pull() {
          var args = arguments,
              array = args[0];
    
          if (!(array && array.length)) {
            return array;
          }
          var index = 0,
              indexOf = getIndexOf(),
              length = args.length;
    
          while (++index < length) {
            var fromIndex = 0,
                value = args[index];
    
            while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
    
        /**
         * Removes elements from `array` corresponding to the given indexes and returns
         * an array of the removed elements. Indexes may be specified as an array of
         * indexes or as individual arguments.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [5, 10, 15, 20];
         * var evens = _.pullAt(array, 1, 3);
         *
         * console.log(array);
         * // => [5, 15]
         *
         * console.log(evens);
         * // => [10, 20]
         */
        var pullAt = restParam(function(array, indexes) {
          indexes = baseFlatten(indexes);
    
          var result = baseAt(array, indexes);
          basePullAt(array, indexes.sort(baseCompareAscending));
          return result;
        });
    
        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate, thisArg) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;
    
          predicate = getCallback(predicate, thisArg, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }
    
        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @alias tail
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.rest([1, 2, 3]);
         * // => [2, 3]
         */
        function rest(array) {
          return drop(array, 1);
        }
    
        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of `Array#slice` to support node
         * lists in IE < 9 and to ensure dense arrays are returned.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          return baseSlice(array, start, end);
        }
    
        /**
         * Uses a binary search to determine the lowest index at which `value` should
         * be inserted into `array` in order to maintain its sort order. If an iteratee
         * function is provided it's invoked for `value` and each element of `array`
         * to compute their sort ranking. The iteratee is bound to `thisArg` and
         * invoked with one argument; (value).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         *
         * _.sortedIndex([4, 4, 5, 5], 5);
         * // => 2
         *
         * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
         *
         * // using an iteratee function
         * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
         *   return this.data[word];
         * }, dict);
         * // => 1
         *
         * // using the `_.property` callback shorthand
         * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
         * // => 1
         */
        var sortedIndex = createSortedIndex();
    
        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 4, 5, 5], 5);
         * // => 4
         */
        var sortedLastIndex = createSortedIndex(true);
    
        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (guard ? isIterateeCall(array, n, guard) : n == null) {
            n = 1;
          }
          n = length - (+n || 0);
          return baseSlice(array, n < 0 ? 0 : n);
        }
    
        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
         * and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRightWhile([1, 2, 3], function(n) {
         *   return n > 1;
         * });
         * // => [2, 3]
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
         * // => ['pebbles']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
         * // => ['fred', 'pebbles']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeRightWhile(users, 'active'), 'user');
         * // => []
         */
        function takeRightWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
            : [];
        }
    
        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is bound to
         * `thisArg` and invoked with three arguments: (value, index, array).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeWhile([1, 2, 3], function(n) {
         *   return n < 3;
         * });
         * // => [1, 2]
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false},
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.takeWhile(users, 'active', false), 'user');
         * // => ['barney', 'fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.takeWhile(users, 'active'), 'user');
         * // => []
         */
        function takeWhile(array, predicate, thisArg) {
          return (array && array.length)
            ? baseWhile(array, getCallback(predicate, thisArg, 3))
            : [];
        }
    
        /**
         * Creates an array of unique values, in order, from all of the provided arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([1, 2], [4, 2], [2, 1]);
         * // => [1, 2, 4]
         */
        var union = restParam(function(arrays) {
          return baseUniq(baseFlatten(arrays, false, true));
        });
    
        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurence of each element
         * is kept. Providing `true` for `isSorted` performs a faster search algorithm
         * for sorted arrays. If an iteratee function is provided it's invoked for
         * each element in the array to generate the criterion by which uniqueness
         * is computed. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, array).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {boolean} [isSorted] Specify the array is sorted.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new duplicate-value-free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         *
         * // using `isSorted`
         * _.uniq([1, 1, 2], true);
         * // => [1, 2]
         *
         * // using an iteratee function
         * _.uniq([1, 2.5, 1.5, 2], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => [1, 2.5]
         *
         * // using the `_.property` callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          if (isSorted != null && typeof isSorted != 'boolean') {
            thisArg = iteratee;
            iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
            isSorted = false;
          }
          var callback = getCallback();
          if (!(iteratee == null && callback === baseCallback)) {
            iteratee = callback(iteratee, thisArg, 3);
          }
          return (isSorted && getIndexOf() === baseIndexOf)
            ? sortedUniq(array, iteratee)
            : baseUniq(array, iteratee);
        }
    
        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         *
         * _.unzip(zipped);
         * // => [['fred', 'barney'], [30, 40], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var index = -1,
              length = 0;
    
          array = arrayFilter(array, function(group) {
            if (isArrayLike(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          var result = Array(length);
          while (++index < length) {
            result[index] = arrayMap(array, baseProperty(index));
          }
          return result;
        }
    
        /**
         * This method is like `_.unzip` except that it accepts an iteratee to specify
         * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee] The function to combine regrouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee, thisArg) {
          var length = array ? array.length : 0;
          if (!length) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          iteratee = bindCallback(iteratee, thisArg, 4);
          return arrayMap(result, function(group) {
            return arrayReduce(group, iteratee, undefined, true);
          });
        }
    
        /**
         * Creates an array excluding all provided values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {Array} array The array to filter.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 3], 1, 2);
         * // => [3]
         */
        var without = restParam(function(array, values) {
          return isArrayLike(array)
            ? baseDifference(array, values)
            : [];
        });
    
        /**
         * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the provided arrays.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of values.
         * @example
         *
         * _.xor([1, 2], [4, 2]);
         * // => [1, 4]
         */
        function xor() {
          var index = -1,
              length = arguments.length;
    
          while (++index < length) {
            var array = arguments[index];
            if (isArrayLike(array)) {
              var result = result
                ? arrayPush(baseDifference(result, array), baseDifference(array, result))
                : array;
            }
          }
          return result ? baseUniq(result) : [];
        }
    
        /**
         * Creates an array of grouped elements, the first of which contains the first
         * elements of the given arrays, the second of which contains the second elements
         * of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         */
        var zip = restParam(unzip);
    
        /**
         * The inverse of `_.pairs`; this method returns an object composed from arrays
         * of property names and values. Provide either a single two dimensional array,
         * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
         * and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @alias object
         * @category Array
         * @param {Array} props The property names.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject([['fred', 30], ['barney', 40]]);
         * // => { 'fred': 30, 'barney': 40 }
         *
         * _.zipObject(['fred', 'barney'], [30, 40]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        function zipObject(props, values) {
          var index = -1,
              length = props ? props.length : 0,
              result = {};
    
          if (length && !values && !isArray(props[0])) {
            values = [];
          }
          while (++index < length) {
            var key = props[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
    
        /**
         * This method is like `_.zip` except that it accepts an iteratee to specify
         * how grouped values should be combined. The `iteratee` is bound to `thisArg`
         * and invoked with four arguments: (accumulator, value, index, group).
         *
         * @static
         * @memberOf _
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee] The function to combine grouped values.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
         * // => [111, 222]
         */
        var zipWith = restParam(function(arrays) {
          var length = arrays.length,
              iteratee = length > 2 ? arrays[length - 2] : undefined,
              thisArg = length > 1 ? arrays[length - 1] : undefined;
    
          if (length > 2 && typeof iteratee == 'function') {
            length -= 2;
          } else {
            iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
            thisArg = undefined;
          }
          arrays.length = length;
          return unzipWith(arrays, iteratee, thisArg);
        });
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a `lodash` object that wraps `value` with explicit method
         * chaining enabled.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _.chain(users)
         *   .sortBy('age')
         *   .map(function(chr) {
         *     return chr.user + ' is ' + chr.age;
         *   })
         *   .first()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }
    
        /**
         * This method invokes `interceptor` and returns `value`. The interceptor is
         * bound to `thisArg` and invoked with one argument; (value). The purpose of
         * this method is to "tap into" a method chain in order to perform operations
         * on intermediate results within the chain.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor, thisArg) {
          interceptor.call(thisArg, value);
          return value;
        }
    
        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         *
         * @static
         * @memberOf _
         * @category Chain
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @param {*} [thisArg] The `this` binding of `interceptor`.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor, thisArg) {
          return interceptor.call(thisArg, value);
        }
    
        /**
         * Enables explicit method chaining on the wrapper object.
         *
         * @name chain
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // without explicit chaining
         * _(users).first();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // with explicit chaining
         * _(users).chain()
         *   .first()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }
    
        /**
         * Executes the chained sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
    
        /**
         * Creates a new array joining a wrapped array with any additional arrays
         * and/or values.
         *
         * @name concat
         * @memberOf _
         * @category Chain
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var wrapped = _(array).concat(2, [3], [[4]]);
         *
         * console.log(wrapped.value());
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        var wrapperConcat = restParam(function(values) {
          values = baseFlatten(values);
          return this.thru(function(array) {
            return arrayConcat(isArray(array) ? array : [toObject(array)], values);
          });
        });
    
        /**
         * Creates a clone of the chained sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).map(function(value) {
         *   return Math.pow(value, 2);
         * });
         *
         * var other = [3, 4];
         * var otherWrapped = wrapped.plant(other);
         *
         * otherWrapped.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;
    
          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }
    
        /**
         * Reverses the wrapped array so the first element becomes the last, the
         * second element becomes the second to last, and so on.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @category Chain
         * @returns {Object} Returns the new reversed `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
    
          var interceptor = function(value) {
            return value.reverse();
          };
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(interceptor);
        }
    
        /**
         * Produces the result of coercing the unwrapped value to a string.
         *
         * @name toString
         * @memberOf _
         * @category Chain
         * @returns {string} Returns the coerced string value.
         * @example
         *
         * _([1, 2, 3]).toString();
         * // => '1,2,3'
         */
        function wrapperToString() {
          return (this.value() + '');
        }
    
        /**
         * Executes the chained sequence to extract the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @alias run, toJSON, valueOf
         * @category Chain
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates an array of elements corresponding to the given keys, or indexes,
         * of `collection`. Keys may be specified as individual arguments or as arrays
         * of keys.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(number|number[]|string|string[])} [props] The property names
         *  or indexes of elements to pick, specified individually or in arrays.
         * @returns {Array} Returns the new array of picked elements.
         * @example
         *
         * _.at(['a', 'b', 'c'], [0, 2]);
         * // => ['a', 'c']
         *
         * _.at(['barney', 'fred', 'pebbles'], 0, 2);
         * // => ['barney', 'pebbles']
         */
        var at = restParam(function(collection, props) {
          if (isArrayLike(collection)) {
            collection = toIterable(collection);
          }
          return baseAt(collection, baseFlatten(props));
        });
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the number of times the key was returned by `iteratee`.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy([4.3, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
        });
    
        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * The predicate is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'active': false },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.every(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.filter([4, 5, 6], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [4, 6]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.filter(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.filter(users, 'active'), 'user');
         * // => ['barney']
         */
        function filter(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, predicate);
        }
    
        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is bound to `thisArg` and
         * invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.result(_.find(users, function(chr) {
         *   return chr.age < 40;
         * }), 'user');
         * // => 'barney'
         *
         * // using the `_.matches` callback shorthand
         * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.result(_.find(users, 'active', false), 'user');
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.result(_.find(users, 'active'), 'user');
         * // => 'barney'
         */
        var find = createFind(baseEach);
    
        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(baseEachRight, true);
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning the first element that has equivalent property
         * values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
         * // => 'barney'
         *
         * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
         * // => 'fred'
         */
        function findWhere(collection, source) {
          return find(collection, baseMatches(source));
        }
    
        /**
         * Iterates over elements of `collection` invoking `iteratee` for each element.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection). Iteratee functions may exit iteration early
         * by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length" property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEach(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from left to right and returns the array
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
         *   console.log(n, key);
         * });
         * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
         */
        var forEach = createForEach(arrayEach, baseEach);
    
        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias eachRight
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2]).forEachRight(function(n) {
         *   console.log(n);
         * }).value();
         * // => logs each value from right to left and returns the array
         */
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return Math.floor(n);
         * });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(n) {
         *   return this.floor(n);
         * }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using the `_.property` callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
    
        /**
         * Checks if `target` is in `collection` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the offset
         * from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @alias contains, include
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {*} target The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {boolean} Returns `true` if a matching element is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.includes('pebbles', 'eb');
         * // => true
         */
        function includes(collection, target, fromIndex, guard) {
          var length = collection ? getLength(collection) : 0;
          if (!isLength(length)) {
            collection = values(collection);
            length = collection.length;
          }
          if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
            fromIndex = 0;
          } else {
            fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
          }
          return (typeof collection == 'string' || !isArray(collection) && isString(collection))
            ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
            : (!!length && getIndexOf(collection, target, fromIndex) > -1);
        }
    
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through `iteratee`. The corresponding value
         * of each key is the last element responsible for generating the key. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var keyData = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.indexBy(keyData, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return String.fromCharCode(object.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keyData, function(object) {
         *   return this.fromCharCode(object.code);
         * }, String);
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         */
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
    
        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `methodName` is a function it's
         * invoked for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invoke([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invoke = restParam(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              isProp = isKey(path),
              result = isArrayLike(collection) ? Array(collection.length) : [];
    
          baseEach(collection, function(value) {
            var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
            result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
          });
          return result;
        });
    
        /**
         * Creates an array of values by running each element in `collection` through
         * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
         * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
         * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
         * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
         * `sum`, `uniq`, and `words`
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function timesThree(n) {
         *   return n * 3;
         * }
         *
         * _.map([1, 2], timesThree);
         * // => [3, 6]
         *
         * _.map({ 'a': 1, 'b': 2 }, timesThree);
         * // => [3, 6] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee, thisArg) {
          var func = isArray(collection) ? arrayMap : baseMap;
          iteratee = getCallback(iteratee, thisArg, 3);
          return func(collection, iteratee);
        }
    
        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, while the second of which
         * contains elements `predicate` returns falsey for. The predicate is bound
         * to `thisArg` and invoked with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * _.partition([1, 2, 3], function(n) {
         *   return n % 2;
         * });
         * // => [[1, 3], [2]]
         *
         * _.partition([1.2, 2.3, 3.4], function(n) {
         *   return this.floor(n) % 2;
         * }, Math);
         * // => [[1.2, 3.4], [2.3]]
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * var mapper = function(array) {
         *   return _.pluck(array, 'user');
         * };
         *
         * // using the `_.matches` callback shorthand
         * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
         * // => [['pebbles'], ['barney', 'fred']]
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.map(_.partition(users, 'active', false), mapper);
         * // => [['barney', 'pebbles'], ['fred']]
         *
         * // using the `_.property` callback shorthand
         * _.map(_.partition(users, 'active'), mapper);
         * // => [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });
    
        /**
         * Gets the property value of `path` from all elements in `collection`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|string} path The path of the property to pluck.
         * @returns {Array} Returns the property values.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.pluck(users, 'user');
         * // => ['barney', 'fred']
         *
         * var userIndex = _.indexBy(users, 'user');
         * _.pluck(userIndex, 'age');
         * // => [36, 40] (iteration order is not guaranteed)
         */
        function pluck(collection, path) {
          return map(collection, property(path));
        }
    
        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` through `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not provided the first element of `collection` is used as the initial
         * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
         * and `sortByOrder`
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.reduce([1, 2], function(total, n) {
         *   return total + n;
         * });
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         *   return result;
         * }, {});
         * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
         */
        var reduce = createReduce(arrayReduce, baseEach);
    
        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias foldr
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
    
        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * _.reject([1, 2, 3, 4], function(n) {
         *   return n % 2 == 0;
         * });
         * // => [1, 3]
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
         * // => ['barney']
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.pluck(_.reject(users, 'active', false), 'user');
         * // => ['fred']
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.reject(users, 'active'), 'user');
         * // => ['barney']
         */
        function reject(collection, predicate, thisArg) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          predicate = getCallback(predicate, thisArg, 3);
          return func(collection, function(value, index, collection) {
            return !predicate(value, index, collection);
          });
        }
    
        /**
         * Gets a random element or `n` random elements from a collection.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to sample.
         * @param {number} [n] The number of elements to sample.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {*} Returns the random sample(s).
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         *
         * _.sample([1, 2, 3, 4], 2);
         * // => [3, 1]
         */
        function sample(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n == null) {
            collection = toIterable(collection);
            var length = collection.length;
            return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
          }
          var index = -1,
              result = toArray(collection),
              length = result.length,
              lastIndex = length - 1;
    
          n = nativeMin(n < 0 ? 0 : (+n || 0), length);
          while (++index < n) {
            var rand = baseRandom(index, lastIndex),
                value = result[rand];
    
            result[rand] = result[index];
            result[index] = value;
          }
          result.length = n;
          return result;
        }
    
        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          return sample(collection, POSITIVE_INFINITY);
        }
    
        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the size of `collection`.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          var length = collection ? getLength(collection) : 0;
          return isLength(length) ? length : keys(collection).length;
        }
    
        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * The function returns as soon as it finds a passing value and does not iterate
         * over the entire collection. The predicate is bound to `thisArg` and invoked
         * with three arguments: (value, index|key, collection).
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // using the `_.matches` callback shorthand
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.some(users, 'active', false);
         * // => true
         *
         * // using the `_.property` callback shorthand
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, thisArg) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
            predicate = undefined;
          }
          if (typeof predicate != 'function' || thisArg !== undefined) {
            predicate = getCallback(predicate, thisArg, 3);
          }
          return func(collection, predicate);
        }
    
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through `iteratee`. This method performs
         * a stable sort, that is, it preserves the original sort order of equal elements.
         * The `iteratee` is bound to `thisArg` and invoked with three arguments:
         * (value, index|key, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return Math.sin(n);
         * });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(n) {
         *   return this.sin(n);
         * }, Math);
         * // => [3, 1, 2]
         *
         * var users = [
         *   { 'user': 'fred' },
         *   { 'user': 'pebbles' },
         *   { 'user': 'barney' }
         * ];
         *
         * // using the `_.property` callback shorthand
         * _.pluck(_.sortBy(users, 'user'), 'user');
         * // => ['barney', 'fred', 'pebbles']
         */
        function sortBy(collection, iteratee, thisArg) {
          if (collection == null) {
            return [];
          }
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          var index = -1;
          iteratee = getCallback(iteratee, thisArg, 3);
    
          var result = baseMap(collection, function(value, key, collection) {
            return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
          });
          return baseSortBy(result, compareAscending);
        }
    
        /**
         * This method is like `_.sortBy` except that it can sort by multiple iteratees
         * or property names.
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
         *  The iteratees to sort by, specified as individual values or arrays of values.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.map(_.sortByAll(users, ['user', 'age']), _.values);
         * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
         *
         * _.map(_.sortByAll(users, 'user', function(chr) {
         *   return Math.floor(chr.age / 10);
         * }), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        var sortByAll = restParam(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var guard = iteratees[2];
          if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
            iteratees.length = 1;
          }
          return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
    
        /**
         * This method is like `_.sortByAll` except that it allows specifying the
         * sort orders of the iteratees to sort by. If `orders` is unspecified, all
         * values are sorted in ascending order. Otherwise, a value is sorted in
         * ascending order if its corresponding order is "asc", and descending if "desc".
         *
         * If a property name is provided for an iteratee the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If an object is provided for an iteratee the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {boolean[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 42 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // sort by `user` in ascending order and by `age` in descending order
         * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
         * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
         */
        function sortByOrder(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (guard && isIterateeCall(iteratees, orders, guard)) {
            orders = undefined;
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseSortByOrder(collection, iteratees, orders);
        }
    
        /**
         * Performs a deep comparison between each element in `collection` and the
         * source object, returning an array of all elements that have equivalent
         * property values.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Collection
         * @param {Array|Object|string} collection The collection to search.
         * @param {Object} source The object of property values to match.
         * @returns {Array} Returns the new filtered array.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
         *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
         * ];
         *
         * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
         * // => ['barney']
         *
         * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
         * // => ['fred']
         */
        function where(collection, source) {
          return filter(collection, baseMatches(source));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Date
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => logs the number of milliseconds it took for the deferred function to be invoked
         */
        var now = nativeNow || function() {
          return new Date().getTime();
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => logs 'done saving!' after the two async saves have completed
         */
        function after(n, func) {
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          n = nativeIsFinite(n = +n) ? n : 0;
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
    
        /**
         * Creates a function that accepts up to `n` arguments ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          if (guard && isIterateeCall(func, n, guard)) {
            n = undefined;
          }
          n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
          return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }
    
        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery('#add').on('click', _.before(5, addContactToList));
         * // => allows adding up to 4 contacts to the list
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            if (typeof n == 'function') {
              var temp = n;
              n = func;
              func = temp;
            } else {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
          }
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and prepends any additional `_.bind` arguments to those provided to the
         * bound function.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind` this method does not set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var greet = function(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * };
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // using placeholders
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = restParam(function(func, thisArg, partials) {
          var bitmask = BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bind.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(func, bitmask, thisArg, partials, holders);
        });
    
        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method. Method names may be specified as individual arguments or as arrays
         * of method names. If no method names are provided all enumerable function
         * properties, own and inherited, of `object` are bound.
         *
         * **Note:** This method does not set the "length" property of bound functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} [methodNames] The object method names to bind,
         *  specified as individual method names or arrays of method names.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'onClick': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view);
         * jQuery('#docs').on('click', view.onClick);
         * // => logs 'clicked docs' when the element is clicked
         */
        var bindAll = restParam(function(object, methodNames) {
          methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
    
          var index = -1,
              length = methodNames.length;
    
          while (++index < length) {
            var key = methodNames[index];
            object[key] = createWrapper(object[key], BIND_FLAG, object);
          }
          return object;
        });
    
        /**
         * Creates a function that invokes the method at `object[key]` and prepends
         * any additional `_.bindKey` arguments to those provided to the bound function.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist.
         * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Object} object The object the method belongs to.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // using placeholders
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = restParam(function(object, key, partials) {
          var bitmask = BIND_FLAG | BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, bindKey.placeholder);
            bitmask |= PARTIAL_FLAG;
          }
          return createWrapper(key, bitmask, object, partials, holders);
        });
    
        /**
         * Creates a function that accepts one or more arguments of `func` that when
         * called either invokes `func` returning its result, if all `func` arguments
         * have been provided, or returns a function that accepts one or more of the
         * remaining `func` arguments, and so on. The arity of `func` may be specified
         * if `func.length` is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        var curry = createCurry(CURRY_FLAG);
    
        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method does not set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // using placeholders
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
    
        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed invocations. Provide an options object to indicate that `func`
         * should be invoked on the leading and/or trailing edge of the `wait` timeout.
         * Subsequent calls to the debounced function return the result of the last
         * `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify invoking on the leading
         *  edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be
         *  delayed before it's invoked.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // ensure `batchLog` is invoked once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', _.debounce(batchLog, 250, {
         *   'maxWait': 1000
         * }));
         *
         * // cancel a debounced call
         * var todoChanges = _.debounce(batchLog, 1000);
         * Object.observe(models.todo, todoChanges);
         *
         * Object.observe(models, function(changes) {
         *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
         *     todoChanges.cancel();
         *   }
         * }, ['delete']);
         *
         * // ...at some point `models.todo` is changed
         * models.todo.completed = true;
         *
         * // ...before 1 second has passed `models.todo` is deleted
         * // which cancels the debounced `todoChanges` call
         * delete models.todo;
         */
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = wait < 0 ? 0 : (+wait || 0);
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = !!options.leading;
            maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
    
          function cancel() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (maxTimeoutId) {
              clearTimeout(maxTimeoutId);
            }
            lastCalled = 0;
            maxTimeoutId = timeoutId = trailingCall = undefined;
          }
    
          function complete(isCalled, id) {
            if (id) {
              clearTimeout(id);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (isCalled) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = undefined;
              }
            }
          }
    
          function delayed() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0 || remaining > wait) {
              complete(trailingCall, maxTimeoutId);
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          }
    
          function maxDelayed() {
            complete(trailing, timeoutId);
          }
    
          function debounced() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
    
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0 || remaining > maxWait;
    
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              }
              else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            }
            else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = undefined;
            }
            return result;
          }
          debounced.cancel = cancel;
          return debounced;
        }
    
        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        var defer = restParam(function(func, args) {
          return baseDelay(func, 1, args);
        });
    
        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => logs 'later' after one second
         */
        var delay = restParam(function(func, wait, args) {
          return baseDelay(func, wait, args);
        });
    
        /**
         * Creates a function that returns the result of invoking the provided
         * functions with the `this` binding of the created function, where each
         * successive invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow(_.add, square);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();
    
        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the provided functions from right to left.
         *
         * @static
         * @memberOf _
         * @alias backflow, compose
         * @category Function
         * @param {...Function} [funcs] Functions to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight(square, _.add);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);
    
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is coerced to a string and used as the
         * cache key. The `func` is invoked with the `this` binding of the memoized
         * function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoizing function.
         * @example
         *
         * var upperCase = _.memoize(function(string) {
         *   return string.toUpperCase();
         * });
         *
         * upperCase('fred');
         * // => 'FRED'
         *
         * // modifying the result cache
         * upperCase.cache.set('fred', 'BARNEY');
         * upperCase('fred');
         * // => 'BARNEY'
         *
         * // replacing `_.memoize.Cache`
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'barney' };
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'fred' }
         *
         * _.memoize.Cache = WeakMap;
         * var identity = _.memoize(_.identity);
         *
         * identity(object);
         * // => { 'user': 'fred' }
         * identity(other);
         * // => { 'user': 'barney' }
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
    
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result);
            return result;
          };
          memoized.cache = new memoize.Cache;
          return memoized;
        }
    
        /**
         * Creates a function that runs each argument through a corresponding
         * transform function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms] The functions to transform
         * arguments, specified as individual functions or arrays of functions.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var modded = _.modArgs(function(x, y) {
         *   return [x, y];
         * }, square, doubled);
         *
         * modded(1, 2);
         * // => [1, 4]
         *
         * modded(5, 10);
         * // => [25, 20]
         */
        var modArgs = restParam(function(func, transforms) {
          transforms = baseFlatten(transforms);
          if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = transforms.length;
          return restParam(function(args) {
            var index = nativeMin(args.length, length);
            while (index--) {
              args[index] = transforms[index](args[index]);
            }
            return func.apply(this, args);
          });
        });
    
        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
    
        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first call. The `func` is invoked
         * with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // `initialize` invokes `createApplication` once
         */
        function once(func) {
          return before(2, func);
        }
    
        /**
         * Creates a function that invokes `func` with `partial` arguments prepended
         * to those provided to the new function. This method is like `_.bind` except
         * it does **not** alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // using placeholders
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = createPartial(PARTIAL_FLAG);
    
        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to those provided to the new function.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method does not set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) {
         *   return greeting + ' ' + name;
         * };
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // using placeholders
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
    
        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified indexes where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes,
         *  specified as individual indexes or arrays of indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, 2, 0, 1);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         *
         * var map = _.rearg(_.map, [1, 0]);
         * map(function(n) {
         *   return n * 3;
         * }, [1, 2, 3]);
         * // => [3, 6, 9]
         */
        var rearg = restParam(function(func, indexes) {
          return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as an array.
         *
         * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/Web/JavaScript/Reference/Functions/rest_parameters).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.restParam(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function restParam(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                rest = Array(length);
    
            while (++index < length) {
              rest[index] = args[start + index];
            }
            switch (start) {
              case 0: return func.call(this, rest);
              case 1: return func.call(this, args[0], rest);
              case 2: return func.call(this, args[0], args[1], rest);
            }
            var otherArgs = Array(start + 1);
            index = -1;
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = rest;
            return func.apply(this, otherArgs);
          };
        }
    
        /**
         * Creates a function that invokes `func` with the `this` binding of the created
         * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
         *
         * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/Web/JavaScript/Reference/Operators/Spread_operator).
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * // with a Promise
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function(array) {
            return func.apply(this, array);
          };
        }
    
        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed invocations. Provide an options object to indicate
         * that `func` should be invoked on the leading and/or trailing edge of the
         * `wait` timeout. Subsequent calls to the throttled function return the
         * result of the last `func` call.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
         * on the trailing edge of the timeout only if the the throttled function is
         * invoked more than once during the `wait` timeout.
         *
         * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=true] Specify invoking on the leading
         *  edge of the timeout.
         * @param {boolean} [options.trailing=true] Specify invoking on the trailing
         *  edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // avoid excessively updating the position while scrolling
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
         * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
         *   'trailing': false
         * }));
         *
         * // cancel a trailing throttled call
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
    
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
        }
    
        /**
         * Creates a function that provides `value` to the wrapper function as its
         * first argument. Any additional arguments provided to the function are
         * appended to those provided to the wrapper function. The wrapper is invoked
         * with the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} wrapper The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          wrapper = wrapper == null ? identity : wrapper;
          return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
         * otherwise they are assigned by reference. If `customizer` is provided it's
         * invoked to produce the cloned values. If `customizer` returns `undefined`
         * cloning is handled by the method instead. The `customizer` is bound to
         * `thisArg` and invoked with up to three argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var shallow = _.clone(users);
         * shallow[0] === users[0];
         * // => true
         *
         * var deep = _.clone(users, true);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.clone(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 0
         */
        function clone(value, isDeep, customizer, thisArg) {
          if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
            isDeep = false;
          }
          else if (typeof isDeep == 'function') {
            thisArg = customizer;
            customizer = isDeep;
            isDeep = false;
          }
          return typeof customizer == 'function'
            ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 3))
            : baseClone(value, isDeep);
        }
    
        /**
         * Creates a deep clone of `value`. If `customizer` is provided it's invoked
         * to produce the cloned values. If `customizer` returns `undefined` cloning
         * is handled by the method instead. The `customizer` is bound to `thisArg`
         * and invoked with up to three argument; (value [, index|key, object]).
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
         * The enumerable properties of `arguments` objects and objects created by
         * constructors other than `Object` are cloned to plain `Object` objects. An
         * empty object is returned for uncloneable values such as functions, DOM nodes,
         * Maps, Sets, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to deep clone.
         * @param {Function} [customizer] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {*} Returns the deep cloned value.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * var deep = _.cloneDeep(users);
         * deep[0] === users[0];
         * // => false
         *
         * // using a customizer callback
         * var el = _.cloneDeep(document.body, function(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * });
         *
         * el === document.body
         * // => false
         * el.nodeName
         * // => BODY
         * el.childNodes.length;
         * // => 20
         */
        function cloneDeep(value, customizer, thisArg) {
          return typeof customizer == 'function'
            ? baseClone(value, true, bindCallback(customizer, thisArg, 3))
            : baseClone(value, true);
        }
    
        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        function gt(value, other) {
          return value > other;
        }
    
        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        function gte(value, other) {
          return value >= other;
        }
    
        /**
         * Checks if `value` is classified as an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
          return isObjectLike(value) && isArrayLike(value) &&
            hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        }
    
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(function() { return arguments; }());
         * // => false
         */
        var isArray = nativeIsArray || function(value) {
          return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
    
        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
        }
    
        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        function isDate(value) {
          return isObjectLike(value) && objToString.call(value) == dateTag;
        }
    
        /**
         * Checks if `value` is a DOM element.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
        }
    
        /**
         * Checks if `value` is empty. A value is considered empty unless it's an
         * `arguments` object, array, string, or jQuery-like collection with a length
         * greater than `0` or an object with own enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Array|Object|string} value The value to inspect.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
              (isObjectLike(value) && isFunction(value.splice)))) {
            return !value.length;
          }
          return !keys(value).length;
        }
    
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent. If `customizer` is provided it's invoked to compare values.
         * If `customizer` returns `undefined` comparisons are handled by the method
         * instead. The `customizer` is bound to `thisArg` and invoked with up to
         * three arguments: (value, other [, index|key]).
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. Functions and DOM nodes
         * are **not** supported. Provide a customizer function to extend support
         * for comparing other values.
         *
         * @static
         * @memberOf _
         * @alias eq
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var other = { 'user': 'fred' };
         *
         * object == other;
         * // => false
         *
         * _.isEqual(object, other);
         * // => true
         *
         * // using a customizer callback
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqual(array, other, function(value, other) {
         *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
         *     return true;
         *   }
         * });
         * // => true
         */
        function isEqual(value, other, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          var result = customizer ? customizer(value, other) : undefined;
          return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
    
        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
    
        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(10);
         * // => true
         *
         * _.isFinite('10');
         * // => false
         *
         * _.isFinite(true);
         * // => false
         *
         * _.isFinite(Object(10));
         * // => false
         *
         * _.isFinite(Infinity);
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }
    
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in older versions of Chrome and Safari which return 'function' for regexes
          // and Safari 8 which returns 'object' for typed array constructors.
          return isObject(value) && objToString.call(value) == funcTag;
        }
    
        /**
         * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
          // Avoid a V8 JIT bug in Chrome 19-20.
          // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
          var type = typeof value;
          return !!value && (type == 'object' || type == 'function');
        }
    
        /**
         * Performs a deep comparison between `object` and `source` to determine if
         * `object` contains equivalent property values. If `customizer` is provided
         * it's invoked to compare values. If `customizer` returns `undefined`
         * comparisons are handled by the method instead. The `customizer` is bound
         * to `thisArg` and invoked with three arguments: (value, other, index|key).
         *
         * **Note:** This method supports comparing properties of arrays, booleans,
         * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
         * and DOM nodes are **not** supported. Provide a customizer function to extend
         * support for comparing other values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize value comparisons.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.isMatch(object, { 'age': 40 });
         * // => true
         *
         * _.isMatch(object, { 'age': 36 });
         * // => false
         *
         * // using a customizer callback
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatch(object, source, function(value, other) {
         *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
         * });
         * // => true
         */
        function isMatch(object, source, customizer, thisArg) {
          customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
          return baseIsMatch(object, getMatchData(source), customizer);
        }
    
        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
         * which returns `true` for `undefined` and other non-numeric values.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
          return isNumber(value) && value != +value;
        }
    
        /**
         * Checks if `value` is a native function.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (value == null) {
            return false;
          }
          if (isFunction(value)) {
            return reIsNative.test(fnToString.call(value));
          }
          return isObjectLike(value) && (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);
        }
    
        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }
    
        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
         * as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isNumber(8.4);
         * // => true
         *
         * _.isNumber(NaN);
         * // => true
         *
         * _.isNumber('8.4');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
        }
    
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * **Note:** This method assumes objects created by the `Object` constructor
         * have no inherited enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          var Ctor;
    
          // Exit early for non `Object` objects.
          if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value) && !isArguments(value)) ||
              (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
            return false;
          }
          // IE < 9 iterates inherited properties before own properties. If the first
          // iterated property is an object's own property then there are no inherited
          // enumerable properties.
          var result;
          if (lodash.support.ownLast) {
            baseForIn(value, function(subValue, key, object) {
              result = hasOwnProperty.call(object, key);
              return false;
            });
            return result !== false;
          }
          // In most environments an object's own properties are iterated before
          // its inherited properties. If the last iterated property is an object's
          // own property then there are no inherited enumerable properties.
          baseForIn(value, function(subValue, key) {
            result = key;
          });
          return result === undefined || hasOwnProperty.call(value, result);
        }
    
        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        function isRegExp(value) {
          return isObject(value) && objToString.call(value) == regexpTag;
        }
    
        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
        }
    
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        function isTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
    
        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }
    
        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        function lt(value, other) {
          return value < other;
        }
    
        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        function lte(value, other) {
          return value <= other;
        }
    
        /**
         * Converts `value` to an array.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * (function() {
         *   return _.toArray(arguments).slice(1);
         * }(1, 2, 3));
         * // => [2, 3]
         */
        function toArray(value) {
          var length = value ? getLength(value) : 0;
          if (!isLength(length)) {
            return values(value);
          }
          if (!length) {
            return [];
          }
          return (lodash.support.unindexedChars && isString(value))
            ? value.split('')
            : arrayCopy(value);
        }
    
        /**
         * Converts `value` to a plain object flattening inherited enumerable
         * properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return baseCopy(value, keysIn(value));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Recursively merges own enumerable properties of the source object(s), that
         * don't resolve to `undefined` into the destination object. Subsequent sources
         * overwrite property assignments of previous sources. If `customizer` is
         * provided it's invoked to produce the merged values of the destination and
         * source properties. If `customizer` returns `undefined` merging is handled
         * by the method instead. The `customizer` is bound to `thisArg` and invoked
         * with five arguments: (objectValue, sourceValue, key, object, source).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var users = {
         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
         * };
         *
         * var ages = {
         *   'data': [{ 'age': 36 }, { 'age': 40 }]
         * };
         *
         * _.merge(users, ages);
         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
         *
         * // using a customizer callback
         * var object = {
         *   'fruits': ['apple'],
         *   'vegetables': ['beet']
         * };
         *
         * var other = {
         *   'fruits': ['banana'],
         *   'vegetables': ['carrot']
         * };
         *
         * _.merge(object, other, function(a, b) {
         *   if (_.isArray(a)) {
         *     return a.concat(b);
         *   }
         * });
         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
         */
        var merge = createAssigner(baseMerge);
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources overwrite property assignments of previous sources.
         * If `customizer` is provided it's invoked to produce the assigned values.
         * The `customizer` is bound to `thisArg` and invoked with five arguments:
         * (objectValue, sourceValue, key, object, source).
         *
         * **Note:** This method mutates `object` and is based on
         * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
         *
         * @static
         * @memberOf _
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {*} [thisArg] The `this` binding of `customizer`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using a customizer callback
         * var defaults = _.partialRight(_.assign, function(value, other) {
         *   return _.isUndefined(value) ? other : value;
         * });
         *
         * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var assign = createAssigner(function(object, source, customizer) {
          return customizer
            ? assignWith(object, source, customizer)
            : baseAssign(object, source);
        });
    
        /**
         * Creates an object that inherits from the given `prototype` object. If a
         * `properties` object is provided its own enumerable properties are assigned
         * to the created object.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties, guard) {
          var result = baseCreate(prototype);
          if (guard && isIterateeCall(prototype, properties, guard)) {
            properties = undefined;
          }
          return properties ? baseAssign(result, properties) : result;
        }
    
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object for all destination properties that resolve to `undefined`. Once a
         * property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
         * // => { 'user': 'barney', 'age': 36 }
         */
        var defaults = createDefaults(assign, assignDefaults);
    
        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
         * // => { 'user': { 'name': 'barney', 'age': 36 } }
         *
         */
        var defaultsDeep = createDefaults(merge, mergeDefaults);
    
        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // using the `_.matches` callback shorthand
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        var findKey = createFindKey(baseForOwn);
    
        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * If a property name is provided for `predicate` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `predicate` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to search.
         * @param {Function|Object|string} [predicate=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(chr) {
         *   return chr.age < 40;
         * });
         * // => returns `pebbles` assuming `_.findKey` returns `barney`
         *
         * // using the `_.matches` callback shorthand
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // using the `_.matchesProperty` callback shorthand
         * _.findLastKey(users, 'active', false);
         * // => 'fred'
         *
         * // using the `_.property` callback shorthand
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        var findLastKey = createFindKey(baseForOwnRight);
    
        /**
         * Iterates over own and inherited enumerable properties of an object invoking
         * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
         */
        var forIn = createForIn(baseFor);
    
        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
         */
        var forInRight = createForIn(baseForRight);
    
        /**
         * Iterates over own enumerable properties of an object invoking `iteratee`
         * for each property. The `iteratee` is bound to `thisArg` and invoked with
         * three arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'a' and 'b' (iteration order is not guaranteed)
         */
        var forOwn = createForOwn(baseForOwn);
    
        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
         */
        var forOwnRight = createForOwn(baseForOwnRight);
    
        /**
         * Creates an array of function property names from all enumerable properties,
         * own and inherited, of `object`.
         *
         * @static
         * @memberOf _
         * @alias methods
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the new array of property names.
         * @example
         *
         * _.functions(_);
         * // => ['after', 'ary', 'assign', ...]
         */
        function functions(object) {
          return baseFunctions(object, keysIn(object));
        }
    
        /**
         * Gets the property value at `path` of `object`. If the resolved value is
         * `undefined` the `defaultValue` is used in its place.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));
          return result === undefined ? defaultValue : result;
        }
    
        /**
         * Checks if `path` is a direct property.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': { 'c': 3 } } };
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b.c');
         * // => true
         *
         * _.has(object, ['a', 'b', 'c']);
         * // => true
         */
        function has(object, path) {
          if (object == null) {
            return false;
          }
          var result = hasOwnProperty.call(object, path);
          if (!result && !isKey(path)) {
            path = toPath(path);
            object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
            if (object == null) {
              return false;
            }
            path = last(path);
            result = hasOwnProperty.call(object, path);
          }
          return result || (isLength(object.length) && isIndex(path, object.length) &&
            (isArray(object) || isArguments(object) || isString(object)));
        }
    
        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite property
         * assignments of previous values unless `multiValue` is `true`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to invert.
         * @param {boolean} [multiValue] Allow multiple values per key.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         *
         * // with `multiValue`
         * _.invert(object, true);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function invert(object, multiValue, guard) {
          if (guard && isIterateeCall(object, multiValue, guard)) {
            multiValue = undefined;
          }
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
    
          while (++index < length) {
            var key = props[index],
                value = object[key];
    
            if (multiValue) {
              if (hasOwnProperty.call(result, value)) {
                result[value].push(key);
              } else {
                result[value] = [key];
              }
            }
            else {
              result[value] = key;
            }
          }
          return result;
        }
    
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        var keys = !nativeKeys ? shimKeys : function(object) {
          var Ctor = object == null ? undefined : object.constructor;
          if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
              (typeof object == 'function' ? lodash.support.enumPrototypes : isArrayLike(object))) {
            return shimKeys(object);
          }
          return isObject(object) ? nativeKeys(object) : [];
        };
    
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          if (object == null) {
            return [];
          }
          if (!isObject(object)) {
            object = Object(object);
          }
          var length = object.length,
              support = lodash.support;
    
          length = (length && isLength(length) &&
            (isArray(object) || isArguments(object) || isString(object)) && length) || 0;
    
          var Ctor = object.constructor,
              index = -1,
              proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
              isProto = proto === object,
              result = Array(length),
              skipIndexes = length > 0,
              skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
              skipProto = support.enumPrototypes && isFunction(object);
    
          while (++index < length) {
            result[index] = (index + '');
          }
          // lodash skips the `constructor` property when it infers it's iterating
          // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
          // attribute of an existing property and the `constructor` property of a
          // prototype defaults to non-enumerable.
          for (var key in object) {
            if (!(skipProto && key == 'prototype') &&
                !(skipErrorProps && (key == 'message' || key == 'name')) &&
                !(skipIndexes && isIndex(key, length)) &&
                !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          if (support.nonEnumShadows && object !== objectProto) {
            var tag = object === stringProto ? stringTag : (object === errorProto ? errorTag : objToString.call(object)),
                nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];
    
            if (tag == objectTag) {
              proto = objectProto;
            }
            length = shadowProps.length;
            while (length--) {
              key = shadowProps[length];
              var nonEnum = nonEnums[key];
              if (!(isProto && nonEnum) &&
                  (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
                result.push(key);
              }
            }
          }
          return result;
        }
    
        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * property of `object` through `iteratee`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        var mapKeys = createObjectMapper(true);
    
        /**
         * Creates an object with the same keys as `object` and values generated by
         * running each own enumerable property of `object` through `iteratee`. The
         * iteratee function is bound to `thisArg` and invoked with three arguments:
         * (value, key, object).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function|Object|string} [iteratee=_.identity] The function invoked
         *  per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Object} Returns the new mapped object.
         * @example
         *
         * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
         *   return n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * // using the `_.property` callback shorthand
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        var mapValues = createObjectMapper();
    
        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable properties of `object` that are not omitted.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to omit, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.omit(object, 'age');
         * // => { 'user': 'fred' }
         *
         * _.omit(object, _.isNumber);
         * // => { 'user': 'fred' }
         */
        var omit = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          if (typeof props[0] != 'function') {
            var props = arrayMap(baseFlatten(props), String);
            return pickByArray(object, baseDifference(keysIn(object), props));
          }
          var predicate = bindCallback(props[0], props[1], 3);
          return pickByCallback(object, function(value, key, object) {
            return !predicate(value, key, object);
          });
        });
    
        /**
         * Creates a two dimensional array of the key-value pairs for `object`,
         * e.g. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
         */
        function pairs(object) {
          object = toObject(object);
    
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
    
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
    
        /**
         * Creates an object composed of the picked `object` properties. Property
         * names may be specified as individual arguments or as arrays of property
         * names. If `predicate` is provided it's invoked for each property of `object`
         * picking the properties `predicate` returns truthy for. The predicate is
         * bound to `thisArg` and invoked with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {Function|...(string|string[])} [predicate] The function invoked per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `predicate`.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'user': 'fred', 'age': 40 };
         *
         * _.pick(object, 'user');
         * // => { 'user': 'fred' }
         *
         * _.pick(object, _.isString);
         * // => { 'user': 'fred' }
         */
        var pick = restParam(function(object, props) {
          if (object == null) {
            return {};
          }
          return typeof props[0] == 'function'
            ? pickByCallback(object, bindCallback(props[0], props[1], 3))
            : pickByArray(object, baseFlatten(props));
        });
    
        /**
         * This method is like `_.get` except that if the resolved value is a function
         * it's invoked with the `this` binding of its parent object and its result
         * is returned.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a.b.c', 'default');
         * // => 'default'
         *
         * _.result(object, 'a.b.c', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          var result = object == null ? undefined : toObject(object)[path];
          if (result === undefined) {
            if (object != null && !isKey(path, object)) {
              path = toPath(path);
              object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
              result = object == null ? undefined : toObject(object)[last(path)];
            }
            result = result === undefined ? defaultValue : result;
          }
          return isFunction(result) ? result.call(object) : result;
        }
    
        /**
         * Sets the property value of `path` on `object`. If a portion of `path`
         * does not exist it's created.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to augment.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, 'x[0].y.z', 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          if (object == null) {
            return object;
          }
          var pathKey = (path + '');
          path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);
    
          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
    
          while (nested != null && ++index < length) {
            var key = path[index];
            if (isObject(nested)) {
              if (index == lastIndex) {
                nested[key] = value;
              } else if (nested[key] == null) {
                nested[key] = isIndex(path[index + 1]) ? [] : {};
              }
            }
            nested = nested[key];
          }
          return object;
        }
    
        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own enumerable
         * properties through `iteratee`, with each invocation potentially mutating
         * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
         * with four arguments: (accumulator, value, key, object). Iteratee functions
         * may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Array|Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * });
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
         *   result[key] = n * 3;
         * });
         * // => { 'a': 3, 'b': 6 }
         */
        function transform(object, iteratee, accumulator, thisArg) {
          var isArr = isArray(object) || isTypedArray(object);
          iteratee = getCallback(iteratee, thisArg, 4);
    
          if (accumulator == null) {
            if (isArr || isObject(object)) {
              var Ctor = object.constructor;
              if (isArr) {
                accumulator = isArray(object) ? new Ctor : [];
              } else {
                accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
              }
            } else {
              accumulator = {};
            }
          }
          (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }
    
        /**
         * Creates an array of the own enumerable property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return baseValues(object, keys(object));
        }
    
        /**
         * Creates an array of the own and inherited enumerable property values
         * of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return baseValues(object, keysIn(object));
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Checks if `n` is between `start` and up to but not including, `end`. If
         * `end` is not specified it's set to `start` with `start` then set to `0`.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} n The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         */
        function inRange(value, start, end) {
          start = +start || 0;
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
    
        /**
         * Produces a random number between `min` and `max` (inclusive). If only one
         * argument is provided a number between `0` and the given number is returned.
         * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
         * number is returned instead of an integer.
         *
         * @static
         * @memberOf _
         * @category Number
         * @param {number} [min=0] The minimum possible value.
         * @param {number} [max=1] The maximum possible value.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(min, max, floating) {
          if (floating && isIterateeCall(min, max, floating)) {
            max = floating = undefined;
          }
          var noMin = min == null,
              noMax = max == null;
    
          if (floating == null) {
            if (noMax && typeof min == 'boolean') {
              floating = min;
              min = 1;
            }
            else if (typeof max == 'boolean') {
              floating = max;
              noMax = true;
            }
          }
          if (noMin && noMax) {
            max = 1;
            noMax = false;
          }
          min = +min || 0;
          if (noMax) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          if (floating || min % 1 || max % 1) {
            var rand = nativeRandom();
            return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
          }
          return baseRandom(min, max);
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar');
         * // => 'fooBar'
         *
         * _.camelCase('__foo_bar__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
        });
    
        /**
         * Capitalizes the first character of `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('fred');
         * // => 'Fred'
         */
        function capitalize(string) {
          string = baseToString(string);
          return string && (string.charAt(0).toUpperCase() + string.slice(1));
        }
    
        /**
         * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = baseToString(string);
          return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
    
        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search from.
         * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = baseToString(string);
          target = (target + '');
    
          var length = string.length;
          position = position === undefined
            ? length
            : nativeMin(position < 0 ? 0 : (+position || 0), length);
    
          position -= target.length;
          return position >= 0 && string.indexOf(target, position) == position;
        }
    
        /**
         * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
         * their corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional characters
         * use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value.
         * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * Backticks are escaped because in Internet Explorer < 9, they can break out
         * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
         * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
         * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
         * for more details.
         *
         * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
         * to reduce XSS vectors.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          // Reset `lastIndex` because in IE < 9 `String#replace` does not.
          string = baseToString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }
    
        /**
         * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
         * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
         */
        function escapeRegExp(string) {
          string = baseToString(string);
          return (string && reHasRegExpChars.test(string))
            ? string.replace(reRegExpChars, escapeRegExpChar)
            : (string || '(?:)');
        }
    
        /**
         * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__foo_bar__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });
    
        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = baseToString(string);
          length = +length;
    
          var strLength = string.length;
          if (strLength >= length || !nativeIsFinite(length)) {
            return string;
          }
          var mid = (length - strLength) / 2,
              leftLength = nativeFloor(mid),
              rightLength = nativeCeil(mid);
    
          chars = createPadding('', rightLength, chars);
          return chars.slice(0, leftLength) + string + chars;
        }
    
        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padLeft('abc', 6);
         * // => '   abc'
         *
         * _.padLeft('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padLeft('abc', 3);
         * // => 'abc'
         */
        var padLeft = createPadDir();
    
        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padRight('abc', 6);
         * // => 'abc   '
         *
         * _.padRight('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padRight('abc', 3);
         * // => 'abc'
         */
        var padRight = createPadDir(true);
    
        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
         * in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
         * of `parseInt`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
          // Chrome fails to trim leading <BOM> whitespace characters.
          // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
          if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          string = trim(string);
          return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
        }
    
        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=0] The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n) {
          var result = '';
          string = baseToString(string);
          n = +n;
          if (n < 1 || !string || !nativeIsFinite(n)) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            string += string;
          } while (n);
    
          return result;
        }
    
        /**
         * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--foo-bar');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });
    
        /**
         * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__foo_bar__');
         * // => 'Foo Bar'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
    
        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to search.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = baseToString(string);
          position = position == null
            ? 0
            : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
    
          return string.lastIndexOf(target, position) == position;
        }
    
        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is provided it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options] The options object.
         * @param {RegExp} [options.escape] The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
         * @param {Object} [options.imports] An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
         * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
         * @param {string} [options.variable] The data object variable name.
         * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // using the "interpolate" delimiter to create a compiled template
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // using the HTML "escape" delimiter to escape data property values
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // using the "evaluate" delimiter to execute JavaScript and generate HTML
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the internal `print` function in "evaluate" delimiters
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // using the ES delimiter as an alternative to the default "interpolate" delimiter
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // using custom template delimiters
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // using backslashes to treat delimiters as plain text
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // using the `imports` option to import `jQuery` as `jq`
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the `sourceURL` option to specify a custom sourceURL for the template
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
         *
         * // using the `variable` option to ensure a with-statement isn't used in the compiled template
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // using the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and a stack trace
         * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, otherOptions) {
          // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;
    
          if (otherOptions && isIterateeCall(string, options, otherOptions)) {
            options = otherOptions = undefined;
          }
          string = baseToString(string);
          options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
    
          var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
    
          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";
    
          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');
    
          // Use a sourceURL for easier debugging.
          var sourceURL = '//# sourceURL=' +
            ('sourceURL' in options
              ? options.sourceURL
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';
    
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
    
            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
    
            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
    
            // The JS engine embedded in Adobe products requires returning the `match`
            // string in order to produce the correct `offset` value.
            return match;
          });
    
          source += "';\n";
    
          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');
    
          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';
    
          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });
    
          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }
    
        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
          }
          chars = (chars + '');
          return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
    
        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimLeft('  abc  ');
         * // => 'abc  '
         *
         * _.trimLeft('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimLeft(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(trimmedLeftIndex(string));
          }
          return string.slice(charsLeftIndex(string, (chars + '')));
        }
    
        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimRight('  abc  ');
         * // => '  abc'
         *
         * _.trimRight('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimRight(string, chars, guard) {
          var value = string;
          string = baseToString(string);
          if (!string) {
            return string;
          }
          if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
            return string.slice(0, trimmedRightIndex(string) + 1);
          }
          return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
        }
    
        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object|number} [options] The options object or maximum string length.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.trunc('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', 24);
         * // => 'hi-diddly-ho there, n...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.trunc('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function trunc(string, options, guard) {
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
    
          if (options != null) {
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? (+options.length || 0) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            } else {
              length = +options || 0;
            }
          }
          string = baseToString(string);
          if (length >= string.length) {
            return string;
          }
          var end = length - omission.length;
          if (end < 1) {
            return omission;
          }
          var result = string.slice(0, end);
          if (separator == null) {
            return result + omission;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  newEnd,
                  substring = string.slice(0, end);
    
              if (!separator.global) {
                separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                newEnd = match.index;
              }
              result = result.slice(0, newEnd == null ? end : newEnd);
            }
          } else if (string.indexOf(separator, end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }
    
        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
         * corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional HTML
         * entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = baseToString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }
    
        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          if (guard && isIterateeCall(string, pattern, guard)) {
            pattern = undefined;
          }
          string = baseToString(string);
          return string.match(pattern || reWords) || [];
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function} func The function to attempt.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // avoid throwing errors for invalid selectors
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = restParam(function(func, args) {
          try {
            return func.apply(undefined, args);
          } catch(e) {
            return isError(e) ? e : new Error(e);
          }
        });
    
        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and arguments of the created function. If `func` is a property name the
         * created callback returns the property value for a given element. If `func`
         * is an object the created callback returns `true` for elements that contain
         * the equivalent object properties, otherwise it returns `false`.
         *
         * @static
         * @memberOf _
         * @alias iteratee
         * @category Utility
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // wrap to create custom callback shorthands
         * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
         *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
         *   if (!match) {
         *     return callback(func, thisArg);
         *   }
         *   return function(object) {
         *     return match[2] == 'gt'
         *       ? object[match[1]] > match[3]
         *       : object[match[1]] < match[3];
         *   };
         * });
         *
         * _.filter(users, 'age__gt36');
         * // => [{ 'user': 'fred', 'age': 40 }]
         */
        function callback(func, thisArg, guard) {
          if (guard && isIterateeCall(func, thisArg, guard)) {
            thisArg = undefined;
          }
          return isObjectLike(func)
            ? matches(func)
            : baseCallback(func, thisArg);
        }
    
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var object = { 'user': 'fred' };
         * var getter = _.constant(object);
         *
         * getter() === object;
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }
    
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
          return value;
        }
    
        /**
         * Creates a function that performs a deep comparison between a given object
         * and `source`, returning `true` if the given object has equivalent property
         * values, else `false`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties. For comparing a single
         * own or inherited property value see `_.matchesProperty`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, _.matches({ 'age': 40, 'active': false }));
         * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, true));
        }
    
        /**
         * Creates a function that compares the property value of `path` on a given
         * object to `value`.
         *
         * **Note:** This method supports comparing arrays, booleans, `Date` objects,
         * numbers, `Object` objects, regexes, and strings. Objects are compared by
         * their own, not inherited, enumerable properties.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * _.find(users, _.matchesProperty('user', 'fred'));
         * // => { 'user': 'fred' }
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, true));
        }
    
        /**
         * Creates a function that invokes the method at `path` on a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': _.constant(2) } } },
         *   { 'a': { 'b': { 'c': _.constant(1) } } }
         * ];
         *
         * _.map(objects, _.method('a.b.c'));
         * // => [2, 1]
         *
         * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        var method = restParam(function(path, args) {
          return function(object) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path on `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = restParam(function(object, args) {
          return function(path) {
            return invokePath(object, path, args);
          };
        });
    
        /**
         * Adds all own enumerable function properties of a source object to the
         * destination object. If `object` is a function then methods are added to
         * its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.chain=true] Specify whether the functions added
         *  are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          if (options == null) {
            var isObj = isObject(source),
                props = isObj ? keys(source) : undefined,
                methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;
    
            if (!(methodNames ? methodNames.length : isObj)) {
              methodNames = false;
              options = source;
              source = object;
              object = this;
            }
          }
          if (!methodNames) {
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = true,
              index = -1,
              isFunc = isFunction(object),
              length = methodNames.length;
    
          if (options === false) {
            chain = false;
          } else if (isObject(options) && 'chain' in options) {
            chain = options.chain;
          }
          while (++index < length) {
            var methodName = methodNames[index],
                func = source[methodName];
    
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = (function(func) {
                return function() {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                        actions = result.__actions__ = arrayCopy(this.__actions__);
    
                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }(func));
            }
          }
          return object;
        }
    
        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          root._ = oldDash;
          return this;
        }
    
        /**
         * A no-operation function that returns `undefined` regardless of the
         * arguments it receives.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @example
         *
         * var object = { 'user': 'fred' };
         *
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
          // No operation performed.
        }
    
        /**
         * Creates a function that returns the property value at `path` on a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': { 'c': 2 } } },
         *   { 'a': { 'b': { 'c': 1 } } }
         * ];
         *
         * _.map(objects, _.property('a.b.c'));
         * // => [2, 1]
         *
         * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
    
        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the property value at a given path on `object`.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return baseGet(object, toPath(path), (path + ''));
          };
        }
    
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. If `end` is not specified it's
         * set to `start` with `start` then set to `0`. If `end` is less than `start`
         * a zero-length range is created unless a negative `step` is specified.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the new array of numbers.
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        function range(start, end, step) {
          if (step && isIterateeCall(start, end, step)) {
            end = step = undefined;
          }
          start = +start || 0;
          step = step == null ? 1 : (+step || 0);
    
          if (end == null) {
            end = start;
            start = 0;
          } else {
            end = +end || 0;
          }
          // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
          // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
    
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
    
        /**
         * Invokes the iteratee function `n` times, returning an array of the results
         * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
         * one argument; (index).
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
         * // => [3, 6, 4]
         *
         * _.times(3, function(n) {
         *   mage.castSpell(n);
         * });
         * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
         *
         * _.times(3, function(n) {
         *   this.cast(n);
         * }, mage);
         * // => also invokes `mage.castSpell(n)` three times
         */
        function times(n, iteratee, thisArg) {
          n = nativeFloor(n);
    
          // Exit early to avoid a JSC JIT bug in Safari 8
          // where `Array(0)` is treated as `Array(1)`.
          if (n < 1 || !nativeIsFinite(n)) {
            return [];
          }
          var index = -1,
              result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
    
          iteratee = bindCallback(iteratee, thisArg, 1);
          while (++index < n) {
            if (index < MAX_ARRAY_LENGTH) {
              result[index] = iteratee(index);
            } else {
              iteratee(index);
            }
          }
          return result;
        }
    
        /**
         * Generates a unique ID. If `prefix` is provided the ID is appended to it.
         *
         * @static
         * @memberOf _
         * @category Utility
         * @param {string} [prefix] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return baseToString(prefix) + id;
        }
    
        /*------------------------------------------------------------------------*/
    
        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} augend The first number to add.
         * @param {number} addend The second number to add.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        function add(augend, addend) {
          return (+augend || 0) + (+addend || 0);
        }
    
        /**
         * Calculates `n` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');
    
        /**
         * Calculates `n` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');
    
        /**
         * Gets the maximum value of `collection`. If `collection` is empty or falsey
         * `-Infinity` is returned. If an iteratee function is provided it's invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => -Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.max(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'fred', 'age': 40 }
         *
         * // using the `_.property` callback shorthand
         * _.max(users, 'age');
         * // => { 'user': 'fred', 'age': 40 }
         */
        var max = createExtremum(gt, NEGATIVE_INFINITY);
    
        /**
         * Gets the minimum value of `collection`. If `collection` is empty or falsey
         * `Infinity` is returned. If an iteratee function is provided it's invoked
         * for each value in `collection` to generate the criterion by which the value
         * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
         * arguments: (value, index, collection).
         *
         * If a property name is provided for `iteratee` the created `_.property`
         * style callback returns the property value of the given element.
         *
         * If a value is also provided for `thisArg` the created `_.matchesProperty`
         * style callback returns `true` for elements that have a matching property
         * value, else `false`.
         *
         * If an object is provided for `iteratee` the created `_.matches` style
         * callback returns `true` for elements that have the properties of the given
         * object, else `false`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => Infinity
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * _.min(users, function(chr) {
         *   return chr.age;
         * });
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // using the `_.property` callback shorthand
         * _.min(users, 'age');
         * // => { 'user': 'barney', 'age': 36 }
         */
        var min = createExtremum(lt, POSITIVE_INFINITY);
    
        /**
         * Calculates `n` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {number} n The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');
    
        /**
         * Gets the sum of the values in `collection`.
         *
         * @static
         * @memberOf _
         * @category Math
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [iteratee] The function invoked per iteration.
         * @param {*} [thisArg] The `this` binding of `iteratee`.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 6]);
         * // => 10
         *
         * _.sum({ 'a': 4, 'b': 6 });
         * // => 10
         *
         * var objects = [
         *   { 'n': 4 },
         *   { 'n': 6 }
         * ];
         *
         * _.sum(objects, function(object) {
         *   return object.n;
         * });
         * // => 10
         *
         * // using the `_.property` callback shorthand
         * _.sum(objects, 'n');
         * // => 10
         */
        function sum(collection, iteratee, thisArg) {
          if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
            iteratee = undefined;
          }
          iteratee = getCallback(iteratee, thisArg, 3);
          return iteratee.length == 1
            ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
            : baseSum(collection, iteratee);
        }
    
        /*------------------------------------------------------------------------*/
    
        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
    
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
    
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
    
        // Add functions to the `Map` cache.
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
    
        // Add functions to the `Set` cache.
        SetCache.prototype.push = cachePush;
    
        // Assign cache to `_.memoize`.
        memoize.Cache = MapCache;
    
        // Add functions that return wrapped values when chaining.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.modArgs = modArgs;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
    
        // Add aliases.
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
    
        // Add functions to `lodash.prototype`.
        mixin(lodash, lodash);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions that return unwrapped values when chaining.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.floor = floor;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
    
        // Add aliases.
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.eq = isEqual;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
    
        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!lodash.prototype[methodName]) {
              source[methodName] = func;
            }
          });
          return source;
        }()), false);
    
        /*------------------------------------------------------------------------*/
    
        // Add functions capable of returning wrapped and unwrapped values when chaining.
        lodash.sample = sample;
    
        lodash.prototype.sample = function(n) {
          if (!this.__chain__ && n == null) {
            return sample(this.value());
          }
          return this.thru(function(value) {
            return sample(value, n);
          });
        };
    
        /*------------------------------------------------------------------------*/
    
        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type string
         */
        lodash.VERSION = VERSION;
    
        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
    
        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            var filtered = this.__filtered__;
            if (filtered && !index) {
              return new LazyWrapper(this);
            }
            n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);
    
            var result = this.clone();
            if (filtered) {
              result.__takeCount__ = nativeMin(result.__takeCount__, n);
            } else {
              result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
            }
            return result;
          };
    
          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
    
        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type != LAZY_MAP_FLAG;
    
          LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
            var result = this.clone();
            result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });
    
        // Add `LazyWrapper` methods for `_.first` and `_.last`.
        arrayEach(['first', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');
    
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
    
        // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
        arrayEach(['initial', 'rest'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');
    
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
    
        // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
        arrayEach(['pluck', 'where'], function(methodName, index) {
          var operationName = index ? 'filter' : 'map',
              createCallback = index ? baseMatches : property;
    
          LazyWrapper.prototype[methodName] = function(value) {
            return this[operationName](createCallback(value));
          };
        });
    
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
    
        LazyWrapper.prototype.reject = function(predicate, thisArg) {
          predicate = getCallback(predicate, thisArg, 1);
          return this.filter(function(value) {
            return !predicate(value);
          });
        };
    
        LazyWrapper.prototype.slice = function(start, end) {
          start = start == null ? 0 : (+start || 0);
    
          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = (+end || 0);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };
    
        LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
          return this.reverse().takeWhile(predicate, thisArg).reverse();
        };
    
        LazyWrapper.prototype.toArray = function() {
          return this.take(POSITIVE_INFINITY);
        };
    
        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
              retUnwrapped = /^(?:first|last)$/.test(methodName),
              lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];
    
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var args = retUnwrapped ? [1] : arguments,
                chainAll = this.__chain__,
                value = this.__wrapped__,
                isHybrid = !!this.__actions__.length,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
    
            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var interceptor = function(value) {
              return (retUnwrapped && chainAll)
                ? lodashFunc(value, 1)[0]
                : lodashFunc.apply(undefined, arrayPush([value], args));
            };
    
            var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
                onlyLazy = isLazy && !isHybrid;
    
            if (retUnwrapped && !chainAll) {
              if (onlyLazy) {
                value = value.clone();
                value.__actions__.push(action);
                return func.call(value);
              }
              return lodashFunc.call(undefined, this.value())[0];
            }
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push(action);
              return new LodashWrapper(result, chainAll);
            }
            return this.thru(interceptor);
          };
        });
    
        // Add `Array` and `String` methods to `lodash.prototype`.
        arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
          var protoFunc = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              fixObjects = !support.spliceObjects && /^(?:pop|shift|splice)$/.test(methodName),
              retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
    
          // Avoid array-like object bugs with `Array#shift` and `Array#splice` in
          // IE < 9, Firefox < 10, and RingoJS.
          var func = !fixObjects ? protoFunc : function() {
            var result = protoFunc.apply(this, arguments);
            if (this.length === 0) {
              delete this[0];
            }
            return result;
          };
    
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              return func.apply(this.value(), args);
            }
            return this[chainName](function(value) {
              return func.apply(value, args);
            });
          };
        });
    
        // Map minified function names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = (lodashFunc.name + ''),
                names = realNames[key] || (realNames[key] = []);
    
            names.push({ 'name': methodName, 'func': lodashFunc });
          }
        });
    
        realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];
    
        // Add functions to the lazy wrapper.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
    
        // Add chaining functions to the `lodash` wrapper.
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.concat = wrapperConcat;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
    
        // Add function aliases to the `lodash` wrapper.
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
    
        return lodash;
      }
    
      /*--------------------------------------------------------------------------*/
    
      // Export lodash.
      var _ = runInContext();
    
      // Some AMD build optimizers like r.js check for condition patterns like the following:
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        // Expose lodash to the global object when an AMD loader is present to avoid
        // errors in cases where lodash is loaded by a script tag and not intended
        // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
        // more details.
        root._ = _;
    
        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        define(function() {
          return _;
        });
      }
      // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
      else if (freeExports && freeModule) {
        // Export for Node.js or RingoJS.
        if (moduleExports) {
          (freeModule.exports = _)._ = _;
        }
        // Export for Rhino with CommonJS support.
        else {
          freeExports._ = _;
        }
      }
      else {
        // Export for a browser or Rhino.
        root._ = _;
      }
    }.call(this));
    
  provide("lodash-compat", module.exports);
}(global));

// pakmanager:compression
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * compression
     * Copyright(c) 2010 Sencha Inc.
     * Copyright(c) 2011 TJ Holowaychuk
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict'
    
    /**
     * Module dependencies.
     * @private
     */
    
    var accepts = require('accepts')
    var bytes = require('bytes')
    var compressible = require('compressible')
    var debug = require('debug')('compression')
    var onHeaders = require('on-headers')
    var vary = require('vary')
    var zlib = require('zlib')
    
    /**
     * Module exports.
     */
    
    module.exports = compression
    module.exports.filter = shouldCompress
    
    /**
     * Module variables.
     * @private
     */
    
    var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/
    
    /**
     * Compress response data with gzip / deflate.
     *
     * @param {Object} options
     * @return {Function} middleware
     * @public
     */
    
    function compression(options) {
      var opts = options || {}
    
      // options
      var filter = opts.filter || shouldCompress
      var threshold = bytes.parse(opts.threshold)
    
      if (threshold == null) {
        threshold = 1024
      }
    
      return function compression(req, res, next){
        var ended = false
        var length
        var listeners = []
        var write = res.write
        var on = res.on
        var end = res.end
        var stream
    
        // flush
        res.flush = function flush() {
          if (stream) {
            stream.flush()
          }
        }
    
        // proxy
    
        res.write = function(chunk, encoding){
          if (ended) {
            return false
          }
    
          if (!this._header) {
            this._implicitHeader()
          }
    
          return stream
            ? stream.write(new Buffer(chunk, encoding))
            : write.call(this, chunk, encoding)
        };
    
        res.end = function(chunk, encoding){
          if (ended) {
            return false
          }
    
          if (!this._header) {
            // estimate the length
            if (!this.getHeader('Content-Length')) {
              length = chunkLength(chunk, encoding)
            }
    
            this._implicitHeader()
          }
    
          if (!stream) {
            return end.call(this, chunk, encoding)
          }
    
          // mark ended
          ended = true
    
          // write Buffer for Node.js 0.8
          return chunk
            ? stream.end(new Buffer(chunk, encoding))
            : stream.end()
        };
    
        res.on = function(type, listener){
          if (!listeners || type !== 'drain') {
            return on.call(this, type, listener)
          }
    
          if (stream) {
            return stream.on(type, listener)
          }
    
          // buffer listeners for future stream
          listeners.push([type, listener])
    
          return this
        }
    
        function nocompress(msg) {
          debug('no compression: %s', msg)
          addListeners(res, on, listeners)
          listeners = null
        }
    
        onHeaders(res, function(){
          // determine if request is filtered
          if (!filter(req, res)) {
            nocompress('filtered')
            return
          }
    
          // determine if the entity should be transformed
          if (!shouldTransform(req, res)) {
            nocompress('no transform')
            return
          }
    
          // vary
          vary(res, 'Accept-Encoding')
    
          // content-length below threshold
          if (Number(res.getHeader('Content-Length')) < threshold || length < threshold) {
            nocompress('size below threshold')
            return
          }
    
          var encoding = res.getHeader('Content-Encoding') || 'identity';
    
          // already encoded
          if ('identity' !== encoding) {
            nocompress('already encoded')
            return
          }
    
          // head
          if ('HEAD' === req.method) {
            nocompress('HEAD request')
            return
          }
    
          // compression method
          var accept = accepts(req)
          var method = accept.encoding(['gzip', 'deflate', 'identity'])
    
          // we really don't prefer deflate
          if (method === 'deflate' && accept.encoding(['gzip'])) {
            method = accept.encoding(['gzip', 'identity'])
          }
    
          // negotiation failed
          if (!method || method === 'identity') {
            nocompress('not acceptable')
            return
          }
    
          // compression stream
          debug('%s compression', method)
          stream = method === 'gzip'
            ? zlib.createGzip(opts)
            : zlib.createDeflate(opts)
    
          // add buffered listeners to stream
          addListeners(stream, stream.on, listeners)
    
          // header fields
          res.setHeader('Content-Encoding', method);
          res.removeHeader('Content-Length');
    
          // compression
          stream.on('data', function(chunk){
            if (write.call(res, chunk) === false) {
              stream.pause()
            }
          });
    
          stream.on('end', function(){
            end.call(res);
          });
    
          on.call(res, 'drain', function() {
            stream.resume()
          });
        });
    
        next();
      };
    }
    
    /**
     * Add bufferred listeners to stream
     * @private
     */
    
    function addListeners(stream, on, listeners) {
      for (var i = 0; i < listeners.length; i++) {
        on.apply(stream, listeners[i])
      }
    }
    
    /**
     * Get the length of a given chunk
     */
    
    function chunkLength(chunk, encoding) {
      if (!chunk) {
        return 0
      }
    
      return !Buffer.isBuffer(chunk)
        ? Buffer.byteLength(chunk, encoding)
        : chunk.length
    }
    
    /**
     * Default filter function.
     * @private
     */
    
    function shouldCompress(req, res) {
      var type = res.getHeader('Content-Type')
    
      if (type === undefined || !compressible(type)) {
        debug('%s not compressible', type)
        return false
      }
    
      return true
    }
    
    /**
     * Determine if the entity should be transformed.
     * @private
     */
    
    function shouldTransform(req, res) {
      var cacheControl = res.getHeader('Cache-Control')
    
      // Don't compress for Cache-Control: no-transform
      // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
      return !cacheControl
        || !cacheControlNoTransformRegExp.test(cacheControl)
    }
    
  provide("compression", module.exports);
}(global));

// pakmanager:express
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * express
     * Copyright(c) 2009-2013 TJ Holowaychuk
     * Copyright(c) 2013 Roman Shtylman
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    module.exports = require('./lib/express');
    
  provide("express", module.exports);
}(global));

// pakmanager:serve-index
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * serve-index
     * Copyright(c) 2011 Sencha Inc.
     * Copyright(c) 2011 TJ Holowaychuk
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */
    
    'use strict';
    
    /**
     * Module dependencies.
     * @private
     */
    
    var accepts = require('accepts');
    var createError = require('http-errors');
    var debug = require('debug')('serve-index');
    var escapeHtml = require('escape-html');
    var fs = require('fs')
      , path = require('path')
      , normalize = path.normalize
      , sep = path.sep
      , extname = path.extname
      , join = path.join;
    var Batch = require('batch');
    var mime = require('mime-types');
    var parseUrl = require('parseurl');
    var resolve = require('path').resolve;
    
    /**
     * Module exports.
     * @public
     */
    
    module.exports = serveIndex;
    
    /*!
     * Icon cache.
     */
    
    var cache = {};
    
    /*!
     * Default template.
     */
    
    var defaultTemplate = join(__dirname, 'public', 'directory.html');
    
    /*!
     * Stylesheet.
     */
    
    var defaultStylesheet = join(__dirname, 'public', 'style.css');
    
    /**
     * Media types and the map for content negotiation.
     */
    
    var mediaTypes = [
      'text/html',
      'text/plain',
      'application/json'
    ];
    
    var mediaType = {
      'text/html': 'html',
      'text/plain': 'plain',
      'application/json': 'json'
    };
    
    /**
     * Serve directory listings with the given `root` path.
     *
     * See Readme.md for documentation of options.
     *
     * @param {String} root
     * @param {Object} options
     * @return {Function} middleware
     * @public
     */
    
    function serveIndex(root, options) {
      var opts = options || {};
    
      // root required
      if (!root) {
        throw new TypeError('serveIndex() root path required');
      }
    
      // resolve root to absolute and normalize
      var rootPath = normalize(resolve(root) + sep);
    
      var filter = opts.filter;
      var hidden = opts.hidden;
      var icons = opts.icons;
      var stylesheet = opts.stylesheet || defaultStylesheet;
      var template = opts.template || defaultTemplate;
      var view = opts.view || 'tiles';
    
      return function (req, res, next) {
        if (req.method !== 'GET' && req.method !== 'HEAD') {
          res.statusCode = 'OPTIONS' === req.method ? 200 : 405;
          res.setHeader('Allow', 'GET, HEAD, OPTIONS');
          res.setHeader('Content-Length', '0');
          res.end();
          return;
        }
    
        // parse URLs
        var url = parseUrl(req);
        var originalUrl = parseUrl.original(req);
        var dir = decodeURIComponent(url.pathname);
        var originalDir = decodeURIComponent(originalUrl.pathname);
    
        // join / normalize from root dir
        var path = normalize(join(rootPath, dir));
    
        // null byte(s), bad request
        if (~path.indexOf('\0')) return next(createError(400));
    
        // malicious path
        if ((path + sep).substr(0, rootPath.length) !== rootPath) {
          debug('malicious path "%s"', path);
          return next(createError(403));
        }
    
        // determine ".." display
        var showUp = normalize(resolve(path) + sep) !== rootPath;
    
        // check if we have a directory
        debug('stat "%s"', path);
        fs.stat(path, function(err, stat){
          if (err && err.code === 'ENOENT') {
            return next();
          }
    
          if (err) {
            err.status = err.code === 'ENAMETOOLONG'
              ? 414
              : 500;
            return next(err);
          }
    
          if (!stat.isDirectory()) return next();
    
          // fetch files
          debug('readdir "%s"', path);
          fs.readdir(path, function(err, files){
            if (err) return next(err);
            if (!hidden) files = removeHidden(files);
            if (filter) files = files.filter(function(filename, index, list) {
              return filter(filename, index, list, path);
            });
            files.sort();
    
            // content-negotiation
            var accept = accepts(req);
            var type = accept.type(mediaTypes);
    
            // not acceptable
            if (!type) return next(createError(406));
            serveIndex[mediaType[type]](req, res, files, next, originalDir, showUp, icons, path, view, template, stylesheet);
          });
        });
      };
    };
    
    /**
     * Respond with text/html.
     */
    
    serveIndex.html = function _html(req, res, files, next, dir, showUp, icons, path, view, template, stylesheet) {
      var render = typeof template !== 'function'
        ? createHtmlRender(template)
        : template
    
      if (showUp) {
        files.unshift('..');
      }
    
      // stat all files
      stat(path, files, function (err, stats) {
        if (err) return next(err);
    
        // combine the stats into the file list
        var fileList = files.map(function (file, i) {
          return { name: file, stat: stats[i] };
        });
    
        // sort file list
        fileList.sort(fileSort);
    
        // read stylesheet
        fs.readFile(stylesheet, 'utf8', function (err, style) {
          if (err) return next(err);
    
          // create locals for rendering
          var locals = {
            directory: dir,
            displayIcons: Boolean(icons),
            fileList: fileList,
            path: path,
            style: style,
            viewName: view
          };
    
          // render html
          render(locals, function (err, body) {
            if (err) return next(err);
    
            var buf = new Buffer(body, 'utf8');
            res.setHeader('Content-Type', 'text/html; charset=utf-8');
            res.setHeader('Content-Length', buf.length);
            res.end(buf);
          });
        });
      });
    };
    
    /**
     * Respond with application/json.
     */
    
    serveIndex.json = function _json(req, res, files) {
      var body = JSON.stringify(files);
      var buf = new Buffer(body, 'utf8');
    
      res.setHeader('Content-Type', 'application/json; charset=utf-8');
      res.setHeader('Content-Length', buf.length);
      res.end(buf);
    };
    
    /**
     * Respond with text/plain.
     */
    
    serveIndex.plain = function _plain(req, res, files) {
      var body = files.join('\n') + '\n';
      var buf = new Buffer(body, 'utf8');
    
      res.setHeader('Content-Type', 'text/plain; charset=utf-8');
      res.setHeader('Content-Length', buf.length);
      res.end(buf);
    };
    
    /**
     * Map html `files`, returning an html unordered list.
     * @private
     */
    
    function createHtmlFileList(files, dir, useIcons, view) {
      var html = '<ul id="files" class="view-' + escapeHtml(view) + '">'
        + (view == 'details' ? (
          '<li class="header">'
          + '<span class="name">Name</span>'
          + '<span class="size">Size</span>'
          + '<span class="date">Modified</span>'
          + '</li>') : '');
    
      html += files.map(function (file) {
        var classes = [];
        var isDir = file.stat && file.stat.isDirectory();
        var path = dir.split('/').map(function (c) { return encodeURIComponent(c); });
    
        if (useIcons) {
          classes.push('icon');
    
          if (isDir) {
            classes.push('icon-directory');
          } else {
            var ext = extname(file.name);
            var icon = iconLookup(file.name);
    
            classes.push('icon');
            classes.push('icon-' + ext.substring(1));
    
            if (classes.indexOf(icon.className) === -1) {
              classes.push(icon.className);
            }
          }
        }
    
        path.push(encodeURIComponent(file.name));
    
        var date = file.stat && file.name !== '..'
          ? file.stat.mtime.toLocaleDateString() + ' ' + file.stat.mtime.toLocaleTimeString()
          : '';
        var size = file.stat && !isDir
          ? file.stat.size
          : '';
    
        return '<li><a href="'
          + escapeHtml(normalizeSlashes(normalize(path.join('/'))))
          + '" class="' + escapeHtml(classes.join(' ')) + '"'
          + ' title="' + escapeHtml(file.name) + '">'
          + '<span class="name">' + escapeHtml(file.name) + '</span>'
          + '<span class="size">' + escapeHtml(size) + '</span>'
          + '<span class="date">' + escapeHtml(date) + '</span>'
          + '</a></li>';
      }).join('\n');
    
      html += '</ul>';
    
      return html;
    }
    
    /**
     * Create function to render html.
     */
    
    function createHtmlRender(template) {
      return function render(locals, callback) {
        // read template
        fs.readFile(template, 'utf8', function (err, str) {
          if (err) return callback(err);
    
          var body = str
            .replace(/\{style\}/g, locals.style.concat(iconStyle(locals.fileList, locals.displayIcons)))
            .replace(/\{files\}/g, createHtmlFileList(locals.fileList, locals.directory, locals.displayIcons, locals.viewName))
            .replace(/\{directory\}/g, escapeHtml(locals.directory))
            .replace(/\{linked-path\}/g, htmlPath(locals.directory));
    
          callback(null, body);
        });
      };
    }
    
    /**
     * Sort function for with directories first.
     */
    
    function fileSort(a, b) {
      // sort ".." to the top
      if (a.name === '..' || b.name === '..') {
        return a.name === b.name ? 0
          : a.name === '..' ? -1 : 1;
      }
    
      return Number(b.stat && b.stat.isDirectory()) - Number(a.stat && a.stat.isDirectory()) ||
        String(a.name).toLocaleLowerCase().localeCompare(String(b.name).toLocaleLowerCase());
    }
    
    /**
     * Map html `dir`, returning a linked path.
     */
    
    function htmlPath(dir) {
      var parts = dir.split('/');
      var crumb = new Array(parts.length);
    
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
    
        if (part) {
          parts[i] = encodeURIComponent(part);
          crumb[i] = '<a href="' + escapeHtml(parts.slice(0, i + 1).join('/')) + '">' + escapeHtml(part) + '</a>';
        }
      }
    
      return crumb.join(' / ');
    }
    
    /**
     * Get the icon data for the file name.
     */
    
    function iconLookup(filename) {
      var ext = extname(filename);
    
      // try by extension
      if (icons[ext]) {
        return {
          className: 'icon-' + ext.substring(1),
          fileName: icons[ext]
        };
      }
    
      var mimetype = mime.lookup(ext);
    
      // default if no mime type
      if (mimetype === false) {
        return {
          className: 'icon-default',
          fileName: icons.default
        };
      }
    
      // try by mime type
      if (icons[mimetype]) {
        return {
          className: 'icon-' + mimetype.replace('/', '-'),
          fileName: icons[mimetype]
        };
      }
    
      var suffix = mimetype.split('+')[1];
    
      if (suffix && icons['+' + suffix]) {
        return {
          className: 'icon-' + suffix,
          fileName: icons['+' + suffix]
        };
      }
    
      var type = mimetype.split('/')[0];
    
      // try by type only
      if (icons[type]) {
        return {
          className: 'icon-' + type,
          fileName: icons[type]
        };
      }
    
      return {
        className: 'icon-default',
        fileName: icons.default
      };
    }
    
    /**
     * Load icon images, return css string.
     */
    
    function iconStyle(files, useIcons) {
      if (!useIcons) return '';
      var className;
      var i;
      var iconName;
      var list = [];
      var rules = {};
      var selector;
      var selectors = {};
      var style = '';
    
      for (i = 0; i < files.length; i++) {
        var file = files[i];
    
        var isDir = file.stat && file.stat.isDirectory();
        var icon = isDir
          ? { className: 'icon-directory', fileName: icons.folder }
          : iconLookup(file.name);
        var iconName = icon.fileName;
    
        selector = '#files .' + icon.className + ' .name';
    
        if (!rules[iconName]) {
          rules[iconName] = 'background-image: url(data:image/png;base64,' + load(iconName) + ');'
          selectors[iconName] = [];
          list.push(iconName);
        }
    
        if (selectors[iconName].indexOf(selector) === -1) {
          selectors[iconName].push(selector);
        }
      }
    
      for (i = 0; i < list.length; i++) {
        iconName = list[i];
        style += selectors[iconName].join(',\n') + ' {\n  ' + rules[iconName] + '\n}\n';
      }
    
      return style;
    }
    
    /**
     * Load and cache the given `icon`.
     *
     * @param {String} icon
     * @return {String}
     * @api private
     */
    
    function load(icon) {
      if (cache[icon]) return cache[icon];
      return cache[icon] = fs.readFileSync(__dirname + '/public/icons/' + icon, 'base64');
    }
    
    /**
     * Normalizes the path separator from system separator
     * to URL separator, aka `/`.
     *
     * @param {String} path
     * @return {String}
     * @api private
     */
    
    function normalizeSlashes(path) {
      return path.split(sep).join('/');
    };
    
    /**
     * Filter "hidden" `files`, aka files
     * beginning with a `.`.
     *
     * @param {Array} files
     * @return {Array}
     * @api private
     */
    
    function removeHidden(files) {
      return files.filter(function(file){
        return '.' != file[0];
      });
    }
    
    /**
     * Stat all files and return array of stat
     * in same order.
     */
    
    function stat(dir, files, cb) {
      var batch = new Batch();
    
      batch.concurrency(10);
    
      files.forEach(function(file){
        batch.push(function(done){
          fs.stat(join(dir, file), function(err, stat){
            if (err && err.code !== 'ENOENT') return done(err);
    
            // pass ENOENT as null stat, not error
            done(null, stat || null);
          });
        });
      });
    
      batch.end(cb);
    }
    
    /**
     * Icon map.
     */
    
    var icons = {
      // base icons
      'default': 'page_white.png',
      'folder': 'folder.png',
    
      // generic mime type icons
      'image': 'image.png',
      'text': 'page_white_text.png',
      'video': 'film.png',
    
      // generic mime suffix icons
      '+json': 'page_white_code.png',
      '+xml': 'page_white_code.png',
      '+zip': 'box.png',
    
      // specific mime type icons
      'application/font-woff': 'font.png',
      'application/javascript': 'page_white_code_red.png',
      'application/json': 'page_white_code.png',
      'application/msword': 'page_white_word.png',
      'application/pdf': 'page_white_acrobat.png',
      'application/postscript': 'page_white_vector.png',
      'application/rtf': 'page_white_word.png',
      'application/vnd.ms-excel': 'page_white_excel.png',
      'application/vnd.ms-powerpoint': 'page_white_powerpoint.png',
      'application/vnd.oasis.opendocument.presentation': 'page_white_powerpoint.png',
      'application/vnd.oasis.opendocument.spreadsheet': 'page_white_excel.png',
      'application/vnd.oasis.opendocument.text': 'page_white_word.png',
      'application/x-7z-compressed': 'box.png',
      'application/x-sh': 'application_xp_terminal.png',
      'application/x-font-ttf': 'font.png',
      'application/x-msaccess': 'page_white_database.png',
      'application/x-shockwave-flash': 'page_white_flash.png',
      'application/x-sql': 'page_white_database.png',
      'application/x-tar': 'box.png',
      'application/x-xz': 'box.png',
      'application/xml': 'page_white_code.png',
      'application/zip': 'box.png',
      'image/svg+xml': 'page_white_vector.png',
      'text/css': 'page_white_code.png',
      'text/html': 'page_white_code.png',
      'text/less': 'page_white_code.png',
    
      // other, extension-specific icons
      '.accdb': 'page_white_database.png',
      '.apk': 'box.png',
      '.app': 'application_xp.png',
      '.as': 'page_white_actionscript.png',
      '.asp': 'page_white_code.png',
      '.aspx': 'page_white_code.png',
      '.bat': 'application_xp_terminal.png',
      '.bz2': 'box.png',
      '.c': 'page_white_c.png',
      '.cab': 'box.png',
      '.cfm': 'page_white_coldfusion.png',
      '.clj': 'page_white_code.png',
      '.cc': 'page_white_cplusplus.png',
      '.cgi': 'application_xp_terminal.png',
      '.cpp': 'page_white_cplusplus.png',
      '.cs': 'page_white_csharp.png',
      '.db': 'page_white_database.png',
      '.dbf': 'page_white_database.png',
      '.deb': 'box.png',
      '.dll': 'page_white_gear.png',
      '.dmg': 'drive.png',
      '.docx': 'page_white_word.png',
      '.erb': 'page_white_ruby.png',
      '.exe': 'application_xp.png',
      '.fnt': 'font.png',
      '.gam': 'controller.png',
      '.gz': 'box.png',
      '.h': 'page_white_h.png',
      '.ini': 'page_white_gear.png',
      '.iso': 'cd.png',
      '.jar': 'box.png',
      '.java': 'page_white_cup.png',
      '.jsp': 'page_white_cup.png',
      '.lua': 'page_white_code.png',
      '.lz': 'box.png',
      '.lzma': 'box.png',
      '.m': 'page_white_code.png',
      '.map': 'map.png',
      '.msi': 'box.png',
      '.mv4': 'film.png',
      '.otf': 'font.png',
      '.pdb': 'page_white_database.png',
      '.php': 'page_white_php.png',
      '.pl': 'page_white_code.png',
      '.pkg': 'box.png',
      '.pptx': 'page_white_powerpoint.png',
      '.psd': 'page_white_picture.png',
      '.py': 'page_white_code.png',
      '.rar': 'box.png',
      '.rb': 'page_white_ruby.png',
      '.rm': 'film.png',
      '.rom': 'controller.png',
      '.rpm': 'box.png',
      '.sass': 'page_white_code.png',
      '.sav': 'controller.png',
      '.scss': 'page_white_code.png',
      '.srt': 'page_white_text.png',
      '.tbz2': 'box.png',
      '.tgz': 'box.png',
      '.tlz': 'box.png',
      '.vb': 'page_white_code.png',
      '.vbs': 'page_white_code.png',
      '.xcf': 'page_white_picture.png',
      '.xlsx': 'page_white_excel.png',
      '.yaws': 'page_white_code.png'
    };
    
  provide("serve-index", module.exports);
}(global));

// pakmanager:sockjs
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./lib/sockjs');
    
  provide("sockjs", module.exports);
}(global));

// pakmanager:stream-cache
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports = require('./lib/StreamCache');
    
  provide("stream-cache", module.exports);
}(global));

// pakmanager:webpack-dev-middleware
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
    	MIT License http://www.opensource.org/licenses/mit-license.php
    	Author Tobias Koppers @sokra
    */
    var MemoryFileSystem = require("memory-fs");
    var mime = require("mime");
    var parseRange = require("range-parser");
    
    var HASH_REGEXP = /[0-9a-f]{10,}/;
    
    // constructor for the middleware
    module.exports = function(compiler, options) {
    	if(!options) options = {};
    	if(typeof options.watchOptions === "undefined") options.watchOptions = {};
    	if(typeof options.watchDelay !== "undefined") {
    		// TODO remove this in next major version
    		console.warn("options.watchDelay is deprecated: Use 'options.watchOptions.aggregateTimeout' instead");
    		options.watchOptions.aggregateTimeout = options.watchDelay;
    	}
    	if(typeof options.watchOptions.aggregateTimeout === "undefined") options.watchOptions.aggregateTimeout = 200;
    	if(typeof options.stats === "undefined") options.stats = {};
    	if(!options.stats.context) options.stats.context = process.cwd();
    	if(options.lazy) {
    		if(typeof options.filename === "string") {
    			var str = options.filename
    				.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
    				.replace(/\\\[[a-z]+\\\]/ig, ".+");
    			options.filename = new RegExp("^[\/]{0,1}" + str + "$");
    		}
    	}
    
    	// store our files in memory
    	var files = {};
    	var fs = compiler.outputFileSystem = new MemoryFileSystem();
    
    	compiler.plugin("done", function(stats) {
    		// We are now on valid state
    		state = true;
    		// Do the stuff in nextTick, because bundle may be invalidated
    		//  if a change happend while compiling
    		process.nextTick(function() {
    			// check if still in valid state
    			if(!state) return;
    			// print webpack output
    			var displayStats = (!options.quiet && options.stats !== false);
    			if(displayStats &&
    				!(stats.hasErrors() || stats.hasWarnings()) &&
    				options.noInfo)
    				displayStats = false;
    			if(displayStats) {
    				console.log(stats.toString(options.stats));
    			}
    			if (!options.noInfo && !options.quiet)
    				console.info("webpack: bundle is now VALID.");
    
    			// execute callback that are delayed
    			var cbs = callbacks;
    			callbacks = [];
    			cbs.forEach(function continueBecauseBundleAvailible(cb) {
    				cb();
    			});
    		});
    
    		// In lazy mode, we may issue another rebuild
    		if(forceRebuild) {
    			forceRebuild = false;
    			rebuild();
    		}
    	});
    
    	// on compiling
    	function invalidPlugin() {
    		if(state && (!options.noInfo && !options.quiet))
    			console.info("webpack: bundle is now INVALID.");
    		// We are now in invalid state
    		state = false;
    	}
    	function invalidAsyncPlugin(compiler, callback) {
    		invalidPlugin();
    		callback();
    	}
    	compiler.plugin("invalid", invalidPlugin);
    	compiler.plugin("watch-run", invalidAsyncPlugin);
    	compiler.plugin("run", invalidAsyncPlugin);
    
    	// the state, false: bundle invalid, true: bundle valid
    	var state = false;
    
    	// in lazy mode, rebuild automatically
    	var forceRebuild = false;
    
    	// delayed callback
    	var callbacks = [];
    
    	// wait for bundle valid
    	function ready(fn, req) {
    		if(state) return fn();
    		if(!options.noInfo && !options.quiet)
    			console.log("webpack: wait until bundle finished: " + (req.url || fn.name));
    		callbacks.push(fn);
    	}
    
    	// start watching
    	if(!options.lazy) {
    		var watching = compiler.watch(options.watchOptions, function(err) {
    			if(err) throw err;
    		});
    	} else {
    		state = true;
    	}
    
    	function rebuild() {
    		if(state) {
    			state = false;
    			compiler.run(function(err) {
    				if(err) throw err;
    			});
    		} else {
    			forceRebuild = true;
    		}
    	}
    
    	function pathJoin(a, b) {
    		return a == "/" ? "/" + b : (a||"") + "/" + b
    	}
    
    	function getFilenameFromUrl(url) {
    		// publicPrefix is the folder our bundle should be in
    		var localPrefix = options.publicPath || "/";
    		if(url.indexOf(localPrefix) !== 0) {
    			if(/^(https?:)?\/\//.test(localPrefix)) {
    				localPrefix = "/" + localPrefix.replace(/^(https?:)?\/\/[^\/]+\//, "");
    				// fast exit if another directory requested
    				if(url.indexOf(localPrefix) !== 0) return false;
    			} else return false;
    		}
    		// get filename from request
    		var filename = url.substr(localPrefix.length);
    		if(filename.indexOf("?") >= 0) {
    			filename = filename.substr(0, filename.indexOf("?"));
    		}
    		return filename ? pathJoin(compiler.outputPath, filename) : compiler.outputPath;
    	}
    
    	function handleRangeHeaders(content, req, res) {
    		if (req.headers['Accept-Ranges']) res.setHeader('Accept-Ranges', 'bytes');
    		if (req.headers.range) {
    			var ranges = parseRange(content.length, req.headers.range);
    
    			// unsatisfiable
    			if (-1 == ranges) {
    				res.setHeader('Content-Range', 'bytes */' + content.length);
    				res.statusCode = 416;
    				return content;
    			}
    
    			// valid (syntactically invalid/multiple ranges are treated as a regular response)
    			if (-2 != ranges && ranges.length === 1) {
    				// Content-Range
    				res.statusCode = 206;
    				var length = content.length;
    				res.setHeader(
    					'Content-Range',
    					'bytes ' + ranges[0].start + '-' + ranges[0].end + '/' + length
    				);
    
    				content = content.slice(ranges[0].start, ranges[0].end + 1);
    			}
    		}
    		return content;
    	}
    
    	// The middleware function
    	function webpackDevMiddleware(req, res, next) {
    		var filename = getFilenameFromUrl(req.url);
    		if (filename === false) return next();
    
    		// in lazy mode, rebuild on bundle request
    		if(options.lazy && (!options.filename || options.filename.test(filename)))
    			rebuild();
    
    		if(HASH_REGEXP.test(filename)) {
    			try {
    				if(fs.statSync(filename).isFile()) {
    					processRequest();
    					return;
    				}
    			} catch(e) {}
    		}
    		// delay the request until we have a vaild bundle
    		ready(processRequest, req);
    		function processRequest() {
    			try {
    				var stat = fs.statSync(filename);
    				if(!stat.isFile()) {
    					if (stat.isDirectory()) {
    						filename = pathJoin(filename, "index.html");
    						stat = fs.statSync(filename);
    						if(!stat.isFile()) throw "next";
    					} else {
    						throw "next";
    					}
    				}
    			} catch(e) {
    				return next();
    			}
    
    			// server content
    			var content = fs.readFileSync(filename);
    			content = handleRangeHeaders(content, req, res);
    			res.setHeader("Access-Control-Allow-Origin", "*"); // To support XHR, etc.
    			res.setHeader("Content-Type", mime.lookup(filename));
    			res.setHeader("Content-Length", content.length);
    			if(options.headers) {
    				for(var name in options.headers) {
    					res.setHeader(name, options.headers[name]);
    				}
    			}
    			if (res.send) res.send(content);
    			else res.end(content);
    		}
    	}
    
    	webpackDevMiddleware.getFilenameFromUrl = getFilenameFromUrl;
    
    	webpackDevMiddleware.waitUntilValid = function(callback) {
    		callback = callback || function(){};
    		if (!watching || !watching.running) callback();
    		else ready(callback, {});
    	};
    
    	webpackDevMiddleware.invalidate = function(callback) {
    		callback = callback || function(){};
    		if(watching) {
    			ready(callback, {});
    			watching.invalidate();
    		} else {
    			callback();
    		}
    	};
    
    	webpackDevMiddleware.close = function(callback) {
    		callback = callback || function(){};
    		if(watching) watching.close(callback);
    		else callback();
    	};
    
    	webpackDevMiddleware.fileSystem = fs;
    
    	return webpackDevMiddleware;
    }
    
  provide("webpack-dev-middleware", module.exports);
}(global));

// pakmanager:helmet
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var connect = require('connect');
    
    var crossdomain = require('./lib/deprecated-crossdomain');
    var config = require('./config.json');
    
    function helmet() {
      var chain = connect();
      config.defaultMiddleware.forEach(function(middlewareName) {
        chain.use(helmet[middlewareName]());
      });
      return chain;
    }
    
    Object.keys(config.middlewares).forEach(function(moduleName) {
      var pkg = require(moduleName);
      var aliases = config.middlewares[moduleName];
      helmet[moduleName] = pkg;
      aliases.forEach(function(aliasName) {
        helmet[aliasName] = pkg;
      });
    });
    
    helmet.crossdomain = helmet.crossDomain = crossdomain;
    
    module.exports = helmet;
    
  provide("helmet", module.exports);
}(global));

// pakmanager:material-ui
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Icons = exports.Utils = exports.Tooltip = exports.ToolbarTitle = exports.ToolbarSeparator = exports.ToolbarGroup = exports.Toolbar = exports.TextField = exports.TimePicker = exports.ThemeWrapper = exports.Toggle = exports.TableRowColumn = exports.TableRow = exports.TableHeaderColumn = exports.TableHeader = exports.TableFooter = exports.TableBody = exports.Table = exports.Tabs = exports.Tab = exports.Snackbar = exports.Styles = exports.SvgIcon = exports.Slider = exports.SelectableContainerEnhance = exports.SelectField = exports.Ripples = exports.RefreshIndicator = exports.RaisedButton = exports.RadioButtonGroup = exports.RadioButton = exports.Popover = exports.Paper = exports.Overlay = exports.Mixins = exports.MenuItem = exports.Menu = exports.ListItem = exports.ListDivider = exports.List = exports.LinearProgress = exports.LeftNav = exports.IconMenu = exports.IconButton = exports.GridTile = exports.GridList = exports.FontIcon = exports.FloatingActionButton = exports.FlatButton = exports.EnhancedButton = exports.DropDownMenu = exports.DropDownIcon = exports.Divider = exports.Dialog = exports.DatePickerDialog = exports.DatePicker = exports.ClearFix = exports.CircularProgress = exports.Checkbox = exports.CardTitle = exports.CardText = exports.CardMedia = exports.CardHeader = exports.CardExpandable = exports.CardActions = exports.Card = exports.BeforeAfterWrapper = exports.Badge = exports.Avatar = exports.AutoComplete = exports.AppCanvas = exports.AppBar = undefined;
    
    var _appBar = require('./app-bar');
    
    var _appBar2 = _interopRequireDefault(_appBar);
    
    var _appCanvas = require('./app-canvas');
    
    var _appCanvas2 = _interopRequireDefault(_appCanvas);
    
    var _autoComplete = require('./auto-complete');
    
    var _autoComplete2 = _interopRequireDefault(_autoComplete);
    
    var _avatar = require('./avatar');
    
    var _avatar2 = _interopRequireDefault(_avatar);
    
    var _badge = require('./badge');
    
    var _badge2 = _interopRequireDefault(_badge);
    
    var _beforeAfterWrapper = require('./before-after-wrapper');
    
    var _beforeAfterWrapper2 = _interopRequireDefault(_beforeAfterWrapper);
    
    var _card = require('./card/card');
    
    var _card2 = _interopRequireDefault(_card);
    
    var _cardActions = require('./card/card-actions');
    
    var _cardActions2 = _interopRequireDefault(_cardActions);
    
    var _cardExpandable = require('./card/card-expandable');
    
    var _cardExpandable2 = _interopRequireDefault(_cardExpandable);
    
    var _cardHeader = require('./card/card-header');
    
    var _cardHeader2 = _interopRequireDefault(_cardHeader);
    
    var _cardMedia = require('./card/card-media');
    
    var _cardMedia2 = _interopRequireDefault(_cardMedia);
    
    var _cardText = require('./card/card-text');
    
    var _cardText2 = _interopRequireDefault(_cardText);
    
    var _cardTitle = require('./card/card-title');
    
    var _cardTitle2 = _interopRequireDefault(_cardTitle);
    
    var _checkbox = require('./checkbox');
    
    var _checkbox2 = _interopRequireDefault(_checkbox);
    
    var _circularProgress = require('./circular-progress');
    
    var _circularProgress2 = _interopRequireDefault(_circularProgress);
    
    var _clearfix = require('./clearfix');
    
    var _clearfix2 = _interopRequireDefault(_clearfix);
    
    var _datePicker = require('./date-picker/date-picker');
    
    var _datePicker2 = _interopRequireDefault(_datePicker);
    
    var _datePickerDialog = require('./date-picker/date-picker-dialog');
    
    var _datePickerDialog2 = _interopRequireDefault(_datePickerDialog);
    
    var _dialog = require('./dialog');
    
    var _dialog2 = _interopRequireDefault(_dialog);
    
    var _divider = require('./divider');
    
    var _divider2 = _interopRequireDefault(_divider);
    
    var _dropDownIcon = require('./drop-down-icon');
    
    var _dropDownIcon2 = _interopRequireDefault(_dropDownIcon);
    
    var _dropDownMenu = require('./drop-down-menu');
    
    var _dropDownMenu2 = _interopRequireDefault(_dropDownMenu);
    
    var _enhancedButton = require('./enhanced-button');
    
    var _enhancedButton2 = _interopRequireDefault(_enhancedButton);
    
    var _flatButton = require('./flat-button');
    
    var _flatButton2 = _interopRequireDefault(_flatButton);
    
    var _floatingActionButton = require('./floating-action-button');
    
    var _floatingActionButton2 = _interopRequireDefault(_floatingActionButton);
    
    var _fontIcon = require('./font-icon');
    
    var _fontIcon2 = _interopRequireDefault(_fontIcon);
    
    var _gridList = require('./grid-list/grid-list');
    
    var _gridList2 = _interopRequireDefault(_gridList);
    
    var _gridTile = require('./grid-list/grid-tile');
    
    var _gridTile2 = _interopRequireDefault(_gridTile);
    
    var _iconButton = require('./icon-button');
    
    var _iconButton2 = _interopRequireDefault(_iconButton);
    
    var _iconMenu = require('./menus/icon-menu');
    
    var _iconMenu2 = _interopRequireDefault(_iconMenu);
    
    var _leftNav = require('./left-nav');
    
    var _leftNav2 = _interopRequireDefault(_leftNav);
    
    var _linearProgress = require('./linear-progress');
    
    var _linearProgress2 = _interopRequireDefault(_linearProgress);
    
    var _list = require('./lists/list');
    
    var _list2 = _interopRequireDefault(_list);
    
    var _listDivider = require('./lists/list-divider');
    
    var _listDivider2 = _interopRequireDefault(_listDivider);
    
    var _listItem = require('./lists/list-item');
    
    var _listItem2 = _interopRequireDefault(_listItem);
    
    var _menu = require('./menus/menu');
    
    var _menu2 = _interopRequireDefault(_menu);
    
    var _menuItem = require('./menus/menu-item');
    
    var _menuItem2 = _interopRequireDefault(_menuItem);
    
    var _mixins = require('./mixins');
    
    var _mixins2 = _interopRequireDefault(_mixins);
    
    var _overlay = require('./overlay');
    
    var _overlay2 = _interopRequireDefault(_overlay);
    
    var _paper = require('./paper');
    
    var _paper2 = _interopRequireDefault(_paper);
    
    var _popover = require('./popover/popover');
    
    var _popover2 = _interopRequireDefault(_popover);
    
    var _radioButton = require('./radio-button');
    
    var _radioButton2 = _interopRequireDefault(_radioButton);
    
    var _radioButtonGroup = require('./radio-button-group');
    
    var _radioButtonGroup2 = _interopRequireDefault(_radioButtonGroup);
    
    var _raisedButton = require('./raised-button');
    
    var _raisedButton2 = _interopRequireDefault(_raisedButton);
    
    var _refreshIndicator = require('./refresh-indicator');
    
    var _refreshIndicator2 = _interopRequireDefault(_refreshIndicator);
    
    var _ripples = require('./ripples');
    
    var _ripples2 = _interopRequireDefault(_ripples);
    
    var _selectField = require('./select-field');
    
    var _selectField2 = _interopRequireDefault(_selectField);
    
    var _selectableEnhance = require('./hoc/selectable-enhance');
    
    var _selectableEnhance2 = _interopRequireDefault(_selectableEnhance);
    
    var _slider = require('./slider');
    
    var _slider2 = _interopRequireDefault(_slider);
    
    var _svgIcon = require('./svg-icon');
    
    var _svgIcon2 = _interopRequireDefault(_svgIcon);
    
    var _styles = require('./styles');
    
    var _styles2 = _interopRequireDefault(_styles);
    
    var _snackbar = require('./snackbar');
    
    var _snackbar2 = _interopRequireDefault(_snackbar);
    
    var _tab = require('./tabs/tab');
    
    var _tab2 = _interopRequireDefault(_tab);
    
    var _tabs = require('./tabs/tabs');
    
    var _tabs2 = _interopRequireDefault(_tabs);
    
    var _table = require('./table/table');
    
    var _table2 = _interopRequireDefault(_table);
    
    var _tableBody = require('./table/table-body');
    
    var _tableBody2 = _interopRequireDefault(_tableBody);
    
    var _tableFooter = require('./table/table-footer');
    
    var _tableFooter2 = _interopRequireDefault(_tableFooter);
    
    var _tableHeader = require('./table/table-header');
    
    var _tableHeader2 = _interopRequireDefault(_tableHeader);
    
    var _tableHeaderColumn = require('./table/table-header-column');
    
    var _tableHeaderColumn2 = _interopRequireDefault(_tableHeaderColumn);
    
    var _tableRow = require('./table/table-row');
    
    var _tableRow2 = _interopRequireDefault(_tableRow);
    
    var _tableRowColumn = require('./table/table-row-column');
    
    var _tableRowColumn2 = _interopRequireDefault(_tableRowColumn);
    
    var _toggle = require('./toggle');
    
    var _toggle2 = _interopRequireDefault(_toggle);
    
    var _themeWrapper = require('./theme-wrapper');
    
    var _themeWrapper2 = _interopRequireDefault(_themeWrapper);
    
    var _timePicker = require('./time-picker');
    
    var _timePicker2 = _interopRequireDefault(_timePicker);
    
    var _TextField = require('./TextField');
    
    var _TextField2 = _interopRequireDefault(_TextField);
    
    var _toolbar = require('./toolbar/toolbar');
    
    var _toolbar2 = _interopRequireDefault(_toolbar);
    
    var _toolbarGroup = require('./toolbar/toolbar-group');
    
    var _toolbarGroup2 = _interopRequireDefault(_toolbarGroup);
    
    var _toolbarSeparator = require('./toolbar/toolbar-separator');
    
    var _toolbarSeparator2 = _interopRequireDefault(_toolbarSeparator);
    
    var _toolbarTitle = require('./toolbar/toolbar-title');
    
    var _toolbarTitle2 = _interopRequireDefault(_toolbarTitle);
    
    var _tooltip = require('./tooltip');
    
    var _tooltip2 = _interopRequireDefault(_tooltip);
    
    var _utils = require('./utils');
    
    var _utils2 = _interopRequireDefault(_utils);
    
    var _menu3 = require('./svg-icons/navigation/menu');
    
    var _menu4 = _interopRequireDefault(_menu3);
    
    var _chevronLeft = require('./svg-icons/navigation/chevron-left');
    
    var _chevronLeft2 = _interopRequireDefault(_chevronLeft);
    
    var _chevronRight = require('./svg-icons/navigation/chevron-right');
    
    var _chevronRight2 = _interopRequireDefault(_chevronRight);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    exports.AppBar = _appBar2.default;
    exports.AppCanvas = _appCanvas2.default;
    exports.AutoComplete = _autoComplete2.default;
    exports.Avatar = _avatar2.default;
    exports.Badge = _badge2.default;
    exports.BeforeAfterWrapper = _beforeAfterWrapper2.default;
    exports.Card = _card2.default;
    exports.CardActions = _cardActions2.default;
    exports.CardExpandable = _cardExpandable2.default;
    exports.CardHeader = _cardHeader2.default;
    exports.CardMedia = _cardMedia2.default;
    exports.CardText = _cardText2.default;
    exports.CardTitle = _cardTitle2.default;
    exports.Checkbox = _checkbox2.default;
    exports.CircularProgress = _circularProgress2.default;
    exports.ClearFix = _clearfix2.default;
    exports.DatePicker = _datePicker2.default;
    exports.DatePickerDialog = _datePickerDialog2.default;
    exports.Dialog = _dialog2.default;
    exports.Divider = _divider2.default;
    exports.DropDownIcon = _dropDownIcon2.default;
    exports.DropDownMenu = _dropDownMenu2.default;
    exports.EnhancedButton = _enhancedButton2.default;
    exports.FlatButton = _flatButton2.default;
    exports.FloatingActionButton = _floatingActionButton2.default;
    exports.FontIcon = _fontIcon2.default;
    exports.GridList = _gridList2.default;
    exports.GridTile = _gridTile2.default;
    exports.IconButton = _iconButton2.default;
    exports.IconMenu = _iconMenu2.default;
    exports.LeftNav = _leftNav2.default;
    exports.LinearProgress = _linearProgress2.default;
    exports.List = _list2.default;
    exports.ListDivider = _listDivider2.default;
    exports.ListItem = _listItem2.default;
    exports.Menu = _menu2.default;
    exports.MenuItem = _menuItem2.default;
    exports.Mixins = _mixins2.default;
    exports.Overlay = _overlay2.default;
    exports.Paper = _paper2.default;
    exports.Popover = _popover2.default;
    exports.RadioButton = _radioButton2.default;
    exports.RadioButtonGroup = _radioButtonGroup2.default;
    exports.RaisedButton = _raisedButton2.default;
    exports.RefreshIndicator = _refreshIndicator2.default;
    exports.Ripples = _ripples2.default;
    exports.SelectField = _selectField2.default;
    exports.SelectableContainerEnhance = _selectableEnhance2.default;
    exports.Slider = _slider2.default;
    exports.SvgIcon = _svgIcon2.default;
    exports.Styles = _styles2.default;
    exports.Snackbar = _snackbar2.default;
    exports.Tab = _tab2.default;
    exports.Tabs = _tabs2.default;
    exports.Table = _table2.default;
    exports.TableBody = _tableBody2.default;
    exports.TableFooter = _tableFooter2.default;
    exports.TableHeader = _tableHeader2.default;
    exports.TableHeaderColumn = _tableHeaderColumn2.default;
    exports.TableRow = _tableRow2.default;
    exports.TableRowColumn = _tableRowColumn2.default;
    exports.Toggle = _toggle2.default;
    exports.ThemeWrapper = _themeWrapper2.default;
    exports.TimePicker = _timePicker2.default;
    exports.TextField = _TextField2.default;
    exports.Toolbar = _toolbar2.default;
    exports.ToolbarGroup = _toolbarGroup2.default;
    exports.ToolbarSeparator = _toolbarSeparator2.default;
    exports.ToolbarTitle = _toolbarTitle2.default;
    exports.Tooltip = _tooltip2.default;
    exports.Utils = _utils2.default;
    var Icons = exports.Icons = {
      NavigationMenu: _menu4.default,
      NavigationChevronLeft: _chevronLeft2.default,
      NavigationChevronRight: _chevronRight2.default
    };
    
    exports.default = {
      AppBar: _appBar2.default,
      AppCanvas: _appCanvas2.default,
      AutoComplete: _autoComplete2.default,
      Avatar: _avatar2.default,
      Badge: _badge2.default,
      BeforeAfterWrapper: _beforeAfterWrapper2.default,
      Card: _card2.default,
      CardActions: _cardActions2.default,
      CardExpandable: _cardExpandable2.default,
      CardHeader: _cardHeader2.default,
      CardMedia: _cardMedia2.default,
      CardText: _cardText2.default,
      CardTitle: _cardTitle2.default,
      Checkbox: _checkbox2.default,
      CircularProgress: _circularProgress2.default,
      ClearFix: _clearfix2.default,
      DatePicker: _datePicker2.default,
      DatePickerDialog: _datePickerDialog2.default,
      Dialog: _dialog2.default,
      Divider: _divider2.default,
      DropDownIcon: _dropDownIcon2.default,
      DropDownMenu: _dropDownMenu2.default,
      EnhancedButton: _enhancedButton2.default,
      FlatButton: _flatButton2.default,
      FloatingActionButton: _floatingActionButton2.default,
      FontIcon: _fontIcon2.default,
      GridList: _gridList2.default,
      GridTile: _gridTile2.default,
      IconButton: _iconButton2.default,
      IconMenu: _iconMenu2.default,
      LeftNav: _leftNav2.default,
      LinearProgress: _linearProgress2.default,
      List: _list2.default,
      ListDivider: _listDivider2.default,
      ListItem: _listItem2.default,
      Menu: _menu2.default,
      MenuItem: _menuItem2.default,
      Mixins: _mixins2.default,
      Overlay: _overlay2.default,
      Paper: _paper2.default,
      Popover: _popover2.default,
      RadioButton: _radioButton2.default,
      RadioButtonGroup: _radioButtonGroup2.default,
      RaisedButton: _raisedButton2.default,
      RefreshIndicator: _refreshIndicator2.default,
      Ripples: _ripples2.default,
      SelectField: _selectField2.default,
      SelectableContainerEnhance: _selectableEnhance2.default,
      Slider: _slider2.default,
      SvgIcon: _svgIcon2.default,
      Styles: _styles2.default,
      Snackbar: _snackbar2.default,
      Tab: _tab2.default,
      Tabs: _tabs2.default,
      Table: _table2.default,
      TableBody: _tableBody2.default,
      TableFooter: _tableFooter2.default,
      TableHeader: _tableHeader2.default,
      TableHeaderColumn: _tableHeaderColumn2.default,
      TableRow: _tableRow2.default,
      TableRowColumn: _tableRowColumn2.default,
      Toggle: _toggle2.default,
      ThemeWrapper: _themeWrapper2.default,
      TimePicker: _timePicker2.default,
      TextField: _TextField2.default,
      Toolbar: _toolbar2.default,
      ToolbarGroup: _toolbarGroup2.default,
      ToolbarSeparator: _toolbarSeparator2.default,
      ToolbarTitle: _toolbarTitle2.default,
      Tooltip: _tooltip2.default,
      Utils: _utils2.default
    };
  provide("material-ui", module.exports);
}(global));

// pakmanager:mongoose
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  
    /**
     * Export lib/mongoose
     *
     */
    
    module.exports = require('./lib/');
    
  provide("mongoose", module.exports);
}(global));